var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
define(["exports", "core/ajax"], function(exports, ajax) {
  "use strict";
  /**
  * @vue/shared v3.5.0-beta.3
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function makeMap$2(str2, expectsLowerCase) {
    const set2 = new Set(str2.split(","));
    return (val) => set2.has(val);
  }
  const EMPTY_OBJ$1 = {};
  const NOOP$1 = () => {
  };
  const extend$2 = Object.assign;
  const remove$1 = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  const hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  const hasOwn$3 = (val, key) => hasOwnProperty$3.call(val, key);
  const isArray$2 = Array.isArray;
  const isMap$1 = (val) => toTypeString$2(val) === "[object Map]";
  const isSet$1 = (val) => toTypeString$2(val) === "[object Set]";
  const isFunction$2 = (val) => typeof val === "function";
  const isString$2 = (val) => typeof val === "string";
  const isSymbol$2 = (val) => typeof val === "symbol";
  const isObject$1 = (val) => val !== null && typeof val === "object";
  const objectToString$2 = Object.prototype.toString;
  const toTypeString$2 = (value) => objectToString$2.call(value);
  const toRawType = (value) => {
    return toTypeString$2(value).slice(8, -1);
  };
  const isPlainObject$3 = (val) => toTypeString$2(val) === "[object Object]";
  const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  const def$2 = (obj, key, value, writable = false) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      writable,
      value
    });
  };
  /**
  * @vue/reactivity v3.5.0-beta.3
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  let activeEffectScope;
  class EffectScope {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this.effects = [];
      this.cleanups = [];
      this._isPaused = false;
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
      }
    }
    get active() {
      return this._active;
    }
    pause() {
      if (this._active) {
        this._isPaused = true;
        if (this.scopes) {
          for (let i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].pause();
          }
        }
        for (let i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].pause();
        }
      }
    }
    /**
     * Resumes the effect scope, including all child scopes and effects.
     */
    resume() {
      if (this._active) {
        if (this._isPaused) {
          this._isPaused = false;
          if (this.scopes) {
            for (let i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].resume();
            }
          }
          for (let i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].resume();
          }
        }
      }
    }
    run(fn) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
      activeEffectScope = this;
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
      activeEffectScope = this.parent;
    }
    stop(fromParent) {
      if (this._active) {
        let i, l;
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].stop();
        }
        for (i = 0, l = this.cleanups.length; i < l; i++) {
          this.cleanups[i]();
        }
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].stop(true);
          }
        }
        if (!this.detached && this.parent && !fromParent) {
          const last = this.parent.scopes.pop();
          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }
        this.parent = void 0;
        this._active = false;
      }
    }
  }
  function effectScope(detached) {
    return new EffectScope(detached);
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  function onScopeDispose(fn, failSilently = false) {
    if (activeEffectScope) {
      activeEffectScope.cleanups.push(fn);
    }
  }
  let activeSub;
  const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
  class ReactiveEffect {
    constructor(fn) {
      this.fn = fn;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 1 | 4;
      this.nextEffect = void 0;
      this.cleanup = void 0;
      this.scheduler = void 0;
      if (activeEffectScope && activeEffectScope.active) {
        activeEffectScope.effects.push(this);
      }
    }
    pause() {
      this.flags |= 64;
    }
    resume() {
      if (this.flags & 64) {
        this.flags &= ~64;
        if (pausedQueueEffects.has(this)) {
          pausedQueueEffects.delete(this);
          this.trigger();
        }
      }
    }
    /**
     * @internal
     */
    notify() {
      if (this.flags & 2 && !(this.flags & 32)) {
        return;
      }
      if (!(this.flags & 8)) {
        this.flags |= 8;
        this.nextEffect = batchedEffect;
        batchedEffect = this;
      }
    }
    run() {
      if (!(this.flags & 1)) {
        return this.fn();
      }
      this.flags |= 2;
      cleanupEffect(this);
      prepareDeps(this);
      const prevEffect = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = this;
      shouldTrack = true;
      try {
        return this.fn();
      } finally {
        cleanupDeps(this);
        activeSub = prevEffect;
        shouldTrack = prevShouldTrack;
        this.flags &= ~2;
      }
    }
    stop() {
      if (this.flags & 1) {
        for (let link2 = this.deps; link2; link2 = link2.nextDep) {
          removeSub(link2);
        }
        this.deps = this.depsTail = void 0;
        cleanupEffect(this);
        this.onStop && this.onStop();
        this.flags &= ~1;
      }
    }
    trigger() {
      if (this.flags & 64) {
        pausedQueueEffects.add(this);
      } else if (this.scheduler) {
        this.scheduler();
      } else {
        this.runIfDirty();
      }
    }
    /**
     * @internal
     */
    runIfDirty() {
      if (isDirty(this)) {
        this.run();
      }
    }
    get dirty() {
      return isDirty(this);
    }
  }
  let batchDepth = 0;
  let batchedEffect;
  function startBatch() {
    batchDepth++;
  }
  function endBatch() {
    if (batchDepth > 1) {
      batchDepth--;
      return;
    }
    batchDepth--;
    let error;
    while (batchedEffect) {
      let e = batchedEffect;
      batchedEffect = void 0;
      while (e) {
        const next = e.nextEffect;
        e.nextEffect = void 0;
        e.flags &= ~8;
        if (e.flags & 1) {
          try {
            e.trigger();
          } catch (err) {
            if (!error) error = err;
          }
        }
        e = next;
      }
    }
    if (error) throw error;
  }
  function prepareDeps(sub) {
    for (let link2 = sub.deps; link2; link2 = link2.nextDep) {
      link2.version = -1;
      link2.prevActiveLink = link2.dep.activeLink;
      link2.dep.activeLink = link2;
    }
  }
  function cleanupDeps(sub) {
    let head;
    let tail = sub.depsTail;
    for (let link2 = tail; link2; link2 = link2.prevDep) {
      if (link2.version === -1) {
        if (link2 === tail) tail = link2.prevDep;
        removeSub(link2);
        removeDep(link2);
      } else {
        head = link2;
      }
      link2.dep.activeLink = link2.prevActiveLink;
      link2.prevActiveLink = void 0;
    }
    sub.deps = head;
    sub.depsTail = tail;
  }
  function isDirty(sub) {
    for (let link2 = sub.deps; link2; link2 = link2.nextDep) {
      if (link2.dep.version !== link2.version || link2.dep.computed && refreshComputed(link2.dep.computed) === false || link2.dep.version !== link2.version) {
        return true;
      }
    }
    if (sub._dirty) {
      return true;
    }
    return false;
  }
  function refreshComputed(computed2) {
    if (computed2.flags & 2) {
      return false;
    }
    if (computed2.flags & 4 && !(computed2.flags & 16)) {
      return;
    }
    computed2.flags &= ~16;
    if (computed2.globalVersion === globalVersion) {
      return;
    }
    computed2.globalVersion = globalVersion;
    const dep = computed2.dep;
    computed2.flags |= 2;
    if (dep.version > 0 && !computed2.isSSR && !isDirty(computed2)) {
      computed2.flags &= ~2;
      return;
    }
    const prevSub = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = computed2;
    shouldTrack = true;
    try {
      prepareDeps(computed2);
      const value = computed2.fn();
      if (dep.version === 0 || hasChanged(value, computed2._value)) {
        computed2._value = value;
        dep.version++;
      }
    } catch (err) {
      dep.version++;
      throw err;
    } finally {
      activeSub = prevSub;
      shouldTrack = prevShouldTrack;
      cleanupDeps(computed2);
      computed2.flags &= ~2;
    }
  }
  function removeSub(link2) {
    const { dep, prevSub, nextSub } = link2;
    if (prevSub) {
      prevSub.nextSub = nextSub;
      link2.prevSub = void 0;
    }
    if (nextSub) {
      nextSub.prevSub = prevSub;
      link2.nextSub = void 0;
    }
    if (dep.subs === link2) {
      dep.subs = prevSub;
    }
    if (!dep.subs && dep.computed) {
      dep.computed.flags &= ~4;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l);
      }
    }
  }
  function removeDep(link2) {
    const { prevDep, nextDep } = link2;
    if (prevDep) {
      prevDep.nextDep = nextDep;
      link2.prevDep = void 0;
    }
    if (nextDep) {
      nextDep.prevDep = prevDep;
      link2.nextDep = void 0;
    }
  }
  let shouldTrack = true;
  const trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function cleanupEffect(e) {
    const { cleanup } = e;
    e.cleanup = void 0;
    if (cleanup) {
      const prevSub = activeSub;
      activeSub = void 0;
      try {
        cleanup();
      } finally {
        activeSub = prevSub;
      }
    }
  }
  let globalVersion = 0;
  class Dep {
    constructor(computed2) {
      this.computed = computed2;
      this.version = 0;
      this.activeLink = void 0;
      this.subs = void 0;
    }
    track(debugInfo) {
      if (!activeSub || !shouldTrack) {
        return;
      }
      let link2 = this.activeLink;
      if (link2 === void 0 || link2.sub !== activeSub) {
        link2 = this.activeLink = {
          dep: this,
          sub: activeSub,
          version: this.version,
          nextDep: void 0,
          prevDep: void 0,
          nextSub: void 0,
          prevSub: void 0,
          prevActiveLink: void 0
        };
        if (!activeSub.deps) {
          activeSub.deps = activeSub.depsTail = link2;
        } else {
          link2.prevDep = activeSub.depsTail;
          activeSub.depsTail.nextDep = link2;
          activeSub.depsTail = link2;
        }
        if (activeSub.flags & 4) {
          addSub(link2);
        }
      } else if (link2.version === -1) {
        link2.version = this.version;
        if (link2.nextDep) {
          const next = link2.nextDep;
          next.prevDep = link2.prevDep;
          if (link2.prevDep) {
            link2.prevDep.nextDep = next;
          }
          link2.prevDep = activeSub.depsTail;
          link2.nextDep = void 0;
          activeSub.depsTail.nextDep = link2;
          activeSub.depsTail = link2;
          if (activeSub.deps === link2) {
            activeSub.deps = next;
          }
        }
      }
      return link2;
    }
    trigger(debugInfo) {
      this.version++;
      globalVersion++;
      this.notify(debugInfo);
    }
    notify(debugInfo) {
      startBatch();
      try {
        if (false) ;
        for (let link2 = this.subs; link2; link2 = link2.prevSub) {
          link2.sub.notify();
        }
      } finally {
        endBatch();
      }
    }
  }
  function addSub(link2) {
    const computed2 = link2.dep.computed;
    if (computed2 && !link2.dep.subs) {
      computed2.flags |= 4 | 16;
      for (let l = computed2.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link2.dep.subs;
    if (currentTail !== link2) {
      link2.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link2;
    }
    link2.dep.subs = link2;
  }
  const targetMap = /* @__PURE__ */ new WeakMap();
  const ITERATE_KEY = Symbol(
    ""
  );
  const MAP_KEY_ITERATE_KEY = Symbol(
    ""
  );
  const ARRAY_ITERATE_KEY = Symbol(
    ""
  );
  function track(target, type2, key) {
    if (shouldTrack && activeSub) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = new Dep());
      }
      {
        dep.track();
      }
    }
  }
  function trigger(target, type2, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      globalVersion++;
      return;
    }
    let deps = [];
    if (type2 === "clear") {
      deps = [...depsMap.values()];
    } else {
      const targetIsArray = isArray$2(target);
      const isArrayIndex = targetIsArray && isIntegerKey(key);
      if (targetIsArray && key === "length") {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol$2(key2) && key2 >= newLength) {
            deps.push(dep);
          }
        });
      } else {
        const push = (dep) => dep && deps.push(dep);
        if (key !== void 0) {
          push(depsMap.get(key));
        }
        if (isArrayIndex) {
          push(depsMap.get(ARRAY_ITERATE_KEY));
        }
        switch (type2) {
          case "add":
            if (!targetIsArray) {
              push(depsMap.get(ITERATE_KEY));
              if (isMap$1(target)) {
                push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isArrayIndex) {
              push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!targetIsArray) {
              push(depsMap.get(ITERATE_KEY));
              if (isMap$1(target)) {
                push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap$1(target)) {
              push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
    }
    startBatch();
    for (const dep of deps) {
      {
        dep.trigger();
      }
    }
    endBatch();
  }
  function getDepFromReactive(object, key) {
    var _a2;
    return (_a2 = targetMap.get(object)) == null ? void 0 : _a2.get(key);
  }
  function reactiveReadArray(array) {
    const raw = toRaw(array);
    if (raw === array) return raw;
    track(raw, "iterate", ARRAY_ITERATE_KEY);
    return isShallow(array) ? raw : raw.map(toReactive);
  }
  function shallowReadArray(arr) {
    track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
    return arr;
  }
  const arrayInstrumentations = {
    __proto__: null,
    [Symbol.iterator]() {
      return iterator(this, Symbol.iterator, toReactive);
    },
    concat(...args) {
      return reactiveReadArray(this).concat(
        ...args.map((x) => reactiveReadArray(x))
      );
    },
    entries() {
      return iterator(this, "entries", (value) => {
        value[1] = toReactive(value[1]);
        return value;
      });
    },
    every(fn, thisArg) {
      return apply(this, "every", fn, thisArg, void 0, arguments);
    },
    filter(fn, thisArg) {
      return apply(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
    },
    find(fn, thisArg) {
      return apply(this, "find", fn, thisArg, toReactive, arguments);
    },
    findIndex(fn, thisArg) {
      return apply(this, "findIndex", fn, thisArg, void 0, arguments);
    },
    findLast(fn, thisArg) {
      return apply(this, "findLast", fn, thisArg, toReactive, arguments);
    },
    findLastIndex(fn, thisArg) {
      return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
    },
    // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
    forEach(fn, thisArg) {
      return apply(this, "forEach", fn, thisArg, void 0, arguments);
    },
    includes(...args) {
      return searchProxy(this, "includes", args);
    },
    indexOf(...args) {
      return searchProxy(this, "indexOf", args);
    },
    join(separator) {
      return reactiveReadArray(this).join(separator);
    },
    // keys() iterator only reads `length`, no optimisation required
    lastIndexOf(...args) {
      return searchProxy(this, "lastIndexOf", args);
    },
    map(fn, thisArg) {
      return apply(this, "map", fn, thisArg, void 0, arguments);
    },
    pop() {
      return noTracking(this, "pop");
    },
    push(...args) {
      return noTracking(this, "push", args);
    },
    reduce(fn, ...args) {
      return reduce(this, "reduce", fn, args);
    },
    reduceRight(fn, ...args) {
      return reduce(this, "reduceRight", fn, args);
    },
    shift() {
      return noTracking(this, "shift");
    },
    // slice could use ARRAY_ITERATE but also seems to beg for range tracking
    some(fn, thisArg) {
      return apply(this, "some", fn, thisArg, void 0, arguments);
    },
    splice(...args) {
      return noTracking(this, "splice", args);
    },
    toReversed() {
      return reactiveReadArray(this).toReversed();
    },
    toSorted(comparer) {
      return reactiveReadArray(this).toSorted(comparer);
    },
    toSpliced(...args) {
      return reactiveReadArray(this).toSpliced(...args);
    },
    unshift(...args) {
      return noTracking(this, "unshift", args);
    },
    values() {
      return iterator(this, "values", toReactive);
    }
  };
  function iterator(self2, method, wrapValue) {
    const arr = shallowReadArray(self2);
    const iter = arr[method]();
    if (arr !== self2 && !isShallow(self2)) {
      iter._next = iter.next;
      iter.next = () => {
        const result = iter._next();
        if (result.value) {
          result.value = wrapValue(result.value);
        }
        return result;
      };
    }
    return iter;
  }
  const arrayProto = Array.prototype;
  function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
    const arr = shallowReadArray(self2);
    const needsWrap = arr !== self2 && !isShallow(self2);
    const methodFn = arr[method];
    if (methodFn !== arrayProto[method]) {
      const result2 = methodFn.apply(arr, args);
      return needsWrap ? toReactive(result2) : result2;
    }
    let wrappedFn = fn;
    if (arr !== self2) {
      if (needsWrap) {
        wrappedFn = function(item, index) {
          return fn.call(this, toReactive(item), index, self2);
        };
      } else if (fn.length > 2) {
        wrappedFn = function(item, index) {
          return fn.call(this, item, index, self2);
        };
      }
    }
    const result = methodFn.call(arr, wrappedFn, thisArg);
    return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
  }
  function reduce(self2, method, fn, args) {
    const arr = shallowReadArray(self2);
    let wrappedFn = fn;
    if (arr !== self2) {
      if (!isShallow(self2)) {
        wrappedFn = function(acc, item, index) {
          return fn.call(this, acc, toReactive(item), index, self2);
        };
      } else if (fn.length > 3) {
        wrappedFn = function(acc, item, index) {
          return fn.call(this, acc, item, index, self2);
        };
      }
    }
    return arr[method](wrappedFn, ...args);
  }
  function searchProxy(self2, method, args) {
    const arr = toRaw(self2);
    track(arr, "iterate", ARRAY_ITERATE_KEY);
    const res = arr[method](...args);
    if ((res === -1 || res === false) && isProxy(args[0])) {
      args[0] = toRaw(args[0]);
      return arr[method](...args);
    }
    return res;
  }
  function noTracking(self2, method, args = []) {
    pauseTracking();
    startBatch();
    const res = toRaw(self2)[method].apply(self2, args);
    endBatch();
    resetTracking();
    return res;
  }
  const isNonTrackableKeys = /* @__PURE__ */ makeMap$2(`__proto__,__v_isRef,__isVue`);
  const builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$2)
  );
  function hasOwnProperty$2(key) {
    if (!isSymbol$2(key)) key = String(key);
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  class BaseReactiveHandler {
    constructor(_isReadonly = false, _isShallow = false) {
      this._isReadonly = _isReadonly;
      this._isShallow = _isShallow;
    }
    get(target, key, receiver) {
      const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return isShallow2;
      } else if (key === "__v_raw") {
        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
        // this means the receiver is a user proxy of the reactive proxy
        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
          return target;
        }
        return;
      }
      const targetIsArray = isArray$2(target);
      if (!isReadonly2) {
        let fn;
        if (targetIsArray && (fn = arrayInstrumentations[key])) {
          return fn;
        }
        if (key === "hasOwnProperty") {
          return hasOwnProperty$2;
        }
      }
      const res = Reflect.get(
        target,
        key,
        // if this is a proxy wrapping a ref, return methods using the raw ref
        // as receiver so that we don't have to call `toRaw` on the ref in all
        // its class methods
        isRef$1(target) ? target : receiver
      );
      if (isSymbol$2(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (isShallow2) {
        return res;
      }
      if (isRef$1(res)) {
        return targetIsArray && isIntegerKey(key) ? res : res.value;
      }
      if (isObject$1(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    }
  }
  class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(false, isShallow2);
    }
    set(target, key, value, receiver) {
      let oldValue = target[key];
      if (!this._isShallow) {
        const isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray$2(target) && isRef$1(oldValue) && !isRef$1(value)) {
          if (isOldValueReadonly) {
            return false;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$3(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
      }
      return result;
    }
    deleteProperty(target, key) {
      const hadKey = hasOwn$3(target, key);
      target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    has(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol$2(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    ownKeys(target) {
      track(
        target,
        "iterate",
        isArray$2(target) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target);
    }
  }
  class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(true, isShallow2);
    }
    set(target, key) {
      return true;
    }
    deleteProperty(target, key) {
      return true;
    }
  }
  const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
  const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
  const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
  const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
  const toShallow = (value) => value;
  const getProto = (v) => Reflect.getPrototypeOf(v);
  function get(target, key, isReadonly2 = false, isShallow2 = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
      if (hasChanged(key, rawKey)) {
        track(rawTarget, "get", key);
      }
      track(rawTarget, "get", rawKey);
    }
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has(key, isReadonly2 = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
      if (hasChanged(key, rawKey)) {
        track(rawTarget, "has", key);
      }
      track(rawTarget, "has", rawKey);
    }
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly2 = false) {
    target = target["__v_raw"];
    !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value, _isShallow = false) {
    if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
      value = toRaw(value);
    }
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set(key, value, _isShallow = false) {
    if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
      value = toRaw(value);
    }
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    }
    const oldValue = get2.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    }
    get2 ? get2.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0);
    }
    return result;
  }
  function createForEach(isReadonly2, isShallow2) {
    return function forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap$1(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type2) {
    return function(...args) {
      return type2 === "delete" ? false : type2 === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key) {
        return get(this, key);
      },
      get size() {
        return size(this);
      },
      has,
      add,
      set,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key) {
        return get(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has,
      add(value) {
        return add.call(this, value, true);
      },
      set(key, value) {
        return set.call(this, key, value, true);
      },
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key) {
        return get(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key) {
        return get(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = [
      "keys",
      "values",
      "entries",
      Symbol.iterator
    ];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
      shallowInstrumentations2[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations2[method] = createIterableMethod(
        method,
        true,
        true
      );
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  const [
    mutableInstrumentations,
    readonlyInstrumentations,
    shallowInstrumentations,
    shallowReadonlyInstrumentations
  ] = /* @__PURE__ */ createInstrumentations();
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(
        hasOwn$3(instrumentations, key) && key in target ? instrumentations : target,
        key,
        receiver
      );
    };
  }
  const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  const reactiveMap = /* @__PURE__ */ new WeakMap();
  const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  const readonlyMap = /* @__PURE__ */ new WeakMap();
  const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function shallowReactive(target) {
    return createReactiveObject(
      target,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
    );
  }
  function readonly(target) {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function shallowReadonly(target) {
    return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    );
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject$1(target)) {
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(
      target,
      targetType === 2 ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    if (Object.isExtensible(value)) {
      def$2(value, "__v_skip", true);
    }
    return value;
  }
  const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
  function isRef$1(r) {
    return r ? r["__v_isRef"] === true : false;
  }
  function ref(value) {
    return createRef(value, false);
  }
  function createRef(rawValue, shallow) {
    if (isRef$1(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  class RefImpl {
    constructor(value, isShallow2) {
      this.dep = new Dep();
      this["__v_isRef"] = true;
      this["__v_isShallow"] = false;
      this._rawValue = isShallow2 ? value : toRaw(value);
      this._value = isShallow2 ? value : toReactive(value);
      this["__v_isShallow"] = isShallow2;
    }
    get value() {
      {
        this.dep.track();
      }
      return this._value;
    }
    set value(newValue) {
      const oldValue = this._rawValue;
      const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
      newValue = useDirectValue ? newValue : toRaw(newValue);
      if (hasChanged(newValue, oldValue)) {
        this._rawValue = newValue;
        this._value = useDirectValue ? newValue : toReactive(newValue);
        {
          this.dep.trigger();
        }
      }
    }
  }
  function unref(ref2) {
    return isRef$1(ref2) ? ref2.value : ref2;
  }
  const shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef$1(oldValue) && !isRef$1(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  function toRefs(object) {
    const ret = isArray$2(object) ? new Array(object.length) : {};
    for (const key in object) {
      ret[key] = propertyToRef(object, key);
    }
    return ret;
  }
  class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
      this._object = _object;
      this._key = _key;
      this._defaultValue = _defaultValue;
      this["__v_isRef"] = true;
      this._value = void 0;
    }
    get value() {
      const val = this._object[this._key];
      return this._value = val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
      this._object[this._key] = newVal;
    }
    get dep() {
      return getDepFromReactive(toRaw(this._object), this._key);
    }
  }
  function propertyToRef(source, key, defaultValue) {
    const val = source[key];
    return isRef$1(val) ? val : new ObjectRefImpl(source, key, defaultValue);
  }
  class ComputedRefImpl {
    constructor(fn, setter, isSSR) {
      this.fn = fn;
      this.setter = setter;
      this._value = void 0;
      this.dep = new Dep(this);
      this.__v_isRef = true;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 16;
      this.globalVersion = globalVersion - 1;
      this.effect = this;
      this["__v_isReadonly"] = !setter;
      this.isSSR = isSSR;
    }
    /**
     * @internal
     */
    notify() {
      if (activeSub !== this) {
        this.flags |= 16;
        this.dep.notify();
      }
    }
    get value() {
      const link2 = this.dep.track();
      refreshComputed(this);
      if (link2) {
        link2.version = this.dep.version;
      }
      return this._value;
    }
    set value(newValue) {
      if (this.setter) {
        this.setter(newValue);
      }
    }
  }
  function computed$1(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    if (isFunction$2(getterOrOptions)) {
      getter = getterOrOptions;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, isSSR);
    return cRef;
  }
  const INITIAL_WATCHER_VALUE = {};
  const cleanupMap = /* @__PURE__ */ new WeakMap();
  let activeWatcher = void 0;
  function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
    if (owner) {
      let cleanups = cleanupMap.get(owner);
      if (!cleanups) cleanupMap.set(owner, cleanups = []);
      cleanups.push(cleanupFn);
    }
  }
  function watch$1(source, cb, options = EMPTY_OBJ$1) {
    const { immediate, deep, once, scheduler, augmentJob, call } = options;
    const reactiveGetter = (source2) => {
      if (deep) return source2;
      if (isShallow(source2) || deep === false || deep === 0)
        return traverse(source2, 1);
      return traverse(source2);
    };
    let effect2;
    let getter;
    let cleanup;
    let boundCleanup;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef$1(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => reactiveGetter(source);
      forceTrigger = true;
    } else if (isArray$2(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
      getter = () => source.map((s) => {
        if (isRef$1(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return reactiveGetter(s);
        } else if (isFunction$2(s)) {
          return call ? call(s, 2) : s();
        } else ;
      });
    } else if (isFunction$2(source)) {
      if (cb) {
        getter = call ? () => call(source, 2) : source;
      } else {
        getter = () => {
          if (cleanup) {
            pauseTracking();
            try {
              cleanup();
            } finally {
              resetTracking();
            }
          }
          const currentEffect = activeWatcher;
          activeWatcher = effect2;
          try {
            return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
          } finally {
            activeWatcher = currentEffect;
          }
        };
      }
    } else {
      getter = NOOP$1;
    }
    if (cb && deep) {
      const baseGetter = getter;
      const depth = deep === true ? Infinity : deep;
      getter = () => traverse(baseGetter(), depth);
    }
    if (once) {
      if (cb) {
        const _cb = cb;
        cb = (...args) => {
          _cb(...args);
          effect2.stop();
        };
      } else {
        const _getter = getter;
        getter = () => {
          _getter();
          effect2.stop();
        };
      }
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = (immediateFirstRun) => {
      if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
          if (cleanup) {
            cleanup();
          }
          const currentWatcher = activeWatcher;
          activeWatcher = effect2;
          try {
            const args = [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              boundCleanup
            ];
            call ? call(cb, 3, args) : (
              // @ts-expect-error
              cb(...args)
            );
            oldValue = newValue;
          } finally {
            activeWatcher = currentWatcher;
          }
        }
      } else {
        effect2.run();
      }
    };
    if (augmentJob) {
      augmentJob(job);
    }
    effect2 = new ReactiveEffect(getter);
    effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
    boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
    cleanup = effect2.onStop = () => {
      const cleanups = cleanupMap.get(effect2);
      if (cleanups) {
        if (call) {
          call(cleanups, 4);
        } else {
          for (const cleanup2 of cleanups) cleanup2();
        }
        cleanupMap.delete(effect2);
      }
    };
    if (cb) {
      if (immediate) {
        job(true);
      } else {
        oldValue = effect2.run();
      }
    } else if (scheduler) {
      scheduler(job.bind(null, true), true);
    } else {
      effect2.run();
    }
    const scope = getCurrentScope();
    const watchHandle = () => {
      effect2.stop();
      if (scope) {
        remove$1(scope.effects, effect2);
      }
    };
    watchHandle.pause = effect2.pause.bind(effect2);
    watchHandle.resume = effect2.resume.bind(effect2);
    watchHandle.stop = watchHandle;
    return watchHandle;
  }
  function traverse(value, depth = Infinity, seen) {
    if (depth <= 0 || !isObject$1(value) || value["__v_skip"]) {
      return value;
    }
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    depth--;
    if (isRef$1(value)) {
      traverse(value.value, depth, seen);
    } else if (isArray$2(value)) {
      for (let i = 0; i < value.length; i++) {
        traverse(value[i], depth, seen);
      }
    } else if (isSet$1(value) || isMap$1(value)) {
      value.forEach((v) => {
        traverse(v, depth, seen);
      });
    } else if (isPlainObject$3(value)) {
      for (const key in value) {
        traverse(value[key], depth, seen);
      }
      for (const key of Object.getOwnPropertySymbols(value)) {
        if (Object.prototype.propertyIsEnumerable.call(value, key)) {
          traverse(value[key], depth, seen);
        }
      }
    }
    return value;
  }
  /**
  * @vue/shared v3.5.0-beta.3
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function makeMap$1(str2, expectsLowerCase) {
    const set2 = new Set(str2.split(","));
    return (val) => set2.has(val);
  }
  const EMPTY_OBJ = {};
  const EMPTY_ARR = [];
  const NOOP = () => {
  };
  const NO = () => false;
  const isOn$1 = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  const isModelListener$1 = (key) => key.startsWith("onUpdate:");
  const extend$1 = Object.assign;
  const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  const hasOwn$2 = (val, key) => hasOwnProperty$1.call(val, key);
  const isArray$1 = Array.isArray;
  const isMap = (val) => toTypeString$1(val) === "[object Map]";
  const isSet = (val) => toTypeString$1(val) === "[object Set]";
  const isFunction$1 = (val) => typeof val === "function";
  const isString$1 = (val) => typeof val === "string";
  const isSymbol$1 = (val) => typeof val === "symbol";
  const isObject = (val) => val !== null && typeof val === "object";
  const isPromise$1 = (val) => {
    return (isObject(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
  };
  const objectToString$1 = Object.prototype.toString;
  const toTypeString$1 = (value) => objectToString$1.call(value);
  const isPlainObject$2 = (val) => toTypeString$1(val) === "[object Object]";
  const isReservedProp = /* @__PURE__ */ makeMap$1(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  const cacheStringFunction$1 = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str2) => {
      const hit = cache[str2];
      return hit || (cache[str2] = fn(str2));
    };
  };
  const camelizeRE$1 = /-(\w)/g;
  const camelize$1 = cacheStringFunction$1(
    (str2) => {
      return str2.replace(camelizeRE$1, (_, c) => c ? c.toUpperCase() : "");
    }
  );
  const hyphenateRE$1 = /\B([A-Z])/g;
  const hyphenate$1 = cacheStringFunction$1(
    (str2) => str2.replace(hyphenateRE$1, "-$1").toLowerCase()
  );
  const capitalize$1 = cacheStringFunction$1((str2) => {
    return str2.charAt(0).toUpperCase() + str2.slice(1);
  });
  const toHandlerKey = cacheStringFunction$1(
    (str2) => {
      const s = str2 ? `on${capitalize$1(str2)}` : ``;
      return s;
    }
  );
  const invokeArrayFns$1 = (fns, ...arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](...arg);
    }
  };
  const def$1 = (obj, key, value, writable = false) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      writable,
      value
    });
  };
  const looseToNumber$1 = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function normalizeStyle(value) {
    if (isArray$1(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString$1(value) || isObject(value)) {
      return value;
    }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString$1(value)) {
      res = value;
    } else if (isArray$1(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  const isRef = (val) => {
    return !!(val && val["__v_isRef"] === true);
  };
  const toDisplayString = (val) => {
    return isString$1(val) ? val : val == null ? "" : isArray$1(val) || isObject(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
  };
  const replacer = (_key, val) => {
    if (isRef(val)) {
      return replacer(_key, val.value);
    } else if (isMap(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce(
          (entries, [key, val2], i) => {
            entries[stringifySymbol(key, i) + " =>"] = val2;
            return entries;
          },
          {}
        )
      };
    } else if (isSet(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
      };
    } else if (isSymbol$1(val)) {
      return stringifySymbol(val);
    } else if (isObject(val) && !isArray$1(val) && !isPlainObject$2(val)) {
      return String(val);
    }
    return val;
  };
  const stringifySymbol = (v, i = "") => {
    var _a2;
    return (
      // Symbol.description in es2019+ so we need to cast here to pass
      // the lib: es2016 check
      isSymbol$1(v) ? `Symbol(${(_a2 = v.description) != null ? _a2 : i})` : v
    );
  };
  /**
  * @vue/runtime-core v3.5.0-beta.3
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const stack = [];
  let isWarning = false;
  function warn$1(msg, ...args) {
    if (isWarning) return;
    isWarning = true;
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
          // eslint-disable-next-line no-restricted-syntax
          msg + args.map((a) => {
            var _a2, _b;
            return (_b = (_a2 = a.toString) == null ? void 0 : _a2.call(a)) != null ? _b : JSON.stringify(a);
          }).join(""),
          instance && instance.proxy,
          trace.map(
            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
          ).join("\n"),
          trace
        ]
      );
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && // avoid spamming console during tests
      true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
    isWarning = false;
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last = normalizedStack[0];
      if (last && last.vnode === currentVNode) {
        last.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
      logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(
      vnode.component,
      vnode.type,
      isRoot
    )}`;
    const close2 = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close2] : [open + close2];
  }
  function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString$1(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key}=${value}`];
    } else if (isRef$1(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction$1(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key}=`, value];
    }
  }
  function callWithErrorHandling(fn, instance, type2, args) {
    try {
      return args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type2);
    }
  }
  function callWithAsyncErrorHandling(fn, instance, type2, args) {
    if (isFunction$1(fn)) {
      const res = callWithErrorHandling(fn, instance, type2, args);
      if (res && isPromise$1(res)) {
        res.catch((err) => {
          handleError(err, instance, type2);
        });
      }
      return res;
    }
    if (isArray$1(fn)) {
      const values = [];
      for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type2, args));
      }
      return values;
    }
  }
  function handleError(err, instance, type2, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = `https://vuejs.org/error-reference/#runtime-${type2}`;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i = 0; i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      if (errorHandler) {
        pauseTracking();
        callWithErrorHandling(errorHandler, null, 10, [
          err,
          exposedInstance,
          errorInfo
        ]);
        resetTracking();
        return;
      }
    }
    logError(err, type2, contextVNode, throwInDev, throwUnhandledErrorInProduction);
  }
  function logError(err, type2, contextVNode, throwInDev = true, throwInProd = false) {
    if (throwInProd) {
      throw err;
    } else {
      console.error(err);
    }
  }
  let isFlushing = false;
  let isFlushPending = false;
  const queue = [];
  let flushIndex = 0;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = /* @__PURE__ */ Promise.resolve();
  let currentFlushPromise = null;
  function nextTick(fn) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
  }
  function findInsertionIndex(id) {
    let start = isFlushing ? flushIndex + 1 : 0;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJob = queue[middle];
      const middleJobId = getId(middleJob);
      if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
        start = middle + 1;
      } else {
        end = middle;
      }
    }
    return start;
  }
  function queueJob(job) {
    if (!(job.flags & 1)) {
      const jobId = getId(job);
      const lastJob = queue[queue.length - 1];
      if (!lastJob || // fast path when the job id is larger than the tail
      !(job.flags & 2) && jobId >= getId(lastJob)) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(jobId), 0, job);
      }
      if (!(job.flags & 4)) {
        job.flags |= 1;
      }
      queueFlush();
    }
  }
  function queueFlush() {
    if (!isFlushing && !isFlushPending) {
      isFlushPending = true;
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray$1(cb)) {
      if (activePostFlushCbs && cb.id === -1) {
        activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
      } else if (!(cb.flags & 1)) {
        pendingPostFlushCbs.push(cb);
        if (!(cb.flags & 4)) {
          cb.flags |= 1;
        }
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
    for (; i < queue.length; i++) {
      const cb = queue[i];
      if (cb && cb.flags & 2) {
        if (instance && cb.id !== instance.uid) {
          continue;
        }
        queue.splice(i, 1);
        i--;
        cb();
        cb.flags &= ~1;
      }
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)].sort(
        (a, b) => getId(a) - getId(b)
      );
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        const cb = activePostFlushCbs[postFlushIndex];
        if (!(cb.flags & 8)) cb();
        cb.flags &= ~1;
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
  function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && !(job.flags & 8)) {
          if (false) ;
          callWithErrorHandling(
            job,
            job.i,
            job.i ? 15 : 14
          );
          job.flags &= ~1;
        }
      }
    } finally {
      flushIndex = 0;
      queue.length = 0;
      flushPostFlushCbs();
      isFlushing = false;
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs();
      }
    }
  }
  let currentRenderingInstance = null;
  let currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
      return vnode;
    }
    const instance = getComponentPublicInstance(currentRenderingInstance);
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
      if (dir) {
        if (isFunction$1(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
      const binding = bindings[i];
      if (oldBindings) {
        binding.oldValue = oldBindings[i].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  const TeleportEndKey = Symbol("_vte");
  const isTeleport = (type2) => type2.__isTeleport;
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function defineComponent(options, extraOptions) {
    return isFunction$1(options) ? (
      // #8326: extend call and options.name access are considered side-effects
      // by Rollup, so we have to wrap it in a pure-annotated IIFE.
      /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))()
    ) : options;
  }
  function markAsyncBoundary(instance) {
    instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
  }
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray$1(rawRef)) {
      rawRef.forEach(
        (r, i) => setRef(
          r,
          oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i] : oldRawRef),
          parentSuspense,
          vnode,
          isUnmount
        )
      );
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref3 } = rawRef;
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref3) {
      if (isString$1(oldRef)) {
        refs[oldRef] = null;
        if (hasOwn$2(setupState, oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef$1(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction$1(ref3)) {
      callWithErrorHandling(ref3, owner, 12, [value, refs]);
    } else {
      const _isString = isString$1(ref3);
      const _isRef = isRef$1(ref3);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? hasOwn$2(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
            if (isUnmount) {
              isArray$1(existing) && remove(existing, refValue);
            } else {
              if (!isArray$1(existing)) {
                if (_isString) {
                  refs[ref3] = [refValue];
                  if (hasOwn$2(setupState, ref3)) {
                    setupState[ref3] = refs[ref3];
                  }
                } else {
                  ref3.value = [refValue];
                  if (rawRef.k) refs[rawRef.k] = ref3.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref3] = value;
            if (hasOwn$2(setupState, ref3)) {
              setupState[ref3] = value;
            }
          } else if (_isRef) {
            ref3.value = value;
            if (rawRef.k) refs[rawRef.k] = value;
          } else ;
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      }
    }
  }
  const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type2, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type2, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type2, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
    const injected = injectHook(
      type2,
      hook,
      keepAliveRoot,
      true
      /* prepend */
    );
    onUnmounted(() => {
      remove(keepAliveRoot[type2], injected);
    }, target);
  }
  function injectHook(type2, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type2] || (target[type2] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        pauseTracking();
        const reset = setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type2, args);
        reset();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    }
  }
  const createHook = (lifecycle) => (hook, target = currentInstance) => {
    if (!isInSSRComponentSetup || lifecycle === "sp") {
      injectHook(lifecycle, (...args) => hook(...args), target);
    }
  };
  const onBeforeMount = createHook("bm");
  const onMounted = createHook("m");
  const onBeforeUpdate = createHook(
    "bu"
  );
  const onUpdated = createHook("u");
  const onBeforeUnmount = createHook(
    "bum"
  );
  const onUnmounted = createHook("um");
  const onServerPrefetch = createHook(
    "sp"
  );
  const onRenderTriggered = createHook("rtg");
  const onRenderTracked = createHook("rtc");
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = cache;
    const sourceIsArray = isArray$1(source);
    if (sourceIsArray || isString$1(source)) {
      const sourceIsReactiveArray = sourceIsArray && isReactive(source);
      if (sourceIsReactiveArray) {
        source = shallowReadArray(source);
      }
      ret = new Array(source.length);
      for (let i = 0, l = source.length; i < l; i++) {
        ret[i] = renderItem(
          sourceIsReactiveArray ? toReactive(source[i]) : source[i],
          i,
          void 0,
          cached
        );
      }
    } else if (typeof source === "number") {
      ret = new Array(source);
      for (let i = 0; i < source; i++) {
        ret[i] = renderItem(i + 1, i, void 0, cached);
      }
    } else if (isObject(source)) {
      if (source[Symbol.iterator]) {
        ret = Array.from(
          source,
          (item, i) => renderItem(item, i, void 0, cached)
        );
      } else {
        const keys = Object.keys(source);
        ret = new Array(keys.length);
        for (let i = 0, l = keys.length; i < l; i++) {
          const key = keys[i];
          ret[i] = renderItem(source[key], key, i, cached);
        }
      }
    } else {
      ret = [];
    }
    return ret;
  }
  const getPublicInstance = (i) => {
    if (!i) return null;
    if (isStatefulComponent(i)) return getComponentPublicInstance(i);
    return getPublicInstance(i.parent);
  };
  const publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
      $: (i) => i,
      $el: (i) => i.vnode.el,
      $data: (i) => i.data,
      $props: (i) => i.props,
      $attrs: (i) => i.attrs,
      $slots: (i) => i.slots,
      $refs: (i) => i.refs,
      $parent: (i) => getPublicInstance(i.parent),
      $root: (i) => getPublicInstance(i.root),
      $host: (i) => i.ce,
      $emit: (i) => i.emit,
      $options: (i) => resolveMergedOptions(i),
      $forceUpdate: (i) => i.f || (i.f = () => {
        queueJob(i.update);
      }),
      $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
      $watch: (i) => instanceWatch.bind(i)
    })
  );
  const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$2(state, key);
  const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      if (key === "__v_skip") {
        return true;
      }
      const { ctx, setupState, data, props, accessCache, type: type2, appContext } = instance;
      let normalizedProps;
      if (key[0] !== "$") {
        const n = accessCache[key];
        if (n !== void 0) {
          switch (n) {
            case 1:
              return setupState[key];
            case 2:
              return data[key];
            case 4:
              return ctx[key];
            case 3:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn$2(data, key)) {
          accessCache[key] = 2;
          return data[key];
        } else if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (normalizedProps = instance.propsOptions[0]) && hasOwn$2(normalizedProps, key)
        ) {
          accessCache[key] = 3;
          return props[key];
        } else if (ctx !== EMPTY_OBJ && hasOwn$2(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (shouldCacheAccess) {
          accessCache[key] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance.attrs, "get", "");
        }
        return publicGetter(instance);
      } else if (
        // css module (injected by vue-loader)
        (cssModule = type2.__cssModules) && (cssModule = cssModule[key])
      ) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn$2(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (
        // global properties
        globalProperties = appContext.config.globalProperties, hasOwn$2(globalProperties, key)
      ) {
        {
          return globalProperties[key];
        }
      } else ;
    },
    set({ _: instance }, key, value) {
      const { data, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (data !== EMPTY_OBJ && hasOwn$2(data, key)) {
        data[key] = value;
        return true;
      } else if (hasOwn$2(instance.props, key)) {
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        return false;
      } else {
        {
          ctx[key] = value;
        }
      }
      return true;
    },
    has({
      _: { data, setupState, accessCache, ctx, appContext, propsOptions }
    }, key) {
      let normalizedProps;
      return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn$2(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$2(normalizedProps, key) || hasOwn$2(ctx, key) || hasOwn$2(publicPropertiesMap, key) || hasOwn$2(appContext.config.globalProperties, key);
    },
    defineProperty(target, key, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key] = 0;
      } else if (hasOwn$2(descriptor, "value")) {
        this.set(target, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key, descriptor);
    }
  };
  function normalizePropsOrEmits(props) {
    return isArray$1(props) ? props.reduce(
      (normalized, p2) => (normalized[p2] = null, normalized),
      {}
    ) : props;
  }
  let shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook(options.beforeCreate, instance, "bc");
    }
    const {
      // state
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      // lifecycle
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render: render2,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      // public API
      expose,
      inheritAttrs,
      // assets
      components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = null;
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction$1(methodHandler)) {
          {
            ctx[key] = methodHandler.bind(publicThis);
          }
        }
      }
    }
    if (dataOptions) {
      const data = dataOptions.call(publicThis, publicThis);
      if (!isObject(data)) ;
      else {
        instance.data = reactive(data);
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
        const c = computed({
          get: get2,
          set: set2
        });
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => c.value,
          set: (v) => c.value = v
        });
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray$1(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray$1(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render2 && instance.render === NOOP) {
      instance.render = render2;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
    if (serverPrefetch) {
      markAsyncBoundary(instance);
    }
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray$1(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject(opt)) {
        if ("default" in opt) {
          injected = inject(
            opt.from || key,
            opt.default,
            true
          );
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef$1(injected)) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
    }
  }
  function callHook(hook, instance, type2) {
    callWithAsyncErrorHandling(
      isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
      instance,
      type2
    );
  }
  function createWatcher(raw, ctx, publicThis, key) {
    let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString$1(raw)) {
      const handler = ctx[raw];
      if (isFunction$1(handler)) {
        {
          watch(getter, handler);
        }
      }
    } else if (isFunction$1(raw)) {
      {
        watch(getter, raw.bind(publicThis));
      }
    } else if (isObject(raw)) {
      if (isArray$1(raw)) {
        raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
      } else {
        const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction$1(handler)) {
          watch(getter, handler, raw);
        }
      }
    } else ;
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const {
      mixins: globalMixins,
      optionsCache: cache,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
        );
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    if (isObject(base)) {
      cache.set(base, resolved);
    }
    return resolved;
  }
  function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        (m) => mergeOptions(to, m, strats, true)
      );
    }
    for (const key in from) {
      if (asMixin && key === "expose") ;
      else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
      }
    }
    return to;
  }
  const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return extend$1(
        isFunction$1(to) ? to.call(this, this) : to,
        isFunction$1(from) ? from.call(this, this) : from
      );
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray$1(raw)) {
      const res = {};
      for (let i = 0; i < raw.length; i++) {
        res[raw[i]] = raw[i];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from) : from;
  }
  function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
      if (isArray$1(to) && isArray$1(from)) {
        return [.../* @__PURE__ */ new Set([...to, ...from])];
      }
      return extend$1(
        /* @__PURE__ */ Object.create(null),
        normalizePropsOrEmits(to),
        normalizePropsOrEmits(from != null ? from : {})
      );
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to, from) {
    if (!to) return from;
    if (!from) return to;
    const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
    for (const key in from) {
      merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let uid$1 = 0;
  function createAppAPI(render2, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction$1(rootComponent)) {
        rootComponent = extend$1({}, rootComponent);
      }
      if (rootProps != null && !isObject(rootProps)) {
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = /* @__PURE__ */ new WeakSet();
      const pluginCleanupFns = [];
      let isMounted = false;
      const app = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version,
        get config() {
          return context.config;
        },
        set config(v) {
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin)) ;
          else if (plugin && isFunction$1(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app, ...options);
          } else if (isFunction$1(plugin)) {
            installedPlugins.add(plugin);
            plugin(app, ...options);
          } else ;
          return app;
        },
        mixin(mixin) {
          {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            }
          }
          return app;
        },
        component(name, component) {
          if (!component) {
            return context.components[name];
          }
          context.components[name] = component;
          return app;
        },
        directive(name, directive) {
          if (!directive) {
            return context.directives[name];
          }
          context.directives[name] = directive;
          return app;
        },
        mount(rootContainer, isHydrate, namespace) {
          if (!isMounted) {
            const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (namespace === true) {
              namespace = "svg";
            } else if (namespace === false) {
              namespace = void 0;
            }
            if (isHydrate && hydrate) {
              hydrate(vnode, rootContainer);
            } else {
              render2(vnode, rootContainer, namespace);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            return getComponentPublicInstance(vnode.component);
          }
        },
        onUnmount(cleanupFn) {
          pluginCleanupFns.push(cleanupFn);
        },
        unmount() {
          if (isMounted) {
            callWithAsyncErrorHandling(
              pluginCleanupFns,
              app._instance,
              16
            );
            render2(null, app._container);
            delete app._container.__vue_app__;
          }
        },
        provide(key, value) {
          context.provides[key] = value;
          return app;
        },
        runWithContext(fn) {
          const lastApp = currentApp;
          currentApp = app;
          try {
            return fn();
          } finally {
            currentApp = lastApp;
          }
        }
      };
      return app;
    };
  }
  let currentApp = null;
  function provide(key, value) {
    if (!currentInstance) ;
    else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else ;
    }
  }
  function hasInjectionContext() {
    return !!(currentInstance || currentRenderingInstance || currentApp);
  }
  const internalObjectProto = {};
  const createInternalObject = () => Object.create(internalObjectProto);
  const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = createInternalObject();
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
      // always force full diff in dev
      // - #1942 if hmr is enabled with sfc component
      // - vite#872 non-sfc component used by sfc component
      (optimized || patchFlag > 0) && !(patchFlag & 16)
    ) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i = 0; i < propsToUpdate.length; i++) {
          let key = propsToUpdate[i];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          const value = rawProps[key];
          if (options) {
            if (hasOwn$2(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize$1(key);
              props[camelizedKey] = resolvePropValue(
                options,
                rawCurrentProps,
                camelizedKey,
                value,
                instance,
                false
              );
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || // for camelCase
        !hasOwn$2(rawProps, key) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = hyphenate$1(key)) === key || !hasOwn$2(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && // for camelCase
            (rawPrevProps[key] !== void 0 || // for kebab-case
            rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(
                options,
                rawCurrentProps,
                key,
                void 0,
                instance,
                true
              );
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn$2(rawProps, key) && true) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance.attrs, "set", "");
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options && hasOwn$2(options, camelKey = camelize$1(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs) || value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i = 0; i < needCastKeys.length; i++) {
        const key = needCastKeys[i];
        props[key] = resolvePropValue(
          options,
          rawCurrentProps,
          key,
          castValues[key],
          instance,
          !hasOwn$2(castValues, key)
        );
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
      const hasDefault = hasOwn$2(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            const reset = setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(
              null,
              props
            );
            reset();
          }
        } else {
          value = defaultValue;
        }
        if (instance.ce) {
          instance.ce._setProp(key, value);
        }
      }
      if (opt[
        0
        /* shouldCast */
      ]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[
          1
          /* shouldCastTrue */
        ] && (value === "" || value === hyphenate$1(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  const mixinPropsCache = /* @__PURE__ */ new WeakMap();
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = asMixin ? mixinPropsCache : appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction$1(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys] = normalizePropsOptions(raw2, appContext, true);
        extend$1(normalized, props);
        if (keys) needCastKeys.push(...keys);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject(comp)) {
        cache.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray$1(raw)) {
      for (let i = 0; i < raw.length; i++) {
        const normalizedKey = camelize$1(raw[i]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      for (const key in raw) {
        const normalizedKey = camelize$1(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend$1({}, opt);
          const propType = prop.type;
          let shouldCast = false;
          let shouldCastTrue = true;
          if (isArray$1(propType)) {
            for (let index = 0; index < propType.length; ++index) {
              const type2 = propType[index];
              const typeName = isFunction$1(type2) && type2.name;
              if (typeName === "Boolean") {
                shouldCast = true;
                break;
              } else if (typeName === "String") {
                shouldCastTrue = false;
              }
            }
          } else {
            shouldCast = isFunction$1(propType) && propType.name === "Boolean";
          }
          prop[
            0
            /* shouldCast */
          ] = shouldCast;
          prop[
            1
            /* shouldCastTrue */
          ] = shouldCastTrue;
          if (shouldCast || hasOwn$2(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject(comp)) {
      cache.set(comp, res);
    }
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$" && !isReservedProp(key)) {
      return true;
    }
    return false;
  }
  const isInternalKey = (key) => key[0] === "_" || key === "$stable";
  const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  const normalizeSlot = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (false) ;
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key)) continue;
      const value = rawSlots[key];
      if (isFunction$1(value)) {
        slots[key] = normalizeSlot(key, value, ctx);
      } else if (value != null) {
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  const normalizeVNodeSlots = (instance, children) => {
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  const assignSlots = (slots, children, optimized) => {
    for (const key in children) {
      if (optimized || key !== "_") {
        slots[key] = children[key];
      }
    }
  };
  const initSlots = (instance, children, optimized) => {
    const slots = instance.slots = createInternalObject();
    if (instance.vnode.shapeFlag & 32) {
      const type2 = children._;
      if (type2) {
        assignSlots(slots, children, optimized);
        if (optimized) {
          def$1(slots, "_", type2, true);
        }
      } else {
        normalizeObjectSlots(children, slots);
      }
    } else if (children) {
      normalizeVNodeSlots(instance, children);
    }
  };
  const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type2 = children._;
      if (type2) {
        if (optimized && type2 === 1) {
          needDeletionCheck = false;
        } else {
          assignSlots(slots, children, optimized);
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
          delete slots[key];
        }
      }
    }
  };
  const queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    const target = getGlobalThis();
    target.__VUE__ = true;
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type: type2, ref: ref3, shapeFlag } = n2;
      switch (type2) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, namespace);
          }
          break;
        case Fragment:
          processFragment(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          break;
        default:
          if (shapeFlag & 1) {
            processElement(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 6) {
            processComponent(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 64) {
            type2.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (shapeFlag & 128) {
            type2.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else ;
      }
      if (ref3 != null && parentComponent) {
        setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateText(n2.children),
          container,
          anchor
        );
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateComment(n2.children || ""),
          container,
          anchor
        );
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, namespace) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace,
        n2.el,
        n2.anchor
      );
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      if (n2.type === "svg") {
        namespace = "svg";
      } else if (n2.type === "math") {
        namespace = "mathml";
      }
      if (n1 == null) {
        mountElement(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { props, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(
        vnode.type,
        namespace,
        props && props.is,
        props
      );
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(vnode, namespace),
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], namespace, parentComponent);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value, namespace);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i = 0; i < slotScopeIds.length; i++) {
          hostSetScopeId(el, slotScopeIds[i]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
          const parentVNode = parentComponent.vnode;
          setScopeId(
            el,
            parentVNode,
            parentVNode.scopeId,
            parentVNode.slotScopeIds,
            parentComponent.parent
          );
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
      for (let i = start; i < children.length; i++) {
        const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
        patch(
          null,
          child,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
        hostSetElementText(el, "");
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          el,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds
        );
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds,
          false
        );
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, oldProps, newProps, parentComponent, namespace);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, namespace);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              const key = propsToUpdate[i];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(el, key, prev, next, namespace, parentComponent);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
      for (let i = 0; i < newChildren.length; i++) {
        const oldVNode = oldChildren[i];
        const newVNode = newChildren[i];
        const container = (
          // oldVNode may be an errored async setup() component inside Suspense
          // which will not have a mounted element
          oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
          // of the Fragment itself so it can move its children.
          (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
          // which also requires the correct parent container
          !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
          oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
            // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer
          )
        );
        patch(
          oldVNode,
          newVNode,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          true
        );
      }
    };
    const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(
                el,
                key,
                oldProps[key],
                null,
                namespace,
                parentComponent
              );
            }
          }
        }
        for (const key in newProps) {
          if (isReservedProp(key)) continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(el, key, prev, next, namespace, parentComponent);
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(
          // #10007
          // such fragment like `<></>` will be compiled into
          // a fragment which doesn't have a children.
          // In this case fallback to an empty array
          n2.children || [],
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            container,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          if (
            // #2080 if the stable fragment has a key, it's a <template v-for> that may
            //  get moved around. Make sure all root level vnodes inherit el.
            // #2134 or if it's a component root, it may also get moved around
            // as the component is being moved.
            n2.key != null || parentComponent && n2 === parentComponent.subTree
          ) {
            traverseStaticChildren(
              n1,
              n2,
              true
              /* shallow */
            );
          }
        } else {
          patchChildren(
            n1,
            n2,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(
            n2,
            container,
            anchor,
            namespace,
            optimized
          );
        } else {
          mountComponent(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            optimized
          );
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
      const instance = initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      );
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        setupComponent(instance, false, optimized);
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
      } else {
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          namespace,
          optimized
        );
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          updateComponentPreRender(instance, n2, optimized);
          return;
        } else {
          instance.next = n2;
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m, parent, root, type: type2 } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns$1(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          toggleRecurse(instance, true);
          if (el && hydrateNode) {
            const hydrateSubTree = () => {
              instance.subTree = renderComponentRoot(instance);
              hydrateNode(
                el,
                instance.subTree,
                instance,
                parentSuspense,
                null
              );
            };
            if (isAsyncWrapperVNode) {
              type2.__asyncHydrate(
                el,
                instance,
                hydrateSubTree
              );
            } else {
              hydrateSubTree();
            }
          } else {
            if (root.ce) {
              root.ce._injectChildStyle(type2);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            patch(
              null,
              subTree,
              container,
              anchor,
              instance,
              parentSuspense,
              namespace
            );
            initialVNode.el = subTree.el;
          }
          if (m) {
            queuePostRenderEffect(m, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
              parentSuspense
            );
          }
          if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u, parent, vnode } = instance;
          {
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(() => {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          let originNext = next;
          let vnodeHook;
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns$1(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          toggleRecurse(instance, true);
          const nextTree = renderComponentRoot(instance);
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          patch(
            prevTree,
            nextTree,
            // parent may have changed if it's in a teleport
            hostParentNode(prevTree.el),
            // anchor may have changed if it's in a fragment
            getNextHostNode(prevTree),
            instance,
            parentSuspense,
            namespace
          );
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, next, vnode),
              parentSuspense
            );
          }
        }
      };
      instance.scope.on();
      const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
      instance.scope.off();
      const update = instance.update = effect2.run.bind(effect2);
      const job = instance.job = effect2.runIfDirty.bind(effect2);
      job.i = instance;
      job.id = instance.uid;
      effect2.scheduler = () => queueJob(job);
      toggleRecurse(instance, true);
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i;
      for (i = 0; i < commonLength; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        patch(
          c1[i],
          nextChild,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
      if (oldLength > newLength) {
        unmountChildren(
          c1,
          parentComponent,
          parentSuspense,
          true,
          false,
          commonLength
        );
      } else {
        mountChildren(
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized,
          commonLength
        );
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let i = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i <= e1 && i <= e2) {
        const n1 = c1[i];
        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        i++;
      }
      while (i <= e1 && i <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i > e1) {
        if (i <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i <= e2) {
            patch(
              null,
              c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            i++;
          }
        }
      } else if (i > e2) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } else {
        const s1 = i;
        const s2 = i;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i = s2; i <= e2; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (nextChild.key != null) {
            keyToNewIndexMap.set(nextChild.key, i);
          }
        }
        let j;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
        for (i = s1; i <= e1; i++) {
          const prevChild = c1[i];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j = s2; j <= e2; j++) {
              if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                newIndex = j;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(
              prevChild,
              c2[newIndex],
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j = increasingNewIndexSequence.length - 1;
        for (i = toBePatched - 1; i >= 0; i--) {
          const nextIndex = s2 + i;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i] === 0) {
            patch(
              null,
              nextChild,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (moved) {
            if (j < 0 || i !== increasingNewIndexSequence[j]) {
              move(nextChild, container, anchor, 2);
            } else {
              j--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type: type2, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type2.move(vnode, container, anchor, internals);
        return;
      }
      if (type2 === Fragment) {
        hostInsert(el, container, anchor);
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type2 === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type: type2,
        props,
        ref: ref3,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs,
        cacheIndex
      } = vnode;
      if (patchFlag === -2) {
        optimized = false;
      }
      if (ref3 != null) {
        setRef(ref3, null, parentSuspense, vnode, true);
      }
      if (cacheIndex != null) {
        parentComponent.renderCache[cacheIndex] = void 0;
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(
            vnode,
            parentComponent,
            parentSuspense,
            internals,
            doRemove
          );
        } else if (dynamicChildren && // #5154
        // when v-once is used inside a block, setBlockTracking(-1) marks the
        // parent block with hasOnce: true
        // so that it doesn't take the fast path during unmount - otherwise
        // components nested in v-once are never unmounted.
        !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
        (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(
            dynamicChildren,
            parentComponent,
            parentSuspense,
            false,
            true
          );
        } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type: type2, el, anchor, transition } = vnode;
      if (type2 === Fragment) {
        {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type2 === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      const { bum, scope, job, subTree, um, m, a } = instance;
      invalidateMount(m);
      invalidateMount(a);
      if (bum) {
        invokeArrayFns$1(bum);
      }
      scope.stop();
      if (job) {
        job.flags |= 8;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i = start; i < children.length; i++) {
        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      const el = hostNextSibling(vnode.anchor || vnode.el);
      const teleportEnd = el && el[TeleportEndKey];
      return teleportEnd ? hostNextSibling(teleportEnd) : el;
    };
    let isFlushing2 = false;
    const render2 = (vnode, container, namespace) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(
          container._vnode || null,
          vnode,
          container,
          null,
          null,
          null,
          namespace
        );
      }
      container._vnode = vnode;
      if (!isFlushing2) {
        isFlushing2 = true;
        flushPreFlushCbs();
        flushPostFlushCbs();
        isFlushing2 = false;
      }
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate;
    let hydrateNode;
    return {
      render: render2,
      hydrate,
      createApp: createAppAPI(render2, hydrate)
    };
  }
  function resolveChildrenNamespace({ type: type2, props }, currentNamespace) {
    return currentNamespace === "svg" && type2 === "foreignObject" || currentNamespace === "mathml" && type2 === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse({ effect: effect2, job }, allowed) {
    if (allowed) {
      effect2.flags |= 32;
      job.flags |= 4;
    } else {
      effect2.flags &= ~32;
      job.flags &= ~4;
    }
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray$1(ch1) && isArray$1(ch2)) {
      for (let i = 0; i < ch1.length; i++) {
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }
          if (!shallow && c2.patchFlag !== -2)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
      const arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p2[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = u + v >> 1;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p2[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p2[v];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }
  function invalidateMount(hooks) {
    if (hooks) {
      for (let i = 0; i < hooks.length; i++)
        hooks[i].flags |= 8;
    }
  }
  const ssrContextKey = Symbol.for("v-scx");
  const useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey);
      return ctx;
    }
  };
  function watch(source, cb, options) {
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb, options = EMPTY_OBJ) {
    const { immediate, deep, flush, once } = options;
    const baseWatchOptions = extend$1({}, options);
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else if (!cb || immediate) {
        baseWatchOptions.once = true;
      } else {
        return {
          stop: NOOP,
          resume: NOOP,
          pause: NOOP
        };
      }
    }
    const instance = currentInstance;
    baseWatchOptions.call = (fn, type2, args) => callWithAsyncErrorHandling(fn, instance, type2, args);
    let isPre = false;
    if (flush === "post") {
      baseWatchOptions.scheduler = (job) => {
        queuePostRenderEffect(job, instance && instance.suspense);
      };
    } else if (flush !== "sync") {
      isPre = true;
      baseWatchOptions.scheduler = (job, isFirstRun) => {
        if (isFirstRun) {
          job();
        } else {
          queueJob(job);
        }
      };
    }
    baseWatchOptions.augmentJob = (job) => {
      if (cb) {
        job.flags |= 4;
      }
      if (isPre) {
        job.flags |= 2;
        if (instance) {
          job.id = instance.uid;
          job.i = instance;
        }
      }
    };
    const watchHandle = watch$1(source, cb, baseWatchOptions);
    if (ssrCleanup) ssrCleanup.push(watchHandle);
    return watchHandle;
  }
  function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction$1(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const reset = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    reset();
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i = 0; i < segments.length && cur; i++) {
        cur = cur[segments[i]];
      }
      return cur;
    };
  }
  const getModelModifiers = (props, modelName) => {
    return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize$1(modelName)}Modifiers`] || props[`${hyphenate$1(modelName)}Modifiers`];
  };
  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props = instance.vnode.props || EMPTY_OBJ;
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
    if (modifiers) {
      if (modifiers.trim) {
        args = rawArgs.map((a) => isString$1(a) ? a.trim() : a);
      }
      if (modifiers.number) {
        args = rawArgs.map(looseToNumber$1);
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
    props[handlerName = toHandlerKey(camelize$1(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate$1(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(
        handler,
        instance,
        6,
        args
      );
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(
        onceHandler,
        instance,
        6,
        args
      );
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction$1(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend$1(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject(comp)) {
        cache.set(comp, null);
      }
      return null;
    }
    if (isArray$1(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend$1(normalized, raw);
    }
    if (isObject(comp)) {
      cache.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn$1(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn$2(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$2(options, hyphenate$1(key)) || hasOwn$2(options, key);
  }
  function markAttrsAccessed() {
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit: emit2,
      render: render2,
      renderCache,
      props,
      data,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    const prev = setCurrentRenderingInstance(instance);
    let result;
    let fallthroughAttrs;
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        const thisProxy = false ? new Proxy(proxyToUse, {
          get(target, key, receiver) {
            warn$1(
              `Property '${String(
                key
              )}' was accessed via 'this'. Avoid using 'this' in templates.`
            );
            return Reflect.get(target, key, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(
          render2.call(
            thisProxy,
            proxyToUse,
            renderCache,
            false ? shallowReadonly(props) : props,
            setupState,
            data,
            ctx
          )
        );
        fallthroughAttrs = attrs;
      } else {
        const render22 = Component;
        if (false) ;
        result = normalizeVNode(
          render22.length > 1 ? render22(
            false ? shallowReadonly(props) : props,
            false ? {
              get attrs() {
                markAttrsAccessed();
                return shallowReadonly(attrs);
              },
              slots,
              emit: emit2
            } : { attrs, slots, emit: emit2 }
          ) : render22(
            false ? shallowReadonly(props) : props,
            null
          )
        );
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root = result;
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root;
      if (keys.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys.some(isModelListener$1)) {
            fallthroughAttrs = filterModelListeners(
              fallthroughAttrs,
              propsOptions
            );
          }
          root = cloneVNode(root, fallthroughAttrs, false, true);
        }
      }
    }
    if (vnode.dirs) {
      root = cloneVNode(root, null, false, true);
      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      root.transition = vnode.transition;
    }
    {
      result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
      if (key === "class" || key === "style" || isOn$1(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
      if (!isModelListener$1(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i = 0; i < dynamicProps.length; i++) {
          const key = dynamicProps[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
      const key = nextKeys[i];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    while (parent) {
      const root = parent.subTree;
      if (root.suspense && root.suspense.activeBranch === vnode) {
        root.el = vnode.el;
      }
      if (root === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
      } else {
        break;
      }
    }
  }
  const isSuspense = (type2) => type2.__isSuspense;
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray$1(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  const Fragment = Symbol.for("v-fgt");
  const Text = Symbol.for("v-txt");
  const Comment = Symbol.for("v-cmt");
  const Static = Symbol.for("v-stc");
  const blockStack = [];
  let currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  let isBlockTreeEnabled = 1;
  function setBlockTracking(value) {
    isBlockTreeEnabled += value;
    if (value < 0 && currentBlock) {
      currentBlock.hasOnce = true;
    }
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type2, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
      createBaseVNode(
        type2,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        true
      )
    );
  }
  function createBlock(type2, props, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type2,
        props,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    return n1.type === n2.type && n1.key === n2.key;
  }
  const normalizeKey = ({ key }) => key != null ? key : null;
  const normalizeRef = ({
    ref: ref3,
    ref_key,
    ref_for
  }) => {
    if (typeof ref3 === "number") {
      ref3 = "" + ref3;
    }
    return ref3 != null ? isString$1(ref3) || isRef$1(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
  };
  function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type: type2,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type2.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString$1(children) ? 8 : 16;
    }
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  const createVNode = _createVNode;
  function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
      type2 = Comment;
    }
    if (isVNode(type2)) {
      const cloned = cloneVNode(
        type2,
        props,
        true
        /* mergeRef: true */
      );
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type2)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag = -2;
      return cloned;
    }
    if (isClassComponent(type2)) {
      type2 = type2.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString$1(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject(style)) {
        if (isProxy(style) && !isArray$1(style)) {
          style = extend$1({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString$1(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject(type2) ? 4 : isFunction$1(type2) ? 2 : 0;
    return createBaseVNode(
      type2,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props) {
    if (!props) return null;
    return isProxy(props) || isInternalObject(props) ? extend$1({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
    const { props, ref: ref3, patchFlag, children, transition } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? (
        // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
      ) : ref3,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children,
      target: vnode.target,
      targetStart: vnode.targetStart,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: preserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition,
      // These should technically only be non-null on mounted VNodes. However,
      // they *should* be copied for kept-alive vnodes. So we just always copy
      // them since them being non-null during a mount doesn't affect the logic as
      // they will simply be overwritten.
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    if (transition && cloneTransition) {
      setTransitionHooks(
        cloned,
        transition.clone(cloned)
      );
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray$1(child)) {
      return createVNode(
        Fragment,
        null,
        // #3666, avoid reference pollution when reusing vnode
        child.slice()
      );
    } else if (typeof child === "object") {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type2 = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray$1(children)) {
      type2 = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type2 = 32;
        const slotFlag = children._;
        if (!slotFlag && !isInternalObject(children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction$1(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type2 = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type2 = 16;
        children = [createTextVNode(children)];
      } else {
        type2 = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type2;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
      const toMerge = args[i];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn$1(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  const emptyAppContext = createAppContext();
  let uid = 0;
  function createComponentInstance(vnode, parent, suspense) {
    const type2 = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type: type2,
      parent,
      appContext,
      root: null,
      // to be immediately set
      next: null,
      subTree: null,
      // will be set synchronously right after creation
      effect: null,
      update: null,
      // will be set synchronously right after creation
      job: null,
      scope: new EffectScope(
        true
        /* detached */
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      ids: parent ? parent.ids : ["", 0, 0],
      accessCache: null,
      renderCache: [],
      // local resolved assets
      components: null,
      directives: null,
      // resolved props and emits options
      propsOptions: normalizePropsOptions(type2, appContext),
      emitsOptions: normalizeEmitsOptions(type2, appContext),
      // emit
      emit: null,
      // to be set immediately
      emitted: null,
      // props default value
      propsDefaults: EMPTY_OBJ,
      // inheritAttrs
      inheritAttrs: type2.inheritAttrs,
      // state
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      // suspense related
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      // lifecycle hooks
      // not using enums here because it results in computed properties
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    {
      instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  let currentInstance = null;
  let internalSetCurrentInstance;
  let setInSSRSetupState;
  {
    const g = getGlobalThis();
    const registerGlobalSetter = (key, setter) => {
      let setters;
      if (!(setters = g[key])) setters = g[key] = [];
      setters.push(setter);
      return (v) => {
        if (setters.length > 1) setters.forEach((set2) => set2(v));
        else setters[0](v);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      `__VUE_INSTANCE_SETTERS__`,
      (v) => currentInstance = v
    );
    setInSSRSetupState = registerGlobalSetter(
      `__VUE_SSR_SETTERS__`,
      (v) => isInSSRComponentSetup = v
    );
  }
  const setCurrentInstance = (instance) => {
    const prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return () => {
      instance.scope.off();
      internalSetCurrentInstance(prev);
    };
  };
  const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false, optimized = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children, optimized);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    const { setup } = Component;
    if (setup) {
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      const reset = setCurrentInstance(instance);
      pauseTracking();
      const setupResult = callWithErrorHandling(
        setup,
        instance,
        0,
        [
          instance.props,
          setupContext
        ]
      );
      resetTracking();
      reset();
      if (isPromise$1(setupResult)) {
        if (!isAsyncWrapper(instance)) markAsyncBoundary(instance);
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction$1(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject(setupResult)) {
      instance.setupState = proxyRefs(setupResult);
    } else ;
    finishComponentSetup(instance, isSSR);
  }
  let compile;
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      if (!isSSR && compile && !Component.render) {
        const template = Component.template || resolveMergedOptions(instance).template;
        if (template) {
          const { isCustomElement, compilerOptions } = instance.appContext.config;
          const { delimiters, compilerOptions: componentCompilerOptions } = Component;
          const finalCompilerOptions = extend$1(
            extend$1(
              {
                isCustomElement,
                delimiters
              },
              compilerOptions
            ),
            componentCompilerOptions
          );
          Component.render = compile(template, finalCompilerOptions);
        }
      }
      instance.render = Component.render || NOOP;
    }
    {
      const reset = setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        reset();
      }
    }
  }
  const attrsProxyHandlers = {
    get(target, key) {
      track(target, "get", "");
      return target[key];
    }
  };
  function createSetupContext(instance) {
    const expose = (exposed) => {
      instance.exposed = exposed || {};
    };
    {
      return {
        attrs: new Proxy(instance.attrs, attrsProxyHandlers),
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getComponentPublicInstance(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has(target, key) {
          return key in target || key in publicPropertiesMap;
        }
      }));
    } else {
      return instance.proxy;
    }
  }
  const classifyRE = /(?:^|[-_])(\w)/g;
  const classify = (str2) => str2.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component, includeInferred = true) {
    return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
      const match = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component) {
            return key;
          }
        }
      };
      name = inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction$1(value) && "__vccOpts" in value;
  }
  const computed = (getterOrOptions, debugOptions) => {
    const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    return c;
  };
  const version = "3.5.0-beta.3";
  /**
  * @vue/shared v3.5.0-beta.3
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function makeMap(str2, expectsLowerCase) {
    const set2 = new Set(str2.split(","));
    return (val) => set2.has(val);
  }
  const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  const isModelListener = (key) => key.startsWith("onUpdate:");
  const extend = Object.assign;
  const hasOwnProperty = Object.prototype.hasOwnProperty;
  const hasOwn$1 = (val, key) => hasOwnProperty.call(val, key);
  const isArray = Array.isArray;
  const isFunction = (val) => typeof val === "function";
  const isString = (val) => typeof val === "string";
  const isSymbol = (val) => typeof val === "symbol";
  const objectToString = Object.prototype.toString;
  const toTypeString = (value) => objectToString.call(value);
  const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
  const cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str2) => {
      const hit = cache[str2];
      return hit || (cache[str2] = fn(str2));
    };
  };
  const camelizeRE = /-(\w)/g;
  const camelize = cacheStringFunction(
    (str2) => {
      return str2.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    }
  );
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction(
    (str2) => str2.replace(hyphenateRE, "-$1").toLowerCase()
  );
  const capitalize = cacheStringFunction((str2) => {
    return str2.charAt(0).toUpperCase() + str2.slice(1);
  });
  const invokeArrayFns = (fns, ...arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](...arg);
    }
  };
  const looseToNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  const toNumber = (val) => {
    const n = isString(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
  };
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  /**
  * @vue/runtime-dom v3.5.0-beta.3
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  let policy = void 0;
  const tt = typeof window !== "undefined" && window.trustedTypes;
  if (tt) {
    try {
      policy = /* @__PURE__ */ tt.createPolicy("vue", {
        createHTML: (val) => val
      });
    } catch (e) {
    }
  }
  const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
  const svgNS = "http://www.w3.org/2000/svg";
  const mathmlNS = "http://www.w3.org/1998/Math/MathML";
  const doc = typeof document !== "undefined" ? document : null;
  const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  const nodeOps = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag2, namespace, is, props) => {
      const el = namespace === "svg" ? doc.createElementNS(svgNS, tag2) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag2) : is ? doc.createElement(tag2, { is }) : doc.createElement(tag2);
      if (tag2 === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
      node.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id) {
      el.setAttribute(id, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, namespace, start, end) {
      const before = anchor ? anchor.previousSibling : parent.lastChild;
      if (start && (start === end || start.nextSibling)) {
        while (true) {
          parent.insertBefore(start.cloneNode(true), anchor);
          if (start === end || !(start = start.nextSibling)) break;
        }
      } else {
        templateContainer.innerHTML = unsafeToTrustedHTML(
          namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
        );
        const template = templateContainer.content;
        if (namespace === "svg" || namespace === "mathml") {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent.insertBefore(template, anchor);
      }
      return [
        // first
        before ? before.nextSibling : parent.firstChild,
        // last
        anchor ? anchor.previousSibling : parent.lastChild
      ];
    }
  };
  const vtcKey = Symbol("_vtc");
  function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  const vShowOriginalDisplay = Symbol("_vod");
  const vShowHidden = Symbol("_vsh");
  const CSS_VAR_TEXT = Symbol("");
  const displayRE = /(^|;)\s*display\s*:/;
  function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString(next);
    let hasControlledDisplay = false;
    if (next && !isCssString) {
      if (prev) {
        if (!isString(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        } else {
          for (const prevStyle of prev.split(";")) {
            const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
      }
      for (const key in next) {
        if (key === "display") {
          hasControlledDisplay = true;
        }
        setStyle(style, key, next[key]);
      }
    } else {
      if (isCssString) {
        if (prev !== next) {
          const cssVarText = style[CSS_VAR_TEXT];
          if (cssVarText) {
            next += ";" + cssVarText;
          }
          style.cssText = next;
          hasControlledDisplay = displayRE.test(next);
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
    }
    if (vShowOriginalDisplay in el) {
      el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
      if (el[vShowHidden]) {
        style.display = "none";
      }
    }
  }
  const importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
    if (isArray(val)) {
      val.forEach((v) => setStyle(style, name, v));
    } else {
      if (val == null) val = "";
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(
            hyphenate(prefixed),
            val.replace(importantRE, ""),
            "important"
          );
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  const prefixes = ["Webkit", "Moz", "ms"];
  const prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize$1(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize(name);
    for (let i = 0; i < prefixes.length; i++) {
      const prefixed = prefixes[i] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  const xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance, isBoolean = isSpecialBooleanAttr(key)) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      if (value == null || isBoolean && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(
          key,
          isBoolean ? "" : isSymbol(value) ? String(value) : value
        );
      }
    }
  }
  function patchDOMProp(el, key, value, parentComponent) {
    if (key === "innerHTML" || key === "textContent") {
      if (value == null) return;
      el[key] = value;
      return;
    }
    const tag2 = el.tagName;
    if (key === "value" && tag2 !== "PROGRESS" && // custom elements may use _value internally
    !tag2.includes("-")) {
      const oldValue = tag2 === "OPTION" ? el.getAttribute("value") || "" : el.value;
      const newValue = value == null ? "" : String(value);
      if (oldValue !== newValue || !("_value" in el)) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      el._value = value;
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type2 = typeof el[key];
      if (type2 === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type2 === "string") {
        value = "";
        needRemove = true;
      } else if (type2 === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key] = value;
    } catch (e) {
    }
    needRemove && el.removeAttribute(key);
  }
  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  const veiKey = Symbol("_vei");
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = nextValue;
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(
          nextValue,
          instance
        );
        addEventListener(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m;
      while (m = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m[0].length);
        options[m[0].toLowerCase()] = true;
      }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options];
  }
  let cachedNow = 0;
  const p = /* @__PURE__ */ Promise.resolve();
  const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      if (!e._vts) {
        e._vts = Date.now();
      } else if (e._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e, invoker.value),
        instance,
        5,
        [e]
      );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray(value)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map(
        (fn) => (e2) => !e2._stopped && fn && fn(e2)
      );
    } else {
      return value;
    }
  }
  const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
  key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
  const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
    const isSVG = namespace === "svg";
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(el, key, nextValue);
      if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
        patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
      }
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && isNativeOn(key) && isFunction(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (key === "width" || key === "height") {
      const tag2 = el.tagName;
      if (tag2 === "IMG" || tag2 === "VIDEO" || tag2 === "CANVAS" || tag2 === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key) && isString(value)) {
      return false;
    }
    if (key in el) {
      return true;
    }
    if (el._isVueCE && (/[A-Z]/.test(key) || !isString(value))) {
      return true;
    }
    return false;
  }
  const REMOVAL = {};
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function defineCustomElement(options, extraOptions, _createApp) {
    const Comp = /* @__PURE__ */ defineComponent(options, extraOptions);
    if (isPlainObject$1(Comp)) extend(Comp, extraOptions);
    class VueCustomElement extends VueElement {
      constructor(initialProps) {
        super(Comp, initialProps, _createApp);
      }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
  }
  const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
  };
  class VueElement extends BaseClass {
    constructor(_def, _props = {}, _createApp = createApp) {
      super();
      this._def = _def;
      this._props = _props;
      this._createApp = _createApp;
      this._isVueCE = true;
      this._instance = null;
      this._app = null;
      this._nonce = this._def.nonce;
      this._connected = false;
      this._resolved = false;
      this._numberProps = null;
      this._styleChildren = /* @__PURE__ */ new WeakSet();
      this._ob = null;
      if (this.shadowRoot && _createApp !== createApp) {
        this._root = this.shadowRoot;
      } else {
        if (_def.shadowRoot !== false) {
          this.attachShadow({ mode: "open" });
          this._root = this.shadowRoot;
        } else {
          this._root = this;
        }
      }
      if (!this._def.__asyncLoader) {
        this._resolveProps(this._def);
      }
    }
    connectedCallback() {
      if (!this.shadowRoot) {
        this._parseSlots();
      }
      this._connected = true;
      let parent = this;
      while (parent = parent && (parent.parentNode || parent.host)) {
        if (parent instanceof VueElement) {
          this._parent = parent;
          break;
        }
      }
      if (!this._instance) {
        if (this._resolved) {
          this._setParent();
          this._update();
        } else {
          if (parent && parent._pendingResolve) {
            this._pendingResolve = parent._pendingResolve.then(() => {
              this._pendingResolve = void 0;
              this._resolveDef();
            });
          } else {
            this._resolveDef();
          }
        }
      }
    }
    _setParent(parent = this._parent) {
      if (parent) {
        this._instance.parent = parent._instance;
        this._instance.provides = parent._instance.provides;
      }
    }
    disconnectedCallback() {
      this._connected = false;
      nextTick(() => {
        if (!this._connected) {
          if (this._ob) {
            this._ob.disconnect();
            this._ob = null;
          }
          this._app && this._app.unmount();
          this._instance.ce = void 0;
          this._app = this._instance = null;
        }
      });
    }
    /**
     * resolve inner component definition (handle possible async component)
     */
    _resolveDef() {
      if (this._pendingResolve) {
        return;
      }
      for (let i = 0; i < this.attributes.length; i++) {
        this._setAttr(this.attributes[i].name);
      }
      this._ob = new MutationObserver((mutations) => {
        for (const m of mutations) {
          this._setAttr(m.attributeName);
        }
      });
      this._ob.observe(this, { attributes: true });
      const resolve = (def2, isAsync = false) => {
        this._resolved = true;
        this._pendingResolve = void 0;
        const { props, styles } = def2;
        let numberProps;
        if (props && !isArray(props)) {
          for (const key in props) {
            const opt = props[key];
            if (opt === Number || opt && opt.type === Number) {
              if (key in this._props) {
                this._props[key] = toNumber(this._props[key]);
              }
              (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key)] = true;
            }
          }
        }
        this._numberProps = numberProps;
        if (isAsync) {
          this._resolveProps(def2);
        }
        if (this.shadowRoot) {
          this._applyStyles(styles);
        }
        this._mount(def2);
      };
      const asyncDef = this._def.__asyncLoader;
      if (asyncDef) {
        this._pendingResolve = asyncDef().then(
          (def2) => resolve(this._def = def2, true)
        );
      } else {
        resolve(this._def);
      }
    }
    _mount(def2) {
      this._app = this._createApp(def2);
      if (def2.configureApp) {
        def2.configureApp(this._app);
      }
      this._app._ceVNode = this._createVNode();
      this._app.mount(this._root);
      const exposed = this._instance && this._instance.exposed;
      if (!exposed) return;
      for (const key in exposed) {
        if (!hasOwn$1(this, key)) {
          Object.defineProperty(this, key, {
            // unwrap ref to be consistent with public instance behavior
            get: () => unref(exposed[key])
          });
        }
      }
    }
    _resolveProps(def2) {
      const { props } = def2;
      const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});
      for (const key of Object.keys(this)) {
        if (key[0] !== "_" && declaredPropKeys.includes(key)) {
          this._setProp(key, this[key]);
        }
      }
      for (const key of declaredPropKeys.map(camelize)) {
        Object.defineProperty(this, key, {
          get() {
            return this._getProp(key);
          },
          set(val) {
            this._setProp(key, val, true, true);
          }
        });
      }
    }
    _setAttr(key) {
      if (key.startsWith("data-v-")) return;
      const has2 = this.hasAttribute(key);
      let value = has2 ? this.getAttribute(key) : REMOVAL;
      const camelKey = camelize(key);
      if (has2 && this._numberProps && this._numberProps[camelKey]) {
        value = toNumber(value);
      }
      this._setProp(camelKey, value, false, true);
    }
    /**
     * @internal
     */
    _getProp(key) {
      return this._props[key];
    }
    /**
     * @internal
     */
    _setProp(key, val, shouldReflect = true, shouldUpdate = false) {
      if (val !== this._props[key]) {
        if (val === REMOVAL) {
          delete this._props[key];
        } else {
          this._props[key] = val;
        }
        if (shouldUpdate && this._instance) {
          this._update();
        }
        if (shouldReflect) {
          if (val === true) {
            this.setAttribute(hyphenate(key), "");
          } else if (typeof val === "string" || typeof val === "number") {
            this.setAttribute(hyphenate(key), val + "");
          } else if (!val) {
            this.removeAttribute(hyphenate(key));
          }
        }
      }
    }
    _update() {
      render(this._createVNode(), this._root);
    }
    _createVNode() {
      const baseProps = {};
      if (!this.shadowRoot) {
        baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);
      }
      const vnode = createVNode(this._def, extend(baseProps, this._props));
      if (!this._instance) {
        vnode.ce = (instance) => {
          this._instance = instance;
          instance.ce = this;
          instance.isCE = true;
          const dispatch = (event, args) => {
            this.dispatchEvent(
              new CustomEvent(
                event,
                isPlainObject$1(args[0]) ? extend({ detail: args }, args[0]) : { detail: args }
              )
            );
          };
          instance.emit = (event, ...args) => {
            dispatch(event, args);
            if (hyphenate(event) !== event) {
              dispatch(hyphenate(event), args);
            }
          };
          this._setParent();
        };
      }
      return vnode;
    }
    _applyStyles(styles, owner) {
      if (!styles) return;
      if (owner) {
        if (owner === this._def || this._styleChildren.has(owner)) {
          return;
        }
        this._styleChildren.add(owner);
      }
      const nonce = this._nonce;
      for (let i = styles.length - 1; i >= 0; i--) {
        const s = document.createElement("style");
        if (nonce) s.setAttribute("nonce", nonce);
        s.textContent = styles[i];
        this.shadowRoot.prepend(s);
      }
    }
    /**
     * Only called when shaddowRoot is false
     */
    _parseSlots() {
      const slots = this._slots = {};
      let n;
      while (n = this.firstChild) {
        const slotName = n.nodeType === 1 && n.getAttribute("slot") || "default";
        (slots[slotName] || (slots[slotName] = [])).push(n);
        this.removeChild(n);
      }
    }
    /**
     * Only called when shaddowRoot is false
     */
    _renderSlots() {
      const outlets = this.querySelectorAll("slot");
      const scopeId = this._instance.type.__scopeId;
      for (let i = 0; i < outlets.length; i++) {
        const o = outlets[i];
        const slotName = o.getAttribute("name") || "default";
        const content = this._slots[slotName];
        const parent = o.parentNode;
        if (content) {
          for (const n of content) {
            if (scopeId && n.nodeType === 1) {
              const id = scopeId + "-s";
              const walker = document.createTreeWalker(n, 1);
              n.setAttribute(id, "");
              let child;
              while (child = walker.nextNode()) {
                child.setAttribute(id, "");
              }
            }
            parent.insertBefore(n, o);
          }
        } else {
          while (o.firstChild) parent.insertBefore(o.firstChild, o);
        }
        parent.removeChild(o);
      }
    }
    /**
     * @internal
     */
    _injectChildStyle(comp) {
      this._applyStyles(comp.styles, comp);
    }
    /**
     * @internal
     */
    _removeChildStyle(comp) {
    }
  }
  const getModelAssigner = (vnode) => {
    const fn = vnode.props["onUpdate:modelValue"] || false;
    return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
  };
  function onCompositionStart(e) {
    e.target.composing = true;
  }
  function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
      target.composing = false;
      target.dispatchEvent(new Event("input"));
    }
  }
  const assignKey = Symbol("_assign");
  const vModelText = {
    created(el, { modifiers: { lazy, trim, number } }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      const castToNumber = number || vnode.props && vnode.props.type === "number";
      addEventListener(el, lazy ? "change" : "input", (e) => {
        if (e.target.composing) return;
        let domValue = el.value;
        if (trim) {
          domValue = domValue.trim();
        }
        if (castToNumber) {
          domValue = looseToNumber(domValue);
        }
        el[assignKey](domValue);
      });
      if (trim) {
        addEventListener(el, "change", () => {
          el.value = el.value.trim();
        });
      }
      if (!lazy) {
        addEventListener(el, "compositionstart", onCompositionStart);
        addEventListener(el, "compositionend", onCompositionEnd);
        addEventListener(el, "change", onCompositionEnd);
      }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted(el, { value }) {
      el.value = value == null ? "" : value;
    },
    beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      if (el.composing) return;
      const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
      const newValue = value == null ? "" : value;
      if (elValue === newValue) {
        return;
      }
      if (document.activeElement === el && el.type !== "range") {
        if (lazy && value === oldValue) {
          return;
        }
        if (trim && el.value.trim() === newValue) {
          return;
        }
      }
      el.value = newValue;
    }
  };
  const systemModifiers = ["ctrl", "shift", "alt", "meta"];
  const modifierGuards = {
    stop: (e) => e.stopPropagation(),
    prevent: (e) => e.preventDefault(),
    self: (e) => e.target !== e.currentTarget,
    ctrl: (e) => !e.ctrlKey,
    shift: (e) => !e.shiftKey,
    alt: (e) => !e.altKey,
    meta: (e) => !e.metaKey,
    left: (e) => "button" in e && e.button !== 0,
    middle: (e) => "button" in e && e.button !== 1,
    right: (e) => "button" in e && e.button !== 2,
    exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
  };
  const withModifiers = (fn, modifiers) => {
    const cache = fn._withMods || (fn._withMods = {});
    const cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
      for (let i = 0; i < modifiers.length; i++) {
        const guard = modifierGuards[modifiers[i]];
        if (guard && guard(event, modifiers)) return;
      }
      return fn(event, ...args);
    });
  };
  const keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
  };
  const withKeys = (fn, modifiers) => {
    const cache = fn._withKeys || (fn._withKeys = {});
    const cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = (event) => {
      if (!("key" in event)) {
        return;
      }
      const eventKey = hyphenate(event.key);
      if (modifiers.some(
        (k) => k === eventKey || keyNames[k] === eventKey
      )) {
        return fn(event);
      }
    });
  };
  const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
  let renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  const render = (...args) => {
    ensureRenderer().render(...args);
  };
  const createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container) return;
      const component = app._component;
      if (!isFunction(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      if (container.nodeType === 1) {
        container.textContent = "";
      }
      const proxy = mount(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  };
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function normalizeContainer(container) {
    if (isString(container)) {
      const res = document.querySelector(container);
      return res;
    }
    return container;
  }
  const _imports_0 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20width='800px'%20height='800px'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='Menu%20/%20Close_LG'%3e%3cpath%20id='Vector'%20d='M21%2021L12%2012M12%2012L3%203M12%2012L21.0001%203M12%2012L3%2021.0001'%20stroke='%23000000'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/g%3e%3c/svg%3e";
  const _imports_1$2 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20width='800px'%20height='800px'%20viewBox='0%200%2024%2024'%20fill='%23003274'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='Arrow%20/%20Caret_Circle_Up'%3e%3cpath%20id='Vector'%20d='M9%2013L12%2010L15%2013M21%2012C21%207.02944%2016.9706%203%2012%203C7.02944%203%203%207.02944%203%2012C3%2016.9706%207.02944%2021%2012%2021C16.9706%2021%2021%2016.9706%2021%2012Z'%20stroke='%23FFFFFF'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/g%3e%3c/svg%3e";
  const _imports_2$2 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20width='800px'%20height='800px'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='Edit%20/%20List_Unordered'%3e%3cpath%20id='Vector'%20d='M9%2017H19M9%2012H19M9%207H19M5.00195%2017V17.002L5%2017.002V17H5.00195ZM5.00195%2012V12.002L5%2012.002V12H5.00195ZM5.00195%207V7.002L5%207.00195V7H5.00195Z'%20stroke='%23000000'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/g%3e%3c/svg%3e";
  const _imports_3$1 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20width='800px'%20height='800px'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='Navigation%20/%20House_03'%3e%3cpath%20id='Vector'%20d='M2%2020.0001H4M4%2020.0001H10M4%2020.0001V11.4522C4%2010.9179%204%2010.6506%204.06497%2010.4019C4.12255%2010.1816%204.21779%209.97307%204.3457%209.78464C4.49004%209.57201%204.69064%209.39569%205.09277%209.04383L9.89436%204.84244C10.6398%204.19014%2011.0126%203.86397%2011.4324%203.73982C11.8026%203.63035%2012.1972%203.63035%2012.5674%203.73982C12.9875%203.86406%2013.3608%204.19054%2014.1074%204.84383L18.9074%209.04383C19.3095%209.39568%2019.5102%209.57202%2019.6546%209.78464C19.7825%209.97307%2019.877%2010.1816%2019.9346%2010.4019C19.9995%2010.6506%2020%2010.9179%2020%2011.4522V20.0001M10%2020.0001H14M10%2020.0001V16.0001C10%2014.8955%2010.8954%2014.0001%2012%2014.0001C13.1046%2014.0001%2014%2014.8955%2014%2016.0001V20.0001M14%2020.0001H20M20%2020.0001H22'%20stroke='%23000000'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/g%3e%3c/svg%3e";
  const _imports_4 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20width='800px'%20height='800px'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='Warning%20/%20Circle_Help'%3e%3cpath%20id='Vector'%20d='M9.14648%209.07361C9.31728%208.54732%209.63015%208.07896%2010.0508%207.71948C10.4714%207.36001%2010.9838%207.12378%2011.5303%207.03708C12.0768%206.95038%2012.6362%207.0164%2013.1475%207.22803C13.6587%207.43966%2014.1014%207.78875%2014.4268%208.23633C14.7521%208.68391%2014.9469%209.21256%2014.9904%209.76416C15.0339%2010.3158%2014.9238%2010.8688%2014.6727%2011.3618C14.4215%2011.8548%2014.0394%2012.2685%2013.5676%2012.5576C13.0958%2012.8467%2012.5533%2012.9998%2012%2012.9998V14.0002M12%2021C7.02944%2021%203%2016.9706%203%2012C3%207.02944%207.02944%203%2012%203C16.9706%203%2021%207.02944%2021%2012C21%2016.9706%2016.9706%2021%2012%2021ZM12.0498%2017V17.1L11.9502%2017.1002V17H12.0498Z'%20stroke='%23000000'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/g%3e%3c/svg%3e";
  const _imports_1$1 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20fill='%23FFFFFF'%20color='FFFFFF'%20width='800px'%20height='800px'%20viewBox='0%200%2032%2032'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M24%200h-11c-1.104%200-2%200.895-2%202h11v8h8v16h-7v2h7c1.105%200%202-0.895%202-2v-18zM24%208v-5.172l5.171%205.172h-5.171zM2%204c-1.105%200-2%200.896-2%202v24c0%201.105%200.895%202%202%202h17c1.105%200%202-0.895%202-2v-18l-8-8.001h-11zM19%2030h-17v-24h9v8h8v16zM13%2012v-5.172l5.171%205.172h-5.171z'%3e%3c/path%3e%3c/svg%3e";
  const _imports_2$1 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20width='800px'%20height='800px'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='Arrow%20/%20Arrow_Reload_02'%3e%3cpath%20id='Vector'%20d='M14%2016H19V21M10%208H5V3M19.4176%209.0034C18.8569%207.61566%2017.9181%206.41304%2016.708%205.53223C15.4979%204.65141%2014.0652%204.12752%2012.5723%204.02051C11.0794%203.9135%209.58606%204.2274%208.2627%204.92661C6.93933%205.62582%205.83882%206.68254%205.08594%207.97612M4.58203%2014.9971C5.14272%2016.3848%206.08146%2017.5874%207.29157%2018.4682C8.50169%2019.3491%209.93588%2019.8723%2011.4288%2019.9793C12.9217%2020.0863%2014.4138%2019.7725%2015.7371%2019.0732C17.0605%2018.374%2018.1603%2017.3175%2018.9131%2016.0239'%20stroke='%23FFFFFF'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/g%3e%3c/svg%3e";
  const _imports_3 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20width='800px'%20height='800px'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='Communication%20/%20Share_iOS_Export'%3e%3cpath%20id='Vector'%20d='M9%206L12%203M12%203L15%206M12%203V13M7.00023%2010C6.06835%2010%205.60241%2010%205.23486%2010.1522C4.74481%2010.3552%204.35523%2010.7448%204.15224%2011.2349C4%2011.6024%204%2012.0681%204%2013V17.8C4%2018.9201%204%2019.4798%204.21799%2019.9076C4.40973%2020.2839%204.71547%2020.5905%205.0918%2020.7822C5.5192%2021%206.07899%2021%207.19691%2021H16.8036C17.9215%2021%2018.4805%2021%2018.9079%2020.7822C19.2842%2020.5905%2019.5905%2020.2839%2019.7822%2019.9076C20%2019.4802%2020%2018.921%2020%2017.8031V13C20%2012.0681%2019.9999%2011.6024%2019.8477%2011.2349C19.6447%2010.7448%2019.2554%2010.3552%2018.7654%2010.1522C18.3978%2010%2017.9319%2010%2017%2010'%20stroke='%23FFFFFF'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/g%3e%3c/svg%3e";
  const VERSION = "4.56.0";
  let auto = false;
  let kind = void 0;
  let fetch$1 = void 0;
  let FormData$1 = void 0;
  let File$1 = void 0;
  let ReadableStream$1 = void 0;
  let getMultipartRequestOptions = void 0;
  let getDefaultAgent = void 0;
  let fileFromPath = void 0;
  let isFsReadStream = void 0;
  function setShims(shims, options = { auto: false }) {
    if (auto) {
      throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
    }
    if (kind) {
      throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``);
    }
    auto = options.auto;
    kind = shims.kind;
    fetch$1 = shims.fetch;
    FormData$1 = shims.FormData;
    File$1 = shims.File;
    ReadableStream$1 = shims.ReadableStream;
    getMultipartRequestOptions = shims.getMultipartRequestOptions;
    getDefaultAgent = shims.getDefaultAgent;
    fileFromPath = shims.fileFromPath;
    isFsReadStream = shims.isFsReadStream;
  }
  class MultipartBody {
    constructor(body) {
      this.body = body;
    }
    get [Symbol.toStringTag]() {
      return "MultipartBody";
    }
  }
  function getRuntime({ manuallyImported } = {}) {
    const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import … from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
    let _fetch, _Request, _Response, _Headers;
    try {
      _fetch = fetch;
      _Request = Request;
      _Response = Response;
      _Headers = Headers;
    } catch (error) {
      throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
    }
    return {
      kind: "web",
      fetch: _fetch,
      Request: _Request,
      Response: _Response,
      Headers: _Headers,
      FormData: (
        // @ts-ignore
        typeof FormData !== "undefined" ? FormData : class FormData {
          // @ts-ignore
          constructor() {
            throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
          }
        }
      ),
      Blob: typeof Blob !== "undefined" ? Blob : class Blob {
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
        }
      },
      File: (
        // @ts-ignore
        typeof File !== "undefined" ? File : class File {
          // @ts-ignore
          constructor() {
            throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
          }
        }
      ),
      ReadableStream: (
        // @ts-ignore
        typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
          // @ts-ignore
          constructor() {
            throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
          }
        }
      ),
      getMultipartRequestOptions: async (form, opts) => ({
        ...opts,
        body: new MultipartBody(form)
      }),
      getDefaultAgent: (url) => void 0,
      fileFromPath: () => {
        throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
      },
      isFsReadStream: (value) => false
    };
  }
  if (!kind) setShims(getRuntime(), { auto: true });
  class Stream {
    constructor(iterator2, controller) {
      this.iterator = iterator2;
      this.controller = controller;
    }
    static fromSSEResponse(response, controller) {
      let consumed = false;
      async function* iterator2() {
        if (consumed) {
          throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        }
        consumed = true;
        let done = false;
        try {
          for await (const sse of _iterSSEMessages(response, controller)) {
            if (done)
              continue;
            if (sse.data.startsWith("[DONE]")) {
              done = true;
              continue;
            }
            if (sse.event === null) {
              let data;
              try {
                data = JSON.parse(sse.data);
              } catch (e) {
                console.error(`Could not parse message into JSON:`, sse.data);
                console.error(`From chunk:`, sse.raw);
                throw e;
              }
              if (data && data.error) {
                throw new APIError(void 0, data.error, void 0, void 0);
              }
              yield data;
            } else {
              let data;
              try {
                data = JSON.parse(sse.data);
              } catch (e) {
                console.error(`Could not parse message into JSON:`, sse.data);
                console.error(`From chunk:`, sse.raw);
                throw e;
              }
              if (sse.event == "error") {
                throw new APIError(void 0, data.error, data.message, void 0);
              }
              yield { event: sse.event, data };
            }
          }
          done = true;
        } catch (e) {
          if (e instanceof Error && e.name === "AbortError")
            return;
          throw e;
        } finally {
          if (!done)
            controller.abort();
        }
      }
      return new Stream(iterator2, controller);
    }
    /**
     * Generates a Stream from a newline-separated ReadableStream
     * where each item is a JSON value.
     */
    static fromReadableStream(readableStream, controller) {
      let consumed = false;
      async function* iterLines() {
        const lineDecoder = new LineDecoder();
        const iter = readableStreamAsyncIterable(readableStream);
        for await (const chunk of iter) {
          for (const line of lineDecoder.decode(chunk)) {
            yield line;
          }
        }
        for (const line of lineDecoder.flush()) {
          yield line;
        }
      }
      async function* iterator2() {
        if (consumed) {
          throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        }
        consumed = true;
        let done = false;
        try {
          for await (const line of iterLines()) {
            if (done)
              continue;
            if (line)
              yield JSON.parse(line);
          }
          done = true;
        } catch (e) {
          if (e instanceof Error && e.name === "AbortError")
            return;
          throw e;
        } finally {
          if (!done)
            controller.abort();
        }
      }
      return new Stream(iterator2, controller);
    }
    [Symbol.asyncIterator]() {
      return this.iterator();
    }
    /**
     * Splits the stream into two streams which can be
     * independently read from at different speeds.
     */
    tee() {
      const left = [];
      const right = [];
      const iterator2 = this.iterator();
      const teeIterator = (queue2) => {
        return {
          next: () => {
            if (queue2.length === 0) {
              const result = iterator2.next();
              left.push(result);
              right.push(result);
            }
            return queue2.shift();
          }
        };
      };
      return [
        new Stream(() => teeIterator(left), this.controller),
        new Stream(() => teeIterator(right), this.controller)
      ];
    }
    /**
     * Converts this stream to a newline-separated ReadableStream of
     * JSON stringified values in the stream
     * which can be turned back into a Stream with `Stream.fromReadableStream()`.
     */
    toReadableStream() {
      const self2 = this;
      let iter;
      const encoder = new TextEncoder();
      return new ReadableStream$1({
        async start() {
          iter = self2[Symbol.asyncIterator]();
        },
        async pull(ctrl) {
          try {
            const { value, done } = await iter.next();
            if (done)
              return ctrl.close();
            const bytes = encoder.encode(JSON.stringify(value) + "\n");
            ctrl.enqueue(bytes);
          } catch (err) {
            ctrl.error(err);
          }
        },
        async cancel() {
          var _a2;
          await ((_a2 = iter.return) == null ? void 0 : _a2.call(iter));
        }
      });
    }
  }
  async function* _iterSSEMessages(response, controller) {
    if (!response.body) {
      controller.abort();
      throw new OpenAIError(`Attempted to iterate over a response with no body`);
    }
    const sseDecoder = new SSEDecoder();
    const lineDecoder = new LineDecoder();
    const iter = readableStreamAsyncIterable(response.body);
    for await (const sseChunk of iterSSEChunks(iter)) {
      for (const line of lineDecoder.decode(sseChunk)) {
        const sse = sseDecoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    for (const line of lineDecoder.flush()) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  async function* iterSSEChunks(iterator2) {
    let data = new Uint8Array();
    for await (const chunk of iterator2) {
      if (chunk == null) {
        continue;
      }
      const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
      let newData = new Uint8Array(data.length + binaryChunk.length);
      newData.set(data);
      newData.set(binaryChunk, data.length);
      data = newData;
      let patternIndex;
      while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
        yield data.slice(0, patternIndex);
        data = data.slice(patternIndex);
      }
    }
    if (data.length > 0) {
      yield data;
    }
  }
  function findDoubleNewlineIndex(buffer) {
    const newline2 = 10;
    const carriage = 13;
    for (let i = 0; i < buffer.length - 2; i++) {
      if (buffer[i] === newline2 && buffer[i + 1] === newline2) {
        return i + 2;
      }
      if (buffer[i] === carriage && buffer[i + 1] === carriage) {
        return i + 2;
      }
      if (buffer[i] === carriage && buffer[i + 1] === newline2 && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline2) {
        return i + 4;
      }
    }
    return -1;
  }
  class SSEDecoder {
    constructor() {
      this.event = null;
      this.data = [];
      this.chunks = [];
    }
    decode(line) {
      if (line.endsWith("\r")) {
        line = line.substring(0, line.length - 1);
      }
      if (!line) {
        if (!this.event && !this.data.length)
          return null;
        const sse = {
          event: this.event,
          data: this.data.join("\n"),
          raw: this.chunks
        };
        this.event = null;
        this.data = [];
        this.chunks = [];
        return sse;
      }
      this.chunks.push(line);
      if (line.startsWith(":")) {
        return null;
      }
      let [fieldname, _, value] = partition(line, ":");
      if (value.startsWith(" ")) {
        value = value.substring(1);
      }
      if (fieldname === "event") {
        this.event = value;
      } else if (fieldname === "data") {
        this.data.push(value);
      }
      return null;
    }
  }
  class LineDecoder {
    constructor() {
      this.buffer = [];
      this.trailingCR = false;
    }
    decode(chunk) {
      let text = this.decodeText(chunk);
      if (this.trailingCR) {
        text = "\r" + text;
        this.trailingCR = false;
      }
      if (text.endsWith("\r")) {
        this.trailingCR = true;
        text = text.slice(0, -1);
      }
      if (!text) {
        return [];
      }
      const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
      let lines = text.split(LineDecoder.NEWLINE_REGEXP);
      if (trailingNewline) {
        lines.pop();
      }
      if (lines.length === 1 && !trailingNewline) {
        this.buffer.push(lines[0]);
        return [];
      }
      if (this.buffer.length > 0) {
        lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
        this.buffer = [];
      }
      if (!trailingNewline) {
        this.buffer = [lines.pop() || ""];
      }
      return lines;
    }
    decodeText(bytes) {
      if (bytes == null)
        return "";
      if (typeof bytes === "string")
        return bytes;
      if (typeof Buffer !== "undefined") {
        if (bytes instanceof Buffer) {
          return bytes.toString();
        }
        if (bytes instanceof Uint8Array) {
          return Buffer.from(bytes).toString();
        }
        throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
      }
      if (typeof TextDecoder !== "undefined") {
        if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
          this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8"));
          return this.textDecoder.decode(bytes);
        }
        throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
      }
      throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
    }
    flush() {
      if (!this.buffer.length && !this.trailingCR) {
        return [];
      }
      const lines = [this.buffer.join("")];
      this.buffer = [];
      this.trailingCR = false;
      return lines;
    }
  }
  LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
  LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
  function partition(str2, delimiter) {
    const index = str2.indexOf(delimiter);
    if (index !== -1) {
      return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
    }
    return [str2, "", ""];
  }
  function readableStreamAsyncIterable(stream) {
    if (stream[Symbol.asyncIterator])
      return stream;
    const reader = stream.getReader();
    return {
      async next() {
        try {
          const result = await reader.read();
          if (result == null ? void 0 : result.done)
            reader.releaseLock();
          return result;
        } catch (e) {
          reader.releaseLock();
          throw e;
        }
      },
      async return() {
        const cancelPromise = reader.cancel();
        reader.releaseLock();
        await cancelPromise;
        return { done: true, value: void 0 };
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  const isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
  const isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
  const isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
  const isUploadable = (value) => {
    return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
  };
  async function toFile(value, name, options) {
    var _a2;
    value = await value;
    options ?? (options = isFileLike(value) ? { lastModified: value.lastModified, type: value.type } : {});
    if (isResponseLike(value)) {
      const blob = await value.blob();
      name || (name = new URL(value.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
      return new File$1([blob], name, options);
    }
    const bits = await getBytes(value);
    name || (name = getName(value) ?? "unknown_file");
    if (!options.type) {
      const type2 = (_a2 = bits[0]) == null ? void 0 : _a2.type;
      if (typeof type2 === "string") {
        options = { ...options, type: type2 };
      }
    }
    return new File$1(bits, name, options);
  }
  async function getBytes(value) {
    var _a2;
    let parts = [];
    if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
    value instanceof ArrayBuffer) {
      parts.push(value);
    } else if (isBlobLike(value)) {
      parts.push(await value.arrayBuffer());
    } else if (isAsyncIterableIterator(value)) {
      for await (const chunk of value) {
        parts.push(chunk);
      }
    } else {
      throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a2 = value == null ? void 0 : value.constructor) == null ? void 0 : _a2.name}; props: ${propsForError(value)}`);
    }
    return parts;
  }
  function propsForError(value) {
    const props = Object.getOwnPropertyNames(value);
    return `[${props.map((p2) => `"${p2}"`).join(", ")}]`;
  }
  function getName(value) {
    var _a2;
    return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
    ((_a2 = getStringFromMaybeBuffer(value.path)) == null ? void 0 : _a2.split(/[\\/]/).pop());
  }
  const getStringFromMaybeBuffer = (x) => {
    if (typeof x === "string")
      return x;
    if (typeof Buffer !== "undefined" && x instanceof Buffer)
      return String(x);
    return void 0;
  };
  const isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
  const isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
  const multipartFormRequestOptions = async (opts) => {
    const form = await createForm(opts.body);
    return getMultipartRequestOptions(form, opts);
  };
  const createForm = async (body) => {
    const form = new FormData$1();
    await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
    return form;
  };
  const addFormValue = async (form, key, value) => {
    if (value === void 0)
      return;
    if (value == null) {
      throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
    }
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      form.append(key, String(value));
    } else if (isUploadable(value)) {
      const file = await toFile(value);
      form.append(key, file);
    } else if (Array.isArray(value)) {
      await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
    } else if (typeof value === "object") {
      await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
    } else {
      throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
    }
  };
  var define_process_env_default = {};
  var __classPrivateFieldSet$3 = function(receiver, state, value, kind2, f) {
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return state.set(receiver, value), value;
  };
  var __classPrivateFieldGet$4 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _AbstractPage_client;
  async function defaultParseResponse(props) {
    const { response } = props;
    if (props.options.stream) {
      debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller);
      }
      return Stream.fromSSEResponse(response, props.controller);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const isJSON = (contentType == null ? void 0 : contentType.includes("application/json")) || (contentType == null ? void 0 : contentType.includes("application/vnd.api+json"));
    if (isJSON) {
      const json = await response.json();
      debug("response", response.status, response.url, response.headers, json);
      return json;
    }
    const text = await response.text();
    debug("response", response.status, response.url, response.headers, text);
    return text;
  }
  class APIPromise extends Promise {
    constructor(responsePromise, parseResponse = defaultParseResponse) {
      super((resolve) => {
        resolve(null);
      });
      this.responsePromise = responsePromise;
      this.parseResponse = parseResponse;
    }
    _thenUnwrap(transform) {
      return new APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props)));
    }
    /**
     * Gets the raw `Response` instance instead of parsing the response
     * data.
     *
     * If you want to parse the response body but still get the `Response`
     * instance, you can use {@link withResponse()}.
     *
     * 👋 Getting the wrong TypeScript type for `Response`?
     * Try setting `"moduleResolution": "NodeNext"` if you can,
     * or add one of these imports before your first `import … from 'openai'`:
     * - `import 'openai/shims/node'` (if you're running on Node)
     * - `import 'openai/shims/web'` (otherwise)
     */
    asResponse() {
      return this.responsePromise.then((p2) => p2.response);
    }
    /**
     * Gets the parsed response data and the raw `Response` instance.
     *
     * If you just want to get the raw `Response` instance without parsing it,
     * you can use {@link asResponse()}.
     *
     *
     * 👋 Getting the wrong TypeScript type for `Response`?
     * Try setting `"moduleResolution": "NodeNext"` if you can,
     * or add one of these imports before your first `import … from 'openai'`:
     * - `import 'openai/shims/node'` (if you're running on Node)
     * - `import 'openai/shims/web'` (otherwise)
     */
    async withResponse() {
      const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
      return { data, response };
    }
    parse() {
      if (!this.parsedPromise) {
        this.parsedPromise = this.responsePromise.then(this.parseResponse);
      }
      return this.parsedPromise;
    }
    then(onfulfilled, onrejected) {
      return this.parse().then(onfulfilled, onrejected);
    }
    catch(onrejected) {
      return this.parse().catch(onrejected);
    }
    finally(onfinally) {
      return this.parse().finally(onfinally);
    }
  }
  class APIClient {
    constructor({
      baseURL,
      maxRetries = 2,
      timeout = 6e5,
      // 10 minutes
      httpAgent,
      fetch: overridenFetch
    }) {
      this.baseURL = baseURL;
      this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
      this.timeout = validatePositiveInteger("timeout", timeout);
      this.httpAgent = httpAgent;
      this.fetch = overridenFetch ?? fetch$1;
    }
    authHeaders(opts) {
      return {};
    }
    /**
     * Override this to add your own default headers, for example:
     *
     *  {
     *    ...super.defaultHeaders(),
     *    Authorization: 'Bearer 123',
     *  }
     */
    defaultHeaders(opts) {
      return {
        Accept: "application/json",
        "Content-Type": "application/json",
        "User-Agent": this.getUserAgent(),
        ...getPlatformHeaders(),
        ...this.authHeaders(opts)
      };
    }
    /**
     * Override this to add your own headers validation:
     */
    validateHeaders(headers, customHeaders) {
    }
    defaultIdempotencyKey() {
      return `stainless-node-retry-${uuid4()}`;
    }
    get(path, opts) {
      return this.methodRequest("get", path, opts);
    }
    post(path, opts) {
      return this.methodRequest("post", path, opts);
    }
    patch(path, opts) {
      return this.methodRequest("patch", path, opts);
    }
    put(path, opts) {
      return this.methodRequest("put", path, opts);
    }
    delete(path, opts) {
      return this.methodRequest("delete", path, opts);
    }
    methodRequest(method, path, opts) {
      return this.request(Promise.resolve(opts).then(async (opts2) => {
        const body = opts2 && isBlobLike(opts2 == null ? void 0 : opts2.body) ? new DataView(await opts2.body.arrayBuffer()) : (opts2 == null ? void 0 : opts2.body) instanceof DataView ? opts2.body : (opts2 == null ? void 0 : opts2.body) instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2 == null ? void 0 : opts2.body) ? new DataView(opts2.body.buffer) : opts2 == null ? void 0 : opts2.body;
        return { method, path, ...opts2, body };
      }));
    }
    getAPIList(path, Page2, opts) {
      return this.requestAPIList(Page2, { method: "get", path, ...opts });
    }
    calculateContentLength(body) {
      if (typeof body === "string") {
        if (typeof Buffer !== "undefined") {
          return Buffer.byteLength(body, "utf8").toString();
        }
        if (typeof TextEncoder !== "undefined") {
          const encoder = new TextEncoder();
          const encoded = encoder.encode(body);
          return encoded.length.toString();
        }
      } else if (ArrayBuffer.isView(body)) {
        return body.byteLength.toString();
      }
      return null;
    }
    buildRequest(options) {
      var _a2;
      const { method, path, query, headers = {} } = options;
      const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
      const contentLength = this.calculateContentLength(body);
      const url = this.buildURL(path, query);
      if ("timeout" in options)
        validatePositiveInteger("timeout", options.timeout);
      const timeout = options.timeout ?? this.timeout;
      const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);
      const minAgentTimeout = timeout + 1e3;
      if (typeof ((_a2 = httpAgent == null ? void 0 : httpAgent.options) == null ? void 0 : _a2.timeout) === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
        httpAgent.options.timeout = minAgentTimeout;
      }
      if (this.idempotencyHeader && method !== "get") {
        if (!options.idempotencyKey)
          options.idempotencyKey = this.defaultIdempotencyKey();
        headers[this.idempotencyHeader] = options.idempotencyKey;
      }
      const reqHeaders = this.buildHeaders({ options, headers, contentLength });
      const req = {
        method,
        ...body && { body },
        headers: reqHeaders,
        ...httpAgent && { agent: httpAgent },
        // @ts-ignore node-fetch uses a custom AbortSignal type that is
        // not compatible with standard web types
        signal: options.signal ?? null
      };
      return { req, url, timeout };
    }
    buildHeaders({ options, headers, contentLength }) {
      const reqHeaders = {};
      if (contentLength) {
        reqHeaders["content-length"] = contentLength;
      }
      const defaultHeaders = this.defaultHeaders(options);
      applyHeadersMut(reqHeaders, defaultHeaders);
      applyHeadersMut(reqHeaders, headers);
      if (isMultipartBody(options.body) && kind !== "node") {
        delete reqHeaders["content-type"];
      }
      this.validateHeaders(reqHeaders, headers);
      return reqHeaders;
    }
    /**
     * Used as a callback for mutating the given `FinalRequestOptions` object.
     */
    async prepareOptions(options) {
    }
    /**
     * Used as a callback for mutating the given `RequestInit` object.
     *
     * This is useful for cases where you want to add certain headers based off of
     * the request properties, e.g. `method` or `url`.
     */
    async prepareRequest(request, { url, options }) {
    }
    parseHeaders(headers) {
      return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
    }
    makeStatusError(status, error, message, headers) {
      return APIError.generate(status, error, message, headers);
    }
    request(options, remainingRetries = null) {
      return new APIPromise(this.makeRequest(options, remainingRetries));
    }
    async makeRequest(optionsInput, retriesRemaining) {
      var _a2, _b;
      const options = await optionsInput;
      if (retriesRemaining == null) {
        retriesRemaining = options.maxRetries ?? this.maxRetries;
      }
      await this.prepareOptions(options);
      const { req, url, timeout } = this.buildRequest(options);
      await this.prepareRequest(req, { url, options });
      debug("request", url, options, req.headers);
      if ((_a2 = options.signal) == null ? void 0 : _a2.aborted) {
        throw new APIUserAbortError();
      }
      const controller = new AbortController();
      const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
      if (response instanceof Error) {
        if ((_b = options.signal) == null ? void 0 : _b.aborted) {
          throw new APIUserAbortError();
        }
        if (retriesRemaining) {
          return this.retryRequest(options, retriesRemaining);
        }
        if (response.name === "AbortError") {
          throw new APIConnectionTimeoutError();
        }
        throw new APIConnectionError({ cause: response });
      }
      const responseHeaders = createResponseHeaders(response.headers);
      if (!response.ok) {
        if (retriesRemaining && this.shouldRetry(response)) {
          const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
          debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
          return this.retryRequest(options, retriesRemaining, responseHeaders);
        }
        const errText = await response.text().catch((e) => castToError(e).message);
        const errJSON = safeJSON(errText);
        const errMessage = errJSON ? void 0 : errText;
        const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
        debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
        const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
        throw err;
      }
      return { response, options, controller };
    }
    requestAPIList(Page2, options) {
      const request = this.makeRequest(options, null);
      return new PagePromise(this, request, Page2);
    }
    buildURL(path, query) {
      const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
      const defaultQuery = this.defaultQuery();
      if (!isEmptyObj(defaultQuery)) {
        query = { ...defaultQuery, ...query };
      }
      if (typeof query === "object" && query && !Array.isArray(query)) {
        url.search = this.stringifyQuery(query);
      }
      return url.toString();
    }
    stringifyQuery(query) {
      return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
        if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
        }
        if (value === null) {
          return `${encodeURIComponent(key)}=`;
        }
        throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
      }).join("&");
    }
    async fetchWithTimeout(url, init2, ms, controller) {
      const { signal, ...options } = init2 || {};
      if (signal)
        signal.addEventListener("abort", () => controller.abort());
      const timeout = setTimeout(() => controller.abort(), ms);
      return this.getRequestClient().fetch.call(void 0, url, { signal: controller.signal, ...options }).finally(() => {
        clearTimeout(timeout);
      });
    }
    getRequestClient() {
      return { fetch: this.fetch };
    }
    shouldRetry(response) {
      const shouldRetryHeader = response.headers.get("x-should-retry");
      if (shouldRetryHeader === "true")
        return true;
      if (shouldRetryHeader === "false")
        return false;
      if (response.status === 408)
        return true;
      if (response.status === 409)
        return true;
      if (response.status === 429)
        return true;
      if (response.status >= 500)
        return true;
      return false;
    }
    async retryRequest(options, retriesRemaining, responseHeaders) {
      let timeoutMillis;
      const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after-ms"];
      if (retryAfterMillisHeader) {
        const timeoutMs = parseFloat(retryAfterMillisHeader);
        if (!Number.isNaN(timeoutMs)) {
          timeoutMillis = timeoutMs;
        }
      }
      const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after"];
      if (retryAfterHeader && !timeoutMillis) {
        const timeoutSeconds = parseFloat(retryAfterHeader);
        if (!Number.isNaN(timeoutSeconds)) {
          timeoutMillis = timeoutSeconds * 1e3;
        } else {
          timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
        }
      }
      if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
        const maxRetries = options.maxRetries ?? this.maxRetries;
        timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
      }
      await sleep$1(timeoutMillis);
      return this.makeRequest(options, retriesRemaining - 1);
    }
    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
      const initialRetryDelay = 0.5;
      const maxRetryDelay = 8;
      const numRetries = maxRetries - retriesRemaining;
      const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
      const jitter = 1 - Math.random() * 0.25;
      return sleepSeconds * jitter * 1e3;
    }
    getUserAgent() {
      return `${this.constructor.name}/JS ${VERSION}`;
    }
  }
  class AbstractPage {
    constructor(client, response, body, options) {
      _AbstractPage_client.set(this, void 0);
      __classPrivateFieldSet$3(this, _AbstractPage_client, client);
      this.options = options;
      this.response = response;
      this.body = body;
    }
    hasNextPage() {
      const items = this.getPaginatedItems();
      if (!items.length)
        return false;
      return this.nextPageInfo() != null;
    }
    async getNextPage() {
      const nextInfo = this.nextPageInfo();
      if (!nextInfo) {
        throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
      }
      const nextOptions = { ...this.options };
      if ("params" in nextInfo && typeof nextOptions.query === "object") {
        nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
      } else if ("url" in nextInfo) {
        const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
        for (const [key, value] of params) {
          nextInfo.url.searchParams.set(key, value);
        }
        nextOptions.query = void 0;
        nextOptions.path = nextInfo.url.toString();
      }
      return await __classPrivateFieldGet$4(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
    }
    async *iterPages() {
      let page = this;
      yield page;
      while (page.hasNextPage()) {
        page = await page.getNextPage();
        yield page;
      }
    }
    async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
      for await (const page of this.iterPages()) {
        for (const item of page.getPaginatedItems()) {
          yield item;
        }
      }
    }
  }
  class PagePromise extends APIPromise {
    constructor(client, request, Page2) {
      super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
    }
    /**
     * Allow auto-paginating iteration on an unawaited list call, eg:
     *
     *    for await (const item of client.items.list()) {
     *      console.log(item)
     *    }
     */
    async *[Symbol.asyncIterator]() {
      const page = await this;
      for await (const item of page) {
        yield item;
      }
    }
  }
  const createResponseHeaders = (headers) => {
    return new Proxy(Object.fromEntries(
      // @ts-ignore
      headers.entries()
    ), {
      get(target, name) {
        const key = name.toString();
        return target[key.toLowerCase()] || target[key];
      }
    });
  };
  const requestOptionsKeys = {
    method: true,
    path: true,
    query: true,
    body: true,
    headers: true,
    maxRetries: true,
    stream: true,
    timeout: true,
    httpAgent: true,
    signal: true,
    idempotencyKey: true,
    __binaryRequest: true,
    __binaryResponse: true,
    __streamClass: true
  };
  const isRequestOptions = (obj) => {
    return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
  };
  const getPlatformProperties = () => {
    var _a2;
    if (typeof Deno !== "undefined" && Deno.build != null) {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": normalizePlatform(Deno.build.os),
        "X-Stainless-Arch": normalizeArch(Deno.build.arch),
        "X-Stainless-Runtime": "deno",
        "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : ((_a2 = Deno.version) == null ? void 0 : _a2.deno) ?? "unknown"
      };
    }
    if (typeof EdgeRuntime !== "undefined") {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": `other:${EdgeRuntime}`,
        "X-Stainless-Runtime": "edge",
        "X-Stainless-Runtime-Version": process.version
      };
    }
    if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": normalizePlatform(process.platform),
        "X-Stainless-Arch": normalizeArch(process.arch),
        "X-Stainless-Runtime": "node",
        "X-Stainless-Runtime-Version": process.version
      };
    }
    const browserInfo = getBrowserInfo();
    if (browserInfo) {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": "unknown",
        "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
        "X-Stainless-Runtime-Version": browserInfo.version
      };
    }
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": "unknown",
      "X-Stainless-Runtime-Version": "unknown"
    };
  };
  function getBrowserInfo() {
    if (typeof navigator === "undefined" || !navigator) {
      return null;
    }
    const browserPatterns = [
      { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
    ];
    for (const { key, pattern } of browserPatterns) {
      const match = pattern.exec(navigator.userAgent);
      if (match) {
        const major = match[1] || 0;
        const minor = match[2] || 0;
        const patch = match[3] || 0;
        return { browser: key, version: `${major}.${minor}.${patch}` };
      }
    }
    return null;
  }
  const normalizeArch = (arch) => {
    if (arch === "x32")
      return "x32";
    if (arch === "x86_64" || arch === "x64")
      return "x64";
    if (arch === "arm")
      return "arm";
    if (arch === "aarch64" || arch === "arm64")
      return "arm64";
    if (arch)
      return `other:${arch}`;
    return "unknown";
  };
  const normalizePlatform = (platform) => {
    platform = platform.toLowerCase();
    if (platform.includes("ios"))
      return "iOS";
    if (platform === "android")
      return "Android";
    if (platform === "darwin")
      return "MacOS";
    if (platform === "win32")
      return "Windows";
    if (platform === "freebsd")
      return "FreeBSD";
    if (platform === "openbsd")
      return "OpenBSD";
    if (platform === "linux")
      return "Linux";
    if (platform)
      return `Other:${platform}`;
    return "Unknown";
  };
  let _platformHeaders;
  const getPlatformHeaders = () => {
    return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
  };
  const safeJSON = (text) => {
    try {
      return JSON.parse(text);
    } catch (err) {
      return void 0;
    }
  };
  const startsWithSchemeRegexp = new RegExp("^(?:[a-z]+:)?//", "i");
  const isAbsoluteURL = (url) => {
    return startsWithSchemeRegexp.test(url);
  };
  const sleep$1 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
  const validatePositiveInteger = (name, n) => {
    if (typeof n !== "number" || !Number.isInteger(n)) {
      throw new OpenAIError(`${name} must be an integer`);
    }
    if (n < 0) {
      throw new OpenAIError(`${name} must be a positive integer`);
    }
    return n;
  };
  const castToError = (err) => {
    if (err instanceof Error)
      return err;
    return new Error(err);
  };
  const readEnv = (env) => {
    var _a2, _b, _c, _d;
    if (typeof process !== "undefined") {
      return ((_a2 = define_process_env_default == null ? void 0 : define_process_env_default[env]) == null ? void 0 : _a2.trim()) ?? void 0;
    }
    if (typeof Deno !== "undefined") {
      return (_d = (_c = (_b = Deno.env) == null ? void 0 : _b.get) == null ? void 0 : _c.call(_b, env)) == null ? void 0 : _d.trim();
    }
    return void 0;
  };
  function isEmptyObj(obj) {
    if (!obj)
      return true;
    for (const _k in obj)
      return false;
    return true;
  }
  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  function applyHeadersMut(targetHeaders, newHeaders) {
    for (const k in newHeaders) {
      if (!hasOwn(newHeaders, k))
        continue;
      const lowerKey = k.toLowerCase();
      if (!lowerKey)
        continue;
      const val = newHeaders[k];
      if (val === null) {
        delete targetHeaders[lowerKey];
      } else if (val !== void 0) {
        targetHeaders[lowerKey] = val;
      }
    }
  }
  function debug(action, ...args) {
    if (typeof process !== "undefined" && (define_process_env_default == null ? void 0 : define_process_env_default["DEBUG"]) === "true") {
      console.log(`OpenAI:DEBUG:${action}`, ...args);
    }
  }
  const uuid4 = () => {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  };
  const isRunningInBrowser = () => {
    return (
      // @ts-ignore
      typeof window !== "undefined" && // @ts-ignore
      typeof window.document !== "undefined" && // @ts-ignore
      typeof navigator !== "undefined"
    );
  };
  function isObj(obj) {
    return obj != null && typeof obj === "object" && !Array.isArray(obj);
  }
  class OpenAIError extends Error {
  }
  class APIError extends OpenAIError {
    constructor(status, error, message, headers) {
      super(`${APIError.makeMessage(status, error, message)}`);
      this.status = status;
      this.headers = headers;
      this.request_id = headers == null ? void 0 : headers["x-request-id"];
      const data = error;
      this.error = data;
      this.code = data == null ? void 0 : data["code"];
      this.param = data == null ? void 0 : data["param"];
      this.type = data == null ? void 0 : data["type"];
    }
    static makeMessage(status, error, message) {
      const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
      if (status && msg) {
        return `${status} ${msg}`;
      }
      if (status) {
        return `${status} status code (no body)`;
      }
      if (msg) {
        return msg;
      }
      return "(no status code or body)";
    }
    static generate(status, errorResponse, message, headers) {
      if (!status) {
        return new APIConnectionError({ cause: castToError(errorResponse) });
      }
      const error = errorResponse == null ? void 0 : errorResponse["error"];
      if (status === 400) {
        return new BadRequestError(status, error, message, headers);
      }
      if (status === 401) {
        return new AuthenticationError(status, error, message, headers);
      }
      if (status === 403) {
        return new PermissionDeniedError(status, error, message, headers);
      }
      if (status === 404) {
        return new NotFoundError(status, error, message, headers);
      }
      if (status === 409) {
        return new ConflictError(status, error, message, headers);
      }
      if (status === 422) {
        return new UnprocessableEntityError(status, error, message, headers);
      }
      if (status === 429) {
        return new RateLimitError(status, error, message, headers);
      }
      if (status >= 500) {
        return new InternalServerError(status, error, message, headers);
      }
      return new APIError(status, error, message, headers);
    }
  }
  class APIUserAbortError extends APIError {
    constructor({ message } = {}) {
      super(void 0, void 0, message || "Request was aborted.", void 0);
      this.status = void 0;
    }
  }
  class APIConnectionError extends APIError {
    constructor({ message, cause }) {
      super(void 0, void 0, message || "Connection error.", void 0);
      this.status = void 0;
      if (cause)
        this.cause = cause;
    }
  }
  class APIConnectionTimeoutError extends APIConnectionError {
    constructor({ message } = {}) {
      super({ message: message ?? "Request timed out." });
    }
  }
  class BadRequestError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 400;
    }
  }
  class AuthenticationError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 401;
    }
  }
  class PermissionDeniedError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 403;
    }
  }
  class NotFoundError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 404;
    }
  }
  class ConflictError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 409;
    }
  }
  class UnprocessableEntityError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 422;
    }
  }
  class RateLimitError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 429;
    }
  }
  class InternalServerError extends APIError {
  }
  class LengthFinishReasonError extends OpenAIError {
    constructor() {
      super(`Could not parse response content as the length limit was reached`);
    }
  }
  class ContentFilterFinishReasonError extends OpenAIError {
    constructor() {
      super(`Could not parse response content as the request was rejected by the content filter`);
    }
  }
  class Page extends AbstractPage {
    constructor(client, response, body, options) {
      super(client, response, body, options);
      this.data = body.data || [];
      this.object = body.object;
    }
    getPaginatedItems() {
      return this.data ?? [];
    }
    // @deprecated Please use `nextPageInfo()` instead
    /**
     * This page represents a response that isn't actually paginated at the API level
     * so there will never be any next page params.
     */
    nextPageParams() {
      return null;
    }
    nextPageInfo() {
      return null;
    }
  }
  class CursorPage extends AbstractPage {
    constructor(client, response, body, options) {
      super(client, response, body, options);
      this.data = body.data || [];
    }
    getPaginatedItems() {
      return this.data ?? [];
    }
    // @deprecated Please use `nextPageInfo()` instead
    nextPageParams() {
      const info = this.nextPageInfo();
      if (!info)
        return null;
      if ("params" in info)
        return info.params;
      const params = Object.fromEntries(info.url.searchParams);
      if (!Object.keys(params).length)
        return null;
      return params;
    }
    nextPageInfo() {
      var _a2;
      const data = this.getPaginatedItems();
      if (!data.length) {
        return null;
      }
      const id = (_a2 = data[data.length - 1]) == null ? void 0 : _a2.id;
      if (!id) {
        return null;
      }
      return { params: { after: id } };
    }
  }
  class APIResource {
    constructor(client) {
      this._client = client;
    }
  }
  let Completions$2 = class Completions extends APIResource {
    create(body, options) {
      return this._client.post("/chat/completions", { body, ...options, stream: body.stream ?? false });
    }
  };
  /* @__PURE__ */ (function(Completions2) {
  })(Completions$2 || (Completions$2 = {}));
  let Chat$1 = class Chat extends APIResource {
    constructor() {
      super(...arguments);
      this.completions = new Completions$2(this._client);
    }
  };
  (function(Chat2) {
    Chat2.Completions = Completions$2;
  })(Chat$1 || (Chat$1 = {}));
  class Speech extends APIResource {
    /**
     * Generates audio from the input text.
     */
    create(body, options) {
      return this._client.post("/audio/speech", { body, ...options, __binaryResponse: true });
    }
  }
  /* @__PURE__ */ (function(Speech2) {
  })(Speech || (Speech = {}));
  class Transcriptions extends APIResource {
    /**
     * Transcribes audio into the input language.
     */
    create(body, options) {
      return this._client.post("/audio/transcriptions", multipartFormRequestOptions({ body, ...options }));
    }
  }
  /* @__PURE__ */ (function(Transcriptions2) {
  })(Transcriptions || (Transcriptions = {}));
  class Translations extends APIResource {
    /**
     * Translates audio into English.
     */
    create(body, options) {
      return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options }));
    }
  }
  /* @__PURE__ */ (function(Translations2) {
  })(Translations || (Translations = {}));
  class Audio extends APIResource {
    constructor() {
      super(...arguments);
      this.transcriptions = new Transcriptions(this._client);
      this.translations = new Translations(this._client);
      this.speech = new Speech(this._client);
    }
  }
  (function(Audio2) {
    Audio2.Transcriptions = Transcriptions;
    Audio2.Translations = Translations;
    Audio2.Speech = Speech;
  })(Audio || (Audio = {}));
  class Batches extends APIResource {
    /**
     * Creates and executes a batch from an uploaded file of requests
     */
    create(body, options) {
      return this._client.post("/batches", { body, ...options });
    }
    /**
     * Retrieves a batch.
     */
    retrieve(batchId, options) {
      return this._client.get(`/batches/${batchId}`, options);
    }
    list(query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/batches", BatchesPage, { query, ...options });
    }
    /**
     * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
     * 10 minutes, before changing to `cancelled`, where it will have partial results
     * (if any) available in the output file.
     */
    cancel(batchId, options) {
      return this._client.post(`/batches/${batchId}/cancel`, options);
    }
  }
  class BatchesPage extends CursorPage {
  }
  (function(Batches2) {
    Batches2.BatchesPage = BatchesPage;
  })(Batches || (Batches = {}));
  class Assistants extends APIResource {
    /**
     * Create an assistant with a model and instructions.
     */
    create(body, options) {
      return this._client.post("/assistants", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves an assistant.
     */
    retrieve(assistantId, options) {
      return this._client.get(`/assistants/${assistantId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies an assistant.
     */
    update(assistantId, body, options) {
      return this._client.post(`/assistants/${assistantId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/assistants", AssistantsPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Delete an assistant.
     */
    del(assistantId, options) {
      return this._client.delete(`/assistants/${assistantId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  }
  class AssistantsPage extends CursorPage {
  }
  (function(Assistants2) {
    Assistants2.AssistantsPage = AssistantsPage;
  })(Assistants || (Assistants = {}));
  function isRunnableFunctionWithParse(fn) {
    return typeof fn.parse === "function";
  }
  const isAssistantMessage = (message) => {
    return (message == null ? void 0 : message.role) === "assistant";
  };
  const isFunctionMessage = (message) => {
    return (message == null ? void 0 : message.role) === "function";
  };
  const isToolMessage = (message) => {
    return (message == null ? void 0 : message.role) === "tool";
  };
  var __classPrivateFieldSet$2 = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet$3 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _EventStream_instances, _EventStream_connectedPromise, _EventStream_resolveConnectedPromise, _EventStream_rejectConnectedPromise, _EventStream_endPromise, _EventStream_resolveEndPromise, _EventStream_rejectEndPromise, _EventStream_listeners, _EventStream_ended, _EventStream_errored, _EventStream_aborted, _EventStream_catchingPromiseCreated, _EventStream_handleError;
  class EventStream {
    constructor() {
      _EventStream_instances.add(this);
      this.controller = new AbortController();
      _EventStream_connectedPromise.set(this, void 0);
      _EventStream_resolveConnectedPromise.set(this, () => {
      });
      _EventStream_rejectConnectedPromise.set(this, () => {
      });
      _EventStream_endPromise.set(this, void 0);
      _EventStream_resolveEndPromise.set(this, () => {
      });
      _EventStream_rejectEndPromise.set(this, () => {
      });
      _EventStream_listeners.set(this, {});
      _EventStream_ended.set(this, false);
      _EventStream_errored.set(this, false);
      _EventStream_aborted.set(this, false);
      _EventStream_catchingPromiseCreated.set(this, false);
      __classPrivateFieldSet$2(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {
        __classPrivateFieldSet$2(this, _EventStream_resolveConnectedPromise, resolve, "f");
        __classPrivateFieldSet$2(this, _EventStream_rejectConnectedPromise, reject, "f");
      }), "f");
      __classPrivateFieldSet$2(this, _EventStream_endPromise, new Promise((resolve, reject) => {
        __classPrivateFieldSet$2(this, _EventStream_resolveEndPromise, resolve, "f");
        __classPrivateFieldSet$2(this, _EventStream_rejectEndPromise, reject, "f");
      }), "f");
      __classPrivateFieldGet$3(this, _EventStream_connectedPromise, "f").catch(() => {
      });
      __classPrivateFieldGet$3(this, _EventStream_endPromise, "f").catch(() => {
      });
    }
    _run(executor) {
      setTimeout(() => {
        executor().then(() => {
          this._emitFinal();
          this._emit("end");
        }, __classPrivateFieldGet$3(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
      }, 0);
    }
    _connected() {
      if (this.ended)
        return;
      __classPrivateFieldGet$3(this, _EventStream_resolveConnectedPromise, "f").call(this);
      this._emit("connect");
    }
    get ended() {
      return __classPrivateFieldGet$3(this, _EventStream_ended, "f");
    }
    get errored() {
      return __classPrivateFieldGet$3(this, _EventStream_errored, "f");
    }
    get aborted() {
      return __classPrivateFieldGet$3(this, _EventStream_aborted, "f");
    }
    abort() {
      this.controller.abort();
    }
    /**
     * Adds the listener function to the end of the listeners array for the event.
     * No checks are made to see if the listener has already been added. Multiple calls passing
     * the same combination of event and listener will result in the listener being added, and
     * called, multiple times.
     * @returns this ChatCompletionStream, so that calls can be chained
     */
    on(event, listener) {
      const listeners = __classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event] = []);
      listeners.push({ listener });
      return this;
    }
    /**
     * Removes the specified listener from the listener array for the event.
     * off() will remove, at most, one instance of a listener from the listener array. If any single
     * listener has been added multiple times to the listener array for the specified event, then
     * off() must be called multiple times to remove each instance.
     * @returns this ChatCompletionStream, so that calls can be chained
     */
    off(event, listener) {
      const listeners = __classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event];
      if (!listeners)
        return this;
      const index = listeners.findIndex((l) => l.listener === listener);
      if (index >= 0)
        listeners.splice(index, 1);
      return this;
    }
    /**
     * Adds a one-time listener function for the event. The next time the event is triggered,
     * this listener is removed and then invoked.
     * @returns this ChatCompletionStream, so that calls can be chained
     */
    once(event, listener) {
      const listeners = __classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event] = []);
      listeners.push({ listener, once: true });
      return this;
    }
    /**
     * This is similar to `.once()`, but returns a Promise that resolves the next time
     * the event is triggered, instead of calling a listener callback.
     * @returns a Promise that resolves the next time given event is triggered,
     * or rejects if an error is emitted.  (If you request the 'error' event,
     * returns a promise that resolves with the error).
     *
     * Example:
     *
     *   const message = await stream.emitted('message') // rejects if the stream errors
     */
    emitted(event) {
      return new Promise((resolve, reject) => {
        __classPrivateFieldSet$2(this, _EventStream_catchingPromiseCreated, true, "f");
        if (event !== "error")
          this.once("error", reject);
        this.once(event, resolve);
      });
    }
    async done() {
      __classPrivateFieldSet$2(this, _EventStream_catchingPromiseCreated, true, "f");
      await __classPrivateFieldGet$3(this, _EventStream_endPromise, "f");
    }
    _emit(event, ...args) {
      if (__classPrivateFieldGet$3(this, _EventStream_ended, "f")) {
        return;
      }
      if (event === "end") {
        __classPrivateFieldSet$2(this, _EventStream_ended, true, "f");
        __classPrivateFieldGet$3(this, _EventStream_resolveEndPromise, "f").call(this);
      }
      const listeners = __classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event];
      if (listeners) {
        __classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
        listeners.forEach(({ listener }) => listener(...args));
      }
      if (event === "abort") {
        const error = args[0];
        if (!__classPrivateFieldGet$3(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
          Promise.reject(error);
        }
        __classPrivateFieldGet$3(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
        __classPrivateFieldGet$3(this, _EventStream_rejectEndPromise, "f").call(this, error);
        this._emit("end");
        return;
      }
      if (event === "error") {
        const error = args[0];
        if (!__classPrivateFieldGet$3(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
          Promise.reject(error);
        }
        __classPrivateFieldGet$3(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
        __classPrivateFieldGet$3(this, _EventStream_rejectEndPromise, "f").call(this, error);
        this._emit("end");
      }
    }
    _emitFinal() {
    }
  }
  _EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError2(error) {
    __classPrivateFieldSet$2(this, _EventStream_errored, true, "f");
    if (error instanceof Error && error.name === "AbortError") {
      error = new APIUserAbortError();
    }
    if (error instanceof APIUserAbortError) {
      __classPrivateFieldSet$2(this, _EventStream_aborted, true, "f");
      return this._emit("abort", error);
    }
    if (error instanceof OpenAIError) {
      return this._emit("error", error);
    }
    if (error instanceof Error) {
      const openAIError = new OpenAIError(error.message);
      openAIError.cause = error;
      return this._emit("error", openAIError);
    }
    return this._emit("error", new OpenAIError(String(error)));
  };
  function isAutoParsableResponseFormat(response_format) {
    return (response_format == null ? void 0 : response_format["$brand"]) === "auto-parseable-response-format";
  }
  function isAutoParsableTool(tool) {
    return (tool == null ? void 0 : tool["$brand"]) === "auto-parseable-tool";
  }
  function maybeParseChatCompletion(completion, params) {
    if (!params || !hasAutoParseableInput(params)) {
      return {
        ...completion,
        choices: completion.choices.map((choice) => ({
          ...choice,
          message: { ...choice.message, parsed: null, tool_calls: choice.message.tool_calls ?? [] }
        }))
      };
    }
    return parseChatCompletion(completion, params);
  }
  function parseChatCompletion(completion, params) {
    const choices = completion.choices.map((choice) => {
      var _a2;
      if (choice.finish_reason === "length") {
        throw new LengthFinishReasonError();
      }
      if (choice.finish_reason === "content_filter") {
        throw new ContentFilterFinishReasonError();
      }
      return {
        ...choice,
        message: {
          ...choice.message,
          tool_calls: ((_a2 = choice.message.tool_calls) == null ? void 0 : _a2.map((toolCall) => parseToolCall(params, toolCall))) ?? [],
          parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
        }
      };
    });
    return { ...completion, choices };
  }
  function parseResponseFormat(params, content) {
    var _a2, _b;
    if (((_a2 = params.response_format) == null ? void 0 : _a2.type) !== "json_schema") {
      return null;
    }
    if (((_b = params.response_format) == null ? void 0 : _b.type) === "json_schema") {
      if ("$parseRaw" in params.response_format) {
        const response_format = params.response_format;
        return response_format.$parseRaw(content);
      }
      return JSON.parse(content);
    }
    return null;
  }
  function parseToolCall(params, toolCall) {
    var _a2;
    const inputTool = (_a2 = params.tools) == null ? void 0 : _a2.find((inputTool2) => {
      var _a3;
      return ((_a3 = inputTool2.function) == null ? void 0 : _a3.name) === toolCall.function.name;
    });
    return {
      ...toolCall,
      function: {
        ...toolCall.function,
        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCall.function.arguments) : null
      }
    };
  }
  function shouldParseToolCall(params, toolCall) {
    var _a2;
    if (!params) {
      return false;
    }
    const inputTool = (_a2 = params.tools) == null ? void 0 : _a2.find((inputTool2) => {
      var _a3;
      return ((_a3 = inputTool2.function) == null ? void 0 : _a3.name) === toolCall.function.name;
    });
    return isAutoParsableTool(inputTool) || (inputTool == null ? void 0 : inputTool.function.strict) || false;
  }
  function hasAutoParseableInput(params) {
    var _a2;
    if (isAutoParsableResponseFormat(params.response_format)) {
      return true;
    }
    return ((_a2 = params.tools) == null ? void 0 : _a2.some((t) => isAutoParsableTool(t) || t.type === "function" && t.function.strict === true)) ?? false;
  }
  function validateInputTools(tools) {
    for (const tool of tools ?? []) {
      if (tool.type !== "function") {
        throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
      }
      if (tool.function.strict !== true) {
        throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
      }
    }
  }
  var __classPrivateFieldGet$2 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionCall, _AbstractChatCompletionRunner_getFinalFunctionCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;
  const DEFAULT_MAX_CHAT_COMPLETIONS = 10;
  class AbstractChatCompletionRunner extends EventStream {
    constructor() {
      super(...arguments);
      _AbstractChatCompletionRunner_instances.add(this);
      this._chatCompletions = [];
      this.messages = [];
    }
    _addChatCompletion(chatCompletion) {
      var _a2;
      this._chatCompletions.push(chatCompletion);
      this._emit("chatCompletion", chatCompletion);
      const message = (_a2 = chatCompletion.choices[0]) == null ? void 0 : _a2.message;
      if (message)
        this._addMessage(message);
      return chatCompletion;
    }
    _addMessage(message, emit2 = true) {
      if (!("content" in message))
        message.content = null;
      this.messages.push(message);
      if (emit2) {
        this._emit("message", message);
        if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {
          this._emit("functionCallResult", message.content);
        } else if (isAssistantMessage(message) && message.function_call) {
          this._emit("functionCall", message.function_call);
        } else if (isAssistantMessage(message) && message.tool_calls) {
          for (const tool_call of message.tool_calls) {
            if (tool_call.type === "function") {
              this._emit("functionCall", tool_call.function);
            }
          }
        }
      }
    }
    /**
     * @returns a promise that resolves with the final ChatCompletion, or rejects
     * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
     */
    async finalChatCompletion() {
      await this.done();
      const completion = this._chatCompletions[this._chatCompletions.length - 1];
      if (!completion)
        throw new OpenAIError("stream ended without producing a ChatCompletion");
      return completion;
    }
    /**
     * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
     */
    async finalContent() {
      await this.done();
      return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    }
    /**
     * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
     * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
     */
    async finalMessage() {
      await this.done();
      return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    }
    /**
     * @returns a promise that resolves with the content of the final FunctionCall, or rejects
     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
     */
    async finalFunctionCall() {
      await this.done();
      return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
    }
    async finalFunctionCallResult() {
      await this.done();
      return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
    }
    async totalUsage() {
      await this.done();
      return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
    }
    allChatCompletions() {
      return [...this._chatCompletions];
    }
    _emitFinal() {
      const completion = this._chatCompletions[this._chatCompletions.length - 1];
      if (completion)
        this._emit("finalChatCompletion", completion);
      const finalMessage = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
      if (finalMessage)
        this._emit("finalMessage", finalMessage);
      const finalContent = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
      if (finalContent)
        this._emit("finalContent", finalContent);
      const finalFunctionCall = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
      if (finalFunctionCall)
        this._emit("finalFunctionCall", finalFunctionCall);
      const finalFunctionCallResult = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
      if (finalFunctionCallResult != null)
        this._emit("finalFunctionCallResult", finalFunctionCallResult);
      if (this._chatCompletions.some((c) => c.usage)) {
        this._emit("totalUsage", __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
      }
    }
    async _createChatCompletion(client, params, options) {
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
      const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
      this._connected();
      return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
    }
    async _runChatCompletion(client, params, options) {
      for (const message of params.messages) {
        this._addMessage(message, false);
      }
      return await this._createChatCompletion(client, params, options);
    }
    async _runFunctions(client, params, options) {
      var _a2;
      const role = "function";
      const { function_call = "auto", stream, ...restParams } = params;
      const singleFunctionToCall = typeof function_call !== "string" && (function_call == null ? void 0 : function_call.name);
      const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
      const functionsByName = {};
      for (const f of params.functions) {
        functionsByName[f.name || f.function.name] = f;
      }
      const functions = params.functions.map((f) => ({
        name: f.name || f.function.name,
        parameters: f.parameters,
        description: f.description
      }));
      for (const message of params.messages) {
        this._addMessage(message, false);
      }
      for (let i = 0; i < maxChatCompletions; ++i) {
        const chatCompletion = await this._createChatCompletion(client, {
          ...restParams,
          function_call,
          functions,
          messages: [...this.messages]
        }, options);
        const message = (_a2 = chatCompletion.choices[0]) == null ? void 0 : _a2.message;
        if (!message) {
          throw new OpenAIError(`missing message in ChatCompletion response`);
        }
        if (!message.function_call)
          return;
        const { name, arguments: args } = message.function_call;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map((f) => JSON.stringify(f.name)).join(", ")}. Please try again`;
          this._addMessage({ role, name, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, name, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error) {
          this._addMessage({
            role,
            name,
            content: error instanceof Error ? error.message : String(error)
          });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, name, content });
        if (singleFunctionToCall)
          return;
      }
    }
    async _runTools(client, params, options) {
      var _a2, _b, _c;
      const role = "tool";
      const { tool_choice = "auto", stream, ...restParams } = params;
      const singleFunctionToCall = typeof tool_choice !== "string" && ((_a2 = tool_choice == null ? void 0 : tool_choice.function) == null ? void 0 : _a2.name);
      const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
      const inputTools = params.tools.map((tool) => {
        if (isAutoParsableTool(tool)) {
          if (!tool.$callback) {
            throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
          }
          return {
            type: "function",
            function: {
              function: tool.$callback,
              name: tool.function.name,
              description: tool.function.description || "",
              parameters: tool.function.parameters,
              parse: tool.$parseRaw,
              strict: true
            }
          };
        }
        return tool;
      });
      const functionsByName = {};
      for (const f of inputTools) {
        if (f.type === "function") {
          functionsByName[f.function.name || f.function.function.name] = f.function;
        }
      }
      const tools = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
        type: "function",
        function: {
          name: t.function.name || t.function.function.name,
          parameters: t.function.parameters,
          description: t.function.description,
          strict: t.function.strict
        }
      } : t) : void 0;
      for (const message of params.messages) {
        this._addMessage(message, false);
      }
      for (let i = 0; i < maxChatCompletions; ++i) {
        const chatCompletion = await this._createChatCompletion(client, {
          ...restParams,
          tool_choice,
          tools,
          messages: [...this.messages]
        }, options);
        const message = (_b = chatCompletion.choices[0]) == null ? void 0 : _b.message;
        if (!message) {
          throw new OpenAIError(`missing message in ChatCompletion response`);
        }
        if (!((_c = message.tool_calls) == null ? void 0 : _c.length)) {
          return;
        }
        for (const tool_call of message.tool_calls) {
          if (tool_call.type !== "function")
            continue;
          const tool_call_id = tool_call.id;
          const { name, arguments: args } = tool_call.function;
          const fn = functionsByName[name];
          if (!fn) {
            const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
            this._addMessage({ role, tool_call_id, content: content2 });
            continue;
          } else if (singleFunctionToCall && singleFunctionToCall !== name) {
            const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
            this._addMessage({ role, tool_call_id, content: content2 });
            continue;
          }
          let parsed;
          try {
            parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
          } catch (error) {
            const content2 = error instanceof Error ? error.message : String(error);
            this._addMessage({ role, tool_call_id, content: content2 });
            continue;
          }
          const rawContent = await fn.function(parsed, this);
          const content = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
          this._addMessage({ role, tool_call_id, content });
          if (singleFunctionToCall) {
            return;
          }
        }
      }
      return;
    }
  }
  _AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
    return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
  }, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
    let i = this.messages.length;
    while (i-- > 0) {
      const message = this.messages[i];
      if (isAssistantMessage(message)) {
        const { function_call, ...rest } = message;
        const ret = {
          ...rest,
          content: message.content ?? null,
          refusal: message.refusal ?? null
        };
        if (function_call) {
          ret.function_call = function_call;
        }
        return ret;
      }
    }
    throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
  }, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall2() {
    var _a2, _b;
    for (let i = this.messages.length - 1; i >= 0; i--) {
      const message = this.messages[i];
      if (isAssistantMessage(message) && (message == null ? void 0 : message.function_call)) {
        return message.function_call;
      }
      if (isAssistantMessage(message) && ((_a2 = message == null ? void 0 : message.tool_calls) == null ? void 0 : _a2.length)) {
        return (_b = message.tool_calls.at(-1)) == null ? void 0 : _b.function;
      }
    }
    return;
  }, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult2() {
    for (let i = this.messages.length - 1; i >= 0; i--) {
      const message = this.messages[i];
      if (isFunctionMessage(message) && message.content != null) {
        return message.content;
      }
      if (isToolMessage(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => {
        var _a2;
        return x.role === "assistant" && ((_a2 = x.tool_calls) == null ? void 0 : _a2.some((y) => y.type === "function" && y.id === message.tool_call_id));
      })) {
        return message.content;
      }
    }
    return;
  }, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
    const total = {
      completion_tokens: 0,
      prompt_tokens: 0,
      total_tokens: 0
    };
    for (const { usage } of this._chatCompletions) {
      if (usage) {
        total.completion_tokens += usage.completion_tokens;
        total.prompt_tokens += usage.prompt_tokens;
        total.total_tokens += usage.total_tokens;
      }
    }
    return total;
  }, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
    if (params.n != null && params.n > 1) {
      throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
    }
  }, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
    return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
  };
  class ChatCompletionRunner extends AbstractChatCompletionRunner {
    /** @deprecated - please use `runTools` instead. */
    static runFunctions(client, params, options) {
      const runner = new ChatCompletionRunner();
      const opts = {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
      };
      runner._run(() => runner._runFunctions(client, params, opts));
      return runner;
    }
    static runTools(client, params, options) {
      const runner = new ChatCompletionRunner();
      const opts = {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
      };
      runner._run(() => runner._runTools(client, params, opts));
      return runner;
    }
    _addMessage(message) {
      super._addMessage(message);
      if (isAssistantMessage(message) && message.content) {
        this._emit("content", message.content);
      }
    }
  }
  const tokenize = (input) => {
    let current = 0;
    let tokens = [];
    while (current < input.length) {
      let char = input[current];
      if (char === "\\") {
        current++;
        continue;
      }
      if (char === "{") {
        tokens.push({
          type: "brace",
          value: "{"
        });
        current++;
        continue;
      }
      if (char === "}") {
        tokens.push({
          type: "brace",
          value: "}"
        });
        current++;
        continue;
      }
      if (char === "[") {
        tokens.push({
          type: "paren",
          value: "["
        });
        current++;
        continue;
      }
      if (char === "]") {
        tokens.push({
          type: "paren",
          value: "]"
        });
        current++;
        continue;
      }
      if (char === ":") {
        tokens.push({
          type: "separator",
          value: ":"
        });
        current++;
        continue;
      }
      if (char === ",") {
        tokens.push({
          type: "delimiter",
          value: ","
        });
        current++;
        continue;
      }
      if (char === '"') {
        let value = "";
        let danglingQuote = false;
        char = input[++current];
        while (char !== '"') {
          if (current === input.length) {
            danglingQuote = true;
            break;
          }
          if (char === "\\") {
            current++;
            if (current === input.length) {
              danglingQuote = true;
              break;
            }
            value += char + input[current];
            char = input[++current];
          } else {
            value += char;
            char = input[++current];
          }
        }
        char = input[++current];
        if (!danglingQuote) {
          tokens.push({
            type: "string",
            value
          });
        }
        continue;
      }
      let WHITESPACE = /\s/;
      if (char && WHITESPACE.test(char)) {
        current++;
        continue;
      }
      let NUMBERS = /[0-9]/;
      if (char && NUMBERS.test(char) || char === "-" || char === ".") {
        let value = "";
        if (char === "-") {
          value += char;
          char = input[++current];
        }
        while (char && NUMBERS.test(char) || char === ".") {
          value += char;
          char = input[++current];
        }
        tokens.push({
          type: "number",
          value
        });
        continue;
      }
      let LETTERS = /[a-z]/i;
      if (char && LETTERS.test(char)) {
        let value = "";
        while (char && LETTERS.test(char)) {
          if (current === input.length) {
            break;
          }
          value += char;
          char = input[++current];
        }
        if (value == "true" || value == "false" || value === "null") {
          tokens.push({
            type: "name",
            value
          });
        } else {
          current++;
          continue;
        }
        continue;
      }
      current++;
    }
    return tokens;
  }, strip = (tokens) => {
    if (tokens.length === 0) {
      return tokens;
    }
    let lastToken = tokens[tokens.length - 1];
    switch (lastToken.type) {
      case "separator":
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      case "number":
        let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];
        if (lastCharacterOfLastToken === "." || lastCharacterOfLastToken === "-") {
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
        }
      case "string":
        let tokenBeforeTheLastToken = tokens[tokens.length - 2];
        if ((tokenBeforeTheLastToken == null ? void 0 : tokenBeforeTheLastToken.type) === "delimiter") {
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
        } else if ((tokenBeforeTheLastToken == null ? void 0 : tokenBeforeTheLastToken.type) === "brace" && tokenBeforeTheLastToken.value === "{") {
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
        }
        break;
      case "delimiter":
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
    }
    return tokens;
  }, unstrip = (tokens) => {
    let tail = [];
    tokens.map((token) => {
      if (token.type === "brace") {
        if (token.value === "{") {
          tail.push("}");
        } else {
          tail.splice(tail.lastIndexOf("}"), 1);
        }
      }
      if (token.type === "paren") {
        if (token.value === "[") {
          tail.push("]");
        } else {
          tail.splice(tail.lastIndexOf("]"), 1);
        }
      }
    });
    if (tail.length > 0) {
      tail.reverse().map((item) => {
        if (item === "}") {
          tokens.push({
            type: "brace",
            value: "}"
          });
        } else if (item === "]") {
          tokens.push({
            type: "paren",
            value: "]"
          });
        }
      });
    }
    return tokens;
  }, generate = (tokens) => {
    let output = "";
    tokens.map((token) => {
      switch (token.type) {
        case "string":
          output += '"' + token.value + '"';
          break;
        default:
          output += token.value;
          break;
      }
    });
    return output;
  }, partialParse = (input) => JSON.parse(generate(unstrip(strip(tokenize(input)))));
  var __classPrivateFieldSet$1 = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet$1 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _ChatCompletionStream_instances, _ChatCompletionStream_params, _ChatCompletionStream_choiceEventStates, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_getChoiceEventState, _ChatCompletionStream_addChunk, _ChatCompletionStream_emitToolCallDoneEvent, _ChatCompletionStream_emitContentDoneEvents, _ChatCompletionStream_endRequest, _ChatCompletionStream_getAutoParseableResponseFormat, _ChatCompletionStream_accumulateChatCompletion;
  class ChatCompletionStream extends AbstractChatCompletionRunner {
    constructor(params) {
      super();
      _ChatCompletionStream_instances.add(this);
      _ChatCompletionStream_params.set(this, void 0);
      _ChatCompletionStream_choiceEventStates.set(this, void 0);
      _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
      __classPrivateFieldSet$1(this, _ChatCompletionStream_params, params, "f");
      __classPrivateFieldSet$1(this, _ChatCompletionStream_choiceEventStates, [], "f");
    }
    get currentChatCompletionSnapshot() {
      return __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    }
    /**
     * Intended for use on the frontend, consuming a stream produced with
     * `.toReadableStream()` on the backend.
     *
     * Note that messages sent to the model do not appear in `.on('message')`
     * in this context.
     */
    static fromReadableStream(stream) {
      const runner = new ChatCompletionStream(null);
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    static createChatCompletion(client, params, options) {
      const runner = new ChatCompletionStream(params);
      runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
      return runner;
    }
    async _createChatCompletion(client, params, options) {
      var _a2;
      super._createChatCompletion;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
      const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
      this._connected();
      for await (const chunk of stream) {
        __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      }
      if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
        throw new APIUserAbortError();
      }
      return this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
    }
    async _fromReadableStream(readableStream, options) {
      var _a2;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
      this._connected();
      const stream = Stream.fromReadableStream(readableStream, this.controller);
      let chatId;
      for await (const chunk of stream) {
        if (chatId && chatId !== chunk.id) {
          this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
        }
        __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
        chatId = chunk.id;
      }
      if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
        throw new APIUserAbortError();
      }
      return this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
    }
    [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
      if (this.ended)
        return;
      __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
    }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState2(choice) {
      let state = __classPrivateFieldGet$1(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
      if (state) {
        return state;
      }
      state = {
        content_done: false,
        refusal_done: false,
        logprobs_content_done: false,
        logprobs_refusal_done: false,
        done_tool_calls: /* @__PURE__ */ new Set(),
        current_tool_call_index: null
      };
      __classPrivateFieldGet$1(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
      return state;
    }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
      if (this.ended)
        return;
      const completion = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
      this._emit("chunk", chunk, completion);
      for (const choice of chunk.choices) {
        const choiceSnapshot = completion.choices[choice.index];
        if (choice.delta.content != null && ((_a2 = choiceSnapshot.message) == null ? void 0 : _a2.role) === "assistant" && ((_b = choiceSnapshot.message) == null ? void 0 : _b.content)) {
          this._emit("content", choice.delta.content, choiceSnapshot.message.content);
          this._emit("content.delta", {
            delta: choice.delta.content,
            snapshot: choiceSnapshot.message.content,
            parsed: choiceSnapshot.message.parsed
          });
        }
        if (choice.delta.refusal != null && ((_c = choiceSnapshot.message) == null ? void 0 : _c.role) === "assistant" && ((_d = choiceSnapshot.message) == null ? void 0 : _d.refusal)) {
          this._emit("refusal.delta", {
            delta: choice.delta.refusal,
            snapshot: choiceSnapshot.message.refusal
          });
        }
        if (((_e = choice.logprobs) == null ? void 0 : _e.content) != null && ((_f = choiceSnapshot.message) == null ? void 0 : _f.role) === "assistant") {
          this._emit("logprobs.content.delta", {
            content: (_g = choice.logprobs) == null ? void 0 : _g.content,
            snapshot: ((_h = choiceSnapshot.logprobs) == null ? void 0 : _h.content) ?? []
          });
        }
        if (((_i = choice.logprobs) == null ? void 0 : _i.refusal) != null && ((_j = choiceSnapshot.message) == null ? void 0 : _j.role) === "assistant") {
          this._emit("logprobs.refusal.delta", {
            refusal: (_k = choice.logprobs) == null ? void 0 : _k.refusal,
            snapshot: ((_l = choiceSnapshot.logprobs) == null ? void 0 : _l.refusal) ?? []
          });
        }
        const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
        if (choiceSnapshot.finish_reason) {
          __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        for (const toolCall of choice.delta.tool_calls ?? []) {
          if (state.current_tool_call_index !== toolCall.index) {
            __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
            if (state.current_tool_call_index != null) {
              __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
            }
          }
          state.current_tool_call_index = toolCall.index;
        }
        for (const toolCallDelta of choice.delta.tool_calls ?? []) {
          const toolCallSnapshot = (_m = choiceSnapshot.message.tool_calls) == null ? void 0 : _m[toolCallDelta.index];
          if (!(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type)) {
            continue;
          }
          if ((toolCallSnapshot == null ? void 0 : toolCallSnapshot.type) === "function") {
            this._emit("tool_calls.function.arguments.delta", {
              name: (_n = toolCallSnapshot.function) == null ? void 0 : _n.name,
              index: toolCallDelta.index,
              arguments: toolCallSnapshot.function.arguments,
              parsed_arguments: toolCallSnapshot.function.parsed_arguments,
              arguments_delta: ((_o = toolCallDelta.function) == null ? void 0 : _o.arguments) ?? ""
            });
          } else {
            assertNever(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type);
          }
        }
      }
    }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
      var _a2, _b, _c;
      const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (state.done_tool_calls.has(toolCallIndex)) {
        return;
      }
      const toolCallSnapshot = (_a2 = choiceSnapshot.message.tool_calls) == null ? void 0 : _a2[toolCallIndex];
      if (!toolCallSnapshot) {
        throw new Error("no tool call snapshot");
      }
      if (!toolCallSnapshot.type) {
        throw new Error("tool call snapshot missing `type`");
      }
      if (toolCallSnapshot.type === "function") {
        const inputTool = (_c = (_b = __classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _b.tools) == null ? void 0 : _c.find((tool) => tool.type === "function" && tool.function.name === toolCallSnapshot.function.name);
        this._emit("tool_calls.function.arguments.done", {
          name: toolCallSnapshot.function.name,
          index: toolCallIndex,
          arguments: toolCallSnapshot.function.arguments,
          parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCallSnapshot.function.arguments) : null
        });
      } else {
        assertNever(toolCallSnapshot.type);
      }
    }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
      var _a2, _b;
      const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.message.content && !state.content_done) {
        state.content_done = true;
        const responseFormat = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
        this._emit("content.done", {
          content: choiceSnapshot.message.content,
          parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
        });
      }
      if (choiceSnapshot.message.refusal && !state.refusal_done) {
        state.refusal_done = true;
        this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
      }
      if (((_a2 = choiceSnapshot.logprobs) == null ? void 0 : _a2.content) && !state.logprobs_content_done) {
        state.logprobs_content_done = true;
        this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
      }
      if (((_b = choiceSnapshot.logprobs) == null ? void 0 : _b.refusal) && !state.logprobs_refusal_done) {
        state.logprobs_refusal_done = true;
        this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
      }
    }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
      if (this.ended) {
        throw new OpenAIError(`stream has ended, this shouldn't happen`);
      }
      const snapshot = __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
      if (!snapshot) {
        throw new OpenAIError(`request ended without sending any chunks`);
      }
      __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
      __classPrivateFieldSet$1(this, _ChatCompletionStream_choiceEventStates, [], "f");
      return finalizeChatCompletion(snapshot, __classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f"));
    }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
      var _a2;
      const responseFormat = (_a2 = __classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _a2.response_format;
      if (isAutoParsableResponseFormat(responseFormat)) {
        return responseFormat;
      }
      return null;
    }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
      var _a2, _b, _c, _d;
      let snapshot = __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
      const { choices, ...rest } = chunk;
      if (!snapshot) {
        snapshot = __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
          ...rest,
          choices: []
        }, "f");
      } else {
        Object.assign(snapshot, rest);
      }
      for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {
        let choice = snapshot.choices[index];
        if (!choice) {
          choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };
        }
        if (logprobs) {
          if (!choice.logprobs) {
            choice.logprobs = Object.assign({}, logprobs);
          } else {
            const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
            Object.assign(choice.logprobs, rest3);
            if (content2) {
              (_a2 = choice.logprobs).content ?? (_a2.content = []);
              choice.logprobs.content.push(...content2);
            }
            if (refusal2) {
              (_b = choice.logprobs).refusal ?? (_b.refusal = []);
              choice.logprobs.refusal.push(...refusal2);
            }
          }
        }
        if (finish_reason) {
          choice.finish_reason = finish_reason;
          if (__classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput(__classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f"))) {
            if (finish_reason === "length") {
              throw new LengthFinishReasonError();
            }
            if (finish_reason === "content_filter") {
              throw new ContentFilterFinishReasonError();
            }
          }
        }
        Object.assign(choice, other);
        if (!delta)
          continue;
        const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
        Object.assign(choice.message, rest2);
        if (refusal) {
          choice.message.refusal = (choice.message.refusal || "") + refusal;
        }
        if (role)
          choice.message.role = role;
        if (function_call) {
          if (!choice.message.function_call) {
            choice.message.function_call = function_call;
          } else {
            if (function_call.name)
              choice.message.function_call.name = function_call.name;
            if (function_call.arguments) {
              (_c = choice.message.function_call).arguments ?? (_c.arguments = "");
              choice.message.function_call.arguments += function_call.arguments;
            }
          }
        }
        if (content) {
          choice.message.content = (choice.message.content || "") + content;
          if (!choice.message.refusal && __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
            choice.message.parsed = partialParse(choice.message.content);
          }
        }
        if (tool_calls) {
          if (!choice.message.tool_calls)
            choice.message.tool_calls = [];
          for (const { index: index2, id, type: type2, function: fn, ...rest3 } of tool_calls) {
            const tool_call = (_d = choice.message.tool_calls)[index2] ?? (_d[index2] = {});
            Object.assign(tool_call, rest3);
            if (id)
              tool_call.id = id;
            if (type2)
              tool_call.type = type2;
            if (fn)
              tool_call.function ?? (tool_call.function = { name: fn.name ?? "", arguments: "" });
            if (fn == null ? void 0 : fn.name)
              tool_call.function.name = fn.name;
            if (fn == null ? void 0 : fn.arguments) {
              tool_call.function.arguments += fn.arguments;
              if (shouldParseToolCall(__classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f"), tool_call)) {
                tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
              }
            }
          }
        }
      }
      return snapshot;
    }, Symbol.asyncIterator)]() {
      const pushQueue = [];
      const readQueue = [];
      let done = false;
      this.on("chunk", (chunk) => {
        const reader = readQueue.shift();
        if (reader) {
          reader.resolve(chunk);
        } else {
          pushQueue.push(chunk);
        }
      });
      this.on("end", () => {
        done = true;
        for (const reader of readQueue) {
          reader.resolve(void 0);
        }
        readQueue.length = 0;
      });
      this.on("abort", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      this.on("error", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      return {
        next: async () => {
          if (!pushQueue.length) {
            if (done) {
              return { value: void 0, done: true };
            }
            return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
          }
          const chunk = pushQueue.shift();
          return { value: chunk, done: false };
        },
        return: async () => {
          this.abort();
          return { value: void 0, done: true };
        }
      };
    }
    toReadableStream() {
      const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
      return stream.toReadableStream();
    }
  }
  function finalizeChatCompletion(snapshot, params) {
    const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
    const completion = {
      ...rest,
      id,
      choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {
        if (!finish_reason) {
          throw new OpenAIError(`missing finish_reason for choice ${index}`);
        }
        const { content = null, function_call, tool_calls, ...messageRest } = message;
        const role = message.role;
        if (!role) {
          throw new OpenAIError(`missing role for choice ${index}`);
        }
        if (function_call) {
          const { arguments: args, name } = function_call;
          if (args == null) {
            throw new OpenAIError(`missing function_call.arguments for choice ${index}`);
          }
          if (!name) {
            throw new OpenAIError(`missing function_call.name for choice ${index}`);
          }
          return {
            ...choiceRest,
            message: {
              content,
              function_call: { arguments: args, name },
              role,
              refusal: message.refusal ?? null
            },
            finish_reason,
            index,
            logprobs
          };
        }
        if (tool_calls) {
          return {
            ...choiceRest,
            index,
            finish_reason,
            logprobs,
            message: {
              ...messageRest,
              role,
              content,
              refusal: message.refusal ?? null,
              tool_calls: tool_calls.map((tool_call, i) => {
                const { function: fn, type: type2, id: id2, ...toolRest } = tool_call;
                const { arguments: args, name, ...fnRest } = fn || {};
                if (id2 == null) {
                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id
${str(snapshot)}`);
                }
                if (type2 == null) {
                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type
${str(snapshot)}`);
                }
                if (name == null) {
                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name
${str(snapshot)}`);
                }
                if (args == null) {
                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments
${str(snapshot)}`);
                }
                return { ...toolRest, id: id2, type: type2, function: { ...fnRest, name, arguments: args } };
              })
            }
          };
        }
        return {
          ...choiceRest,
          message: { ...messageRest, content, role, refusal: message.refusal ?? null },
          finish_reason,
          index,
          logprobs
        };
      }),
      created,
      model,
      object: "chat.completion",
      ...system_fingerprint ? { system_fingerprint } : {}
    };
    return maybeParseChatCompletion(completion, params);
  }
  function str(x) {
    return JSON.stringify(x);
  }
  function assertNever(_x) {
  }
  class ChatCompletionStreamingRunner extends ChatCompletionStream {
    static fromReadableStream(stream) {
      const runner = new ChatCompletionStreamingRunner(null);
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    /** @deprecated - please use `runTools` instead. */
    static runFunctions(client, params, options) {
      const runner = new ChatCompletionStreamingRunner(null);
      const opts = {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
      };
      runner._run(() => runner._runFunctions(client, params, opts));
      return runner;
    }
    static runTools(client, params, options) {
      const runner = new ChatCompletionStreamingRunner(
        // @ts-expect-error TODO these types are incompatible
        params
      );
      const opts = {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
      };
      runner._run(() => runner._runTools(client, params, opts));
      return runner;
    }
  }
  let Completions$1 = class Completions extends APIResource {
    async parse(body, options) {
      validateInputTools(body.tools);
      const completion = await this._client.chat.completions.create(body, {
        ...options,
        headers: {
          ...options == null ? void 0 : options.headers,
          "X-Stainless-Helper-Method": "beta.chat.completions.parse"
        }
      });
      return parseChatCompletion(completion, body);
    }
    runFunctions(body, options) {
      if (body.stream) {
        return ChatCompletionStreamingRunner.runFunctions(this._client, body, options);
      }
      return ChatCompletionRunner.runFunctions(this._client, body, options);
    }
    runTools(body, options) {
      if (body.stream) {
        return ChatCompletionStreamingRunner.runTools(this._client, body, options);
      }
      return ChatCompletionRunner.runTools(this._client, body, options);
    }
    /**
     * Creates a chat completion stream
     */
    stream(body, options) {
      return ChatCompletionStream.createChatCompletion(this._client, body, options);
    }
  };
  class Chat extends APIResource {
    constructor() {
      super(...arguments);
      this.completions = new Completions$1(this._client);
    }
  }
  (function(Chat2) {
    Chat2.Completions = Completions$1;
  })(Chat || (Chat = {}));
  var __classPrivateFieldGet = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _AssistantStream_instances, _AssistantStream_events, _AssistantStream_runStepSnapshots, _AssistantStream_messageSnapshots, _AssistantStream_messageSnapshot, _AssistantStream_finalRun, _AssistantStream_currentContentIndex, _AssistantStream_currentContent, _AssistantStream_currentToolCallIndex, _AssistantStream_currentToolCall, _AssistantStream_currentEvent, _AssistantStream_currentRunSnapshot, _AssistantStream_currentRunStepSnapshot, _AssistantStream_addEvent, _AssistantStream_endRequest, _AssistantStream_handleMessage, _AssistantStream_handleRunStep, _AssistantStream_handleEvent, _AssistantStream_accumulateRunStep, _AssistantStream_accumulateMessage, _AssistantStream_accumulateContent, _AssistantStream_handleRun;
  class AssistantStream extends EventStream {
    constructor() {
      super(...arguments);
      _AssistantStream_instances.add(this);
      _AssistantStream_events.set(this, []);
      _AssistantStream_runStepSnapshots.set(this, {});
      _AssistantStream_messageSnapshots.set(this, {});
      _AssistantStream_messageSnapshot.set(this, void 0);
      _AssistantStream_finalRun.set(this, void 0);
      _AssistantStream_currentContentIndex.set(this, void 0);
      _AssistantStream_currentContent.set(this, void 0);
      _AssistantStream_currentToolCallIndex.set(this, void 0);
      _AssistantStream_currentToolCall.set(this, void 0);
      _AssistantStream_currentEvent.set(this, void 0);
      _AssistantStream_currentRunSnapshot.set(this, void 0);
      _AssistantStream_currentRunStepSnapshot.set(this, void 0);
    }
    [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
      const pushQueue = [];
      const readQueue = [];
      let done = false;
      this.on("event", (event) => {
        const reader = readQueue.shift();
        if (reader) {
          reader.resolve(event);
        } else {
          pushQueue.push(event);
        }
      });
      this.on("end", () => {
        done = true;
        for (const reader of readQueue) {
          reader.resolve(void 0);
        }
        readQueue.length = 0;
      });
      this.on("abort", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      this.on("error", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      return {
        next: async () => {
          if (!pushQueue.length) {
            if (done) {
              return { value: void 0, done: true };
            }
            return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
          }
          const chunk = pushQueue.shift();
          return { value: chunk, done: false };
        },
        return: async () => {
          this.abort();
          return { value: void 0, done: true };
        }
      };
    }
    static fromReadableStream(stream) {
      const runner = new AssistantStream();
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    async _fromReadableStream(readableStream, options) {
      var _a2;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      this._connected();
      const stream = Stream.fromReadableStream(readableStream, this.controller);
      for await (const event of stream) {
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
      }
      if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
        throw new APIUserAbortError();
      }
      return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
    }
    toReadableStream() {
      const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
      return stream.toReadableStream();
    }
    static createToolAssistantStream(threadId, runId, runs, params, options) {
      const runner = new AssistantStream();
      runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
      }));
      return runner;
    }
    async _createToolAssistantStream(run, threadId, runId, params, options) {
      var _a2;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      const body = { ...params, stream: true };
      const stream = await run.submitToolOutputs(threadId, runId, body, {
        ...options,
        signal: this.controller.signal
      });
      this._connected();
      for await (const event of stream) {
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
      }
      if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
        throw new APIUserAbortError();
      }
      return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
    }
    static createThreadAssistantStream(params, thread, options) {
      const runner = new AssistantStream();
      runner._run(() => runner._threadAssistantStream(params, thread, {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
      }));
      return runner;
    }
    static createAssistantStream(threadId, runs, params, options) {
      const runner = new AssistantStream();
      runner._run(() => runner._runAssistantStream(threadId, runs, params, {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
      }));
      return runner;
    }
    currentEvent() {
      return __classPrivateFieldGet(this, _AssistantStream_currentEvent, "f");
    }
    currentRun() {
      return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, "f");
    }
    currentMessageSnapshot() {
      return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f");
    }
    currentRunStepSnapshot() {
      return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, "f");
    }
    async finalRunSteps() {
      await this.done();
      return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f"));
    }
    async finalMessages() {
      await this.done();
      return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f"));
    }
    async finalRun() {
      await this.done();
      if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
        throw Error("Final run was not received.");
      return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
    }
    async _createThreadAssistantStream(thread, params, options) {
      var _a2;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      const body = { ...params, stream: true };
      const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
      this._connected();
      for await (const event of stream) {
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
      }
      if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
        throw new APIUserAbortError();
      }
      return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
    }
    async _createAssistantStream(run, threadId, params, options) {
      var _a2;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      const body = { ...params, stream: true };
      const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });
      this._connected();
      for await (const event of stream) {
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
      }
      if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
        throw new APIUserAbortError();
      }
      return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
    }
    static accumulateDelta(acc, delta) {
      for (const [key, deltaValue] of Object.entries(delta)) {
        if (!acc.hasOwnProperty(key)) {
          acc[key] = deltaValue;
          continue;
        }
        let accValue = acc[key];
        if (accValue === null || accValue === void 0) {
          acc[key] = deltaValue;
          continue;
        }
        if (key === "index" || key === "type") {
          acc[key] = deltaValue;
          continue;
        }
        if (typeof accValue === "string" && typeof deltaValue === "string") {
          accValue += deltaValue;
        } else if (typeof accValue === "number" && typeof deltaValue === "number") {
          accValue += deltaValue;
        } else if (isObj(accValue) && isObj(deltaValue)) {
          accValue = this.accumulateDelta(accValue, deltaValue);
        } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
          if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
            accValue.push(...deltaValue);
            continue;
          }
        } else {
          throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
        }
        acc[key] = accValue;
      }
      return acc;
    }
    _addRun(run) {
      return run;
    }
    async _threadAssistantStream(params, thread, options) {
      return await this._createThreadAssistantStream(thread, params, options);
    }
    async _runAssistantStream(threadId, runs, params, options) {
      return await this._createAssistantStream(runs, threadId, params, options);
    }
    async _runToolAssistantStream(threadId, runId, runs, params, options) {
      return await this._createToolAssistantStream(runs, threadId, runId, params, options);
    }
  }
  _AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _AssistantStream_currentEvent, event, "f");
    __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
    switch (event.event) {
      case "thread.created":
        break;
      case "thread.run.created":
      case "thread.run.queued":
      case "thread.run.in_progress":
      case "thread.run.requires_action":
      case "thread.run.completed":
      case "thread.run.failed":
      case "thread.run.cancelling":
      case "thread.run.cancelled":
      case "thread.run.expired":
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
        break;
      case "thread.run.step.created":
      case "thread.run.step.in_progress":
      case "thread.run.step.delta":
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
        break;
      case "thread.message.created":
      case "thread.message.in_progress":
      case "thread.message.delta":
      case "thread.message.completed":
      case "thread.message.incomplete":
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
        break;
      case "error":
        throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    }
  }, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run has not been received");
    return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
  }, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
    const [accumulatedMessage, newContent] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
    __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
    __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
    for (const content of newContent) {
      const snapshotContent = accumulatedMessage.content[content.index];
      if ((snapshotContent == null ? void 0 : snapshotContent.type) == "text") {
        this._emit("textCreated", snapshotContent.text);
      }
    }
    switch (event.event) {
      case "thread.message.created":
        this._emit("messageCreated", event.data);
        break;
      case "thread.message.in_progress":
        break;
      case "thread.message.delta":
        this._emit("messageDelta", event.data.delta, accumulatedMessage);
        if (event.data.delta.content) {
          for (const content of event.data.delta.content) {
            if (content.type == "text" && content.text) {
              let textDelta = content.text;
              let snapshot = accumulatedMessage.content[content.index];
              if (snapshot && snapshot.type == "text") {
                this._emit("textDelta", textDelta, snapshot.text);
              } else {
                throw Error("The snapshot associated with this text delta is not text or missing");
              }
            }
            if (content.index != __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")) {
              if (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f")) {
                switch (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f").type) {
                  case "text":
                    this._emit("textDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                    break;
                  case "image_file":
                    this._emit("imageFileDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                    break;
                }
              }
              __classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index, "f");
            }
            __classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
          }
        }
        break;
      case "thread.message.completed":
      case "thread.message.incomplete":
        if (__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
          const currentContent = event.data.content[__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")];
          if (currentContent) {
            switch (currentContent.type) {
              case "image_file":
                this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                break;
              case "text":
                this._emit("textDone", currentContent.text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                break;
            }
          }
        }
        if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f")) {
          this._emit("messageDone", event.data);
        }
        __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, void 0, "f");
    }
  }, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
    const accumulatedRunStep = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
    __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
    switch (event.event) {
      case "thread.run.step.created":
        this._emit("runStepCreated", event.data);
        break;
      case "thread.run.step.delta":
        const delta = event.data.delta;
        if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
          for (const toolCall of delta.step_details.tool_calls) {
            if (toolCall.index == __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, "f")) {
              this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
            } else {
              if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
                this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
              }
              __classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
              __classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
              if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"))
                this._emit("toolCallCreated", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
            }
          }
        }
        this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
        break;
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
        const details = event.data.step_details;
        if (details.type == "tool_calls") {
          if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
            this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
            __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, "f");
          }
        }
        this._emit("runStepDone", event.data, accumulatedRunStep);
        break;
    }
  }, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
    __classPrivateFieldGet(this, _AssistantStream_events, "f").push(event);
    this._emit("event", event);
  }, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
    switch (event.event) {
      case "thread.run.step.created":
        __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
        return event.data;
      case "thread.run.step.delta":
        let snapshot = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
        if (!snapshot) {
          throw Error("Received a RunStepDelta before creation of a snapshot");
        }
        let data = event.data;
        if (data.delta) {
          const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);
          __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
        }
        return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
      case "thread.run.step.in_progress":
        __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
        break;
    }
    if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
      return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    throw new Error("No snapshot available");
  }, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
    let newContent = [];
    switch (event.event) {
      case "thread.message.created":
        return [event.data, newContent];
      case "thread.message.delta":
        if (!snapshot) {
          throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
        }
        let data = event.data;
        if (data.delta.content) {
          for (const contentElement of data.delta.content) {
            if (contentElement.index in snapshot.content) {
              let currentContent = snapshot.content[contentElement.index];
              snapshot.content[contentElement.index] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
            } else {
              snapshot.content[contentElement.index] = contentElement;
              newContent.push(contentElement);
            }
          }
        }
        return [snapshot, newContent];
      case "thread.message.in_progress":
      case "thread.message.completed":
      case "thread.message.incomplete":
        if (snapshot) {
          return [snapshot, newContent];
        } else {
          throw Error("Received thread message event with no existing snapshot");
        }
    }
    throw Error("Tried to accumulate a non-message event");
  }, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
    return AssistantStream.accumulateDelta(currentContent, contentElement);
  }, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
    __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data, "f");
    switch (event.event) {
      case "thread.run.created":
        break;
      case "thread.run.queued":
        break;
      case "thread.run.in_progress":
        break;
      case "thread.run.requires_action":
      case "thread.run.cancelled":
      case "thread.run.failed":
      case "thread.run.completed":
      case "thread.run.expired":
        __classPrivateFieldSet(this, _AssistantStream_finalRun, event.data, "f");
        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, "f");
        }
        break;
    }
  };
  class Messages extends APIResource {
    /**
     * Create a message.
     */
    create(threadId, body, options) {
      return this._client.post(`/threads/${threadId}/messages`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieve a message.
     */
    retrieve(threadId, messageId, options) {
      return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies a message.
     */
    update(threadId, messageId, body, options) {
      return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(threadId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list(threadId, {}, query);
      }
      return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Deletes a message.
     */
    del(threadId, messageId, options) {
      return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  }
  class MessagesPage extends CursorPage {
  }
  (function(Messages2) {
    Messages2.MessagesPage = MessagesPage;
  })(Messages || (Messages = {}));
  class Steps extends APIResource {
    /**
     * Retrieves a run step.
     */
    retrieve(threadId, runId, stepId, options) {
      return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(threadId, runId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list(threadId, runId, {}, query);
      }
      return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  }
  class RunStepsPage extends CursorPage {
  }
  (function(Steps2) {
    Steps2.RunStepsPage = RunStepsPage;
  })(Steps || (Steps = {}));
  class Runs extends APIResource {
    constructor() {
      super(...arguments);
      this.steps = new Steps(this._client);
    }
    create(threadId, body, options) {
      return this._client.post(`/threads/${threadId}/runs`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
        stream: body.stream ?? false
      });
    }
    /**
     * Retrieves a run.
     */
    retrieve(threadId, runId, options) {
      return this._client.get(`/threads/${threadId}/runs/${runId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies a run.
     */
    update(threadId, runId, body, options) {
      return this._client.post(`/threads/${threadId}/runs/${runId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(threadId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list(threadId, {}, query);
      }
      return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Cancels a run that is `in_progress`.
     */
    cancel(threadId, runId, options) {
      return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * A helper to create a run an poll for a terminal state. More information on Run
     * lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    async createAndPoll(threadId, body, options) {
      const run = await this.create(threadId, body, options);
      return await this.poll(threadId, run.id, options);
    }
    /**
     * Create a Run stream
     *
     * @deprecated use `stream` instead
     */
    createAndStream(threadId, body, options) {
      return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
    }
    /**
     * A helper to poll a run status until it reaches a terminal state. More
     * information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    async poll(threadId, runId, options) {
      const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
      if (options == null ? void 0 : options.pollIntervalMs) {
        headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
      }
      while (true) {
        const { data: run, response } = await this.retrieve(threadId, runId, {
          ...options,
          headers: { ...options == null ? void 0 : options.headers, ...headers }
        }).withResponse();
        switch (run.status) {
          case "queued":
          case "in_progress":
          case "cancelling":
            let sleepInterval = 5e3;
            if (options == null ? void 0 : options.pollIntervalMs) {
              sleepInterval = options.pollIntervalMs;
            } else {
              const headerInterval = response.headers.get("openai-poll-after-ms");
              if (headerInterval) {
                const headerIntervalMs = parseInt(headerInterval);
                if (!isNaN(headerIntervalMs)) {
                  sleepInterval = headerIntervalMs;
                }
              }
            }
            await sleep$1(sleepInterval);
            break;
          case "requires_action":
          case "incomplete":
          case "cancelled":
          case "completed":
          case "failed":
          case "expired":
            return run;
        }
      }
    }
    /**
     * Create a Run stream
     */
    stream(threadId, body, options) {
      return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
    }
    submitToolOutputs(threadId, runId, body, options) {
      return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
        stream: body.stream ?? false
      });
    }
    /**
     * A helper to submit a tool output to a run and poll for a terminal run state.
     * More information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    async submitToolOutputsAndPoll(threadId, runId, body, options) {
      const run = await this.submitToolOutputs(threadId, runId, body, options);
      return await this.poll(threadId, run.id, options);
    }
    /**
     * Submit the tool outputs from a previous run and stream the run to a terminal
     * state. More information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    submitToolOutputsStream(threadId, runId, body, options) {
      return AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);
    }
  }
  class RunsPage extends CursorPage {
  }
  (function(Runs2) {
    Runs2.RunsPage = RunsPage;
    Runs2.Steps = Steps;
    Runs2.RunStepsPage = RunStepsPage;
  })(Runs || (Runs = {}));
  class Threads extends APIResource {
    constructor() {
      super(...arguments);
      this.runs = new Runs(this._client);
      this.messages = new Messages(this._client);
    }
    create(body = {}, options) {
      if (isRequestOptions(body)) {
        return this.create({}, body);
      }
      return this._client.post("/threads", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves a thread.
     */
    retrieve(threadId, options) {
      return this._client.get(`/threads/${threadId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies a thread.
     */
    update(threadId, body, options) {
      return this._client.post(`/threads/${threadId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Delete a thread.
     */
    del(threadId, options) {
      return this._client.delete(`/threads/${threadId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    createAndRun(body, options) {
      return this._client.post("/threads/runs", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
        stream: body.stream ?? false
      });
    }
    /**
     * A helper to create a thread, start a run and then poll for a terminal state.
     * More information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    async createAndRunPoll(body, options) {
      const run = await this.createAndRun(body, options);
      return await this.runs.poll(run.thread_id, run.id, options);
    }
    /**
     * Create a thread and stream the run back
     */
    createAndRunStream(body, options) {
      return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
    }
  }
  (function(Threads2) {
    Threads2.Runs = Runs;
    Threads2.RunsPage = RunsPage;
    Threads2.Messages = Messages;
    Threads2.MessagesPage = MessagesPage;
  })(Threads || (Threads = {}));
  const allSettledWithThrow = async (promises) => {
    const results = await Promise.allSettled(promises);
    const rejected = results.filter((result) => result.status === "rejected");
    if (rejected.length) {
      for (const result of rejected) {
        console.error(result.reason);
      }
      throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
    }
    const values = [];
    for (const result of results) {
      if (result.status === "fulfilled") {
        values.push(result.value);
      }
    }
    return values;
  };
  let Files$1 = class Files extends APIResource {
    /**
     * Create a vector store file by attaching a
     * [File](https://platform.openai.com/docs/api-reference/files) to a
     * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
     */
    create(vectorStoreId, body, options) {
      return this._client.post(`/vector_stores/${vectorStoreId}/files`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves a vector store file.
     */
    retrieve(vectorStoreId, fileId, options) {
      return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(vectorStoreId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list(vectorStoreId, {}, query);
      }
      return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Delete a vector store file. This will remove the file from the vector store but
     * the file itself will not be deleted. To delete the file, use the
     * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
     * endpoint.
     */
    del(vectorStoreId, fileId, options) {
      return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Attach a file to the given vector store and wait for it to be processed.
     */
    async createAndPoll(vectorStoreId, body, options) {
      const file = await this.create(vectorStoreId, body, options);
      return await this.poll(vectorStoreId, file.id, options);
    }
    /**
     * Wait for the vector store file to finish processing.
     *
     * Note: this will return even if the file failed to process, you need to check
     * file.last_error and file.status to handle these cases
     */
    async poll(vectorStoreId, fileId, options) {
      const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
      if (options == null ? void 0 : options.pollIntervalMs) {
        headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
      }
      while (true) {
        const fileResponse = await this.retrieve(vectorStoreId, fileId, {
          ...options,
          headers
        }).withResponse();
        const file = fileResponse.data;
        switch (file.status) {
          case "in_progress":
            let sleepInterval = 5e3;
            if (options == null ? void 0 : options.pollIntervalMs) {
              sleepInterval = options.pollIntervalMs;
            } else {
              const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
              if (headerInterval) {
                const headerIntervalMs = parseInt(headerInterval);
                if (!isNaN(headerIntervalMs)) {
                  sleepInterval = headerIntervalMs;
                }
              }
            }
            await sleep$1(sleepInterval);
            break;
          case "failed":
          case "completed":
            return file;
        }
      }
    }
    /**
     * Upload a file to the `files` API and then attach it to the given vector store.
     *
     * Note the file will be asynchronously processed (you can use the alternative
     * polling helper method to wait for processing to complete).
     */
    async upload(vectorStoreId, file, options) {
      const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options);
      return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
    }
    /**
     * Add a file to a vector store and poll until processing is complete.
     */
    async uploadAndPoll(vectorStoreId, file, options) {
      const fileInfo = await this.upload(vectorStoreId, file, options);
      return await this.poll(vectorStoreId, fileInfo.id, options);
    }
  };
  class VectorStoreFilesPage extends CursorPage {
  }
  (function(Files2) {
    Files2.VectorStoreFilesPage = VectorStoreFilesPage;
  })(Files$1 || (Files$1 = {}));
  class FileBatches extends APIResource {
    /**
     * Create a vector store file batch.
     */
    create(vectorStoreId, body, options) {
      return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves a vector store file batch.
     */
    retrieve(vectorStoreId, batchId, options) {
      return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Cancel a vector store file batch. This attempts to cancel the processing of
     * files in this batch as soon as possible.
     */
    cancel(vectorStoreId, batchId, options) {
      return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Create a vector store batch and poll until all files have been processed.
     */
    async createAndPoll(vectorStoreId, body, options) {
      const batch = await this.create(vectorStoreId, body);
      return await this.poll(vectorStoreId, batch.id, options);
    }
    listFiles(vectorStoreId, batchId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.listFiles(vectorStoreId, batchId, {}, query);
      }
      return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, VectorStoreFilesPage, { query, ...options, headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers } });
    }
    /**
     * Wait for the given file batch to be processed.
     *
     * Note: this will return even if one of the files failed to process, you need to
     * check batch.file_counts.failed_count to handle this case.
     */
    async poll(vectorStoreId, batchId, options) {
      const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
      if (options == null ? void 0 : options.pollIntervalMs) {
        headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
      }
      while (true) {
        const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {
          ...options,
          headers
        }).withResponse();
        switch (batch.status) {
          case "in_progress":
            let sleepInterval = 5e3;
            if (options == null ? void 0 : options.pollIntervalMs) {
              sleepInterval = options.pollIntervalMs;
            } else {
              const headerInterval = response.headers.get("openai-poll-after-ms");
              if (headerInterval) {
                const headerIntervalMs = parseInt(headerInterval);
                if (!isNaN(headerIntervalMs)) {
                  sleepInterval = headerIntervalMs;
                }
              }
            }
            await sleep$1(sleepInterval);
            break;
          case "failed":
          case "cancelled":
          case "completed":
            return batch;
        }
      }
    }
    /**
     * Uploads the given files concurrently and then creates a vector store file batch.
     *
     * The concurrency limit is configurable using the `maxConcurrency` parameter.
     */
    async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
      if (files == null || files.length == 0) {
        throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
      }
      const configuredConcurrency = (options == null ? void 0 : options.maxConcurrency) ?? 5;
      const concurrencyLimit = Math.min(configuredConcurrency, files.length);
      const client = this._client;
      const fileIterator = files.values();
      const allFileIds = [...fileIds];
      async function processFiles(iterator2) {
        for (let item of iterator2) {
          const fileObj = await client.files.create({ file: item, purpose: "assistants" }, options);
          allFileIds.push(fileObj.id);
        }
      }
      const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
      await allSettledWithThrow(workers);
      return await this.createAndPoll(vectorStoreId, {
        file_ids: allFileIds
      });
    }
  }
  /* @__PURE__ */ (function(FileBatches2) {
  })(FileBatches || (FileBatches = {}));
  class VectorStores extends APIResource {
    constructor() {
      super(...arguments);
      this.files = new Files$1(this._client);
      this.fileBatches = new FileBatches(this._client);
    }
    /**
     * Create a vector store.
     */
    create(body, options) {
      return this._client.post("/vector_stores", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves a vector store.
     */
    retrieve(vectorStoreId, options) {
      return this._client.get(`/vector_stores/${vectorStoreId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies a vector store.
     */
    update(vectorStoreId, body, options) {
      return this._client.post(`/vector_stores/${vectorStoreId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/vector_stores", VectorStoresPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Delete a vector store.
     */
    del(vectorStoreId, options) {
      return this._client.delete(`/vector_stores/${vectorStoreId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  }
  class VectorStoresPage extends CursorPage {
  }
  (function(VectorStores2) {
    VectorStores2.VectorStoresPage = VectorStoresPage;
    VectorStores2.Files = Files$1;
    VectorStores2.VectorStoreFilesPage = VectorStoreFilesPage;
    VectorStores2.FileBatches = FileBatches;
  })(VectorStores || (VectorStores = {}));
  class Beta extends APIResource {
    constructor() {
      super(...arguments);
      this.vectorStores = new VectorStores(this._client);
      this.chat = new Chat(this._client);
      this.assistants = new Assistants(this._client);
      this.threads = new Threads(this._client);
    }
  }
  (function(Beta2) {
    Beta2.VectorStores = VectorStores;
    Beta2.VectorStoresPage = VectorStoresPage;
    Beta2.Chat = Chat;
    Beta2.Assistants = Assistants;
    Beta2.AssistantsPage = AssistantsPage;
    Beta2.Threads = Threads;
  })(Beta || (Beta = {}));
  class Completions extends APIResource {
    create(body, options) {
      return this._client.post("/completions", { body, ...options, stream: body.stream ?? false });
    }
  }
  /* @__PURE__ */ (function(Completions2) {
  })(Completions || (Completions = {}));
  class Embeddings extends APIResource {
    /**
     * Creates an embedding vector representing the input text.
     */
    create(body, options) {
      return this._client.post("/embeddings", { body, ...options });
    }
  }
  /* @__PURE__ */ (function(Embeddings2) {
  })(Embeddings || (Embeddings = {}));
  class Files extends APIResource {
    /**
     * Upload a file that can be used across various endpoints. Individual files can be
     * up to 512 MB, and the size of all files uploaded by one organization can be up
     * to 100 GB.
     *
     * The Assistants API supports files up to 2 million tokens and of specific file
     * types. See the
     * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
     * details.
     *
     * The Fine-tuning API only supports `.jsonl` files. The input also has certain
     * required formats for fine-tuning
     * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
     * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
     * models.
     *
     * The Batch API only supports `.jsonl` files up to 100 MB in size. The input also
     * has a specific required
     * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
     *
     * Please [contact us](https://help.openai.com/) if you need to increase these
     * storage limits.
     */
    create(body, options) {
      return this._client.post("/files", multipartFormRequestOptions({ body, ...options }));
    }
    /**
     * Returns information about a specific file.
     */
    retrieve(fileId, options) {
      return this._client.get(`/files/${fileId}`, options);
    }
    list(query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/files", FileObjectsPage, { query, ...options });
    }
    /**
     * Delete a file.
     */
    del(fileId, options) {
      return this._client.delete(`/files/${fileId}`, options);
    }
    /**
     * Returns the contents of the specified file.
     */
    content(fileId, options) {
      return this._client.get(`/files/${fileId}/content`, { ...options, __binaryResponse: true });
    }
    /**
     * Returns the contents of the specified file.
     *
     * @deprecated The `.content()` method should be used instead
     */
    retrieveContent(fileId, options) {
      return this._client.get(`/files/${fileId}/content`, {
        ...options,
        headers: { Accept: "application/json", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Waits for the given file to be processed, default timeout is 30 mins.
     */
    async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
      const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
      const start = Date.now();
      let file = await this.retrieve(id);
      while (!file.status || !TERMINAL_STATES.has(file.status)) {
        await sleep$1(pollInterval);
        file = await this.retrieve(id);
        if (Date.now() - start > maxWait) {
          throw new APIConnectionTimeoutError({
            message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
          });
        }
      }
      return file;
    }
  }
  class FileObjectsPage extends Page {
  }
  (function(Files2) {
    Files2.FileObjectsPage = FileObjectsPage;
  })(Files || (Files = {}));
  class Checkpoints extends APIResource {
    list(fineTuningJobId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list(fineTuningJobId, {}, query);
      }
      return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage, { query, ...options });
    }
  }
  class FineTuningJobCheckpointsPage extends CursorPage {
  }
  (function(Checkpoints2) {
    Checkpoints2.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;
  })(Checkpoints || (Checkpoints = {}));
  class Jobs extends APIResource {
    constructor() {
      super(...arguments);
      this.checkpoints = new Checkpoints(this._client);
    }
    /**
     * Creates a fine-tuning job which begins the process of creating a new model from
     * a given dataset.
     *
     * Response includes details of the enqueued job including job status and the name
     * of the fine-tuned models once complete.
     *
     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
     */
    create(body, options) {
      return this._client.post("/fine_tuning/jobs", { body, ...options });
    }
    /**
     * Get info about a fine-tuning job.
     *
     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
     */
    retrieve(fineTuningJobId, options) {
      return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
    }
    list(query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options });
    }
    /**
     * Immediately cancel a fine-tune job.
     */
    cancel(fineTuningJobId, options) {
      return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
    }
    listEvents(fineTuningJobId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.listEvents(fineTuningJobId, {}, query);
      }
      return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
        query,
        ...options
      });
    }
  }
  class FineTuningJobsPage extends CursorPage {
  }
  class FineTuningJobEventsPage extends CursorPage {
  }
  (function(Jobs2) {
    Jobs2.FineTuningJobsPage = FineTuningJobsPage;
    Jobs2.FineTuningJobEventsPage = FineTuningJobEventsPage;
    Jobs2.Checkpoints = Checkpoints;
    Jobs2.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;
  })(Jobs || (Jobs = {}));
  class FineTuning extends APIResource {
    constructor() {
      super(...arguments);
      this.jobs = new Jobs(this._client);
    }
  }
  (function(FineTuning2) {
    FineTuning2.Jobs = Jobs;
    FineTuning2.FineTuningJobsPage = FineTuningJobsPage;
    FineTuning2.FineTuningJobEventsPage = FineTuningJobEventsPage;
  })(FineTuning || (FineTuning = {}));
  class Images extends APIResource {
    /**
     * Creates a variation of a given image.
     */
    createVariation(body, options) {
      return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options }));
    }
    /**
     * Creates an edited or extended image given an original image and a prompt.
     */
    edit(body, options) {
      return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options }));
    }
    /**
     * Creates an image given a prompt.
     */
    generate(body, options) {
      return this._client.post("/images/generations", { body, ...options });
    }
  }
  /* @__PURE__ */ (function(Images2) {
  })(Images || (Images = {}));
  class Models extends APIResource {
    /**
     * Retrieves a model instance, providing basic information about the model such as
     * the owner and permissioning.
     */
    retrieve(model, options) {
      return this._client.get(`/models/${model}`, options);
    }
    /**
     * Lists the currently available models, and provides basic information about each
     * one such as the owner and availability.
     */
    list(options) {
      return this._client.getAPIList("/models", ModelsPage, options);
    }
    /**
     * Delete a fine-tuned model. You must have the Owner role in your organization to
     * delete a model.
     */
    del(model, options) {
      return this._client.delete(`/models/${model}`, options);
    }
  }
  class ModelsPage extends Page {
  }
  (function(Models2) {
    Models2.ModelsPage = ModelsPage;
  })(Models || (Models = {}));
  class Moderations extends APIResource {
    /**
     * Classifies if text is potentially harmful.
     */
    create(body, options) {
      return this._client.post("/moderations", { body, ...options });
    }
  }
  /* @__PURE__ */ (function(Moderations2) {
  })(Moderations || (Moderations = {}));
  class Parts extends APIResource {
    /**
     * Adds a
     * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
     * A Part represents a chunk of bytes from the file you are trying to upload.
     *
     * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
     * maximum of 8 GB.
     *
     * It is possible to add multiple Parts in parallel. You can decide the intended
     * order of the Parts when you
     * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
     */
    create(uploadId, body, options) {
      return this._client.post(`/uploads/${uploadId}/parts`, multipartFormRequestOptions({ body, ...options }));
    }
  }
  /* @__PURE__ */ (function(Parts2) {
  })(Parts || (Parts = {}));
  class Uploads extends APIResource {
    constructor() {
      super(...arguments);
      this.parts = new Parts(this._client);
    }
    /**
     * Creates an intermediate
     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
     * that you can add
     * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
     * Currently, an Upload can accept at most 8 GB in total and expires after an hour
     * after you create it.
     *
     * Once you complete the Upload, we will create a
     * [File](https://platform.openai.com/docs/api-reference/files/object) object that
     * contains all the parts you uploaded. This File is usable in the rest of our
     * platform as a regular File object.
     *
     * For certain `purpose`s, the correct `mime_type` must be specified. Please refer
     * to documentation for the supported MIME types for your use case:
     *
     * - [Assistants](https://platform.openai.com/docs/assistants/tools/file-search/supported-files)
     *
     * For guidance on the proper filename extensions for each purpose, please follow
     * the documentation on
     * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
     */
    create(body, options) {
      return this._client.post("/uploads", { body, ...options });
    }
    /**
     * Cancels the Upload. No Parts may be added after an Upload is cancelled.
     */
    cancel(uploadId, options) {
      return this._client.post(`/uploads/${uploadId}/cancel`, options);
    }
    /**
     * Completes the
     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
     *
     * Within the returned Upload object, there is a nested
     * [File](https://platform.openai.com/docs/api-reference/files/object) object that
     * is ready to use in the rest of the platform.
     *
     * You can specify the order of the Parts by passing in an ordered list of the Part
     * IDs.
     *
     * The number of bytes uploaded upon completion must match the number of bytes
     * initially specified when creating the Upload object. No Parts may be added after
     * an Upload is completed.
     */
    complete(uploadId, body, options) {
      return this._client.post(`/uploads/${uploadId}/complete`, { body, ...options });
    }
  }
  (function(Uploads2) {
    Uploads2.Parts = Parts;
  })(Uploads || (Uploads = {}));
  var _a;
  class OpenAI extends APIClient {
    /**
     * API Client for interfacing with the OpenAI API.
     *
     * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
     * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
     * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
     * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
     */
    constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = readEnv("OPENAI_ORG_ID") ?? null, project = readEnv("OPENAI_PROJECT_ID") ?? null, ...opts } = {}) {
      if (apiKey === void 0) {
        throw new OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
      }
      const options = {
        apiKey,
        organization,
        project,
        ...opts,
        baseURL: baseURL || `https://api.openai.com/v1`
      };
      if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
        throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
      }
      super({
        baseURL: options.baseURL,
        timeout: options.timeout ?? 6e5,
        httpAgent: options.httpAgent,
        maxRetries: options.maxRetries,
        fetch: options.fetch
      });
      this.completions = new Completions(this);
      this.chat = new Chat$1(this);
      this.embeddings = new Embeddings(this);
      this.files = new Files(this);
      this.images = new Images(this);
      this.audio = new Audio(this);
      this.moderations = new Moderations(this);
      this.models = new Models(this);
      this.fineTuning = new FineTuning(this);
      this.beta = new Beta(this);
      this.batches = new Batches(this);
      this.uploads = new Uploads(this);
      this._options = options;
      this.apiKey = apiKey;
      this.organization = organization;
      this.project = project;
    }
    defaultQuery() {
      return this._options.defaultQuery;
    }
    defaultHeaders(opts) {
      return {
        ...super.defaultHeaders(opts),
        "OpenAI-Organization": this.organization,
        "OpenAI-Project": this.project,
        ...this._options.defaultHeaders
      };
    }
    authHeaders(opts) {
      return { Authorization: `Bearer ${this.apiKey}` };
    }
  }
  _a = OpenAI;
  OpenAI.OpenAI = _a;
  OpenAI.DEFAULT_TIMEOUT = 6e5;
  OpenAI.OpenAIError = OpenAIError;
  OpenAI.APIError = APIError;
  OpenAI.APIConnectionError = APIConnectionError;
  OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
  OpenAI.APIUserAbortError = APIUserAbortError;
  OpenAI.NotFoundError = NotFoundError;
  OpenAI.ConflictError = ConflictError;
  OpenAI.RateLimitError = RateLimitError;
  OpenAI.BadRequestError = BadRequestError;
  OpenAI.AuthenticationError = AuthenticationError;
  OpenAI.InternalServerError = InternalServerError;
  OpenAI.PermissionDeniedError = PermissionDeniedError;
  OpenAI.UnprocessableEntityError = UnprocessableEntityError;
  OpenAI.toFile = toFile;
  OpenAI.fileFromPath = fileFromPath;
  (function(OpenAI2) {
    OpenAI2.Page = Page;
    OpenAI2.CursorPage = CursorPage;
    OpenAI2.Completions = Completions;
    OpenAI2.Chat = Chat$1;
    OpenAI2.Embeddings = Embeddings;
    OpenAI2.Files = Files;
    OpenAI2.FileObjectsPage = FileObjectsPage;
    OpenAI2.Images = Images;
    OpenAI2.Audio = Audio;
    OpenAI2.Moderations = Moderations;
    OpenAI2.Models = Models;
    OpenAI2.ModelsPage = ModelsPage;
    OpenAI2.FineTuning = FineTuning;
    OpenAI2.Beta = Beta;
    OpenAI2.Batches = Batches;
    OpenAI2.BatchesPage = BatchesPage;
    OpenAI2.Uploads = Uploads;
  })(OpenAI || (OpenAI = {}));
  var isVue2 = false;
  /*!
   * pinia v2.2.4
   * (c) 2024 Eduardo San Martin Morote
   * @license MIT
   */
  let activePinia;
  const setActivePinia = (pinia) => activePinia = pinia;
  const piniaSymbol = (
    /* istanbul ignore next */
    Symbol()
  );
  function isPlainObject(o) {
    return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
  }
  var MutationType;
  (function(MutationType2) {
    MutationType2["direct"] = "direct";
    MutationType2["patchObject"] = "patch object";
    MutationType2["patchFunction"] = "patch function";
  })(MutationType || (MutationType = {}));
  function createPinia() {
    const scope = effectScope(true);
    const state = scope.run(() => ref({}));
    let _p = [];
    let toBeInstalled = [];
    const pinia = markRaw({
      install(app) {
        setActivePinia(pinia);
        {
          pinia._a = app;
          app.provide(piniaSymbol, pinia);
          app.config.globalProperties.$pinia = pinia;
          toBeInstalled.forEach((plugin) => _p.push(plugin));
          toBeInstalled = [];
        }
      },
      use(plugin) {
        if (!this._a && !isVue2) {
          toBeInstalled.push(plugin);
        } else {
          _p.push(plugin);
        }
        return this;
      },
      _p,
      // it's actually undefined here
      // @ts-expect-error
      _a: null,
      _e: scope,
      _s: /* @__PURE__ */ new Map(),
      state
    });
    return pinia;
  }
  const noop = () => {
  };
  function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
    subscriptions.push(callback);
    const removeSubscription = () => {
      const idx = subscriptions.indexOf(callback);
      if (idx > -1) {
        subscriptions.splice(idx, 1);
        onCleanup();
      }
    };
    if (!detached && getCurrentScope()) {
      onScopeDispose(removeSubscription);
    }
    return removeSubscription;
  }
  function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.slice().forEach((callback) => {
      callback(...args);
    });
  }
  const fallbackRunWithContext = (fn) => fn();
  const ACTION_MARKER = Symbol();
  const ACTION_NAME = Symbol();
  function mergeReactiveObjects(target, patchToApply) {
    if (target instanceof Map && patchToApply instanceof Map) {
      patchToApply.forEach((value, key) => target.set(key, value));
    } else if (target instanceof Set && patchToApply instanceof Set) {
      patchToApply.forEach(target.add, target);
    }
    for (const key in patchToApply) {
      if (!patchToApply.hasOwnProperty(key))
        continue;
      const subPatch = patchToApply[key];
      const targetValue = target[key];
      if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !isRef$1(subPatch) && !isReactive(subPatch)) {
        target[key] = mergeReactiveObjects(targetValue, subPatch);
      } else {
        target[key] = subPatch;
      }
    }
    return target;
  }
  const skipHydrateSymbol = (
    /* istanbul ignore next */
    Symbol()
  );
  function shouldHydrate(obj) {
    return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
  }
  const { assign } = Object;
  function isComputed(o) {
    return !!(isRef$1(o) && o.effect);
  }
  function createOptionsStore(id, options, pinia, hot) {
    const { state, actions, getters } = options;
    const initialState = pinia.state.value[id];
    let store;
    function setup() {
      if (!initialState && true) {
        {
          pinia.state.value[id] = state ? state() : {};
        }
      }
      const localState = toRefs(pinia.state.value[id]);
      return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
        computedGetters[name] = markRaw(computed(() => {
          setActivePinia(pinia);
          const store2 = pinia._s.get(id);
          return getters[name].call(store2, store2);
        }));
        return computedGetters;
      }, {}));
    }
    store = createSetupStore(id, setup, options, pinia, hot, true);
    return store;
  }
  function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign({ actions: {} }, options);
    const $subscribeOptions = { deep: true };
    let isListening;
    let isSyncListening;
    let subscriptions = [];
    let actionSubscriptions = [];
    let debuggerEvents;
    const initialState = pinia.state.value[$id];
    if (!isOptionsStore && !initialState && true) {
      {
        pinia.state.value[$id] = {};
      }
    }
    ref({});
    let activeListener;
    function $patch(partialStateOrMutator) {
      let subscriptionMutation;
      isListening = isSyncListening = false;
      if (typeof partialStateOrMutator === "function") {
        partialStateOrMutator(pinia.state.value[$id]);
        subscriptionMutation = {
          type: MutationType.patchFunction,
          storeId: $id,
          events: debuggerEvents
        };
      } else {
        mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
        subscriptionMutation = {
          type: MutationType.patchObject,
          payload: partialStateOrMutator,
          storeId: $id,
          events: debuggerEvents
        };
      }
      const myListenerId = activeListener = Symbol();
      nextTick().then(() => {
        if (activeListener === myListenerId) {
          isListening = true;
        }
      });
      isSyncListening = true;
      triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
    }
    const $reset = isOptionsStore ? function $reset2() {
      const { state } = options;
      const newState = state ? state() : {};
      this.$patch(($state) => {
        assign($state, newState);
      });
    } : (
      /* istanbul ignore next */
      noop
    );
    function $dispose() {
      scope.stop();
      subscriptions = [];
      actionSubscriptions = [];
      pinia._s.delete($id);
    }
    const action = (fn, name = "") => {
      if (ACTION_MARKER in fn) {
        fn[ACTION_NAME] = name;
        return fn;
      }
      const wrappedAction = function() {
        setActivePinia(pinia);
        const args = Array.from(arguments);
        const afterCallbackList = [];
        const onErrorCallbackList = [];
        function after(callback) {
          afterCallbackList.push(callback);
        }
        function onError(callback) {
          onErrorCallbackList.push(callback);
        }
        triggerSubscriptions(actionSubscriptions, {
          args,
          name: wrappedAction[ACTION_NAME],
          store,
          after,
          onError
        });
        let ret;
        try {
          ret = fn.apply(this && this.$id === $id ? this : store, args);
        } catch (error) {
          triggerSubscriptions(onErrorCallbackList, error);
          throw error;
        }
        if (ret instanceof Promise) {
          return ret.then((value) => {
            triggerSubscriptions(afterCallbackList, value);
            return value;
          }).catch((error) => {
            triggerSubscriptions(onErrorCallbackList, error);
            return Promise.reject(error);
          });
        }
        triggerSubscriptions(afterCallbackList, ret);
        return ret;
      };
      wrappedAction[ACTION_MARKER] = true;
      wrappedAction[ACTION_NAME] = name;
      return wrappedAction;
    };
    const partialStore = {
      _p: pinia,
      // _s: scope,
      $id,
      $onAction: addSubscription.bind(null, actionSubscriptions),
      $patch,
      $reset,
      $subscribe(callback, options2 = {}) {
        const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
        const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {
          if (options2.flush === "sync" ? isSyncListening : isListening) {
            callback({
              storeId: $id,
              type: MutationType.direct,
              events: debuggerEvents
            }, state);
          }
        }, assign({}, $subscribeOptions, options2)));
        return removeSubscription;
      },
      $dispose
    };
    const store = reactive(partialStore);
    pinia._s.set($id, store);
    const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
    const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(() => setup({ action }))));
    for (const key in setupStore) {
      const prop = setupStore[key];
      if (isRef$1(prop) && !isComputed(prop) || isReactive(prop)) {
        if (!isOptionsStore) {
          if (initialState && shouldHydrate(prop)) {
            if (isRef$1(prop)) {
              prop.value = initialState[key];
            } else {
              mergeReactiveObjects(prop, initialState[key]);
            }
          }
          {
            pinia.state.value[$id][key] = prop;
          }
        }
      } else if (typeof prop === "function") {
        const actionValue = action(prop, key);
        {
          setupStore[key] = actionValue;
        }
        optionsForPlugin.actions[key] = prop;
      } else ;
    }
    {
      assign(store, setupStore);
      assign(toRaw(store), setupStore);
    }
    Object.defineProperty(store, "$state", {
      get: () => pinia.state.value[$id],
      set: (state) => {
        $patch(($state) => {
          assign($state, state);
        });
      }
    });
    pinia._p.forEach((extender) => {
      {
        assign(store, scope.run(() => extender({
          store,
          app: pinia._a,
          pinia,
          options: optionsForPlugin
        })));
      }
    });
    if (initialState && isOptionsStore && options.hydrate) {
      options.hydrate(store.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store;
  }
  // @__NO_SIDE_EFFECTS__
  function defineStore(idOrOptions, setup, setupOptions) {
    let id;
    let options;
    const isSetupStore = typeof setup === "function";
    {
      id = idOrOptions;
      options = isSetupStore ? setupOptions : setup;
    }
    function useStore(pinia, hot) {
      const hasContext = hasInjectionContext();
      pinia = // in test mode, ignore the argument provided as we can always retrieve a
      // pinia instance with getActivePinia()
      pinia || (hasContext ? inject(piniaSymbol, null) : null);
      if (pinia)
        setActivePinia(pinia);
      pinia = activePinia;
      if (!pinia._s.has(id)) {
        if (isSetupStore) {
          createSetupStore(id, setup, options, pinia);
        } else {
          createOptionsStore(id, options, pinia);
        }
      }
      const store = pinia._s.get(id);
      return store;
    }
    useStore.$id = id;
    return useStore;
  }
  function isPromise(obj) {
    return obj && typeof obj.then === "function";
  }
  Promise.resolve(false);
  Promise.resolve(true);
  var PROMISE_RESOLVED_VOID = Promise.resolve();
  function sleep(time, resolveWith) {
    if (!time) time = 0;
    return new Promise(function(res) {
      return setTimeout(function() {
        return res(resolveWith);
      }, time);
    });
  }
  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
  }
  function randomToken() {
    return Math.random().toString(36).substring(2);
  }
  var lastMs = 0;
  function microSeconds$4() {
    var ret = Date.now() * 1e3;
    if (ret <= lastMs) {
      ret = lastMs + 1;
    }
    lastMs = ret;
    return ret;
  }
  var microSeconds$3 = microSeconds$4;
  var type$3 = "native";
  function create$3(channelName) {
    var state = {
      time: microSeconds$4(),
      messagesCallback: null,
      bc: new BroadcastChannel(channelName),
      subFns: []
      // subscriberFunctions
    };
    state.bc.onmessage = function(msgEvent) {
      if (state.messagesCallback) {
        state.messagesCallback(msgEvent.data);
      }
    };
    return state;
  }
  function close$3(channelState) {
    channelState.bc.close();
    channelState.subFns = [];
  }
  function postMessage$3(channelState, messageJson) {
    try {
      channelState.bc.postMessage(messageJson, false);
      return PROMISE_RESOLVED_VOID;
    } catch (err) {
      return Promise.reject(err);
    }
  }
  function onMessage$3(channelState, fn) {
    channelState.messagesCallback = fn;
  }
  function canBeUsed$3() {
    if (typeof globalThis !== "undefined" && globalThis.Deno && globalThis.Deno.args) {
      return true;
    }
    if ((typeof window !== "undefined" || typeof self !== "undefined") && typeof BroadcastChannel === "function") {
      if (BroadcastChannel._pubkey) {
        throw new Error("BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill");
      }
      return true;
    } else {
      return false;
    }
  }
  function averageResponseTime$3() {
    return 150;
  }
  var NativeMethod = {
    create: create$3,
    close: close$3,
    onMessage: onMessage$3,
    postMessage: postMessage$3,
    canBeUsed: canBeUsed$3,
    type: type$3,
    averageResponseTime: averageResponseTime$3,
    microSeconds: microSeconds$3
  };
  class ObliviousSet {
    constructor(ttl) {
      __publicField(this, "ttl");
      __publicField(this, "map", /* @__PURE__ */ new Map());
      /**
       * Creating calls to setTimeout() is expensive,
       * so we only do that if there is not timeout already open.
       */
      __publicField(this, "_to", false);
      this.ttl = ttl;
    }
    has(value) {
      return this.map.has(value);
    }
    add(value) {
      this.map.set(value, now());
      if (!this._to) {
        this._to = true;
        setTimeout(() => {
          this._to = false;
          removeTooOldValues(this);
        }, 0);
      }
    }
    clear() {
      this.map.clear();
    }
  }
  function removeTooOldValues(obliviousSet) {
    const olderThen = now() - obliviousSet.ttl;
    const iterator2 = obliviousSet.map[Symbol.iterator]();
    while (true) {
      const next = iterator2.next().value;
      if (!next) {
        return;
      }
      const value = next[0];
      const time = next[1];
      if (time < olderThen) {
        obliviousSet.map.delete(value);
      } else {
        return;
      }
    }
  }
  function now() {
    return Date.now();
  }
  function fillOptionsWithDefaults() {
    var originalOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var options = JSON.parse(JSON.stringify(originalOptions));
    if (typeof options.webWorkerSupport === "undefined") options.webWorkerSupport = true;
    if (!options.idb) options.idb = {};
    if (!options.idb.ttl) options.idb.ttl = 1e3 * 45;
    if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;
    if (originalOptions.idb && typeof originalOptions.idb.onclose === "function") options.idb.onclose = originalOptions.idb.onclose;
    if (!options.localstorage) options.localstorage = {};
    if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1e3 * 60;
    if (originalOptions.methods) options.methods = originalOptions.methods;
    if (!options.node) options.node = {};
    if (!options.node.ttl) options.node.ttl = 1e3 * 60 * 2;
    if (!options.node.maxParallelWrites) options.node.maxParallelWrites = 2048;
    if (typeof options.node.useFastPath === "undefined") options.node.useFastPath = true;
    return options;
  }
  var microSeconds$2 = microSeconds$4;
  var DB_PREFIX = "pubkey.broadcast-channel-0-";
  var OBJECT_STORE_ID = "messages";
  var TRANSACTION_SETTINGS = {
    durability: "relaxed"
  };
  var type$2 = "idb";
  function getIdb() {
    if (typeof indexedDB !== "undefined") return indexedDB;
    if (typeof window !== "undefined") {
      if (typeof window.mozIndexedDB !== "undefined") return window.mozIndexedDB;
      if (typeof window.webkitIndexedDB !== "undefined") return window.webkitIndexedDB;
      if (typeof window.msIndexedDB !== "undefined") return window.msIndexedDB;
    }
    return false;
  }
  function commitIndexedDBTransaction(tx) {
    if (tx.commit) {
      tx.commit();
    }
  }
  function createDatabase(channelName) {
    var IndexedDB = getIdb();
    var dbName = DB_PREFIX + channelName;
    var openRequest = IndexedDB.open(dbName);
    openRequest.onupgradeneeded = function(ev) {
      var db = ev.target.result;
      db.createObjectStore(OBJECT_STORE_ID, {
        keyPath: "id",
        autoIncrement: true
      });
    };
    return new Promise(function(res, rej) {
      openRequest.onerror = function(ev) {
        return rej(ev);
      };
      openRequest.onsuccess = function() {
        res(openRequest.result);
      };
    });
  }
  function writeMessage(db, readerUuid, messageJson) {
    var time = Date.now();
    var writeObject = {
      uuid: readerUuid,
      time,
      data: messageJson
    };
    var tx = db.transaction([OBJECT_STORE_ID], "readwrite", TRANSACTION_SETTINGS);
    return new Promise(function(res, rej) {
      tx.oncomplete = function() {
        return res();
      };
      tx.onerror = function(ev) {
        return rej(ev);
      };
      var objectStore = tx.objectStore(OBJECT_STORE_ID);
      objectStore.add(writeObject);
      commitIndexedDBTransaction(tx);
    });
  }
  function getMessagesHigherThan(db, lastCursorId) {
    var tx = db.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
    var objectStore = tx.objectStore(OBJECT_STORE_ID);
    var ret = [];
    var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
    if (objectStore.getAll) {
      var getAllRequest = objectStore.getAll(keyRangeValue);
      return new Promise(function(res, rej) {
        getAllRequest.onerror = function(err) {
          return rej(err);
        };
        getAllRequest.onsuccess = function(e) {
          res(e.target.result);
        };
      });
    }
    function openCursor() {
      try {
        keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
        return objectStore.openCursor(keyRangeValue);
      } catch (e) {
        return objectStore.openCursor();
      }
    }
    return new Promise(function(res, rej) {
      var openCursorRequest = openCursor();
      openCursorRequest.onerror = function(err) {
        return rej(err);
      };
      openCursorRequest.onsuccess = function(ev) {
        var cursor = ev.target.result;
        if (cursor) {
          if (cursor.value.id < lastCursorId + 1) {
            cursor["continue"](lastCursorId + 1);
          } else {
            ret.push(cursor.value);
            cursor["continue"]();
          }
        } else {
          commitIndexedDBTransaction(tx);
          res(ret);
        }
      };
    });
  }
  function removeMessagesById(channelState, ids) {
    if (channelState.closed) {
      return Promise.resolve([]);
    }
    var tx = channelState.db.transaction(OBJECT_STORE_ID, "readwrite", TRANSACTION_SETTINGS);
    var objectStore = tx.objectStore(OBJECT_STORE_ID);
    return Promise.all(ids.map(function(id) {
      var deleteRequest = objectStore["delete"](id);
      return new Promise(function(res) {
        deleteRequest.onsuccess = function() {
          return res();
        };
      });
    }));
  }
  function getOldMessages(db, ttl) {
    var olderThen = Date.now() - ttl;
    var tx = db.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
    var objectStore = tx.objectStore(OBJECT_STORE_ID);
    var ret = [];
    return new Promise(function(res) {
      objectStore.openCursor().onsuccess = function(ev) {
        var cursor = ev.target.result;
        if (cursor) {
          var msgObk = cursor.value;
          if (msgObk.time < olderThen) {
            ret.push(msgObk);
            cursor["continue"]();
          } else {
            commitIndexedDBTransaction(tx);
            res(ret);
          }
        } else {
          res(ret);
        }
      };
    });
  }
  function cleanOldMessages(channelState) {
    return getOldMessages(channelState.db, channelState.options.idb.ttl).then(function(tooOld) {
      return removeMessagesById(channelState, tooOld.map(function(msg) {
        return msg.id;
      }));
    });
  }
  function create$2(channelName, options) {
    options = fillOptionsWithDefaults(options);
    return createDatabase(channelName).then(function(db) {
      var state = {
        closed: false,
        lastCursorId: 0,
        channelName,
        options,
        uuid: randomToken(),
        /**
         * emittedMessagesIds
         * contains all messages that have been emitted before
         * @type {ObliviousSet}
         */
        eMIs: new ObliviousSet(options.idb.ttl * 2),
        // ensures we do not read messages in parallel
        writeBlockPromise: PROMISE_RESOLVED_VOID,
        messagesCallback: null,
        readQueuePromises: [],
        db
      };
      db.onclose = function() {
        state.closed = true;
        if (options.idb.onclose) options.idb.onclose();
      };
      _readLoop(state);
      return state;
    });
  }
  function _readLoop(state) {
    if (state.closed) return;
    readNewMessages(state).then(function() {
      return sleep(state.options.idb.fallbackInterval);
    }).then(function() {
      return _readLoop(state);
    });
  }
  function _filterMessage(msgObj, state) {
    if (msgObj.uuid === state.uuid) return false;
    if (state.eMIs.has(msgObj.id)) return false;
    if (msgObj.data.time < state.messagesCallbackTime) return false;
    return true;
  }
  function readNewMessages(state) {
    if (state.closed) return PROMISE_RESOLVED_VOID;
    if (!state.messagesCallback) return PROMISE_RESOLVED_VOID;
    return getMessagesHigherThan(state.db, state.lastCursorId).then(function(newerMessages) {
      var useMessages = newerMessages.filter(function(msgObj) {
        return !!msgObj;
      }).map(function(msgObj) {
        if (msgObj.id > state.lastCursorId) {
          state.lastCursorId = msgObj.id;
        }
        return msgObj;
      }).filter(function(msgObj) {
        return _filterMessage(msgObj, state);
      }).sort(function(msgObjA, msgObjB) {
        return msgObjA.time - msgObjB.time;
      });
      useMessages.forEach(function(msgObj) {
        if (state.messagesCallback) {
          state.eMIs.add(msgObj.id);
          state.messagesCallback(msgObj.data);
        }
      });
      return PROMISE_RESOLVED_VOID;
    });
  }
  function close$2(channelState) {
    channelState.closed = true;
    channelState.db.close();
  }
  function postMessage$2(channelState, messageJson) {
    channelState.writeBlockPromise = channelState.writeBlockPromise.then(function() {
      return writeMessage(channelState.db, channelState.uuid, messageJson);
    }).then(function() {
      if (randomInt(0, 10) === 0) {
        cleanOldMessages(channelState);
      }
    });
    return channelState.writeBlockPromise;
  }
  function onMessage$2(channelState, fn, time) {
    channelState.messagesCallbackTime = time;
    channelState.messagesCallback = fn;
    readNewMessages(channelState);
  }
  function canBeUsed$2() {
    return !!getIdb();
  }
  function averageResponseTime$2(options) {
    return options.idb.fallbackInterval * 2;
  }
  var IndexedDBMethod = {
    create: create$2,
    close: close$2,
    onMessage: onMessage$2,
    postMessage: postMessage$2,
    canBeUsed: canBeUsed$2,
    type: type$2,
    averageResponseTime: averageResponseTime$2,
    microSeconds: microSeconds$2
  };
  var microSeconds$1 = microSeconds$4;
  var KEY_PREFIX = "pubkey.broadcastChannel-";
  var type$1 = "localstorage";
  function getLocalStorage() {
    var localStorage2;
    if (typeof window === "undefined") return null;
    try {
      localStorage2 = window.localStorage;
      localStorage2 = window["ie8-eventlistener/storage"] || window.localStorage;
    } catch (e) {
    }
    return localStorage2;
  }
  function storageKey(channelName) {
    return KEY_PREFIX + channelName;
  }
  function postMessage$1(channelState, messageJson) {
    return new Promise(function(res) {
      sleep().then(function() {
        var key = storageKey(channelState.channelName);
        var writeObj = {
          token: randomToken(),
          time: Date.now(),
          data: messageJson,
          uuid: channelState.uuid
        };
        var value = JSON.stringify(writeObj);
        getLocalStorage().setItem(key, value);
        var ev = document.createEvent("Event");
        ev.initEvent("storage", true, true);
        ev.key = key;
        ev.newValue = value;
        window.dispatchEvent(ev);
        res();
      });
    });
  }
  function addStorageEventListener(channelName, fn) {
    var key = storageKey(channelName);
    var listener = function listener2(ev) {
      if (ev.key === key) {
        fn(JSON.parse(ev.newValue));
      }
    };
    window.addEventListener("storage", listener);
    return listener;
  }
  function removeStorageEventListener(listener) {
    window.removeEventListener("storage", listener);
  }
  function create$1(channelName, options) {
    options = fillOptionsWithDefaults(options);
    if (!canBeUsed$1()) {
      throw new Error("BroadcastChannel: localstorage cannot be used");
    }
    var uuid = randomToken();
    var eMIs = new ObliviousSet(options.localstorage.removeTimeout);
    var state = {
      channelName,
      uuid,
      eMIs
      // emittedMessagesIds
    };
    state.listener = addStorageEventListener(channelName, function(msgObj) {
      if (!state.messagesCallback) return;
      if (msgObj.uuid === uuid) return;
      if (!msgObj.token || eMIs.has(msgObj.token)) return;
      if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return;
      eMIs.add(msgObj.token);
      state.messagesCallback(msgObj.data);
    });
    return state;
  }
  function close$1(channelState) {
    removeStorageEventListener(channelState.listener);
  }
  function onMessage$1(channelState, fn, time) {
    channelState.messagesCallbackTime = time;
    channelState.messagesCallback = fn;
  }
  function canBeUsed$1() {
    var ls = getLocalStorage();
    if (!ls) return false;
    try {
      var key = "__broadcastchannel_check";
      ls.setItem(key, "works");
      ls.removeItem(key);
    } catch (e) {
      return false;
    }
    return true;
  }
  function averageResponseTime$1() {
    var defaultTime = 120;
    var userAgent = navigator.userAgent.toLowerCase();
    if (userAgent.includes("safari") && !userAgent.includes("chrome")) {
      return defaultTime * 2;
    }
    return defaultTime;
  }
  var LocalstorageMethod = {
    create: create$1,
    close: close$1,
    onMessage: onMessage$1,
    postMessage: postMessage$1,
    canBeUsed: canBeUsed$1,
    type: type$1,
    averageResponseTime: averageResponseTime$1,
    microSeconds: microSeconds$1
  };
  var microSeconds = microSeconds$4;
  var type = "simulate";
  var SIMULATE_CHANNELS = /* @__PURE__ */ new Set();
  function create(channelName) {
    var state = {
      time: microSeconds(),
      name: channelName,
      messagesCallback: null
    };
    SIMULATE_CHANNELS.add(state);
    return state;
  }
  function close(channelState) {
    SIMULATE_CHANNELS["delete"](channelState);
  }
  var SIMULATE_DELAY_TIME = 5;
  function postMessage(channelState, messageJson) {
    return new Promise(function(res) {
      return setTimeout(function() {
        var channelArray = Array.from(SIMULATE_CHANNELS);
        channelArray.forEach(function(channel) {
          if (channel.name === channelState.name && // has same name
          channel !== channelState && // not own channel
          !!channel.messagesCallback && // has subscribers
          channel.time < messageJson.time) {
            channel.messagesCallback(messageJson);
          }
        });
        res();
      }, SIMULATE_DELAY_TIME);
    });
  }
  function onMessage(channelState, fn) {
    channelState.messagesCallback = fn;
  }
  function canBeUsed() {
    return true;
  }
  function averageResponseTime() {
    return SIMULATE_DELAY_TIME;
  }
  var SimulateMethod = {
    create,
    close,
    onMessage,
    postMessage,
    canBeUsed,
    type,
    averageResponseTime,
    microSeconds
  };
  var METHODS = [
    NativeMethod,
    // fastest
    IndexedDBMethod,
    LocalstorageMethod
  ];
  function chooseMethod(options) {
    var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);
    if (options.type) {
      if (options.type === "simulate") {
        return SimulateMethod;
      }
      var ret = chooseMethods.find(function(m) {
        return m.type === options.type;
      });
      if (!ret) throw new Error("method-type " + options.type + " not found");
      else return ret;
    }
    if (!options.webWorkerSupport) {
      chooseMethods = chooseMethods.filter(function(m) {
        return m.type !== "idb";
      });
    }
    var useMethod = chooseMethods.find(function(method) {
      return method.canBeUsed();
    });
    if (!useMethod) {
      throw new Error("No usable method found in " + JSON.stringify(METHODS.map(function(m) {
        return m.type;
      })));
    } else {
      return useMethod;
    }
  }
  var OPEN_BROADCAST_CHANNELS = /* @__PURE__ */ new Set();
  var lastId = 0;
  var BroadcastChannel$1 = function BroadcastChannel2(name, options) {
    this.id = lastId++;
    OPEN_BROADCAST_CHANNELS.add(this);
    this.name = name;
    if (ENFORCED_OPTIONS) {
      options = ENFORCED_OPTIONS;
    }
    this.options = fillOptionsWithDefaults(options);
    this.method = chooseMethod(this.options);
    this._iL = false;
    this._onML = null;
    this._addEL = {
      message: [],
      internal: []
    };
    this._uMP = /* @__PURE__ */ new Set();
    this._befC = [];
    this._prepP = null;
    _prepareChannel(this);
  };
  BroadcastChannel$1._pubkey = true;
  var ENFORCED_OPTIONS;
  BroadcastChannel$1.prototype = {
    postMessage: function postMessage2(msg) {
      if (this.closed) {
        throw new Error("BroadcastChannel.postMessage(): Cannot post message after channel has closed " + /**
         * In the past when this error appeared, it was really hard to debug.
         * So now we log the msg together with the error so it at least
         * gives some clue about where in your application this happens.
         */
        JSON.stringify(msg));
      }
      return _post(this, "message", msg);
    },
    postInternal: function postInternal(msg) {
      return _post(this, "internal", msg);
    },
    set onmessage(fn) {
      var time = this.method.microSeconds();
      var listenObj = {
        time,
        fn
      };
      _removeListenerObject(this, "message", this._onML);
      if (fn && typeof fn === "function") {
        this._onML = listenObj;
        _addListenerObject(this, "message", listenObj);
      } else {
        this._onML = null;
      }
    },
    addEventListener: function addEventListener2(type2, fn) {
      var time = this.method.microSeconds();
      var listenObj = {
        time,
        fn
      };
      _addListenerObject(this, type2, listenObj);
    },
    removeEventListener: function removeEventListener2(type2, fn) {
      var obj = this._addEL[type2].find(function(obj2) {
        return obj2.fn === fn;
      });
      _removeListenerObject(this, type2, obj);
    },
    close: function close2() {
      var _this = this;
      if (this.closed) {
        return;
      }
      OPEN_BROADCAST_CHANNELS["delete"](this);
      this.closed = true;
      var awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;
      this._onML = null;
      this._addEL.message = [];
      return awaitPrepare.then(function() {
        return Promise.all(Array.from(_this._uMP));
      }).then(function() {
        return Promise.all(_this._befC.map(function(fn) {
          return fn();
        }));
      }).then(function() {
        return _this.method.close(_this._state);
      });
    },
    get type() {
      return this.method.type;
    },
    get isClosed() {
      return this.closed;
    }
  };
  function _post(broadcastChannel, type2, msg) {
    var time = broadcastChannel.method.microSeconds();
    var msgObj = {
      time,
      type: type2,
      data: msg
    };
    var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;
    return awaitPrepare.then(function() {
      var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);
      broadcastChannel._uMP.add(sendPromise);
      sendPromise["catch"]().then(function() {
        return broadcastChannel._uMP["delete"](sendPromise);
      });
      return sendPromise;
    });
  }
  function _prepareChannel(channel) {
    var maybePromise = channel.method.create(channel.name, channel.options);
    if (isPromise(maybePromise)) {
      channel._prepP = maybePromise;
      maybePromise.then(function(s) {
        channel._state = s;
      });
    } else {
      channel._state = maybePromise;
    }
  }
  function _hasMessageListeners(channel) {
    if (channel._addEL.message.length > 0) return true;
    if (channel._addEL.internal.length > 0) return true;
    return false;
  }
  function _addListenerObject(channel, type2, obj) {
    channel._addEL[type2].push(obj);
    _startListening(channel);
  }
  function _removeListenerObject(channel, type2, obj) {
    channel._addEL[type2] = channel._addEL[type2].filter(function(o) {
      return o !== obj;
    });
    _stopListening(channel);
  }
  function _startListening(channel) {
    if (!channel._iL && _hasMessageListeners(channel)) {
      var listenerFn = function listenerFn2(msgObj) {
        channel._addEL[msgObj.type].forEach(function(listenerObject) {
          if (msgObj.time >= listenerObject.time) {
            listenerObject.fn(msgObj.data);
          }
        });
      };
      var time = channel.method.microSeconds();
      if (channel._prepP) {
        channel._prepP.then(function() {
          channel._iL = true;
          channel.method.onMessage(channel._state, listenerFn, time);
        });
      } else {
        channel._iL = true;
        channel.method.onMessage(channel._state, listenerFn, time);
      }
    }
  }
  function _stopListening(channel) {
    if (channel._iL && !_hasMessageListeners(channel)) {
      channel._iL = false;
      var time = channel.method.microSeconds();
      channel.method.onMessage(channel._state, null, time);
    }
  }
  function serialize(obj, serializer = { serialize: JSON.stringify, deserialize: JSON.parse }) {
    return serializer.deserialize(serializer.serialize(obj));
  }
  function stateHasKey(key, $state) {
    return Object.keys($state).includes(key);
  }
  function PiniaSharedState({
    enable = true,
    initialize = true,
    type: type2,
    serializer
  }) {
    return ({ store, options }) => {
      var _a2, _b, _c;
      const isEnabled = ((_a2 = options == null ? void 0 : options.share) == null ? void 0 : _a2.enable) ?? enable;
      const omittedKeys = ((_b = options == null ? void 0 : options.share) == null ? void 0 : _b.omit) ?? [];
      if (!isEnabled)
        return;
      const channel = new BroadcastChannel$1(store.$id, {
        type: type2
      });
      let timestamp = 0;
      let externalUpdate = false;
      const keysToUpdate = Object.keys(store.$state).filter((key) => !omittedKeys.includes(key) && stateHasKey(key, store.$state));
      channel.onmessage = (newState) => {
        if (newState === void 0) {
          channel.postMessage({
            timestamp,
            state: serialize(store.$state, serializer)
          });
          return;
        }
        if (newState.timestamp <= timestamp)
          return;
        externalUpdate = true;
        timestamp = Date.now();
        store.$patch((state) => {
          keysToUpdate.forEach((key) => {
            state[key] = newState.state[key];
          });
        });
      };
      const shouldInitialize = ((_c = options == null ? void 0 : options.share) == null ? void 0 : _c.initialize) ?? initialize;
      if (shouldInitialize)
        channel.postMessage(void 0);
      store.$subscribe((_, state) => {
        if (!externalUpdate) {
          timestamp = Date.now();
          channel.postMessage({
            timestamp,
            state: serialize(state, serializer)
          });
        }
        externalUpdate = false;
      });
    };
  }
  const AI_CLIENT_PROVIDER = Symbol("client");
  const configureAppWithProviders = ({ client, systemPrompt }) => (app) => {
    const pinia = createPinia();
    pinia.use(PiniaSharedState({ enable: true, initialize: false, type: "localstorage" }));
    app.use(pinia).provide(AI_CLIENT_PROVIDER, {
      client,
      systemPrompt
    });
  };
  function useAI() {
    return inject(AI_CLIENT_PROVIDER);
  }
  const useChatboxStore = /* @__PURE__ */ defineStore("chatbox", {
    state: () => ({
      models: [],
      selectedModel: "",
      systemPrompt: "",
      userMessages: [],
      newMessage: "",
      maxTokens: 5e3,
      chatHistory: JSON.parse(localStorage.getItem("chatHistory") || "[]").map((chat) => ({
        ...chat,
        timestamp: new Date(chat.timestamp)
      })),
      currentChatId: localStorage.getItem("currentChatId") || ""
    }),
    actions: {
      setSystemPrompt(prompt) {
        this.systemPrompt = prompt;
      },
      setModels(models) {
        this.models = models;
      },
      setSelectedModel(model) {
        this.selectedModel = model;
      },
      setUserMessages(messages) {
        this.userMessages = [...messages];
        this.saveToStorage();
      },
      addMessage(message) {
        this.userMessages.push(message);
        if (!this.currentChatId && message.role === "user") {
          const id = crypto.randomUUID();
          this.currentChatId = id;
          this.chatHistory.unshift({
            id,
            title: message.content.slice(0, 50) + (message.content.length > 50 ? "..." : ""),
            timestamp: /* @__PURE__ */ new Date(),
            messages: [message]
          });
        } else if (this.currentChatId) {
          const chatIndex = this.chatHistory.findIndex((chat) => chat.id === this.currentChatId);
          if (chatIndex !== -1) {
            this.chatHistory[chatIndex] = {
              ...this.chatHistory[chatIndex],
              messages: [...this.userMessages],
              timestamp: /* @__PURE__ */ new Date()
            };
          }
        }
        this.saveToStorage();
      },
      saveToStorage() {
        localStorage.setItem("chatHistory", JSON.stringify(this.chatHistory));
        localStorage.setItem("currentChatId", this.currentChatId);
      },
      clearMessages() {
        this.userMessages = [];
        this.currentChatId = "";
        this.saveToStorage();
      },
      loadChat(chatId) {
        const chat = this.chatHistory.find((c) => c.id === chatId);
        if (chat) {
          this.currentChatId = chatId;
          this.userMessages = [...chat.messages];
          this.saveToStorage();
        }
      },
      startNewChat() {
        this.clearMessages();
        this.clearNewMessage();
      },
      clearNewMessage() {
        this.newMessage = "";
      }
    },
    getters: {
      messages() {
        if (this.systemPrompt) {
          return [{ role: "system", content: this.systemPrompt }, ...this.userMessages];
        }
        return this.userMessages;
      }
    }
  });
  function _getDefaults() {
    return {
      async: false,
      breaks: false,
      extensions: null,
      gfm: true,
      hooks: null,
      pedantic: false,
      renderer: null,
      silent: false,
      tokenizer: null,
      walkTokens: null
    };
  }
  let _defaults = _getDefaults();
  function changeDefaults(newDefaults) {
    _defaults = newDefaults;
  }
  const escapeTest = /[&<>"']/;
  const escapeReplace = new RegExp(escapeTest.source, "g");
  const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
  const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
  const escapeReplacements = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  const getEscapeReplacement = (ch) => escapeReplacements[ch];
  function escape$1(html2, encode) {
    if (encode) {
      if (escapeTest.test(html2)) {
        return html2.replace(escapeReplace, getEscapeReplacement);
      }
    } else {
      if (escapeTestNoEncode.test(html2)) {
        return html2.replace(escapeReplaceNoEncode, getEscapeReplacement);
      }
    }
    return html2;
  }
  const caret = /(^|[^\[])\^/g;
  function edit(regex, opt) {
    let source = typeof regex === "string" ? regex : regex.source;
    opt = opt || "";
    const obj = {
      replace: (name, val) => {
        let valSource = typeof val === "string" ? val : val.source;
        valSource = valSource.replace(caret, "$1");
        source = source.replace(name, valSource);
        return obj;
      },
      getRegex: () => {
        return new RegExp(source, opt);
      }
    };
    return obj;
  }
  function cleanUrl(href) {
    try {
      href = encodeURI(href).replace(/%25/g, "%");
    } catch {
      return null;
    }
    return href;
  }
  const noopTest = { exec: () => null };
  function splitCells(tableRow, count) {
    const row = tableRow.replace(/\|/g, (match, offset, str2) => {
      let escaped = false;
      let curr = offset;
      while (--curr >= 0 && str2[curr] === "\\")
        escaped = !escaped;
      if (escaped) {
        return "|";
      } else {
        return " |";
      }
    }), cells = row.split(/ \|/);
    let i = 0;
    if (!cells[0].trim()) {
      cells.shift();
    }
    if (cells.length > 0 && !cells[cells.length - 1].trim()) {
      cells.pop();
    }
    if (count) {
      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count)
          cells.push("");
      }
    }
    for (; i < cells.length; i++) {
      cells[i] = cells[i].trim().replace(/\\\|/g, "|");
    }
    return cells;
  }
  function rtrim(str2, c, invert) {
    const l = str2.length;
    if (l === 0) {
      return "";
    }
    let suffLen = 0;
    while (suffLen < l) {
      const currChar = str2.charAt(l - suffLen - 1);
      if (currChar === c && !invert) {
        suffLen++;
      } else if (currChar !== c && invert) {
        suffLen++;
      } else {
        break;
      }
    }
    return str2.slice(0, l - suffLen);
  }
  function findClosingBracket(str2, b) {
    if (str2.indexOf(b[1]) === -1) {
      return -1;
    }
    let level = 0;
    for (let i = 0; i < str2.length; i++) {
      if (str2[i] === "\\") {
        i++;
      } else if (str2[i] === b[0]) {
        level++;
      } else if (str2[i] === b[1]) {
        level--;
        if (level < 0) {
          return i;
        }
      }
    }
    return -1;
  }
  function outputLink(cap, link2, raw, lexer) {
    const href = link2.href;
    const title = link2.title ? escape$1(link2.title) : null;
    const text = cap[1].replace(/\\([\[\]])/g, "$1");
    if (cap[0].charAt(0) !== "!") {
      lexer.state.inLink = true;
      const token = {
        type: "link",
        raw,
        href,
        title,
        text,
        tokens: lexer.inlineTokens(text)
      };
      lexer.state.inLink = false;
      return token;
    }
    return {
      type: "image",
      raw,
      href,
      title,
      text: escape$1(text)
    };
  }
  function indentCodeCompensation(raw, text) {
    const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
    if (matchIndentToCode === null) {
      return text;
    }
    const indentToCode = matchIndentToCode[1];
    return text.split("\n").map((node) => {
      const matchIndentInNode = node.match(/^\s+/);
      if (matchIndentInNode === null) {
        return node;
      }
      const [indentInNode] = matchIndentInNode;
      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }
      return node;
    }).join("\n");
  }
  class _Tokenizer {
    // set by the lexer
    constructor(options) {
      __publicField(this, "options");
      __publicField(this, "rules");
      // set by the lexer
      __publicField(this, "lexer");
      this.options = options || _defaults;
    }
    space(src) {
      const cap = this.rules.block.newline.exec(src);
      if (cap && cap[0].length > 0) {
        return {
          type: "space",
          raw: cap[0]
        };
      }
    }
    code(src) {
      const cap = this.rules.block.code.exec(src);
      if (cap) {
        const text = cap[0].replace(/^(?: {1,4}| {0,3}\t)/gm, "");
        return {
          type: "code",
          raw: cap[0],
          codeBlockStyle: "indented",
          text: !this.options.pedantic ? rtrim(text, "\n") : text
        };
      }
    }
    fences(src) {
      const cap = this.rules.block.fences.exec(src);
      if (cap) {
        const raw = cap[0];
        const text = indentCodeCompensation(raw, cap[3] || "");
        return {
          type: "code",
          raw,
          lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cap[2],
          text
        };
      }
    }
    heading(src) {
      const cap = this.rules.block.heading.exec(src);
      if (cap) {
        let text = cap[2].trim();
        if (/#$/.test(text)) {
          const trimmed = rtrim(text, "#");
          if (this.options.pedantic) {
            text = trimmed.trim();
          } else if (!trimmed || / $/.test(trimmed)) {
            text = trimmed.trim();
          }
        }
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[1].length,
          text,
          tokens: this.lexer.inline(text)
        };
      }
    }
    hr(src) {
      const cap = this.rules.block.hr.exec(src);
      if (cap) {
        return {
          type: "hr",
          raw: rtrim(cap[0], "\n")
        };
      }
    }
    blockquote(src) {
      const cap = this.rules.block.blockquote.exec(src);
      if (cap) {
        let lines = rtrim(cap[0], "\n").split("\n");
        let raw = "";
        let text = "";
        const tokens = [];
        while (lines.length > 0) {
          let inBlockquote = false;
          const currentLines = [];
          let i;
          for (i = 0; i < lines.length; i++) {
            if (/^ {0,3}>/.test(lines[i])) {
              currentLines.push(lines[i]);
              inBlockquote = true;
            } else if (!inBlockquote) {
              currentLines.push(lines[i]);
            } else {
              break;
            }
          }
          lines = lines.slice(i);
          const currentRaw = currentLines.join("\n");
          const currentText = currentRaw.replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, "\n    $1").replace(/^ {0,3}>[ \t]?/gm, "");
          raw = raw ? `${raw}
${currentRaw}` : currentRaw;
          text = text ? `${text}
${currentText}` : currentText;
          const top = this.lexer.state.top;
          this.lexer.state.top = true;
          this.lexer.blockTokens(currentText, tokens, true);
          this.lexer.state.top = top;
          if (lines.length === 0) {
            break;
          }
          const lastToken = tokens[tokens.length - 1];
          if ((lastToken == null ? void 0 : lastToken.type) === "code") {
            break;
          } else if ((lastToken == null ? void 0 : lastToken.type) === "blockquote") {
            const oldToken = lastToken;
            const newText = oldToken.raw + "\n" + lines.join("\n");
            const newToken = this.blockquote(newText);
            tokens[tokens.length - 1] = newToken;
            raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;
            text = text.substring(0, text.length - oldToken.text.length) + newToken.text;
            break;
          } else if ((lastToken == null ? void 0 : lastToken.type) === "list") {
            const oldToken = lastToken;
            const newText = oldToken.raw + "\n" + lines.join("\n");
            const newToken = this.list(newText);
            tokens[tokens.length - 1] = newToken;
            raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;
            text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;
            lines = newText.substring(tokens[tokens.length - 1].raw.length).split("\n");
            continue;
          }
        }
        return {
          type: "blockquote",
          raw,
          tokens,
          text
        };
      }
    }
    list(src) {
      let cap = this.rules.block.list.exec(src);
      if (cap) {
        let bull = cap[1].trim();
        const isordered = bull.length > 1;
        const list2 = {
          type: "list",
          raw: "",
          ordered: isordered,
          start: isordered ? +bull.slice(0, -1) : "",
          loose: false,
          items: []
        };
        bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
        if (this.options.pedantic) {
          bull = isordered ? bull : "[*+-]";
        }
        const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
        let endsWithBlankLine = false;
        while (src) {
          let endEarly = false;
          let raw = "";
          let itemContents = "";
          if (!(cap = itemRegex.exec(src))) {
            break;
          }
          if (this.rules.block.hr.test(src)) {
            break;
          }
          raw = cap[0];
          src = src.substring(raw.length);
          let line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length));
          let nextLine = src.split("\n", 1)[0];
          let blankLine = !line.trim();
          let indent = 0;
          if (this.options.pedantic) {
            indent = 2;
            itemContents = line.trimStart();
          } else if (blankLine) {
            indent = cap[1].length + 1;
          } else {
            indent = cap[2].search(/[^ ]/);
            indent = indent > 4 ? 1 : indent;
            itemContents = line.slice(indent);
            indent += cap[1].length;
          }
          if (blankLine && /^[ \t]*$/.test(nextLine)) {
            raw += nextLine + "\n";
            src = src.substring(nextLine.length + 1);
            endEarly = true;
          }
          if (!endEarly) {
            const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
            const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
            const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
            const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
            while (src) {
              const rawLine = src.split("\n", 1)[0];
              let nextLineWithoutTabs;
              nextLine = rawLine;
              if (this.options.pedantic) {
                nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
                nextLineWithoutTabs = nextLine;
              } else {
                nextLineWithoutTabs = nextLine.replace(/\t/g, "    ");
              }
              if (fencesBeginRegex.test(nextLine)) {
                break;
              }
              if (headingBeginRegex.test(nextLine)) {
                break;
              }
              if (nextBulletRegex.test(nextLine)) {
                break;
              }
              if (hrRegex.test(nextLine)) {
                break;
              }
              if (nextLineWithoutTabs.search(/[^ ]/) >= indent || !nextLine.trim()) {
                itemContents += "\n" + nextLineWithoutTabs.slice(indent);
              } else {
                if (blankLine) {
                  break;
                }
                if (line.replace(/\t/g, "    ").search(/[^ ]/) >= 4) {
                  break;
                }
                if (fencesBeginRegex.test(line)) {
                  break;
                }
                if (headingBeginRegex.test(line)) {
                  break;
                }
                if (hrRegex.test(line)) {
                  break;
                }
                itemContents += "\n" + nextLine;
              }
              if (!blankLine && !nextLine.trim()) {
                blankLine = true;
              }
              raw += rawLine + "\n";
              src = src.substring(rawLine.length + 1);
              line = nextLineWithoutTabs.slice(indent);
            }
          }
          if (!list2.loose) {
            if (endsWithBlankLine) {
              list2.loose = true;
            } else if (/\n[ \t]*\n[ \t]*$/.test(raw)) {
              endsWithBlankLine = true;
            }
          }
          let istask = null;
          let ischecked;
          if (this.options.gfm) {
            istask = /^\[[ xX]\] /.exec(itemContents);
            if (istask) {
              ischecked = istask[0] !== "[ ] ";
              itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
            }
          }
          list2.items.push({
            type: "list_item",
            raw,
            task: !!istask,
            checked: ischecked,
            loose: false,
            text: itemContents,
            tokens: []
          });
          list2.raw += raw;
        }
        list2.items[list2.items.length - 1].raw = list2.items[list2.items.length - 1].raw.trimEnd();
        list2.items[list2.items.length - 1].text = list2.items[list2.items.length - 1].text.trimEnd();
        list2.raw = list2.raw.trimEnd();
        for (let i = 0; i < list2.items.length; i++) {
          this.lexer.state.top = false;
          list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
          if (!list2.loose) {
            const spacers = list2.items[i].tokens.filter((t) => t.type === "space");
            const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
            list2.loose = hasMultipleLineBreaks;
          }
        }
        if (list2.loose) {
          for (let i = 0; i < list2.items.length; i++) {
            list2.items[i].loose = true;
          }
        }
        return list2;
      }
    }
    html(src) {
      const cap = this.rules.block.html.exec(src);
      if (cap) {
        const token = {
          type: "html",
          block: true,
          raw: cap[0],
          pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
          text: cap[0]
        };
        return token;
      }
    }
    def(src) {
      const cap = this.rules.block.def.exec(src);
      if (cap) {
        const tag2 = cap[1].toLowerCase().replace(/\s+/g, " ");
        const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "";
        const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cap[3];
        return {
          type: "def",
          tag: tag2,
          raw: cap[0],
          href,
          title
        };
      }
    }
    table(src) {
      const cap = this.rules.block.table.exec(src);
      if (!cap) {
        return;
      }
      if (!/[:|]/.test(cap[2])) {
        return;
      }
      const headers = splitCells(cap[1]);
      const aligns = cap[2].replace(/^\||\| *$/g, "").split("|");
      const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : [];
      const item = {
        type: "table",
        raw: cap[0],
        header: [],
        align: [],
        rows: []
      };
      if (headers.length !== aligns.length) {
        return;
      }
      for (const align of aligns) {
        if (/^ *-+: *$/.test(align)) {
          item.align.push("right");
        } else if (/^ *:-+: *$/.test(align)) {
          item.align.push("center");
        } else if (/^ *:-+ *$/.test(align)) {
          item.align.push("left");
        } else {
          item.align.push(null);
        }
      }
      for (let i = 0; i < headers.length; i++) {
        item.header.push({
          text: headers[i],
          tokens: this.lexer.inline(headers[i]),
          header: true,
          align: item.align[i]
        });
      }
      for (const row of rows) {
        item.rows.push(splitCells(row, item.header.length).map((cell, i) => {
          return {
            text: cell,
            tokens: this.lexer.inline(cell),
            header: false,
            align: item.align[i]
          };
        }));
      }
      return item;
    }
    lheading(src) {
      const cap = this.rules.block.lheading.exec(src);
      if (cap) {
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[2].charAt(0) === "=" ? 1 : 2,
          text: cap[1],
          tokens: this.lexer.inline(cap[1])
        };
      }
    }
    paragraph(src) {
      const cap = this.rules.block.paragraph.exec(src);
      if (cap) {
        const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
        return {
          type: "paragraph",
          raw: cap[0],
          text,
          tokens: this.lexer.inline(text)
        };
      }
    }
    text(src) {
      const cap = this.rules.block.text.exec(src);
      if (cap) {
        return {
          type: "text",
          raw: cap[0],
          text: cap[0],
          tokens: this.lexer.inline(cap[0])
        };
      }
    }
    escape(src) {
      const cap = this.rules.inline.escape.exec(src);
      if (cap) {
        return {
          type: "escape",
          raw: cap[0],
          text: escape$1(cap[1])
        };
      }
    }
    tag(src) {
      const cap = this.rules.inline.tag.exec(src);
      if (cap) {
        if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
          this.lexer.state.inLink = true;
        } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
          this.lexer.state.inLink = false;
        }
        if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = true;
        } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = false;
        }
        return {
          type: "html",
          raw: cap[0],
          inLink: this.lexer.state.inLink,
          inRawBlock: this.lexer.state.inRawBlock,
          block: false,
          text: cap[0]
        };
      }
    }
    link(src) {
      const cap = this.rules.inline.link.exec(src);
      if (cap) {
        const trimmedUrl = cap[2].trim();
        if (!this.options.pedantic && /^</.test(trimmedUrl)) {
          if (!/>$/.test(trimmedUrl)) {
            return;
          }
          const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
            return;
          }
        } else {
          const lastParenIndex = findClosingBracket(cap[2], "()");
          if (lastParenIndex > -1) {
            const start = cap[0].indexOf("!") === 0 ? 5 : 4;
            const linkLen = start + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = "";
          }
        }
        let href = cap[2];
        let title = "";
        if (this.options.pedantic) {
          const link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
          if (link2) {
            href = link2[1];
            title = link2[3];
          }
        } else {
          title = cap[3] ? cap[3].slice(1, -1) : "";
        }
        href = href.trim();
        if (/^</.test(href)) {
          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
            href = href.slice(1);
          } else {
            href = href.slice(1, -1);
          }
        }
        return outputLink(cap, {
          href: href ? href.replace(this.rules.inline.anyPunctuation, "$1") : href,
          title: title ? title.replace(this.rules.inline.anyPunctuation, "$1") : title
        }, cap[0], this.lexer);
      }
    }
    reflink(src, links) {
      let cap;
      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
        const linkString = (cap[2] || cap[1]).replace(/\s+/g, " ");
        const link2 = links[linkString.toLowerCase()];
        if (!link2) {
          const text = cap[0].charAt(0);
          return {
            type: "text",
            raw: text,
            text
          };
        }
        return outputLink(cap, link2, cap[0], this.lexer);
      }
    }
    emStrong(src, maskedSrc, prevChar = "") {
      let match = this.rules.inline.emStrongLDelim.exec(src);
      if (!match)
        return;
      if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
        return;
      const nextChar = match[1] || match[2] || "";
      if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
        const lLength = [...match[0]].length - 1;
        let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
        const endReg = match[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
        endReg.lastIndex = 0;
        maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
        while ((match = endReg.exec(maskedSrc)) != null) {
          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
          if (!rDelim)
            continue;
          rLength = [...rDelim].length;
          if (match[3] || match[4]) {
            delimTotal += rLength;
            continue;
          } else if (match[5] || match[6]) {
            if (lLength % 3 && !((lLength + rLength) % 3)) {
              midDelimTotal += rLength;
              continue;
            }
          }
          delimTotal -= rLength;
          if (delimTotal > 0)
            continue;
          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
          const lastCharLength = [...match[0]][0].length;
          const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
          if (Math.min(lLength, rLength) % 2) {
            const text2 = raw.slice(1, -1);
            return {
              type: "em",
              raw,
              text: text2,
              tokens: this.lexer.inlineTokens(text2)
            };
          }
          const text = raw.slice(2, -2);
          return {
            type: "strong",
            raw,
            text,
            tokens: this.lexer.inlineTokens(text)
          };
        }
      }
    }
    codespan(src) {
      const cap = this.rules.inline.code.exec(src);
      if (cap) {
        let text = cap[2].replace(/\n/g, " ");
        const hasNonSpaceChars = /[^ ]/.test(text);
        const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
          text = text.substring(1, text.length - 1);
        }
        text = escape$1(text, true);
        return {
          type: "codespan",
          raw: cap[0],
          text
        };
      }
    }
    br(src) {
      const cap = this.rules.inline.br.exec(src);
      if (cap) {
        return {
          type: "br",
          raw: cap[0]
        };
      }
    }
    del(src) {
      const cap = this.rules.inline.del.exec(src);
      if (cap) {
        return {
          type: "del",
          raw: cap[0],
          text: cap[2],
          tokens: this.lexer.inlineTokens(cap[2])
        };
      }
    }
    autolink(src) {
      const cap = this.rules.inline.autolink.exec(src);
      if (cap) {
        let text, href;
        if (cap[2] === "@") {
          text = escape$1(cap[1]);
          href = "mailto:" + text;
        } else {
          text = escape$1(cap[1]);
          href = text;
        }
        return {
          type: "link",
          raw: cap[0],
          text,
          href,
          tokens: [
            {
              type: "text",
              raw: text,
              text
            }
          ]
        };
      }
    }
    url(src) {
      var _a2;
      let cap;
      if (cap = this.rules.inline.url.exec(src)) {
        let text, href;
        if (cap[2] === "@") {
          text = escape$1(cap[0]);
          href = "mailto:" + text;
        } else {
          let prevCapZero;
          do {
            prevCapZero = cap[0];
            cap[0] = ((_a2 = this.rules.inline._backpedal.exec(cap[0])) == null ? void 0 : _a2[0]) ?? "";
          } while (prevCapZero !== cap[0]);
          text = escape$1(cap[0]);
          if (cap[1] === "www.") {
            href = "http://" + cap[0];
          } else {
            href = cap[0];
          }
        }
        return {
          type: "link",
          raw: cap[0],
          text,
          href,
          tokens: [
            {
              type: "text",
              raw: text,
              text
            }
          ]
        };
      }
    }
    inlineText(src) {
      const cap = this.rules.inline.text.exec(src);
      if (cap) {
        let text;
        if (this.lexer.state.inRawBlock) {
          text = cap[0];
        } else {
          text = escape$1(cap[0]);
        }
        return {
          type: "text",
          raw: cap[0],
          text
        };
      }
    }
  }
  const newline = /^(?:[ \t]*(?:\n|$))+/;
  const blockCode = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
  const fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
  const hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
  const heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
  const bullet = /(?:[*+-]|\d{1,9}[.)])/;
  const lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).getRegex();
  const _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
  const blockText = /^[^\n]+/;
  const _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
  const def = edit(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
  const list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
  const _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
  const _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
  const html = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  const paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
  const blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex();
  const blockNormal = {
    blockquote,
    code: blockCode,
    def,
    fences,
    heading,
    hr,
    html,
    lheading,
    list,
    newline,
    paragraph,
    table: noopTest,
    text: blockText
  };
  const gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
  const blockGfm = {
    ...blockNormal,
    table: gfmTable,
    paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
  };
  const blockPedantic = {
    ...blockNormal,
    html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest,
    // fences not supported
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
  };
  const escape = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
  const inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
  const br = /^( {2,}|\\)\n(?!\s*$)/;
  const inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
  const _punctuation = "\\p{P}\\p{S}";
  const punctuation = edit(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, _punctuation).getRegex();
  const blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
  const emStrongLDelim = edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, _punctuation).getRegex();
  const emStrongRDelimAst = edit("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, _punctuation).getRegex();
  const emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, _punctuation).getRegex();
  const anyPunctuation = edit(/\\([punct])/, "gu").replace(/punct/g, _punctuation).getRegex();
  const autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
  const _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex();
  const tag = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
  const _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  const link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
  const reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex();
  const nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex();
  const reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex();
  const inlineNormal = {
    _backpedal: noopTest,
    // only used for GFM url
    anyPunctuation,
    autolink,
    blockSkip,
    br,
    code: inlineCode,
    del: noopTest,
    emStrongLDelim,
    emStrongRDelimAst,
    emStrongRDelimUnd,
    escape,
    link,
    nolink,
    punctuation,
    reflink,
    reflinkSearch,
    tag,
    text: inlineText,
    url: noopTest
  };
  const inlinePedantic = {
    ...inlineNormal,
    link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
  };
  const inlineGfm = {
    ...inlineNormal,
    escape: edit(escape).replace("])", "~|])").getRegex(),
    url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
  };
  const inlineBreaks = {
    ...inlineGfm,
    br: edit(br).replace("{2,}", "*").getRegex(),
    text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
  };
  const block = {
    normal: blockNormal,
    gfm: blockGfm,
    pedantic: blockPedantic
  };
  const inline = {
    normal: inlineNormal,
    gfm: inlineGfm,
    breaks: inlineBreaks,
    pedantic: inlinePedantic
  };
  class _Lexer {
    constructor(options) {
      __publicField(this, "tokens");
      __publicField(this, "options");
      __publicField(this, "state");
      __publicField(this, "tokenizer");
      __publicField(this, "inlineQueue");
      this.tokens = [];
      this.tokens.links = /* @__PURE__ */ Object.create(null);
      this.options = options || _defaults;
      this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      this.tokenizer.lexer = this;
      this.inlineQueue = [];
      this.state = {
        inLink: false,
        inRawBlock: false,
        top: true
      };
      const rules = {
        block: block.normal,
        inline: inline.normal
      };
      if (this.options.pedantic) {
        rules.block = block.pedantic;
        rules.inline = inline.pedantic;
      } else if (this.options.gfm) {
        rules.block = block.gfm;
        if (this.options.breaks) {
          rules.inline = inline.breaks;
        } else {
          rules.inline = inline.gfm;
        }
      }
      this.tokenizer.rules = rules;
    }
    /**
     * Expose Rules
     */
    static get rules() {
      return {
        block,
        inline
      };
    }
    /**
     * Static Lex Method
     */
    static lex(src, options) {
      const lexer = new _Lexer(options);
      return lexer.lex(src);
    }
    /**
     * Static Lex Inline Method
     */
    static lexInline(src, options) {
      const lexer = new _Lexer(options);
      return lexer.inlineTokens(src);
    }
    /**
     * Preprocessing
     */
    lex(src) {
      src = src.replace(/\r\n|\r/g, "\n");
      this.blockTokens(src, this.tokens);
      for (let i = 0; i < this.inlineQueue.length; i++) {
        const next = this.inlineQueue[i];
        this.inlineTokens(next.src, next.tokens);
      }
      this.inlineQueue = [];
      return this.tokens;
    }
    blockTokens(src, tokens = [], lastParagraphClipped = false) {
      if (this.options.pedantic) {
        src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
      }
      let token;
      let lastToken;
      let cutSrc;
      while (src) {
        if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.space(src)) {
          src = src.substring(token.raw.length);
          if (token.raw.length === 1 && tokens.length > 0) {
            tokens[tokens.length - 1].raw += "\n";
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.code(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.fences(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.heading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.hr(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.blockquote(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.list(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.html(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.def(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.raw;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else if (!this.tokens.links[token.tag]) {
            this.tokens.links[token.tag] = {
              href: token.href,
              title: token.title
            };
          }
          continue;
        }
        if (token = this.tokenizer.table(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.lheading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        cutSrc = src;
        if (this.options.extensions && this.options.extensions.startBlock) {
          let startIndex = Infinity;
          const tempSrc = src.slice(1);
          let tempStart;
          this.options.extensions.startBlock.forEach((getStartIndex) => {
            tempStart = getStartIndex.call({ lexer: this }, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        }
        if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
          lastToken = tokens[tokens.length - 1];
          if (lastParagraphClipped && (lastToken == null ? void 0 : lastToken.type) === "paragraph") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          lastParagraphClipped = cutSrc.length !== src.length;
          src = src.substring(token.raw.length);
          continue;
        }
        if (token = this.tokenizer.text(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "text") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      this.state.top = true;
      return tokens;
    }
    inline(src, tokens = []) {
      this.inlineQueue.push({ src, tokens });
      return tokens;
    }
    /**
     * Lexing/Compiling
     */
    inlineTokens(src, tokens = []) {
      let token, lastToken, cutSrc;
      let maskedSrc = src;
      let match;
      let keepPrevChar, prevChar;
      if (this.tokens.links) {
        const links = Object.keys(this.tokens.links);
        if (links.length > 0) {
          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
            if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
              maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
            }
          }
        }
      }
      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      }
      while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
      }
      while (src) {
        if (!keepPrevChar) {
          prevChar = "";
        }
        keepPrevChar = false;
        if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.escape(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.tag(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && token.type === "text" && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.link(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.reflink(src, this.tokens.links)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && token.type === "text" && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.codespan(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.br(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.del(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.autolink(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (!this.state.inLink && (token = this.tokenizer.url(src))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        cutSrc = src;
        if (this.options.extensions && this.options.extensions.startInline) {
          let startIndex = Infinity;
          const tempSrc = src.slice(1);
          let tempStart;
          this.options.extensions.startInline.forEach((getStartIndex) => {
            tempStart = getStartIndex.call({ lexer: this }, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        }
        if (token = this.tokenizer.inlineText(cutSrc)) {
          src = src.substring(token.raw.length);
          if (token.raw.slice(-1) !== "_") {
            prevChar = token.raw.slice(-1);
          }
          keepPrevChar = true;
          lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      return tokens;
    }
  }
  class _Renderer {
    // set by the parser
    constructor(options) {
      __publicField(this, "options");
      __publicField(this, "parser");
      this.options = options || _defaults;
    }
    space(token) {
      return "";
    }
    code({ text, lang, escaped }) {
      var _a2;
      const langString = (_a2 = (lang || "").match(/^\S*/)) == null ? void 0 : _a2[0];
      const code = text.replace(/\n$/, "") + "\n";
      if (!langString) {
        return "<pre><code>" + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
      }
      return '<pre><code class="language-' + escape$1(langString) + '">' + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
    }
    blockquote({ tokens }) {
      const body = this.parser.parse(tokens);
      return `<blockquote>
${body}</blockquote>
`;
    }
    html({ text }) {
      return text;
    }
    heading({ tokens, depth }) {
      return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>
`;
    }
    hr(token) {
      return "<hr>\n";
    }
    list(token) {
      const ordered = token.ordered;
      const start = token.start;
      let body = "";
      for (let j = 0; j < token.items.length; j++) {
        const item = token.items[j];
        body += this.listitem(item);
      }
      const type2 = ordered ? "ol" : "ul";
      const startAttr = ordered && start !== 1 ? ' start="' + start + '"' : "";
      return "<" + type2 + startAttr + ">\n" + body + "</" + type2 + ">\n";
    }
    listitem(item) {
      let itemBody = "";
      if (item.task) {
        const checkbox = this.checkbox({ checked: !!item.checked });
        if (item.loose) {
          if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
            item.tokens[0].text = checkbox + " " + item.tokens[0].text;
            if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
              item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
            }
          } else {
            item.tokens.unshift({
              type: "text",
              raw: checkbox + " ",
              text: checkbox + " "
            });
          }
        } else {
          itemBody += checkbox + " ";
        }
      }
      itemBody += this.parser.parse(item.tokens, !!item.loose);
      return `<li>${itemBody}</li>
`;
    }
    checkbox({ checked }) {
      return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
    }
    paragraph({ tokens }) {
      return `<p>${this.parser.parseInline(tokens)}</p>
`;
    }
    table(token) {
      let header = "";
      let cell = "";
      for (let j = 0; j < token.header.length; j++) {
        cell += this.tablecell(token.header[j]);
      }
      header += this.tablerow({ text: cell });
      let body = "";
      for (let j = 0; j < token.rows.length; j++) {
        const row = token.rows[j];
        cell = "";
        for (let k = 0; k < row.length; k++) {
          cell += this.tablecell(row[k]);
        }
        body += this.tablerow({ text: cell });
      }
      if (body)
        body = `<tbody>${body}</tbody>`;
      return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
    }
    tablerow({ text }) {
      return `<tr>
${text}</tr>
`;
    }
    tablecell(token) {
      const content = this.parser.parseInline(token.tokens);
      const type2 = token.header ? "th" : "td";
      const tag2 = token.align ? `<${type2} align="${token.align}">` : `<${type2}>`;
      return tag2 + content + `</${type2}>
`;
    }
    /**
     * span level renderer
     */
    strong({ tokens }) {
      return `<strong>${this.parser.parseInline(tokens)}</strong>`;
    }
    em({ tokens }) {
      return `<em>${this.parser.parseInline(tokens)}</em>`;
    }
    codespan({ text }) {
      return `<code>${text}</code>`;
    }
    br(token) {
      return "<br>";
    }
    del({ tokens }) {
      return `<del>${this.parser.parseInline(tokens)}</del>`;
    }
    link({ href, title, tokens }) {
      const text = this.parser.parseInline(tokens);
      const cleanHref = cleanUrl(href);
      if (cleanHref === null) {
        return text;
      }
      href = cleanHref;
      let out = '<a href="' + href + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += ">" + text + "</a>";
      return out;
    }
    image({ href, title, text }) {
      const cleanHref = cleanUrl(href);
      if (cleanHref === null) {
        return text;
      }
      href = cleanHref;
      let out = `<img src="${href}" alt="${text}"`;
      if (title) {
        out += ` title="${title}"`;
      }
      out += ">";
      return out;
    }
    text(token) {
      return "tokens" in token && token.tokens ? this.parser.parseInline(token.tokens) : token.text;
    }
  }
  class _TextRenderer {
    // no need for block level renderers
    strong({ text }) {
      return text;
    }
    em({ text }) {
      return text;
    }
    codespan({ text }) {
      return text;
    }
    del({ text }) {
      return text;
    }
    html({ text }) {
      return text;
    }
    text({ text }) {
      return text;
    }
    link({ text }) {
      return "" + text;
    }
    image({ text }) {
      return "" + text;
    }
    br() {
      return "";
    }
  }
  class _Parser {
    constructor(options) {
      __publicField(this, "options");
      __publicField(this, "renderer");
      __publicField(this, "textRenderer");
      this.options = options || _defaults;
      this.options.renderer = this.options.renderer || new _Renderer();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.renderer.parser = this;
      this.textRenderer = new _TextRenderer();
    }
    /**
     * Static Parse Method
     */
    static parse(tokens, options) {
      const parser = new _Parser(options);
      return parser.parse(tokens);
    }
    /**
     * Static Parse Inline Method
     */
    static parseInline(tokens, options) {
      const parser = new _Parser(options);
      return parser.parseInline(tokens);
    }
    /**
     * Parse Loop
     */
    parse(tokens, top = true) {
      let out = "";
      for (let i = 0; i < tokens.length; i++) {
        const anyToken = tokens[i];
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {
          const genericToken = anyToken;
          const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
          if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
            out += ret || "";
            continue;
          }
        }
        const token = anyToken;
        switch (token.type) {
          case "space": {
            out += this.renderer.space(token);
            continue;
          }
          case "hr": {
            out += this.renderer.hr(token);
            continue;
          }
          case "heading": {
            out += this.renderer.heading(token);
            continue;
          }
          case "code": {
            out += this.renderer.code(token);
            continue;
          }
          case "table": {
            out += this.renderer.table(token);
            continue;
          }
          case "blockquote": {
            out += this.renderer.blockquote(token);
            continue;
          }
          case "list": {
            out += this.renderer.list(token);
            continue;
          }
          case "html": {
            out += this.renderer.html(token);
            continue;
          }
          case "paragraph": {
            out += this.renderer.paragraph(token);
            continue;
          }
          case "text": {
            let textToken = token;
            let body = this.renderer.text(textToken);
            while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
              textToken = tokens[++i];
              body += "\n" + this.renderer.text(textToken);
            }
            if (top) {
              out += this.renderer.paragraph({
                type: "paragraph",
                raw: body,
                text: body,
                tokens: [{ type: "text", raw: body, text: body }]
              });
            } else {
              out += body;
            }
            continue;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return "";
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
    /**
     * Parse Inline Tokens
     */
    parseInline(tokens, renderer2) {
      renderer2 = renderer2 || this.renderer;
      let out = "";
      for (let i = 0; i < tokens.length; i++) {
        const anyToken = tokens[i];
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {
          const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);
          if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(anyToken.type)) {
            out += ret || "";
            continue;
          }
        }
        const token = anyToken;
        switch (token.type) {
          case "escape": {
            out += renderer2.text(token);
            break;
          }
          case "html": {
            out += renderer2.html(token);
            break;
          }
          case "link": {
            out += renderer2.link(token);
            break;
          }
          case "image": {
            out += renderer2.image(token);
            break;
          }
          case "strong": {
            out += renderer2.strong(token);
            break;
          }
          case "em": {
            out += renderer2.em(token);
            break;
          }
          case "codespan": {
            out += renderer2.codespan(token);
            break;
          }
          case "br": {
            out += renderer2.br(token);
            break;
          }
          case "del": {
            out += renderer2.del(token);
            break;
          }
          case "text": {
            out += renderer2.text(token);
            break;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return "";
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
  }
  class _Hooks {
    constructor(options) {
      __publicField(this, "options");
      __publicField(this, "block");
      this.options = options || _defaults;
    }
    /**
     * Process markdown before marked
     */
    preprocess(markdown) {
      return markdown;
    }
    /**
     * Process HTML after marked is finished
     */
    postprocess(html2) {
      return html2;
    }
    /**
     * Process all tokens before walk tokens
     */
    processAllTokens(tokens) {
      return tokens;
    }
    /**
     * Provide function to tokenize markdown
     */
    provideLexer() {
      return this.block ? _Lexer.lex : _Lexer.lexInline;
    }
    /**
     * Provide function to parse tokens
     */
    provideParser() {
      return this.block ? _Parser.parse : _Parser.parseInline;
    }
  }
  __publicField(_Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
    "preprocess",
    "postprocess",
    "processAllTokens"
  ]));
  class Marked {
    constructor(...args) {
      __publicField(this, "defaults", _getDefaults());
      __publicField(this, "options", this.setOptions);
      __publicField(this, "parse", this.parseMarkdown(true));
      __publicField(this, "parseInline", this.parseMarkdown(false));
      __publicField(this, "Parser", _Parser);
      __publicField(this, "Renderer", _Renderer);
      __publicField(this, "TextRenderer", _TextRenderer);
      __publicField(this, "Lexer", _Lexer);
      __publicField(this, "Tokenizer", _Tokenizer);
      __publicField(this, "Hooks", _Hooks);
      this.use(...args);
    }
    /**
     * Run callback for every token
     */
    walkTokens(tokens, callback) {
      var _a2, _b;
      let values = [];
      for (const token of tokens) {
        values = values.concat(callback.call(this, token));
        switch (token.type) {
          case "table": {
            const tableToken = token;
            for (const cell of tableToken.header) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
            for (const row of tableToken.rows) {
              for (const cell of row) {
                values = values.concat(this.walkTokens(cell.tokens, callback));
              }
            }
            break;
          }
          case "list": {
            const listToken = token;
            values = values.concat(this.walkTokens(listToken.items, callback));
            break;
          }
          default: {
            const genericToken = token;
            if ((_b = (_a2 = this.defaults.extensions) == null ? void 0 : _a2.childTokens) == null ? void 0 : _b[genericToken.type]) {
              this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
                const tokens2 = genericToken[childTokens].flat(Infinity);
                values = values.concat(this.walkTokens(tokens2, callback));
              });
            } else if (genericToken.tokens) {
              values = values.concat(this.walkTokens(genericToken.tokens, callback));
            }
          }
        }
      }
      return values;
    }
    use(...args) {
      const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
      args.forEach((pack) => {
        const opts = { ...pack };
        opts.async = this.defaults.async || opts.async || false;
        if (pack.extensions) {
          pack.extensions.forEach((ext) => {
            if (!ext.name) {
              throw new Error("extension name required");
            }
            if ("renderer" in ext) {
              const prevRenderer = extensions.renderers[ext.name];
              if (prevRenderer) {
                extensions.renderers[ext.name] = function(...args2) {
                  let ret = ext.renderer.apply(this, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args2);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if ("tokenizer" in ext) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              const extLevel = extensions[ext.level];
              if (extLevel) {
                extLevel.unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) {
                if (ext.level === "block") {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === "inline") {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if ("childTokens" in ext && ext.childTokens) {
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
          opts.extensions = extensions;
        }
        if (pack.renderer) {
          const renderer2 = this.defaults.renderer || new _Renderer(this.defaults);
          for (const prop in pack.renderer) {
            if (!(prop in renderer2)) {
              throw new Error(`renderer '${prop}' does not exist`);
            }
            if (["options", "parser"].includes(prop)) {
              continue;
            }
            const rendererProp = prop;
            const rendererFunc = pack.renderer[rendererProp];
            const prevRenderer = renderer2[rendererProp];
            renderer2[rendererProp] = (...args2) => {
              let ret = rendererFunc.apply(renderer2, args2);
              if (ret === false) {
                ret = prevRenderer.apply(renderer2, args2);
              }
              return ret || "";
            };
          }
          opts.renderer = renderer2;
        }
        if (pack.tokenizer) {
          const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
          for (const prop in pack.tokenizer) {
            if (!(prop in tokenizer)) {
              throw new Error(`tokenizer '${prop}' does not exist`);
            }
            if (["options", "rules", "lexer"].includes(prop)) {
              continue;
            }
            const tokenizerProp = prop;
            const tokenizerFunc = pack.tokenizer[tokenizerProp];
            const prevTokenizer = tokenizer[tokenizerProp];
            tokenizer[tokenizerProp] = (...args2) => {
              let ret = tokenizerFunc.apply(tokenizer, args2);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args2);
              }
              return ret;
            };
          }
          opts.tokenizer = tokenizer;
        }
        if (pack.hooks) {
          const hooks = this.defaults.hooks || new _Hooks();
          for (const prop in pack.hooks) {
            if (!(prop in hooks)) {
              throw new Error(`hook '${prop}' does not exist`);
            }
            if (["options", "block"].includes(prop)) {
              continue;
            }
            const hooksProp = prop;
            const hooksFunc = pack.hooks[hooksProp];
            const prevHook = hooks[hooksProp];
            if (_Hooks.passThroughHooks.has(prop)) {
              hooks[hooksProp] = (arg) => {
                if (this.defaults.async) {
                  return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                    return prevHook.call(hooks, ret2);
                  });
                }
                const ret = hooksFunc.call(hooks, arg);
                return prevHook.call(hooks, ret);
              };
            } else {
              hooks[hooksProp] = (...args2) => {
                let ret = hooksFunc.apply(hooks, args2);
                if (ret === false) {
                  ret = prevHook.apply(hooks, args2);
                }
                return ret;
              };
            }
          }
          opts.hooks = hooks;
        }
        if (pack.walkTokens) {
          const walkTokens = this.defaults.walkTokens;
          const packWalktokens = pack.walkTokens;
          opts.walkTokens = function(token) {
            let values = [];
            values.push(packWalktokens.call(this, token));
            if (walkTokens) {
              values = values.concat(walkTokens.call(this, token));
            }
            return values;
          };
        }
        this.defaults = { ...this.defaults, ...opts };
      });
      return this;
    }
    setOptions(opt) {
      this.defaults = { ...this.defaults, ...opt };
      return this;
    }
    lexer(src, options) {
      return _Lexer.lex(src, options ?? this.defaults);
    }
    parser(tokens, options) {
      return _Parser.parse(tokens, options ?? this.defaults);
    }
    parseMarkdown(blockType) {
      const parse = (src, options) => {
        const origOpt = { ...options };
        const opt = { ...this.defaults, ...origOpt };
        const throwError = this.onError(!!opt.silent, !!opt.async);
        if (this.defaults.async === true && origOpt.async === false) {
          return throwError(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
        }
        if (typeof src === "undefined" || src === null) {
          return throwError(new Error("marked(): input parameter is undefined or null"));
        }
        if (typeof src !== "string") {
          return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
        }
        if (opt.hooks) {
          opt.hooks.options = opt;
          opt.hooks.block = blockType;
        }
        const lexer = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline;
        const parser = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;
        if (opt.async) {
          return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
        }
        try {
          if (opt.hooks) {
            src = opt.hooks.preprocess(src);
          }
          let tokens = lexer(src, opt);
          if (opt.hooks) {
            tokens = opt.hooks.processAllTokens(tokens);
          }
          if (opt.walkTokens) {
            this.walkTokens(tokens, opt.walkTokens);
          }
          let html2 = parser(tokens, opt);
          if (opt.hooks) {
            html2 = opt.hooks.postprocess(html2);
          }
          return html2;
        } catch (e) {
          return throwError(e);
        }
      };
      return parse;
    }
    onError(silent, async) {
      return (e) => {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (silent) {
          const msg = "<p>An error occurred:</p><pre>" + escape$1(e.message + "", true) + "</pre>";
          if (async) {
            return Promise.resolve(msg);
          }
          return msg;
        }
        if (async) {
          return Promise.reject(e);
        }
        throw e;
      };
    }
  }
  const markedInstance = new Marked();
  function marked(src, opt) {
    return markedInstance.parse(src, opt);
  }
  marked.options = marked.setOptions = function(options) {
    markedInstance.setOptions(options);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
  };
  marked.getDefaults = _getDefaults;
  marked.defaults = _defaults;
  marked.use = function(...args) {
    markedInstance.use(...args);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
  };
  marked.walkTokens = function(tokens, callback) {
    return markedInstance.walkTokens(tokens, callback);
  };
  marked.parseInline = markedInstance.parseInline;
  marked.Parser = _Parser;
  marked.parser = _Parser.parse;
  marked.Renderer = _Renderer;
  marked.TextRenderer = _TextRenderer;
  marked.Lexer = _Lexer;
  marked.lexer = _Lexer.lex;
  marked.Tokenizer = _Tokenizer;
  marked.Hooks = _Hooks;
  marked.parse = marked;
  marked.options;
  marked.setOptions;
  marked.use;
  marked.walkTokens;
  marked.parseInline;
  _Parser.parse;
  _Lexer.lex;
  const _imports_1 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20width='800px'%20height='800px'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='Edit%20/%20Edit_Pencil_01'%3e%3cpath%20id='Vector'%20d='M12%208.00012L4%2016.0001V20.0001L8%2020.0001L16%2012.0001M12%208.00012L14.8686%205.13146L14.8704%205.12976C15.2652%204.73488%2015.463%204.53709%2015.691%204.46301C15.8919%204.39775%2016.1082%204.39775%2016.3091%204.46301C16.5369%204.53704%2016.7345%204.7346%2017.1288%205.12892L18.8686%206.86872C19.2646%207.26474%2019.4627%207.46284%2019.5369%207.69117C19.6022%207.89201%2019.6021%208.10835%2019.5369%208.3092C19.4628%208.53736%2019.265%208.73516%2018.8695%209.13061L18.8686%209.13146L16%2012.0001M12%208.00012L16%2012.0001'%20stroke='%23000000'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/g%3e%3c/svg%3e";
  const _imports_2 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20width='800px'%20height='800px'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='Interface%20/%20Trash_Full'%3e%3cpath%20id='Vector'%20d='M14%2010V17M10%2010V17M6%206V17.8C6%2018.9201%206%2019.4798%206.21799%2019.9076C6.40973%2020.2839%206.71547%2020.5905%207.0918%2020.7822C7.5192%2021%208.07899%2021%209.19691%2021H14.8031C15.921%2021%2016.48%2021%2016.9074%2020.7822C17.2837%2020.5905%2017.5905%2020.2839%2017.7822%2019.9076C18%2019.4802%2018%2018.921%2018%2017.8031V6M6%206H8M6%206H4M8%206H16M8%206C8%205.06812%208%204.60241%208.15224%204.23486C8.35523%203.74481%208.74432%203.35523%209.23438%203.15224C9.60192%203%2010.0681%203%2011%203H13C13.9319%203%2014.3978%203%2014.7654%203.15224C15.2554%203.35523%2015.6447%203.74481%2015.8477%204.23486C15.9999%204.6024%2016%205.06812%2016%206M16%206H18M18%206H20'%20stroke='%23000000'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/g%3e%3c/svg%3e";
  const _hoisted_1$3 = {
    key: 0,
    class: "chat-history-overlay"
  };
  const _hoisted_2$3 = { class: "chat-history-modal" };
  const _hoisted_3$3 = { class: "chat-history-search-container" };
  const _hoisted_4$2 = { class: "chat-history-content" };
  const _hoisted_5$2 = {
    key: 0,
    class: "chat-history-empty-container"
  };
  const _hoisted_6$2 = {
    key: 1,
    class: "chat-history-list"
  };
  const _hoisted_7$1 = ["onMouseenter"];
  const _hoisted_8$1 = { class: "chat-item-actions" };
  const _hoisted_9$1 = ["onClick"];
  const _hoisted_10$1 = ["onClick"];
  const _hoisted_11 = ["onClick"];
  const _hoisted_12 = {
    key: 0,
    class: "chat-title-edit"
  };
  const _hoisted_13 = ["onKeydown", "onBlur"];
  const _hoisted_14 = { key: 1 };
  const _hoisted_15 = { class: "chat-title" };
  const _hoisted_16 = { class: "chat-date" };
  const _sfc_main$3 = /* @__PURE__ */ defineComponent({
    __name: "ChatHistory",
    emits: ["loadChat"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const chatbox = useChatboxStore();
      const isVisible = ref(false);
      const searchQuery = ref("");
      const hoveredChatId = ref(null);
      const editingChatId = ref(null);
      const editTitle = ref("");
      const filteredChats = computed(() => {
        if (!searchQuery.value) return chatbox.chatHistory;
        const query = searchQuery.value.toLowerCase();
        return chatbox.chatHistory.filter(
          (chat) => chat.title.toLowerCase().includes(query) || chat.messages.some((msg) => msg.content.toLowerCase().includes(query))
        );
      });
      const formatDate = (date) => {
        if (!date) return "";
        return new Date(date).toLocaleString("en-US", {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit"
        });
      };
      const selectChat = (chatId) => {
        if (editingChatId.value === null) {
          chatbox.loadChat(chatId);
          hide();
        }
      };
      const startEdit = (event, chat) => {
        event.stopPropagation();
        editingChatId.value = chat.id;
        editTitle.value = chat.title;
      };
      const saveEdit = (event, chatId) => {
        event.stopPropagation();
        if (editTitle.value.trim()) {
          const chatIndex = chatbox.chatHistory.findIndex((chat) => chat.id === chatId);
          if (chatIndex !== -1) {
            chatbox.chatHistory[chatIndex].title = editTitle.value.trim();
            chatbox.saveToStorage();
          }
        }
        editingChatId.value = null;
        editTitle.value = "";
      };
      const deleteChat = (chatId) => {
        if (confirm("Are you sure you want to delete this chat?")) {
          const chatIndex = chatbox.chatHistory.findIndex((chat) => chat.id === chatId);
          if (chatIndex !== -1) {
            chatbox.chatHistory.splice(chatIndex, 1);
            if (chatbox.currentChatId === chatId) {
              chatbox.clearMessages();
              chatbox.currentChatId = "";
            }
            chatbox.saveToStorage();
          }
        }
      };
      const handleKeyDown = (event, chatId) => {
        if (event.key === "Enter") {
          saveEdit(event, chatId);
        } else if (event.key === "Escape") {
          editingChatId.value = null;
          editTitle.value = "";
        }
      };
      const show = () => {
        isVisible.value = true;
      };
      const hide = () => {
        isVisible.value = false;
        hoveredChatId.value = null;
        editingChatId.value = null;
        editTitle.value = "";
      };
      __expose({ show, hide });
      return (_ctx, _cache) => {
        return isVisible.value ? (openBlock(), createElementBlock("div", _hoisted_1$3, [
          createBaseVNode("div", _hoisted_2$3, [
            createBaseVNode("div", { class: "chat-history-header" }, [
              _cache[4] || (_cache[4] = createBaseVNode("h2", { class: "chat-history-title" }, "TeacherAIde", -1)),
              _cache[5] || (_cache[5] = createBaseVNode("div", { class: "chat-history-subtitle" }, "Chat History", -1)),
              createBaseVNode("img", {
                onClick: hide,
                src: _imports_0,
                alt: "close",
                class: "chat-history-close"
              })
            ]),
            createBaseVNode("div", _hoisted_3$3, [
              withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
                type: "text",
                placeholder: "Search your chats...",
                class: "chat-history-search-input"
              }, null, 512), [
                [vModelText, searchQuery.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_4$2, [
              filteredChats.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_5$2, _cache[6] || (_cache[6] = [
                createBaseVNode("div", { class: "chat-history-empty" }, [
                  createBaseVNode("p", null, "Your chat history is currently empty."),
                  createBaseVNode("p", null, "Return to Home screen and start a new conversation!")
                ], -1)
              ]))) : (openBlock(), createElementBlock("div", _hoisted_6$2, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(filteredChats.value, (chat) => {
                  return openBlock(), createElementBlock("div", {
                    key: chat.id,
                    class: normalizeClass(["chat-history-item", { active: hoveredChatId.value === chat.id }]),
                    onMouseenter: ($event) => hoveredChatId.value = chat.id,
                    onMouseleave: _cache[3] || (_cache[3] = ($event) => hoveredChatId.value = null)
                  }, [
                    createBaseVNode("div", _hoisted_8$1, [
                      createBaseVNode("img", {
                        onClick: withModifiers(($event) => startEdit($event, chat), ["stop"]),
                        src: _imports_1,
                        alt: "edit",
                        class: "action-icon",
                        title: "Edit title"
                      }, null, 8, _hoisted_9$1),
                      createBaseVNode("img", {
                        onClick: withModifiers(($event) => deleteChat(chat.id), ["stop"]),
                        src: _imports_2,
                        alt: "delete",
                        class: "action-icon",
                        title: "Delete chat"
                      }, null, 8, _hoisted_10$1)
                    ]),
                    createBaseVNode("div", {
                      class: "chat-item-content",
                      onClick: ($event) => selectChat(chat.id)
                    }, [
                      editingChatId.value === chat.id ? (openBlock(), createElementBlock("div", _hoisted_12, [
                        withDirectives(createBaseVNode("input", {
                          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => editTitle.value = $event),
                          type: "text",
                          onClick: _cache[2] || (_cache[2] = withModifiers(() => {
                          }, ["stop"])),
                          onKeydown: (e) => handleKeyDown(e, chat.id),
                          onBlur: ($event) => saveEdit($event, chat.id),
                          class: "chat-title-input",
                          ref_for: true,
                          ref: "editInput"
                        }, null, 40, _hoisted_13), [
                          [vModelText, editTitle.value]
                        ])
                      ])) : (openBlock(), createElementBlock("div", _hoisted_14, [
                        createBaseVNode("div", _hoisted_15, toDisplayString(chat.title), 1),
                        createBaseVNode("div", _hoisted_16, toDisplayString(formatDate(chat.timestamp)), 1)
                      ]))
                    ], 8, _hoisted_11)
                  ], 42, _hoisted_7$1);
                }), 128))
              ]))
            ])
          ])
        ])) : createCommentVNode("", true);
      };
    }
  });
  const _style_0$3 = "\n.chat-history-overlay[data-v-099e7435] {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: rgba(0, 0, 0, 0.5);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1000;\n}\n.chat-history-modal[data-v-099e7435] {\n  background-color: white;\n  border-radius: 12px;\n  width: 90%;\n  max-width: 500px;\n  height: 90vh;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n}\n.chat-history-header[data-v-099e7435] {\n  padding: 20px;\n  border-bottom: 1px solid #e5e7eb;\n  position: relative;\n}\n.chat-history-title[data-v-099e7435] {\n  color: #003274;\n  font-size: 24px;\n  font-weight: 600;\n  margin: 0;\n}\n.chat-history-subtitle[data-v-099e7435] {\n  color: #93a3bc;\n  font-size: 18px;\n  margin-top: 4px;\n}\n.chat-history-close[data-v-099e7435] {\n  position: absolute;\n  top: 20px;\n  right: 20px;\n  width: 15px;\n  height: 15px;\n  cursor: pointer;\n}\n.chat-history-search-container[data-v-099e7435] {\n  padding: 12px 20px;\n  border-bottom: 1px solid #e5e7eb;\n}\n.chat-history-search-input[data-v-099e7435] {\n  width: 100%;\n  padding: 8px 12px;\n  border: 1px solid #e5e7eb;\n  border-radius: 4px;\n  font-size: 14px;\n  outline: none;\n  box-sizing: border-box;\n}\n.chat-history-search-input[data-v-099e7435]:focus {\n  border-color: #003274;\n}\n.chat-history-content[data-v-099e7435] {\n  flex: 1;\n  overflow-y: auto;\n  padding: 20px;\n}\n.chat-history-empty-container[data-v-099e7435] {\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  text-align: center;\n  color: #6b7280;\n}\n.chat-history-empty[data-v-099e7435] {\n  padding: 20px;\n}\n.chat-history-empty p[data-v-099e7435] {\n  margin: 4px 0;\n}\n.chat-history-list[data-v-099e7435] {\n  display: flex;\n  flex-direction: column;\n  gap: 12px;\n}\n.chat-history-item[data-v-099e7435] {\n  position: relative;\n  background-color: #e7eef7;\n  border-radius: 8px;\n  padding: 16px;\n  padding-right: 32px;\n  cursor: pointer;\n  transition: all 0.2s ease;\n}\n.chat-history-item.active[data-v-099e7435] {\n  background-color: #b8cce8;\n}\n.chat-item-actions[data-v-099e7435] {\n  position: absolute;\n  top: 8px;\n  right: 8px;\n  z-index: 1;\n  display: flex;\n  gap: 8px;\n}\n.action-icon[data-v-099e7435] {\n  width: 16px;\n  height: 16px;\n  cursor: pointer;\n  opacity: 0;\n  transition: opacity 0.2s ease;\n}\n.chat-history-item:hover .action-icon[data-v-099e7435] {\n  opacity: 0.6;\n}\n.action-icon[data-v-099e7435]:hover {\n  opacity: 1 !important;\n}\n.chat-title-edit[data-v-099e7435] {\n  margin-right: 40px;\n}\n.chat-title-input[data-v-099e7435] {\n  width: 100%;\n  padding: 4px 8px;\n  border: 1px solid #003274;\n  border-radius: 4px;\n  font-size: 14px;\n  background: white;\n  color: #003274;\n}\n.chat-title-input[data-v-099e7435]:focus {\n  outline: none;\n  border-color: #003274;\n  box-shadow: 0 0 0 2px rgba(0, 50, 116, 0.1);\n}\n.chat-title[data-v-099e7435] {\n  font-size: 16px;\n  color: #1f2937;\n  font-weight: 500;\n  margin-bottom: 4px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.chat-date[data-v-099e7435] {\n  font-size: 12px;\n  color: #6b7280;\n}\n\n/* Scrollbar styling */\n.chat-history-content[data-v-099e7435]::-webkit-scrollbar {\n  width: 6px;\n}\n.chat-history-content[data-v-099e7435]::-webkit-scrollbar-track {\n  background: transparent;\n}\n.chat-history-content[data-v-099e7435]::-webkit-scrollbar-thumb {\n  background: #ddd;\n  border-radius: 3px;\n}\n.chat-history-content[data-v-099e7435]::-webkit-scrollbar-thumb:hover {\n  background: #c4c4c4;\n}\n";
  const _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };
  const ChatHistory = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["styles", [_style_0$3]], ["__scopeId", "data-v-099e7435"]]);
  const _hoisted_1$2 = {
    key: 0,
    class: "help-overlay"
  };
  const _hoisted_2$2 = { class: "help-modal" };
  const _hoisted_3$2 = { class: "help-content" };
  const _hoisted_4$1 = ["onMouseenter", "onMouseleave", "onClick"];
  const _hoisted_5$1 = { class: "help-question" };
  const _hoisted_6$1 = {
    key: 0,
    class: "help-answer"
  };
  const _sfc_main$2 = /* @__PURE__ */ defineComponent({
    __name: "HelpDialog",
    setup(__props, { expose: __expose }) {
      const isVisible = ref(false);
      const show = () => {
        isVisible.value = true;
      };
      const hide = () => {
        isVisible.value = false;
        helpItems.forEach((item) => item.isExpanded = false);
      };
      const helpItems = reactive([
        {
          id: 1,
          question: "Who is TeacherAIde?",
          answer: "TeacherAIde is a helpful assistant designed to support teachers in their daily tasks.",
          isExpanded: false,
          isHovered: false
        },
        {
          id: 2,
          question: "How to copy answer?",
          answer: "Click the copy icon (clipboard symbol) below any message to copy its content.",
          isExpanded: false,
          isHovered: false
        },
        {
          id: 3,
          question: "How to regenerate answer?",
          answer: "Click the refresh icon below any message to generate a new response.",
          isExpanded: false,
          isHovered: false
        },
        {
          id: 4,
          question: "How to insert answer to editor?",
          answer: "Click the share icon below any message to insert it into your current document.",
          isExpanded: false,
          isHovered: false
        },
        {
          id: 5,
          question: "How to retrieve chat history?",
          answer: "Click the list icon at the bottom left of the screen to view your chat history.",
          isExpanded: false,
          isHovered: false
        },
        {
          id: 6,
          question: "How to edit or delete chat history?",
          answer: "In the chat history view, you can click the pen icon to edit chat session name or click the bin icon to delete the chat session from the chat history.",
          isExpanded: false,
          isHovered: false
        }
      ]);
      const toggleItem = (item) => {
        item.isExpanded = !item.isExpanded;
      };
      __expose({ show, hide });
      return (_ctx, _cache) => {
        return isVisible.value ? (openBlock(), createElementBlock("div", _hoisted_1$2, [
          createBaseVNode("div", _hoisted_2$2, [
            createBaseVNode("div", { class: "help-header" }, [
              _cache[0] || (_cache[0] = createBaseVNode("h2", { class: "help-title" }, "TeacherAIde", -1)),
              _cache[1] || (_cache[1] = createBaseVNode("div", { class: "help-subtitle" }, "Help", -1)),
              createBaseVNode("img", {
                onClick: hide,
                src: _imports_0,
                alt: "close",
                class: "help-close"
              })
            ]),
            createBaseVNode("div", _hoisted_3$2, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(helpItems, (item) => {
                return openBlock(), createElementBlock("div", {
                  key: item.id,
                  class: normalizeClass(["help-item", {
                    active: item.isHovered,
                    expanded: item.isExpanded
                  }]),
                  onMouseenter: ($event) => item.isHovered = true,
                  onMouseleave: ($event) => item.isHovered = false,
                  onClick: ($event) => toggleItem(item)
                }, [
                  createBaseVNode("div", _hoisted_5$1, toDisplayString(item.id) + ". " + toDisplayString(item.question), 1),
                  item.isExpanded ? (openBlock(), createElementBlock("div", _hoisted_6$1, toDisplayString(item.answer), 1)) : createCommentVNode("", true)
                ], 42, _hoisted_4$1);
              }), 128))
            ])
          ])
        ])) : createCommentVNode("", true);
      };
    }
  });
  const _style_0$2 = "\n.help-overlay[data-v-c830c8ad] {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: rgba(0, 0, 0, 0.5);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1000;\n}\n.help-modal[data-v-c830c8ad] {\n  background-color: white;\n  border-radius: 12px;\n  width: 90%;\n  max-width: 500px;\n  height: 90vh;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n}\n.help-header[data-v-c830c8ad] {\n  padding: 20px;\n  border-bottom: 1px solid #e5e7eb;\n  position: relative;\n}\n.help-title[data-v-c830c8ad] {\n  color: #003274;\n  font-size: 24px;\n  font-weight: 600;\n  margin: 0;\n}\n.help-subtitle[data-v-c830c8ad] {\n  color: #93a3bc;\n  font-size: 18px;\n  margin-top: 4px;\n}\n.help-close[data-v-c830c8ad] {\n  position: absolute;\n  top: 20px;\n  right: 20px;\n  width: 15px;\n  height: 15px;\n  cursor: pointer;\n}\n.help-content[data-v-c830c8ad] {\n  flex: 1;\n  overflow-y: auto;\n  padding: 20px;\n}\n.help-item[data-v-c830c8ad] {\n  background-color: #e7eef7;\n  border-radius: 8px;\n  padding: 16px;\n  margin-bottom: 12px;\n  cursor: pointer;\n  transition: all 0.2s ease;\n}\n.help-item.active[data-v-c830c8ad] {\n  background-color: #b8cce8;\n}\n.help-item.expanded[data-v-c830c8ad] {\n  background-color: #b8cce8;\n}\n.help-question[data-v-c830c8ad] {\n  font-size: 16px;\n  color: #003274;\n  font-weight: 500;\n}\n.help-answer[data-v-c830c8ad] {\n  margin-top: 12px;\n  padding-top: 12px;\n  border-top: 1px solid rgba(0, 50, 116, 0.1);\n  color: #4a5568;\n  font-size: 14px;\n  line-height: 1.4;\n}\n\n/* Hover effects */\n.help-close[data-v-c830c8ad]:hover {\n  opacity: 0.8;\n}\n";
  const HelpDialog = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["styles", [_style_0$2]], ["__scopeId", "data-v-c830c8ad"]]);
  const _hoisted_1$1 = { class: "chat-container" };
  const _hoisted_2$1 = { class: "messages-container" };
  const _hoisted_3$1 = {
    key: 0,
    class: "empty-state"
  };
  const _hoisted_4 = {
    key: 0,
    class: "user-message"
  };
  const _hoisted_5 = { class: "message-content" };
  const _hoisted_6 = {
    key: 1,
    class: "assistant-message"
  };
  const _hoisted_7 = ["innerHTML"];
  const _hoisted_8 = { class: "bottom-container" };
  const _hoisted_9 = { class: "input-wrapper" };
  const _hoisted_10 = { class: "input-area" };
  const _sfc_main$1 = /* @__PURE__ */ defineComponent({
    __name: "SimpleChat",
    props: {
      textMessage: { type: String }
    },
    emits: ["back-to-home"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit2 = __emit;
      const chatbox = useChatboxStore();
      const { client, systemPrompt } = useAI();
      const chatHistoryRef = ref(null);
      const helpDialogRef = ref(null);
      new AbortController();
      const sendMessage = async () => {
        if (!chatbox.newMessage) return;
        const userMessage = chatbox.newMessage;
        chatbox.addMessage({
          content: userMessage,
          role: "user"
        });
        chatbox.clearNewMessage();
        try {
          const messages = chatbox.messages;
          const response = await client.chat.completions.create({
            model: chatbox.selectedModel,
            messages,
            max_tokens: chatbox.maxTokens
          });
          if (response.choices[0].message.content) {
            chatbox.addMessage({
              content: response.choices[0].message.content,
              role: "assistant"
            });
          }
        } catch (error) {
          console.error("Failed to send message:", error);
        }
      };
      const goHome = async (event) => {
        try {
          chatbox.clearMessages();
          chatbox.clearNewMessage();
          chatbox.currentChatId = "";
          emit2("back-to-home");
        } catch (err) {
          console.error("Failed to return to home:", err);
        }
      };
      const onLoadChat = (chat) => {
        chatbox.currentChatId = chat.id;
        chatbox.setUserMessages(chat.messages);
        chatbox.clearNewMessage();
      };
      const copyText = async (event) => {
        var _a2;
        try {
          const messageElement = (_a2 = event.target.closest(".assistant-message")) == null ? void 0 : _a2.querySelector(".message-content");
          if (messageElement) {
            const textContent = messageElement.textContent || "";
            await navigator.clipboard.writeText(textContent);
            alert("Message copied to clipboard!");
          } else {
            console.warn("Message content not found");
          }
        } catch (err) {
          console.error("Failed to copy:", err);
          alert("Failed to copy message. Please try again.");
        }
      };
      const refreshText = async (event) => {
        try {
          console.log("Refreshing response...");
          const messageWrappers = document.querySelectorAll(".message-wrapper");
          const currentWrapper = event.target.closest(".message-wrapper");
          if (!currentWrapper) {
            console.warn("Could not find message wrapper");
            return;
          }
          const messageIndex = Array.from(messageWrappers).indexOf(currentWrapper);
          console.log("Message wrapper index:", messageIndex);
          if (messageIndex === -1) {
            console.warn("Could not find message index");
            return;
          }
          const messagesUpToThis = chatbox.messages.slice(0, messageIndex);
          console.log("Messages up to this:", messagesUpToThis);
          const response = await client.chat.completions.create({
            model: chatbox.selectedModel,
            messages: [
              ...chatbox.systemPrompt ? [{ role: "system", content: chatbox.systemPrompt }] : [],
              ...messagesUpToThis
            ],
            max_tokens: chatbox.maxTokens,
            temperature: 1,
            presence_penalty: 0.6,
            frequency_penalty: 0.6,
            top_p: 0.9
          });
          if (!response.choices[0].message.content) {
            throw new Error("No response content received");
          }
          const updatedMessages = chatbox.userMessages.map((msg, idx) => {
            if (idx === messageIndex) {
              return {
                content: response.choices[0].message.content,
                role: "assistant"
              };
            }
            return msg;
          });
          chatbox.clearMessages();
          updatedMessages.forEach((msg) => chatbox.addMessage(msg));
        } catch (err) {
          console.error("Failed to refresh response:", err);
          alert("Failed to generate new response. Please try again.");
        }
      };
      const shareText = async (event) => {
      };
      const displayChatHistory = async (event) => {
        try {
          if (!chatHistoryRef.value) {
            console.warn("Chat history component not initialized");
            return;
          }
          await chatHistoryRef.value.show();
          console.log("Chat history displayed successfully");
        } catch (err) {
          console.error("Failed to display chat history:", err);
          alert("Failed to open chat history. Please try again.");
        }
      };
      const displayHelp = async (event) => {
        try {
          if (!helpDialogRef.value) {
            console.warn("Help dialog component not initialized");
            return;
          }
          await helpDialogRef.value.show();
          console.log("Help dialog displayed successfully");
        } catch (err) {
          console.error("Failed to display help dialog:", err);
          alert("Failed to open help. Please try again.");
        }
      };
      onMounted(() => {
        if (props.textMessage) {
          chatbox.newMessage = props.textMessage;
          sendMessage();
        }
      });
      const handleClose = () => {
        console.log(`close window`);
        let chatwindow = document.getElementById("chat-screen");
        if (chatwindow) {
          chatwindow.style.display = "none";
        }
      };
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$1, [
          createBaseVNode("div", { class: "header" }, [
            _cache[2] || (_cache[2] = createBaseVNode("h2", { class: "title" }, "TeacherAIde", -1)),
            createBaseVNode("img", {
              onClick: handleClose,
              src: _imports_0,
              alt: "close",
              class: "close-icon",
              title: "close"
            })
          ]),
          createBaseVNode("div", _hoisted_2$1, [
            unref(chatbox).messages.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_3$1, _cache[3] || (_cache[3] = [
              createBaseVNode("p", null, "You are a helpful assistant that aids teachers.", -1)
            ]))) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(chatbox).messages, (message, index) => {
              return openBlock(), createElementBlock("div", {
                key: index,
                class: "message-wrapper"
              }, [
                message.role === "user" ? (openBlock(), createElementBlock("div", _hoisted_4, [
                  createBaseVNode("div", _hoisted_5, toDisplayString(message.content), 1)
                ])) : createCommentVNode("", true),
                message.role === "assistant" ? (openBlock(), createElementBlock("div", _hoisted_6, [
                  _cache[4] || (_cache[4] = createBaseVNode("div", { class: "assistant-label" }, "TeacherAIde:", -1)),
                  createBaseVNode("div", {
                    class: "message-content",
                    innerHTML: unref(marked).parse(message.content)
                  }, null, 8, _hoisted_7),
                  createBaseVNode("div", {
                    class: "message-actions",
                    onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    createBaseVNode("img", {
                      onClick: copyText,
                      src: _imports_1$1,
                      alt: "copy",
                      class: "action-icon",
                      title: "Copy to clipboard"
                    }),
                    createBaseVNode("img", {
                      onClick: refreshText,
                      src: _imports_2$1,
                      alt: "refresh",
                      class: "action-icon",
                      title: "Regenerate response"
                    }),
                    createBaseVNode("img", {
                      onClick: shareText,
                      src: _imports_3,
                      alt: "share",
                      class: "action-icon",
                      title: "Copy to editor"
                    })
                  ])
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ]),
          createBaseVNode("div", _hoisted_8, [
            createBaseVNode("div", _hoisted_9, [
              createBaseVNode("div", _hoisted_10, [
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(chatbox).newMessage = $event),
                  onKeyup: withKeys(sendMessage, ["enter"]),
                  type: "text",
                  placeholder: "Ask TeacherAIde...",
                  class: "message-input"
                }, null, 544), [
                  [vModelText, unref(chatbox).newMessage]
                ]),
                createBaseVNode("img", {
                  onClick: sendMessage,
                  src: _imports_1$2,
                  alt: "send",
                  class: "send-icon",
                  title: "send"
                })
              ])
            ]),
            createBaseVNode("div", { class: "navigation" }, [
              createBaseVNode("img", {
                onClick: displayChatHistory,
                src: _imports_2$2,
                alt: "chat history",
                class: "nav-icon",
                title: "Chat history"
              }),
              createBaseVNode("img", {
                onClick: goHome,
                src: _imports_3$1,
                alt: "home",
                class: "nav-icon",
                title: "Start new chat"
              }),
              createBaseVNode("img", {
                onClick: displayHelp,
                src: _imports_4,
                alt: "help",
                class: "nav-icon",
                title: "Help"
              })
            ])
          ]),
          createVNode(ChatHistory, {
            ref_key: "chatHistoryRef",
            ref: chatHistoryRef,
            onLoadChat
          }, null, 512),
          createVNode(HelpDialog, {
            ref_key: "helpDialogRef",
            ref: helpDialogRef
          }, null, 512)
        ]);
      };
    }
  });
  const _style_0$1 = "\n.chat-container[data-v-386c3801] {\n  width: 90%;\n  max-width: 500px;\n  height: 90vh;\n  margin: 20px auto;\n  background: white;\n  border-radius: 12px;\n  display: flex;\n  flex-direction: column;\n  border: 1px solid #e5e7eb;\n  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n}\n.header[data-v-386c3801] {\n  padding: 16px 20px;\n  border-bottom: 1px solid #e5e7eb;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n.title[data-v-386c3801] {\n  color: #003274;\n  font-size: 24px;\n  font-weight: 600;\n  margin: 0;\n}\n.close-icon[data-v-386c3801] {\n  width: 15px;\n  height: 15px;\n  cursor: pointer;\n}\n.messages-container[data-v-386c3801] {\n  flex: 1;\n  overflow-y: auto;\n  padding: 16px 20px;\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n}\n.message-wrapper[data-v-386c3801] {\n  margin-bottom: 8px;\n  width: 100%;\n}\n.user-message[data-v-386c3801] {\n  margin-bottom: 4px;\n}\n.user-message .message-content[data-v-386c3801] {\n  color: #003274;\n  text-align: left;\n  font-weight: 800;\n}\n.assistant-message[data-v-386c3801] {\n  background-color: #f8f9fa;\n  padding: 16px 20px;\n  margin: 0 -20px;\n  position: relative;\n}\n.assistant-label[data-v-386c3801] {\n  color: #003274;\n  font-weight: 800;\n  margin-bottom: 4px;\n}\n.assistant-message .message-content[data-v-386c3801] {\n  color: #000000;\n  text-align: left;\n  margin-bottom: 24px;\n}\n.message-content[data-v-386c3801] {\n  line-height: 1.4;\n  white-space: pre-wrap;\n}\n.message-actions[data-v-386c3801] {\n  position: absolute;\n  bottom: 8px;\n  left: 20px;\n  display: flex;\n  gap: 16px;\n  align-items: center;\n}\n.action-icon[data-v-386c3801] {\n  width: 16px;\n  height: 16px;\n  cursor: pointer;\n  filter: brightness(0);\n  opacity: 0.8;\n  transition: opacity 0.2s ease;\n  padding: 2px;\n}\n.bottom-container[data-v-386c3801] {\n  margin-top: auto;\n}\n.input-wrapper[data-v-386c3801] {\n  padding: 0 20px;\n  margin-bottom: 8px;\n}\n.input-area[data-v-386c3801] {\n  background-color: #003274;\n  border-radius: 25px;\n  display: flex;\n  align-items: center;\n  padding: 8px 16px;\n}\n.message-input[data-v-386c3801] {\n  flex: 1;\n  padding: 8px;\n  border: none;\n  background: transparent;\n  color: white;\n  outline: none;\n  font-size: 14px;\n}\n.message-input[data-v-386c3801]::-moz-placeholder {\n  color: #ffffff;\n  opacity: 0.8;\n}\n.message-input[data-v-386c3801]::placeholder {\n  color: #ffffff;\n  opacity: 0.8;\n}\n.send-icon[data-v-386c3801] {\n  width: 20px;\n  height: 20px;\n  cursor: pointer;\n  margin-left: 8px;\n}\n.navigation[data-v-386c3801] {\n  background: #f8f9fa;\n  padding: 12px 20px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  border-top: 1px solid #e5e7eb;\n  border-bottom-left-radius: 12px;\n  border-bottom-right-radius: 12px;\n}\n.nav-icon[data-v-386c3801] {\n  width: 24px;\n  height: 24px;\n  cursor: pointer;\n  transition: opacity 0.2s ease;\n}\n.nav-icon[data-v-386c3801]:hover,\n.send-icon[data-v-386c3801]:hover,\n.close-icon[data-v-386c3801]:hover {\n  opacity: 0.8;\n}\n.messages-container[data-v-386c3801]::-webkit-scrollbar {\n  width: 6px;\n}\n.messages-container[data-v-386c3801]::-webkit-scrollbar-track {\n  background: transparent;\n}\n.messages-container[data-v-386c3801]::-webkit-scrollbar-thumb {\n  background: #ddd;\n  border-radius: 3px;\n}\n";
  const SimpleChat = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["styles", [_style_0$1]], ["__scopeId", "data-v-386c3801"]]);
  const _hoisted_1 = {
    key: 0,
    class: "home-container"
  };
  const _hoisted_2 = { class: "content-container" };
  const _hoisted_3 = { class: "input-container" };
  const _sfc_main = /* @__PURE__ */ defineComponent({
    __name: "HomeScreen",
    setup(__props) {
      const showChat = ref(false);
      const inputMessage = ref("");
      const chatHistoryRef = ref(null);
      const helpDialogRef = ref(null);
      const displayChatHistory = async () => {
        var _a2;
        (_a2 = chatHistoryRef.value) == null ? void 0 : _a2.show();
      };
      const displayHelp = async () => {
        var _a2;
        (_a2 = helpDialogRef.value) == null ? void 0 : _a2.show();
      };
      const handleAskTeacher = () => {
        if (inputMessage.value.trim()) {
          showChat.value = true;
        }
      };
      const handleClose = () => {
        showChat.value = false;
        inputMessage.value = "";
      };
      const backToHome = () => {
        showChat.value = false;
        inputMessage.value = "";
      };
      return (_ctx, _cache) => {
        return !showChat.value ? (openBlock(), createElementBlock("div", _hoisted_1, [
          createBaseVNode("img", {
            onClick: handleClose,
            src: _imports_0,
            alt: "close",
            class: "close-icon"
          }),
          createBaseVNode("div", _hoisted_2, [
            _cache[1] || (_cache[1] = createBaseVNode("h1", { class: "title" }, "TeacherAIde", -1)),
            _cache[2] || (_cache[2] = createBaseVNode("p", { class: "subtitle" }, "Your personal teaching assistant", -1)),
            createBaseVNode("div", _hoisted_3, [
              withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => inputMessage.value = $event),
                type: "text",
                placeholder: "Ask TeacherAIde...",
                class: "ask-input",
                onKeyup: withKeys(handleAskTeacher, ["enter"])
              }, null, 544), [
                [vModelText, inputMessage.value]
              ]),
              createBaseVNode("img", {
                onClick: handleAskTeacher,
                src: _imports_1$2,
                alt: "send",
                class: "send-icon"
              })
            ])
          ]),
          createBaseVNode("div", { class: "navigation" }, [
            createBaseVNode("img", {
              onClick: displayChatHistory,
              src: _imports_2$2,
              alt: "chat history",
              class: "nav-icon",
              title: "Chat history"
            }),
            _cache[3] || (_cache[3] = createBaseVNode("img", {
              src: _imports_3$1,
              alt: "home",
              class: "nav-icon active",
              title: "Home"
            }, null, -1)),
            createBaseVNode("img", {
              onClick: displayHelp,
              src: _imports_4,
              alt: "help",
              class: "nav-icon",
              title: "Help"
            })
          ]),
          createVNode(ChatHistory, {
            ref_key: "chatHistoryRef",
            ref: chatHistoryRef
          }, null, 512),
          createVNode(HelpDialog, {
            ref_key: "helpDialogRef",
            ref: helpDialogRef
          }, null, 512)
        ])) : (openBlock(), createBlock(SimpleChat, {
          key: 1,
          "text-message": inputMessage.value,
          onBackToHome: backToHome
        }, null, 8, ["text-message"]));
      };
    }
  });
  const _style_0 = "\n.home-container[data-v-48677201] {\n  width: 90%;\n  max-width: 500px;\n  height: 90vh;\n  margin: 20px auto;\n  background: white;\n  border-radius: 12px;\n  display: flex;\n  flex-direction: column;\n  position: relative;\n  border: 1px solid #e5e7eb;\n  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n}\n.close-icon[data-v-48677201] {\n  position: absolute;\n  top: 20px;\n  right: 20px;\n  width: 15px;\n  height: 15px;\n  cursor: pointer;\n}\n.content-container[data-v-48677201] {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  padding: 20px;\n}\n.title[data-v-48677201] {\n  color: #003274;\n  font-size: 32px;\n  font-weight: 600;\n  margin: 0;\n}\n.subtitle[data-v-48677201] {\n  color: #666;\n  margin-top: 8px;\n}\n.input-container[data-v-48677201] {\n  margin-top: 24px;\n  width: calc(100% - 40px);\n  max-width: 400px;\n  position: relative;\n}\n.ask-input[data-v-48677201] {\n  width: calc(100% - 40px);\n  padding: 12px 20px 12px 20px;\n  border-radius: 25px;\n  border: none;\n  background-color: #003274;\n  color: white;\n  font-size: 16px;\n  outline: none;\n}\n.ask-input[data-v-48677201]::-moz-placeholder {\n  color: rgba(255, 255, 255, 0.8);\n}\n.ask-input[data-v-48677201]::placeholder {\n  color: rgba(255, 255, 255, 0.8);\n}\n.send-icon[data-v-48677201] {\n  position: absolute;\n  right: 12px;\n  top: 50%;\n  transform: translateY(-50%);\n  width: 24px;\n  height: 24px;\n  cursor: pointer;\n}\n.navigation[data-v-48677201] {\n  padding: 12px 20px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  border-top: 1px solid #e5e7eb;\n}\n.nav-icon[data-v-48677201] {\n  width: 24px;\n  height: 24px;\n  cursor: pointer;\n  opacity: 0.5;\n}\n.nav-icon.active[data-v-48677201] {\n  opacity: 1;\n}\n";
  const HomeScreen = /* @__PURE__ */ _export_sfc(_sfc_main, [["styles", [_style_0]], ["__scopeId", "data-v-48677201"]]);
  async function fetchThroughlocalTeacheraideOpenAIGateway({
    endpoint,
    method,
    params
  }) {
    return ajax.call([
      {
        methodname: "local_teacheraide_openai_gateway",
        args: {
          endpoint,
          method,
          params
        }
      }
    ])[0];
  }
  const wwwroot = M.cfg.wwwroot;
  const webserviceBaseUrl = `${wwwroot}/webservice/restful/server.php/local_teacheraide_openai_gateway`;
  const webserviceFetch = async (url, init2) => {
    const endpoint = `${url}`.replace(webserviceBaseUrl, "");
    const method = init2 == null ? void 0 : init2.method;
    const body = init2 == null ? void 0 : init2.body;
    const res = await fetchThroughlocalTeacheraideOpenAIGateway({
      endpoint,
      method,
      params: body
    });
    return new Response(res.data, {
      // create standard Response object
      status: 200,
      headers: {
        "Content-Type": "application/json"
      }
    });
  };
  async function init({ systemPrompt }) {
    const client = new OpenAI({
      baseURL: webserviceBaseUrl,
      apiKey: "dummy",
      // This is a dummy API key, as the API key is not needed for using the webservice
      dangerouslyAllowBrowser: true,
      fetch: webserviceFetch
    });
    const configureApp = configureAppWithProviders({ client, systemPrompt });
    customElements.define(
      "teacheraide-simple-chat",
      /* @__PURE__ */ defineCustomElement(HomeScreen, { configureApp })
    );
  }
  exports.init = init;
  Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwLWxhenkuanMiLCJzb3VyY2VzIjpbIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L25vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWNvcmUvbm9kZV9tb2R1bGVzL0B2dWUvc2hhcmVkL2Rpc3Qvc2hhcmVkLmVzbS1idW5kbGVyLmpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9kaXN0L3J1bnRpbWUtY29yZS5lc20tYnVuZGxlci5qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWRvbS9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1kb20vZGlzdC9ydW50aW1lLWRvbS5lc20tYnVuZGxlci5qcyIsIi4uLy4uL3Z1ZS9zcmMvYXNzZXRzL2Nsb3NlX2ljb24uc3ZnIiwiLi4vLi4vdnVlL3NyYy9hc3NldHMvc2VuZF9pY29uXzMuc3ZnIiwiLi4vLi4vdnVlL3NyYy9hc3NldHMvbGlzdF9pY29uLnN2ZyIsIi4uLy4uL3Z1ZS9zcmMvYXNzZXRzL2hvbWVfaWNvbi5zdmciLCIuLi8uLi92dWUvc3JjL2Fzc2V0cy9oZWxwX2ljb24uc3ZnIiwiLi4vLi4vdnVlL3NyYy9hc3NldHMvY29weV9pY29uLnN2ZyIsIi4uLy4uL3Z1ZS9zcmMvYXNzZXRzL3JlZnJlc2hfaWNvbi5zdmciLCIuLi8uLi92dWUvc3JjL2Fzc2V0cy9zaGFyZV9pY29uLnN2ZyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3ZlcnNpb24ubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvX3NoaW1zL3JlZ2lzdHJ5Lm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL19zaGltcy9NdWx0aXBhcnRCb2R5Lm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL19zaGltcy93ZWItcnVudGltZS5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9fc2hpbXMvaW5kZXgubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvc3RyZWFtaW5nLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3VwbG9hZHMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvY29yZS5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9lcnJvci5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9wYWdpbmF0aW9uLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9jaGF0L2NoYXQubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2F1ZGlvL3NwZWVjaC5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9yZXNvdXJjZXMvYXVkaW8vdHJhbnNjcmlwdGlvbnMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2F1ZGlvL3RyYW5zbGF0aW9ucy5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9yZXNvdXJjZXMvYXVkaW8vYXVkaW8ubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2JhdGNoZXMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2JldGEvYXNzaXN0YW50cy5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9saWIvUnVubmFibGVGdW5jdGlvbi5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9saWIvY2hhdENvbXBsZXRpb25VdGlscy5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9saWIvRXZlbnRTdHJlYW0ubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvbGliL3BhcnNlci5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9saWIvQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lci5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9saWIvQ2hhdENvbXBsZXRpb25SdW5uZXIubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvX3ZlbmRvci9wYXJ0aWFsLWpzb24tcGFyc2VyL3BhcnNlci5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9saWIvQ2hhdENvbXBsZXRpb25TdHJlYW0ubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9iZXRhL2NoYXQvY29tcGxldGlvbnMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2JldGEvY2hhdC9jaGF0Lm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL2xpYi9Bc3Npc3RhbnRTdHJlYW0ubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2JldGEvdGhyZWFkcy9tZXNzYWdlcy5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9yZXNvdXJjZXMvYmV0YS90aHJlYWRzL3J1bnMvc3RlcHMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2JldGEvdGhyZWFkcy9ydW5zL3J1bnMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2JldGEvdGhyZWFkcy90aHJlYWRzLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL2xpYi9VdGlsLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9iZXRhL3ZlY3Rvci1zdG9yZXMvZmlsZXMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2JldGEvdmVjdG9yLXN0b3Jlcy9maWxlLWJhdGNoZXMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2JldGEvdmVjdG9yLXN0b3Jlcy92ZWN0b3Itc3RvcmVzLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9iZXRhL2JldGEubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2NvbXBsZXRpb25zLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9lbWJlZGRpbmdzLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9maWxlcy5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9yZXNvdXJjZXMvZmluZS10dW5pbmcvam9icy9jaGVja3BvaW50cy5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9yZXNvdXJjZXMvZmluZS10dW5pbmcvam9icy9qb2JzLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9maW5lLXR1bmluZy9maW5lLXR1bmluZy5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9yZXNvdXJjZXMvaW1hZ2VzLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9tb2RlbHMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL21vZGVyYXRpb25zLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy91cGxvYWRzL3BhcnRzLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy91cGxvYWRzL3VwbG9hZHMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvaW5kZXgubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy92dWUtZGVtaS9saWIvaW5kZXgubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9waW5pYS9kaXN0L3BpbmlhLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvdXRpbC5qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvbWV0aG9kcy9uYXRpdmUuanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29ibGl2aW91cy1zZXQvZGlzdC9lc20vc3JjL2luZGV4LmpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9icm9hZGNhc3QtY2hhbm5lbC9kaXN0L2VzYnJvd3Nlci9vcHRpb25zLmpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9icm9hZGNhc3QtY2hhbm5lbC9kaXN0L2VzYnJvd3Nlci9tZXRob2RzL2luZGV4ZWQtZGIuanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL2Jyb2FkY2FzdC1jaGFubmVsL2Rpc3QvZXNicm93c2VyL21ldGhvZHMvbG9jYWxzdG9yYWdlLmpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9icm9hZGNhc3QtY2hhbm5lbC9kaXN0L2VzYnJvd3Nlci9tZXRob2RzL3NpbXVsYXRlLmpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9icm9hZGNhc3QtY2hhbm5lbC9kaXN0L2VzYnJvd3Nlci9tZXRob2QtY2hvb3Nlci5qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvYnJvYWRjYXN0LWNoYW5uZWwuanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL3BpbmlhLXNoYXJlZC1zdGF0ZS9kaXN0L2luZGV4LmpzIiwiLi4vLi4vdnVlL3NyYy9wcm92aWRlci50cyIsIi4uLy4uL3Z1ZS9zcmMvc3RvcmUvY2hhdGJveC50cyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuZXNtLmpzIiwiLi4vLi4vdnVlL3NyYy9hc3NldHMvZWRpdF9pY29uLnN2ZyIsIi4uLy4uL3Z1ZS9zcmMvYXNzZXRzL3RyYXNoX2ljb24uc3ZnIiwiLi4vLi4vdnVlL3NyYy9jb21wb25lbnRzL0NoYXRIaXN0b3J5LnZ1ZSIsIi4uLy4uL3Z1ZS9zcmMvY29tcG9uZW50cy9IZWxwRGlhbG9nLnZ1ZSIsIi4uLy4uL3Z1ZS9zcmMvY29tcG9uZW50cy9TaW1wbGVDaGF0LnZ1ZSIsIi4uLy4uL3Z1ZS9zcmMvY29tcG9uZW50cy9Ib21lU2NyZWVuLnZ1ZSIsIi4uLy4uL3Z1ZS9zcmMvd2Vic2VydmljZS50cyIsIi4uLy4uL3Z1ZS9zcmMvbWFpbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiogQHZ1ZS9zaGFyZWQgdjMuNS4wLWJldGEuM1xuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWFrZU1hcChzdHIsIGV4cGVjdHNMb3dlckNhc2UpIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldChzdHIuc3BsaXQoXCIsXCIpKTtcbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2UgPyAodmFsKSA9PiBzZXQuaGFzKHZhbC50b0xvd2VyQ2FzZSgpKSA6ICh2YWwpID0+IHNldC5oYXModmFsKTtcbn1cblxuY29uc3QgRU1QVFlfT0JKID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IE9iamVjdC5mcmVlemUoe30pIDoge307XG5jb25zdCBFTVBUWV9BUlIgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcbmNvbnN0IE5PT1AgPSAoKSA9PiB7XG59O1xuY29uc3QgTk8gPSAoKSA9PiBmYWxzZTtcbmNvbnN0IGlzT24gPSAoa2V5KSA9PiBrZXkuY2hhckNvZGVBdCgwKSA9PT0gMTExICYmIGtleS5jaGFyQ29kZUF0KDEpID09PSAxMTAgJiYgLy8gdXBwZXJjYXNlIGxldHRlclxuKGtleS5jaGFyQ29kZUF0KDIpID4gMTIyIHx8IGtleS5jaGFyQ29kZUF0KDIpIDwgOTcpO1xuY29uc3QgaXNNb2RlbExpc3RlbmVyID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoXCJvblVwZGF0ZTpcIik7XG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcbiAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcbiAgaWYgKGkgPiAtMSkge1xuICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gIH1cbn07XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgTWFwXVwiO1xuY29uc3QgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFNldF1cIjtcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbmNvbnN0IGlzUmVnRXhwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiO1xuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN5bWJvbFwiO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIjtcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIChpc09iamVjdCh2YWwpIHx8IGlzRnVuY3Rpb24odmFsKSkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xufTtcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufTtcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiYga2V5ICE9PSBcIk5hTlwiICYmIGtleVswXSAhPT0gXCItXCIgJiYgXCJcIiArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XG5jb25zdCBpc1Jlc2VydmVkUHJvcCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICAvLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXG4gIFwiLGtleSxyZWYscmVmX2ZvcixyZWZfa2V5LG9uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCxvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLG9uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWRcIlxuKTtcbmNvbnN0IGlzQnVpbHRJbkRpcmVjdGl2ZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBcImJpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0LG1lbW9cIlxuKTtcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChzdHIpID0+IHtcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgfTtcbn07XG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIik7XG4gIH1cbik7XG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgXCItJDFcIikudG9Mb3dlckNhc2UoKVxuKTtcbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn0pO1xuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4ge1xuICAgIGNvbnN0IHMgPSBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGA7XG4gICAgcmV0dXJuIHM7XG4gIH1cbik7XG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpO1xuY29uc3QgaW52b2tlQXJyYXlGbnMgPSAoZm5zLCAuLi5hcmcpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBmbnNbaV0oLi4uYXJnKTtcbiAgfVxufTtcbmNvbnN0IGRlZiA9IChvYmosIGtleSwgdmFsdWUsIHdyaXRhYmxlID0gZmFsc2UpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlLFxuICAgIHZhbHVlXG4gIH0pO1xufTtcbmNvbnN0IGxvb3NlVG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBpc1N0cmluZyh2YWwpID8gTnVtYmVyKHZhbCkgOiBOYU47XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xubGV0IF9nbG9iYWxUaGlzO1xuY29uc3QgZ2V0R2xvYmFsVGhpcyA9ICgpID0+IHtcbiAgcmV0dXJuIF9nbG9iYWxUaGlzIHx8IChfZ2xvYmFsVGhpcyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pO1xufTtcbmNvbnN0IGlkZW50UkUgPSAvXltfJGEtekEtWlxceEEwLVxcdUZGRkZdW18kYS16QS1aMC05XFx4QTAtXFx1RkZGRl0qJC87XG5mdW5jdGlvbiBnZW5Qcm9wc0FjY2Vzc0V4cChuYW1lKSB7XG4gIHJldHVybiBpZGVudFJFLnRlc3QobmFtZSkgPyBgX19wcm9wcy4ke25hbWV9YCA6IGBfX3Byb3BzWyR7SlNPTi5zdHJpbmdpZnkobmFtZSl9XWA7XG59XG5cbmNvbnN0IFBhdGNoRmxhZ3MgPSB7XG4gIFwiVEVYVFwiOiAxLFxuICBcIjFcIjogXCJURVhUXCIsXG4gIFwiQ0xBU1NcIjogMixcbiAgXCIyXCI6IFwiQ0xBU1NcIixcbiAgXCJTVFlMRVwiOiA0LFxuICBcIjRcIjogXCJTVFlMRVwiLFxuICBcIlBST1BTXCI6IDgsXG4gIFwiOFwiOiBcIlBST1BTXCIsXG4gIFwiRlVMTF9QUk9QU1wiOiAxNixcbiAgXCIxNlwiOiBcIkZVTExfUFJPUFNcIixcbiAgXCJORUVEX0hZRFJBVElPTlwiOiAzMixcbiAgXCIzMlwiOiBcIk5FRURfSFlEUkFUSU9OXCIsXG4gIFwiU1RBQkxFX0ZSQUdNRU5UXCI6IDY0LFxuICBcIjY0XCI6IFwiU1RBQkxFX0ZSQUdNRU5UXCIsXG4gIFwiS0VZRURfRlJBR01FTlRcIjogMTI4LFxuICBcIjEyOFwiOiBcIktFWUVEX0ZSQUdNRU5UXCIsXG4gIFwiVU5LRVlFRF9GUkFHTUVOVFwiOiAyNTYsXG4gIFwiMjU2XCI6IFwiVU5LRVlFRF9GUkFHTUVOVFwiLFxuICBcIk5FRURfUEFUQ0hcIjogNTEyLFxuICBcIjUxMlwiOiBcIk5FRURfUEFUQ0hcIixcbiAgXCJEWU5BTUlDX1NMT1RTXCI6IDEwMjQsXG4gIFwiMTAyNFwiOiBcIkRZTkFNSUNfU0xPVFNcIixcbiAgXCJERVZfUk9PVF9GUkFHTUVOVFwiOiAyMDQ4LFxuICBcIjIwNDhcIjogXCJERVZfUk9PVF9GUkFHTUVOVFwiLFxuICBcIkNBQ0hFRFwiOiAtMSxcbiAgXCItMVwiOiBcIkNBQ0hFRFwiLFxuICBcIkJBSUxcIjogLTIsXG4gIFwiLTJcIjogXCJCQUlMXCJcbn07XG5jb25zdCBQYXRjaEZsYWdOYW1lcyA9IHtcbiAgWzFdOiBgVEVYVGAsXG4gIFsyXTogYENMQVNTYCxcbiAgWzRdOiBgU1RZTEVgLFxuICBbOF06IGBQUk9QU2AsXG4gIFsxNl06IGBGVUxMX1BST1BTYCxcbiAgWzMyXTogYE5FRURfSFlEUkFUSU9OYCxcbiAgWzY0XTogYFNUQUJMRV9GUkFHTUVOVGAsXG4gIFsxMjhdOiBgS0VZRURfRlJBR01FTlRgLFxuICBbMjU2XTogYFVOS0VZRURfRlJBR01FTlRgLFxuICBbNTEyXTogYE5FRURfUEFUQ0hgLFxuICBbMTAyNF06IGBEWU5BTUlDX1NMT1RTYCxcbiAgWzIwNDhdOiBgREVWX1JPT1RfRlJBR01FTlRgLFxuICBbLTFdOiBgSE9JU1RFRGAsXG4gIFstMl06IGBCQUlMYFxufTtcblxuY29uc3QgU2hhcGVGbGFncyA9IHtcbiAgXCJFTEVNRU5UXCI6IDEsXG4gIFwiMVwiOiBcIkVMRU1FTlRcIixcbiAgXCJGVU5DVElPTkFMX0NPTVBPTkVOVFwiOiAyLFxuICBcIjJcIjogXCJGVU5DVElPTkFMX0NPTVBPTkVOVFwiLFxuICBcIlNUQVRFRlVMX0NPTVBPTkVOVFwiOiA0LFxuICBcIjRcIjogXCJTVEFURUZVTF9DT01QT05FTlRcIixcbiAgXCJURVhUX0NISUxEUkVOXCI6IDgsXG4gIFwiOFwiOiBcIlRFWFRfQ0hJTERSRU5cIixcbiAgXCJBUlJBWV9DSElMRFJFTlwiOiAxNixcbiAgXCIxNlwiOiBcIkFSUkFZX0NISUxEUkVOXCIsXG4gIFwiU0xPVFNfQ0hJTERSRU5cIjogMzIsXG4gIFwiMzJcIjogXCJTTE9UU19DSElMRFJFTlwiLFxuICBcIlRFTEVQT1JUXCI6IDY0LFxuICBcIjY0XCI6IFwiVEVMRVBPUlRcIixcbiAgXCJTVVNQRU5TRVwiOiAxMjgsXG4gIFwiMTI4XCI6IFwiU1VTUEVOU0VcIixcbiAgXCJDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkVcIjogMjU2LFxuICBcIjI1NlwiOiBcIkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRVwiLFxuICBcIkNPTVBPTkVOVF9LRVBUX0FMSVZFXCI6IDUxMixcbiAgXCI1MTJcIjogXCJDT01QT05FTlRfS0VQVF9BTElWRVwiLFxuICBcIkNPTVBPTkVOVFwiOiA2LFxuICBcIjZcIjogXCJDT01QT05FTlRcIlxufTtcblxuY29uc3QgU2xvdEZsYWdzID0ge1xuICBcIlNUQUJMRVwiOiAxLFxuICBcIjFcIjogXCJTVEFCTEVcIixcbiAgXCJEWU5BTUlDXCI6IDIsXG4gIFwiMlwiOiBcIkRZTkFNSUNcIixcbiAgXCJGT1JXQVJERURcIjogMyxcbiAgXCIzXCI6IFwiRk9SV0FSREVEXCJcbn07XG5jb25zdCBzbG90RmxhZ3NUZXh0ID0ge1xuICBbMV06IFwiU1RBQkxFXCIsXG4gIFsyXTogXCJEWU5BTUlDXCIsXG4gIFszXTogXCJGT1JXQVJERURcIlxufTtcblxuY29uc3QgR0xPQkFMU19BTExPV0VEID0gXCJJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLHBhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LE1hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQsY29uc29sZSxFcnJvcixTeW1ib2xcIjtcbmNvbnN0IGlzR2xvYmFsbHlBbGxvd2VkID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoR0xPQkFMU19BTExPV0VEKTtcbmNvbnN0IGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCA9IGlzR2xvYmFsbHlBbGxvd2VkO1xuXG5jb25zdCByYW5nZSA9IDI7XG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZShzb3VyY2UsIHN0YXJ0ID0gMCwgZW5kID0gc291cmNlLmxlbmd0aCkge1xuICBzdGFydCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHN0YXJ0LCBzb3VyY2UubGVuZ3RoKSk7XG4gIGVuZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGVuZCwgc291cmNlLmxlbmd0aCkpO1xuICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBcIlwiO1xuICBsZXQgbGluZXMgPSBzb3VyY2Uuc3BsaXQoLyhcXHI/XFxuKS8pO1xuICBjb25zdCBuZXdsaW5lU2VxdWVuY2VzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDEpO1xuICBsaW5lcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAwKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAobmV3bGluZVNlcXVlbmNlc1tpXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2ldLmxlbmd0aCB8fCAwKTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbGluZSA9IGogKyAxO1xuICAgICAgICByZXMucHVzaChcbiAgICAgICAgICBgJHtsaW5lfSR7XCIgXCIucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5ld0xpbmVTZXFMZW5ndGggPSBuZXdsaW5lU2VxdWVuY2VzW2pdICYmIG5ld2xpbmVTZXF1ZW5jZXNbal0ubGVuZ3RoIHx8IDA7XG4gICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSAobGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGgpKTtcbiAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIiBcIi5yZXBlYXQocGFkKSArIFwiXlwiLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpLCAxKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGlzU3RyaW5nKGl0ZW0pID8gcGFyc2VTdHJpbmdTdHlsZShpdGVtKSA6IG5vcm1hbGl6ZVN0eWxlKGl0ZW0pO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsaXplZCkge1xuICAgICAgICAgIHJlc1trZXldID0gbm9ybWFsaXplZFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuY29uc3QgbGlzdERlbGltaXRlclJFID0gLzsoPyFbXihdKlxcKSkvZztcbmNvbnN0IHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOihbXl0rKS87XG5jb25zdCBzdHlsZUNvbW1lbnRSRSA9IC9cXC9cXCpbXl0qP1xcKlxcLy9nO1xuZnVuY3Rpb24gcGFyc2VTdHJpbmdTdHlsZShjc3NUZXh0KSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBjc3NUZXh0LnJlcGxhY2Uoc3R5bGVDb21tZW50UkUsIFwiXCIpLnNwbGl0KGxpc3REZWxpbWl0ZXJSRSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBjb25zdCB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyUkUpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJldFt0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZShzdHlsZXMpIHtcbiAgbGV0IHJldCA9IFwiXCI7XG4gIGlmICghc3R5bGVzIHx8IGlzU3RyaW5nKHN0eWxlcykpIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xuICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBrZXkuc3RhcnRzV2l0aChgLS1gKSA/IGtleSA6IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgcmV0ICs9IGAke25vcm1hbGl6ZWRLZXl9OiR7dmFsdWV9O2A7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzcyh2YWx1ZSkge1xuICBsZXQgcmVzID0gXCJcIjtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJlcyA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcbiAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgXCIgXCI7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW25hbWVdKSB7XG4gICAgICAgIHJlcyArPSBuYW1lICsgXCIgXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXMudHJpbSgpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMocHJvcHMpIHtcbiAgaWYgKCFwcm9wcykgcmV0dXJuIG51bGw7XG4gIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xuICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xuICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xuICB9XG4gIGlmIChzdHlsZSkge1xuICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICB9XG4gIHJldHVybiBwcm9wcztcbn1cblxuY29uc3QgSFRNTF9UQUdTID0gXCJodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSxhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsaDEsaDIsaDMsaDQsaDUsaDYsbmF2LHNlY3Rpb24sZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdFwiO1xuY29uc3QgU1ZHX1RBR1MgPSBcInN2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSxkZWZzLGRlc2MsZGlzY2FyZCxlbGxpcHNlLGZlQmxlbmQsZmVDb2xvck1hdHJpeCxmZUNvbXBvbmVudFRyYW5zZmVyLGZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsZmVEaXN0YW50TGlnaHQsZmVEcm9wU2hhZG93LGZlRmxvb2QsZmVGdW5jQSxmZUZ1bmNCLGZlRnVuY0csZmVGdW5jUixmZUdhdXNzaWFuQmx1cixmZUltYWdlLGZlTWVyZ2UsZmVNZXJnZU5vZGUsZmVNb3JwaG9sb2d5LGZlT2Zmc2V0LGZlUG9pbnRMaWdodCxmZVNwZWN1bGFyTGlnaHRpbmcsZmVTcG90TGlnaHQsZmVUaWxlLGZlVHVyYnVsZW5jZSxmaWx0ZXIsZm9yZWlnbk9iamVjdCxnLGhhdGNoLGhhdGNocGF0aCxpbWFnZSxsaW5lLGxpbmVhckdyYWRpZW50LG1hcmtlcixtYXNrLG1lc2gsbWVzaGdyYWRpZW50LG1lc2hwYXRjaCxtZXNocm93LG1ldGFkYXRhLG1wYXRoLHBhdGgscGF0dGVybixwb2x5Z29uLHBvbHlsaW5lLHJhZGlhbEdyYWRpZW50LHJlY3Qsc2V0LHNvbGlkY29sb3Isc3RvcCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dFBhdGgsdGl0bGUsdHNwYW4sdW5rbm93bix1c2Usdmlld1wiO1xuY29uc3QgTUFUSF9UQUdTID0gXCJhbm5vdGF0aW9uLGFubm90YXRpb24teG1sLG1hY3Rpb24sbWFsaWduZ3JvdXAsbWFsaWdubWFyayxtYXRoLG1lbmNsb3NlLG1lcnJvcixtZmVuY2VkLG1mcmFjLG1mcmFjdGlvbixtZ2x5cGgsbWksbWxhYmVsZWR0cixtbG9uZ2RpdixtbXVsdGlzY3JpcHRzLG1uLG1vLG1vdmVyLG1wYWRkZWQsbXBoYW50b20sbXByZXNjcmlwdHMsbXJvb3QsbXJvdyxtcyxtc2NhcnJpZXMsbXNjYXJyeSxtc2dyb3VwLG1zbGluZSxtc3BhY2UsbXNxcnQsbXNyb3csbXN0YWNrLG1zdHlsZSxtc3ViLG1zdWJzdXAsbXN1cCxtdGFibGUsbXRkLG10ZXh0LG10cixtdW5kZXIsbXVuZGVyb3Zlcixub25lLHNlbWFudGljc1wiO1xuY29uc3QgVk9JRF9UQUdTID0gXCJhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGhyLGltZyxpbnB1dCxsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdiclwiO1xuY29uc3QgaXNIVE1MVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoSFRNTF9UQUdTKTtcbmNvbnN0IGlzU1ZHVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoU1ZHX1RBR1MpO1xuY29uc3QgaXNNYXRoTUxUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChNQVRIX1RBR1MpO1xuY29uc3QgaXNWb2lkVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoVk9JRF9UQUdTKTtcblxuY29uc3Qgc3BlY2lhbEJvb2xlYW5BdHRycyA9IGBpdGVtc2NvcGUsYWxsb3dmdWxsc2NyZWVuLGZvcm1ub3ZhbGlkYXRlLGlzbWFwLG5vbW9kdWxlLG5vdmFsaWRhdGUscmVhZG9ubHlgO1xuY29uc3QgaXNTcGVjaWFsQm9vbGVhbkF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzKTtcbmNvbnN0IGlzQm9vbGVhbkF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgc3BlY2lhbEJvb2xlYW5BdHRycyArIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGluZXJ0LGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGBcbik7XG5mdW5jdGlvbiBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgfHwgdmFsdWUgPT09IFwiXCI7XG59XG5jb25zdCB1bnNhZmVBdHRyQ2hhclJFID0gL1s+Lz1cIidcXHUwMDA5XFx1MDAwYVxcdTAwMGNcXHUwMDIwXS87XG5jb25zdCBhdHRyVmFsaWRhdGlvbkNhY2hlID0ge307XG5mdW5jdGlvbiBpc1NTUlNhZmVBdHRyTmFtZShuYW1lKSB7XG4gIGlmIChhdHRyVmFsaWRhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV07XG4gIH1cbiAgY29uc3QgaXNVbnNhZmUgPSB1bnNhZmVBdHRyQ2hhclJFLnRlc3QobmFtZSk7XG4gIGlmIChpc1Vuc2FmZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYHVuc2FmZSBhdHRyaWJ1dGUgbmFtZTogJHtuYW1lfWApO1xuICB9XG4gIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdID0gIWlzVW5zYWZlO1xufVxuY29uc3QgcHJvcHNUb0F0dHJNYXAgPSB7XG4gIGFjY2VwdENoYXJzZXQ6IFwiYWNjZXB0LWNoYXJzZXRcIixcbiAgY2xhc3NOYW1lOiBcImNsYXNzXCIsXG4gIGh0bWxGb3I6IFwiZm9yXCIsXG4gIGh0dHBFcXVpdjogXCJodHRwLWVxdWl2XCJcbn07XG5jb25zdCBpc0tub3duSHRtbEF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYGFjY2VwdCxhY2NlcHQtY2hhcnNldCxhY2Nlc3NrZXksYWN0aW9uLGFsaWduLGFsbG93LGFsdCxhc3luYyxhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsYXV0b2ZvY3VzLGF1dG9wbGF5LGJhY2tncm91bmQsYmdjb2xvcixib3JkZXIsYnVmZmVyZWQsY2FwdHVyZSxjaGFsbGVuZ2UsY2hhcnNldCxjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxjb2RlYmFzZSxjb2xvcixjb2xzLGNvbHNwYW4sY29udGVudCxjb250ZW50ZWRpdGFibGUsY29udGV4dG1lbnUsY29udHJvbHMsY29vcmRzLGNyb3Nzb3JpZ2luLGNzcCxkYXRhLGRhdGV0aW1lLGRlY29kaW5nLGRlZmF1bHQsZGVmZXIsZGlyLGRpcm5hbWUsZGlzYWJsZWQsZG93bmxvYWQsZHJhZ2dhYmxlLGRyb3B6b25lLGVuY3R5cGUsZW50ZXJrZXloaW50LGZvcixmb3JtLGZvcm1hY3Rpb24sZm9ybWVuY3R5cGUsZm9ybW1ldGhvZCxmb3Jtbm92YWxpZGF0ZSxmb3JtdGFyZ2V0LGhlYWRlcnMsaGVpZ2h0LGhpZGRlbixoaWdoLGhyZWYsaHJlZmxhbmcsaHR0cC1lcXVpdixpY29uLGlkLGltcG9ydGFuY2UsaW5lcnQsaW50ZWdyaXR5LGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvYWRpbmcsbGlzdCxsb29wLGxvdyxtYW5pZmVzdCxtYXgsbWF4bGVuZ3RoLG1pbmxlbmd0aCxtZWRpYSxtaW4sbXVsdGlwbGUsbXV0ZWQsbmFtZSxub3ZhbGlkYXRlLG9wZW4sb3B0aW11bSxwYXR0ZXJuLHBpbmcscGxhY2Vob2xkZXIscG9zdGVyLHByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxyZWZlcnJlcnBvbGljeSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsc2NvcGUsc2NvcGVkLHNlbGVjdGVkLHNoYXBlLHNpemUsc2l6ZXMsc2xvdCxzcGFuLHNwZWxsY2hlY2ssc3JjLHNyY2RvYyxzcmNsYW5nLHNyY3NldCxzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCx2YWx1ZSx3aWR0aCx3cmFwYFxuKTtcbmNvbnN0IGlzS25vd25TdmdBdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIGB4bWxucyxhY2NlbnQtaGVpZ2h0LGFjY3VtdWxhdGUsYWRkaXRpdmUsYWxpZ25tZW50LWJhc2VsaW5lLGFscGhhYmV0aWMsYW1wbGl0dWRlLGFyYWJpYy1mb3JtLGFzY2VudCxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVR5cGUsYXppbXV0aCxiYXNlRnJlcXVlbmN5LGJhc2VsaW5lLXNoaWZ0LGJhc2VQcm9maWxlLGJib3gsYmVnaW4sYmlhcyxieSxjYWxjTW9kZSxjYXAtaGVpZ2h0LGNsYXNzLGNsaXAsY2xpcFBhdGhVbml0cyxjbGlwLXBhdGgsY2xpcC1ydWxlLGNvbG9yLGNvbG9yLWludGVycG9sYXRpb24sY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzLGNvbG9yLXByb2ZpbGUsY29sb3ItcmVuZGVyaW5nLGNvbnRlbnRTY3JpcHRUeXBlLGNvbnRlbnRTdHlsZVR5cGUsY3Jvc3NvcmlnaW4sY3Vyc29yLGN4LGN5LGQsZGVjZWxlcmF0ZSxkZXNjZW50LGRpZmZ1c2VDb25zdGFudCxkaXJlY3Rpb24sZGlzcGxheSxkaXZpc29yLGRvbWluYW50LWJhc2VsaW5lLGR1cixkeCxkeSxlZGdlTW9kZSxlbGV2YXRpb24sZW5hYmxlLWJhY2tncm91bmQsZW5kLGV4cG9uZW50LGZpbGwsZmlsbC1vcGFjaXR5LGZpbGwtcnVsZSxmaWx0ZXIsZmlsdGVyUmVzLGZpbHRlclVuaXRzLGZsb29kLWNvbG9yLGZsb29kLW9wYWNpdHksZm9udC1mYW1pbHksZm9udC1zaXplLGZvbnQtc2l6ZS1hZGp1c3QsZm9udC1zdHJldGNoLGZvbnQtc3R5bGUsZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZvcm1hdCxmcm9tLGZyLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCxnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCxnbHlwaFJlZixncmFkaWVudFRyYW5zZm9ybSxncmFkaWVudFVuaXRzLGhhbmdpbmcsaGVpZ2h0LGhyZWYsaHJlZmxhbmcsaG9yaXotYWR2LXgsaG9yaXotb3JpZ2luLXgsaWQsaWRlb2dyYXBoaWMsaW1hZ2UtcmVuZGVyaW5nLGluLGluMixpbnRlcmNlcHQsayxrMSxrMixrMyxrNCxrZXJuZWxNYXRyaXgsa2VybmVsVW5pdExlbmd0aCxrZXJuaW5nLGtleVBvaW50cyxrZXlTcGxpbmVzLGtleVRpbWVzLGxhbmcsbGVuZ3RoQWRqdXN0LGxldHRlci1zcGFjaW5nLGxpZ2h0aW5nLWNvbG9yLGxpbWl0aW5nQ29uZUFuZ2xlLGxvY2FsLG1hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLG1hc2ssbWFza0NvbnRlbnRVbml0cyxtYXNrVW5pdHMsbWF0aGVtYXRpY2FsLG1heCxtZWRpYSxtZXRob2QsbWluLG1vZGUsbmFtZSxudW1PY3RhdmVzLG9mZnNldCxvcGFjaXR5LG9wZXJhdG9yLG9yZGVyLG9yaWVudCxvcmllbnRhdGlvbixvcmlnaW4sb3ZlcmZsb3csb3ZlcmxpbmUtcG9zaXRpb24sb3ZlcmxpbmUtdGhpY2tuZXNzLHBhbm9zZS0xLHBhaW50LW9yZGVyLHBhdGgscGF0aExlbmd0aCxwYXR0ZXJuQ29udGVudFVuaXRzLHBhdHRlcm5UcmFuc2Zvcm0scGF0dGVyblVuaXRzLHBpbmcscG9pbnRlci1ldmVudHMscG9pbnRzLHBvaW50c0F0WCxwb2ludHNBdFkscG9pbnRzQXRaLHByZXNlcnZlQWxwaGEscHJlc2VydmVBc3BlY3RSYXRpbyxwcmltaXRpdmVVbml0cyxyLHJhZGl1cyxyZWZlcnJlclBvbGljeSxyZWZYLHJlZlkscmVsLHJlbmRlcmluZy1pbnRlbnQscmVwZWF0Q291bnQscmVwZWF0RHVyLHJlcXVpcmVkRXh0ZW5zaW9ucyxyZXF1aXJlZEZlYXR1cmVzLHJlc3RhcnQscmVzdWx0LHJvdGF0ZSxyeCxyeSxzY2FsZSxzZWVkLHNoYXBlLXJlbmRlcmluZyxzbG9wZSxzcGFjaW5nLHNwZWN1bGFyQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxzcGVlZCxzcHJlYWRNZXRob2Qsc3RhcnRPZmZzZXQsc3RkRGV2aWF0aW9uLHN0ZW1oLHN0ZW12LHN0aXRjaFRpbGVzLHN0b3AtY29sb3Isc3RvcC1vcGFjaXR5LHN0cmlrZXRocm91Z2gtcG9zaXRpb24sc3RyaWtldGhyb3VnaC10aGlja25lc3Msc3RyaW5nLHN0cm9rZSxzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSxzdHJva2Utd2lkdGgsc3R5bGUsc3VyZmFjZVNjYWxlLHN5c3RlbUxhbmd1YWdlLHRhYmluZGV4LHRhYmxlVmFsdWVzLHRhcmdldCx0YXJnZXRYLHRhcmdldFksdGV4dC1hbmNob3IsdGV4dC1kZWNvcmF0aW9uLHRleHQtcmVuZGVyaW5nLHRleHRMZW5ndGgsdG8sdHJhbnNmb3JtLHRyYW5zZm9ybS1vcmlnaW4sdHlwZSx1MSx1Mix1bmRlcmxpbmUtcG9zaXRpb24sdW5kZXJsaW5lLXRoaWNrbmVzcyx1bmljb2RlLHVuaWNvZGUtYmlkaSx1bmljb2RlLXJhbmdlLHVuaXRzLXBlci1lbSx2LWFscGhhYmV0aWMsdi1oYW5naW5nLHYtaWRlb2dyYXBoaWMsdi1tYXRoZW1hdGljYWwsdmFsdWVzLHZlY3Rvci1lZmZlY3QsdmVyc2lvbix2ZXJ0LWFkdi15LHZlcnQtb3JpZ2luLXgsdmVydC1vcmlnaW4teSx2aWV3Qm94LHZpZXdUYXJnZXQsdmlzaWJpbGl0eSx3aWR0aCx3aWR0aHMsd29yZC1zcGFjaW5nLHdyaXRpbmctbW9kZSx4LHgtaGVpZ2h0LHgxLHgyLHhDaGFubmVsU2VsZWN0b3IseGxpbms6YWN0dWF0ZSx4bGluazphcmNyb2xlLHhsaW5rOmhyZWYseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLHhsaW5rOnR5cGUseG1sbnM6eGxpbmsseG1sOmJhc2UseG1sOmxhbmcseG1sOnNwYWNlLHkseTEseTIseUNoYW5uZWxTZWxlY3Rvcix6LHpvb21BbmRQYW5gXG4pO1xuZnVuY3Rpb24gaXNSZW5kZXJhYmxlQXR0clZhbHVlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCI7XG59XG5cbmNvbnN0IGVzY2FwZVJFID0gL1tcIicmPD5dLztcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gIGNvbnN0IHN0ciA9IFwiXCIgKyBzdHJpbmc7XG4gIGNvbnN0IG1hdGNoID0gZXNjYXBlUkUuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBsZXQgaHRtbCA9IFwiXCI7XG4gIGxldCBlc2NhcGVkO1xuICBsZXQgaW5kZXg7XG4gIGxldCBsYXN0SW5kZXggPSAwO1xuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICBlc2NhcGVkID0gXCImcXVvdDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM4OlxuICAgICAgICBlc2NhcGVkID0gXCImYW1wO1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIGVzY2FwZWQgPSBcIiYjMzk7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmx0O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZndDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGVkO1xuICB9XG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG59XG5jb25zdCBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XG4gIHJldHVybiBzcmMucmVwbGFjZShjb21tZW50U3RyaXBSRSwgXCJcIik7XG59XG5cbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGVxdWFsICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgZXF1YWwgPSBsb29zZUVxdWFsKGFbaV0sIGJbaV0pO1xuICB9XG4gIHJldHVybiBlcXVhbDtcbn1cbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xuICBsZXQgYlZhbGlkVHlwZSA9IGlzRGF0ZShiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCkgOiBmYWxzZTtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNTeW1ib2woYSk7XG4gIGJWYWxpZFR5cGUgPSBpc1N5bWJvbChiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xuICBiVmFsaWRUeXBlID0gaXNBcnJheShiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikgOiBmYWxzZTtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XG4gIGJWYWxpZFR5cGUgPSBpc09iamVjdChiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIGlmICghYVZhbGlkVHlwZSB8fCAhYlZhbGlkVHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYSkubGVuZ3RoO1xuICAgIGNvbnN0IGJLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhiKS5sZW5ndGg7XG4gICAgaWYgKGFLZXlzQ291bnQgIT09IGJLZXlzQ291bnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgY29uc3QgYUhhc0tleSA9IGEuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGNvbnN0IGJIYXNLZXkgPSBiLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBpZiAoYUhhc0tleSAmJiAhYkhhc0tleSB8fCAhYUhhc0tleSAmJiBiSGFzS2V5IHx8ICFsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbn1cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xuICByZXR1cm4gYXJyLmZpbmRJbmRleCgoaXRlbSkgPT4gbG9vc2VFcXVhbChpdGVtLCB2YWwpKTtcbn1cblxuY29uc3QgaXNSZWYgPSAodmFsKSA9PiB7XG4gIHJldHVybiAhISh2YWwgJiYgdmFsW1wiX192X2lzUmVmXCJdID09PSB0cnVlKTtcbn07XG5jb25zdCB0b0Rpc3BsYXlTdHJpbmcgPSAodmFsKSA9PiB7XG4gIHJldHVybiBpc1N0cmluZyh2YWwpID8gdmFsIDogdmFsID09IG51bGwgPyBcIlwiIDogaXNBcnJheSh2YWwpIHx8IGlzT2JqZWN0KHZhbCkgJiYgKHZhbC50b1N0cmluZyA9PT0gb2JqZWN0VG9TdHJpbmcgfHwgIWlzRnVuY3Rpb24odmFsLnRvU3RyaW5nKSkgPyBpc1JlZih2YWwpID8gdG9EaXNwbGF5U3RyaW5nKHZhbC52YWx1ZSkgOiBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKSA6IFN0cmluZyh2YWwpO1xufTtcbmNvbnN0IHJlcGxhY2VyID0gKF9rZXksIHZhbCkgPT4ge1xuICBpZiAoaXNSZWYodmFsKSkge1xuICAgIHJldHVybiByZXBsYWNlcihfa2V5LCB2YWwudmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoXG4gICAgICAgIChlbnRyaWVzLCBba2V5LCB2YWwyXSwgaSkgPT4ge1xuICAgICAgICAgIGVudHJpZXNbc3RyaW5naWZ5U3ltYm9sKGtleSwgaSkgKyBcIiA9PlwiXSA9IHZhbDI7XG4gICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHt9XG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgU2V0KCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLnZhbHVlcygpXS5tYXAoKHYpID0+IHN0cmluZ2lmeVN5bWJvbCh2KSlcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzU3ltYm9sKHZhbCkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5U3ltYm9sKHZhbCk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSAmJiAhaXNBcnJheSh2YWwpICYmICFpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5jb25zdCBzdHJpbmdpZnlTeW1ib2wgPSAodiwgaSA9IFwiXCIpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKFxuICAgIC8vIFN5bWJvbC5kZXNjcmlwdGlvbiBpbiBlczIwMTkrIHNvIHdlIG5lZWQgdG8gY2FzdCBoZXJlIHRvIHBhc3NcbiAgICAvLyB0aGUgbGliOiBlczIwMTYgY2hlY2tcbiAgICBpc1N5bWJvbCh2KSA/IGBTeW1ib2woJHsoX2EgPSB2LmRlc2NyaXB0aW9uKSAhPSBudWxsID8gX2EgOiBpfSlgIDogdlxuICApO1xufTtcblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgUGF0Y2hGbGFncywgU2hhcGVGbGFncywgU2xvdEZsYWdzLCBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgZGVmLCBlc2NhcGVIdG1sLCBlc2NhcGVIdG1sQ29tbWVudCwgZXh0ZW5kLCBnZW5Qcm9wc0FjY2Vzc0V4cCwgZ2VuZXJhdGVDb2RlRnJhbWUsIGdldEdsb2JhbFRoaXMsIGhhc0NoYW5nZWQsIGhhc093biwgaHlwaGVuYXRlLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGludm9rZUFycmF5Rm5zLCBpc0FycmF5LCBpc0Jvb2xlYW5BdHRyLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGlzRGF0ZSwgaXNGdW5jdGlvbiwgaXNHbG9iYWxseUFsbG93ZWQsIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25IdG1sQXR0ciwgaXNLbm93blN2Z0F0dHIsIGlzTWFwLCBpc01hdGhNTFRhZywgaXNNb2RlbExpc3RlbmVyLCBpc09iamVjdCwgaXNPbiwgaXNQbGFpbk9iamVjdCwgaXNQcm9taXNlLCBpc1JlZ0V4cCwgaXNSZW5kZXJhYmxlQXR0clZhbHVlLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIGxvb3NlVG9OdW1iZXIsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIG9iamVjdFRvU3RyaW5nLCBwYXJzZVN0cmluZ1N0eWxlLCBwcm9wc1RvQXR0ck1hcCwgcmVtb3ZlLCBzbG90RmxhZ3NUZXh0LCBzdHJpbmdpZnlTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCB0b1Jhd1R5cGUsIHRvVHlwZVN0cmluZyB9O1xuIiwiLyoqXG4qIEB2dWUvcmVhY3Rpdml0eSB2My41LjAtYmV0YS4zXG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG5pbXBvcnQgeyBoYXNDaGFuZ2VkLCBleHRlbmQsIGlzQXJyYXksIGlzSW50ZWdlcktleSwgaXNTeW1ib2wsIGlzTWFwLCBoYXNPd24sIGlzT2JqZWN0LCBtYWtlTWFwLCBjYXBpdGFsaXplLCB0b1Jhd1R5cGUsIGRlZiwgaXNGdW5jdGlvbiwgRU1QVFlfT0JKLCBpc1NldCwgaXNQbGFpbk9iamVjdCwgTk9PUCwgcmVtb3ZlIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5mdW5jdGlvbiB3YXJuKG1zZywgLi4uYXJncykge1xuICBjb25zb2xlLndhcm4oYFtWdWUgd2Fybl0gJHttc2d9YCwgLi4uYXJncyk7XG59XG5cbmxldCBhY3RpdmVFZmZlY3RTY29wZTtcbmNsYXNzIEVmZmVjdFNjb3BlIHtcbiAgY29uc3RydWN0b3IoZGV0YWNoZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuZGV0YWNoZWQgPSBkZXRhY2hlZDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZWZmZWN0cyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuY2xlYW51cHMgPSBbXTtcbiAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMucGFyZW50ID0gYWN0aXZlRWZmZWN0U2NvcGU7XG4gICAgaWYgKCFkZXRhY2hlZCAmJiBhY3RpdmVFZmZlY3RTY29wZSkge1xuICAgICAgdGhpcy5pbmRleCA9IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgfHwgKGFjdGl2ZUVmZmVjdFNjb3BlLnNjb3BlcyA9IFtdKSkucHVzaChcbiAgICAgICAgdGhpc1xuICAgICAgKSAtIDE7XG4gICAgfVxuICB9XG4gIGdldCBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgfVxuICBwYXVzZSgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5zY29wZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnNjb3Blc1tpXS5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuZWZmZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXN1bWVzIHRoZSBlZmZlY3Qgc2NvcGUsIGluY2x1ZGluZyBhbGwgY2hpbGQgc2NvcGVzIGFuZCBlZmZlY3RzLlxuICAgKi9cbiAgcmVzdW1lKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zY29wZXMpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zY29wZXNbaV0ucmVzdW1lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuZWZmZWN0c1tpXS5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBydW4oZm4pIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWZmZWN0U2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IGN1cnJlbnRFZmZlY3RTY29wZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oYGNhbm5vdCBydW4gYW4gaW5hY3RpdmUgZWZmZWN0IHNjb3BlLmApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9uKCkge1xuICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9mZigpIHtcbiAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXMucGFyZW50O1xuICB9XG4gIHN0b3AoZnJvbVBhcmVudCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIGxldCBpLCBsO1xuICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuZWZmZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNsZWFudXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmNsZWFudXBzW2ldKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zY29wZXMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnN0b3AodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5kZXRhY2hlZCAmJiB0aGlzLnBhcmVudCAmJiAhZnJvbVBhcmVudCkge1xuICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5wYXJlbnQuc2NvcGVzLnBvcCgpO1xuICAgICAgICBpZiAobGFzdCAmJiBsYXN0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuc2NvcGVzW3RoaXMuaW5kZXhdID0gbGFzdDtcbiAgICAgICAgICBsYXN0LmluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wYXJlbnQgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVmZmVjdFNjb3BlKGRldGFjaGVkKSB7XG4gIHJldHVybiBuZXcgRWZmZWN0U2NvcGUoZGV0YWNoZWQpO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xuICByZXR1cm4gYWN0aXZlRWZmZWN0U2NvcGU7XG59XG5mdW5jdGlvbiBvblNjb3BlRGlzcG9zZShmbiwgZmFpbFNpbGVudGx5ID0gZmFsc2UpIHtcbiAgaWYgKGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gICAgYWN0aXZlRWZmZWN0U2NvcGUuY2xlYW51cHMucHVzaChmbik7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZmFpbFNpbGVudGx5KSB7XG4gICAgd2FybihcbiAgICAgIGBvblNjb3BlRGlzcG9zZSgpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBlZmZlY3Qgc2NvcGUgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLmBcbiAgICApO1xuICB9XG59XG5cbmxldCBhY3RpdmVTdWI7XG5jb25zdCBFZmZlY3RGbGFncyA9IHtcbiAgXCJBQ1RJVkVcIjogMSxcbiAgXCIxXCI6IFwiQUNUSVZFXCIsXG4gIFwiUlVOTklOR1wiOiAyLFxuICBcIjJcIjogXCJSVU5OSU5HXCIsXG4gIFwiVFJBQ0tJTkdcIjogNCxcbiAgXCI0XCI6IFwiVFJBQ0tJTkdcIixcbiAgXCJOT1RJRklFRFwiOiA4LFxuICBcIjhcIjogXCJOT1RJRklFRFwiLFxuICBcIkRJUlRZXCI6IDE2LFxuICBcIjE2XCI6IFwiRElSVFlcIixcbiAgXCJBTExPV19SRUNVUlNFXCI6IDMyLFxuICBcIjMyXCI6IFwiQUxMT1dfUkVDVVJTRVwiLFxuICBcIlBBVVNFRFwiOiA2NCxcbiAgXCI2NFwiOiBcIlBBVVNFRFwiXG59O1xuY29uc3QgcGF1c2VkUXVldWVFZmZlY3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG5jbGFzcyBSZWFjdGl2ZUVmZmVjdCB7XG4gIGNvbnN0cnVjdG9yKGZuKSB7XG4gICAgdGhpcy5mbiA9IGZuO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwcyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlcHNUYWlsID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZmxhZ3MgPSAxIHwgNDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLm5leHRFZmZlY3QgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5jbGVhbnVwID0gdm9pZCAwO1xuICAgIHRoaXMuc2NoZWR1bGVyID0gdm9pZCAwO1xuICAgIGlmIChhY3RpdmVFZmZlY3RTY29wZSAmJiBhY3RpdmVFZmZlY3RTY29wZS5hY3RpdmUpIHtcbiAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlLmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5mbGFncyB8PSA2NDtcbiAgfVxuICByZXN1bWUoKSB7XG4gICAgaWYgKHRoaXMuZmxhZ3MgJiA2NCkge1xuICAgICAgdGhpcy5mbGFncyAmPSB+NjQ7XG4gICAgICBpZiAocGF1c2VkUXVldWVFZmZlY3RzLmhhcyh0aGlzKSkge1xuICAgICAgICBwYXVzZWRRdWV1ZUVmZmVjdHMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbm90aWZ5KCkge1xuICAgIGlmICh0aGlzLmZsYWdzICYgMiAmJiAhKHRoaXMuZmxhZ3MgJiAzMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEodGhpcy5mbGFncyAmIDgpKSB7XG4gICAgICB0aGlzLmZsYWdzIHw9IDg7XG4gICAgICB0aGlzLm5leHRFZmZlY3QgPSBiYXRjaGVkRWZmZWN0O1xuICAgICAgYmF0Y2hlZEVmZmVjdCA9IHRoaXM7XG4gICAgfVxuICB9XG4gIHJ1bigpIHtcbiAgICBpZiAoISh0aGlzLmZsYWdzICYgMSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZuKCk7XG4gICAgfVxuICAgIHRoaXMuZmxhZ3MgfD0gMjtcbiAgICBjbGVhbnVwRWZmZWN0KHRoaXMpO1xuICAgIHByZXBhcmVEZXBzKHRoaXMpO1xuICAgIGNvbnN0IHByZXZFZmZlY3QgPSBhY3RpdmVTdWI7XG4gICAgY29uc3QgcHJldlNob3VsZFRyYWNrID0gc2hvdWxkVHJhY2s7XG4gICAgYWN0aXZlU3ViID0gdGhpcztcbiAgICBzaG91bGRUcmFjayA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLmZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGFjdGl2ZVN1YiAhPT0gdGhpcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiQWN0aXZlIGVmZmVjdCB3YXMgbm90IHJlc3RvcmVkIGNvcnJlY3RseSAtIHRoaXMgaXMgbGlrZWx5IGEgVnVlIGludGVybmFsIGJ1Zy5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2xlYW51cERlcHModGhpcyk7XG4gICAgICBhY3RpdmVTdWIgPSBwcmV2RWZmZWN0O1xuICAgICAgc2hvdWxkVHJhY2sgPSBwcmV2U2hvdWxkVHJhY2s7XG4gICAgICB0aGlzLmZsYWdzICY9IH4yO1xuICAgIH1cbiAgfVxuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLmZsYWdzICYgMSkge1xuICAgICAgZm9yIChsZXQgbGluayA9IHRoaXMuZGVwczsgbGluazsgbGluayA9IGxpbmsubmV4dERlcCkge1xuICAgICAgICByZW1vdmVTdWIobGluayk7XG4gICAgICB9XG4gICAgICB0aGlzLmRlcHMgPSB0aGlzLmRlcHNUYWlsID0gdm9pZCAwO1xuICAgICAgY2xlYW51cEVmZmVjdCh0aGlzKTtcbiAgICAgIHRoaXMub25TdG9wICYmIHRoaXMub25TdG9wKCk7XG4gICAgICB0aGlzLmZsYWdzICY9IH4xO1xuICAgIH1cbiAgfVxuICB0cmlnZ2VyKCkge1xuICAgIGlmICh0aGlzLmZsYWdzICYgNjQpIHtcbiAgICAgIHBhdXNlZFF1ZXVlRWZmZWN0cy5hZGQodGhpcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNjaGVkdWxlcikge1xuICAgICAgdGhpcy5zY2hlZHVsZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydW5JZkRpcnR5KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJ1bklmRGlydHkoKSB7XG4gICAgaWYgKGlzRGlydHkodGhpcykpIHtcbiAgICAgIHRoaXMucnVuKCk7XG4gICAgfVxuICB9XG4gIGdldCBkaXJ0eSgpIHtcbiAgICByZXR1cm4gaXNEaXJ0eSh0aGlzKTtcbiAgfVxufVxubGV0IGJhdGNoRGVwdGggPSAwO1xubGV0IGJhdGNoZWRFZmZlY3Q7XG5mdW5jdGlvbiBzdGFydEJhdGNoKCkge1xuICBiYXRjaERlcHRoKys7XG59XG5mdW5jdGlvbiBlbmRCYXRjaCgpIHtcbiAgaWYgKGJhdGNoRGVwdGggPiAxKSB7XG4gICAgYmF0Y2hEZXB0aC0tO1xuICAgIHJldHVybjtcbiAgfVxuICBiYXRjaERlcHRoLS07XG4gIGxldCBlcnJvcjtcbiAgd2hpbGUgKGJhdGNoZWRFZmZlY3QpIHtcbiAgICBsZXQgZSA9IGJhdGNoZWRFZmZlY3Q7XG4gICAgYmF0Y2hlZEVmZmVjdCA9IHZvaWQgMDtcbiAgICB3aGlsZSAoZSkge1xuICAgICAgY29uc3QgbmV4dCA9IGUubmV4dEVmZmVjdDtcbiAgICAgIGUubmV4dEVmZmVjdCA9IHZvaWQgMDtcbiAgICAgIGUuZmxhZ3MgJj0gfjg7XG4gICAgICBpZiAoZS5mbGFncyAmIDEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlLnRyaWdnZXIoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGUgPSBuZXh0O1xuICAgIH1cbiAgfVxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xufVxuZnVuY3Rpb24gcHJlcGFyZURlcHMoc3ViKSB7XG4gIGZvciAobGV0IGxpbmsgPSBzdWIuZGVwczsgbGluazsgbGluayA9IGxpbmsubmV4dERlcCkge1xuICAgIGxpbmsudmVyc2lvbiA9IC0xO1xuICAgIGxpbmsucHJldkFjdGl2ZUxpbmsgPSBsaW5rLmRlcC5hY3RpdmVMaW5rO1xuICAgIGxpbmsuZGVwLmFjdGl2ZUxpbmsgPSBsaW5rO1xuICB9XG59XG5mdW5jdGlvbiBjbGVhbnVwRGVwcyhzdWIpIHtcbiAgbGV0IGhlYWQ7XG4gIGxldCB0YWlsID0gc3ViLmRlcHNUYWlsO1xuICBmb3IgKGxldCBsaW5rID0gdGFpbDsgbGluazsgbGluayA9IGxpbmsucHJldkRlcCkge1xuICAgIGlmIChsaW5rLnZlcnNpb24gPT09IC0xKSB7XG4gICAgICBpZiAobGluayA9PT0gdGFpbCkgdGFpbCA9IGxpbmsucHJldkRlcDtcbiAgICAgIHJlbW92ZVN1YihsaW5rKTtcbiAgICAgIHJlbW92ZURlcChsaW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZCA9IGxpbms7XG4gICAgfVxuICAgIGxpbmsuZGVwLmFjdGl2ZUxpbmsgPSBsaW5rLnByZXZBY3RpdmVMaW5rO1xuICAgIGxpbmsucHJldkFjdGl2ZUxpbmsgPSB2b2lkIDA7XG4gIH1cbiAgc3ViLmRlcHMgPSBoZWFkO1xuICBzdWIuZGVwc1RhaWwgPSB0YWlsO1xufVxuZnVuY3Rpb24gaXNEaXJ0eShzdWIpIHtcbiAgZm9yIChsZXQgbGluayA9IHN1Yi5kZXBzOyBsaW5rOyBsaW5rID0gbGluay5uZXh0RGVwKSB7XG4gICAgaWYgKGxpbmsuZGVwLnZlcnNpb24gIT09IGxpbmsudmVyc2lvbiB8fCBsaW5rLmRlcC5jb21wdXRlZCAmJiByZWZyZXNoQ29tcHV0ZWQobGluay5kZXAuY29tcHV0ZWQpID09PSBmYWxzZSB8fCBsaW5rLmRlcC52ZXJzaW9uICE9PSBsaW5rLnZlcnNpb24pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoc3ViLl9kaXJ0eSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlZnJlc2hDb21wdXRlZChjb21wdXRlZCkge1xuICBpZiAoY29tcHV0ZWQuZmxhZ3MgJiAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjb21wdXRlZC5mbGFncyAmIDQgJiYgIShjb21wdXRlZC5mbGFncyAmIDE2KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb21wdXRlZC5mbGFncyAmPSB+MTY7XG4gIGlmIChjb21wdXRlZC5nbG9iYWxWZXJzaW9uID09PSBnbG9iYWxWZXJzaW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbXB1dGVkLmdsb2JhbFZlcnNpb24gPSBnbG9iYWxWZXJzaW9uO1xuICBjb25zdCBkZXAgPSBjb21wdXRlZC5kZXA7XG4gIGNvbXB1dGVkLmZsYWdzIHw9IDI7XG4gIGlmIChkZXAudmVyc2lvbiA+IDAgJiYgIWNvbXB1dGVkLmlzU1NSICYmICFpc0RpcnR5KGNvbXB1dGVkKSkge1xuICAgIGNvbXB1dGVkLmZsYWdzICY9IH4yO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcmV2U3ViID0gYWN0aXZlU3ViO1xuICBjb25zdCBwcmV2U2hvdWxkVHJhY2sgPSBzaG91bGRUcmFjaztcbiAgYWN0aXZlU3ViID0gY29tcHV0ZWQ7XG4gIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBwcmVwYXJlRGVwcyhjb21wdXRlZCk7XG4gICAgY29uc3QgdmFsdWUgPSBjb21wdXRlZC5mbigpO1xuICAgIGlmIChkZXAudmVyc2lvbiA9PT0gMCB8fCBoYXNDaGFuZ2VkKHZhbHVlLCBjb21wdXRlZC5fdmFsdWUpKSB7XG4gICAgICBjb21wdXRlZC5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgIGRlcC52ZXJzaW9uKys7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZXAudmVyc2lvbisrO1xuICAgIHRocm93IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICBhY3RpdmVTdWIgPSBwcmV2U3ViO1xuICAgIHNob3VsZFRyYWNrID0gcHJldlNob3VsZFRyYWNrO1xuICAgIGNsZWFudXBEZXBzKGNvbXB1dGVkKTtcbiAgICBjb21wdXRlZC5mbGFncyAmPSB+MjtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlU3ViKGxpbmspIHtcbiAgY29uc3QgeyBkZXAsIHByZXZTdWIsIG5leHRTdWIgfSA9IGxpbms7XG4gIGlmIChwcmV2U3ViKSB7XG4gICAgcHJldlN1Yi5uZXh0U3ViID0gbmV4dFN1YjtcbiAgICBsaW5rLnByZXZTdWIgPSB2b2lkIDA7XG4gIH1cbiAgaWYgKG5leHRTdWIpIHtcbiAgICBuZXh0U3ViLnByZXZTdWIgPSBwcmV2U3ViO1xuICAgIGxpbmsubmV4dFN1YiA9IHZvaWQgMDtcbiAgfVxuICBpZiAoZGVwLnN1YnMgPT09IGxpbmspIHtcbiAgICBkZXAuc3VicyA9IHByZXZTdWI7XG4gIH1cbiAgaWYgKCFkZXAuc3VicyAmJiBkZXAuY29tcHV0ZWQpIHtcbiAgICBkZXAuY29tcHV0ZWQuZmxhZ3MgJj0gfjQ7XG4gICAgZm9yIChsZXQgbCA9IGRlcC5jb21wdXRlZC5kZXBzOyBsOyBsID0gbC5uZXh0RGVwKSB7XG4gICAgICByZW1vdmVTdWIobCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZW1vdmVEZXAobGluaykge1xuICBjb25zdCB7IHByZXZEZXAsIG5leHREZXAgfSA9IGxpbms7XG4gIGlmIChwcmV2RGVwKSB7XG4gICAgcHJldkRlcC5uZXh0RGVwID0gbmV4dERlcDtcbiAgICBsaW5rLnByZXZEZXAgPSB2b2lkIDA7XG4gIH1cbiAgaWYgKG5leHREZXApIHtcbiAgICBuZXh0RGVwLnByZXZEZXAgPSBwcmV2RGVwO1xuICAgIGxpbmsubmV4dERlcCA9IHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gZWZmZWN0KGZuLCBvcHRpb25zKSB7XG4gIGlmIChmbi5lZmZlY3QgaW5zdGFuY2VvZiBSZWFjdGl2ZUVmZmVjdCkge1xuICAgIGZuID0gZm4uZWZmZWN0LmZuO1xuICB9XG4gIGNvbnN0IGUgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZm4pO1xuICBpZiAob3B0aW9ucykge1xuICAgIGV4dGVuZChlLCBvcHRpb25zKTtcbiAgfVxuICB0cnkge1xuICAgIGUucnVuKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGUuc3RvcCgpO1xuICAgIHRocm93IGVycjtcbiAgfVxuICBjb25zdCBydW5uZXIgPSBlLnJ1bi5iaW5kKGUpO1xuICBydW5uZXIuZWZmZWN0ID0gZTtcbiAgcmV0dXJuIHJ1bm5lcjtcbn1cbmZ1bmN0aW9uIHN0b3AocnVubmVyKSB7XG4gIHJ1bm5lci5lZmZlY3Quc3RvcCgpO1xufVxubGV0IHNob3VsZFRyYWNrID0gdHJ1ZTtcbmNvbnN0IHRyYWNrU3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHBhdXNlVHJhY2tpbmcoKSB7XG4gIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XG4gIHNob3VsZFRyYWNrID0gZmFsc2U7XG59XG5mdW5jdGlvbiBlbmFibGVUcmFja2luZygpIHtcbiAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgc2hvdWxkVHJhY2sgPSB0cnVlO1xufVxuZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcbiAgY29uc3QgbGFzdCA9IHRyYWNrU3RhY2sucG9wKCk7XG4gIHNob3VsZFRyYWNrID0gbGFzdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IGxhc3Q7XG59XG5mdW5jdGlvbiBvbkVmZmVjdENsZWFudXAoZm4sIGZhaWxTaWxlbnRseSA9IGZhbHNlKSB7XG4gIGlmIChhY3RpdmVTdWIgaW5zdGFuY2VvZiBSZWFjdGl2ZUVmZmVjdCkge1xuICAgIGFjdGl2ZVN1Yi5jbGVhbnVwID0gZm47XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZmFpbFNpbGVudGx5KSB7XG4gICAgd2FybihcbiAgICAgIGBvbkVmZmVjdENsZWFudXAoKSB3YXMgY2FsbGVkIHdoZW4gdGhlcmUgd2FzIG5vIGFjdGl2ZSBlZmZlY3QgdG8gYXNzb2NpYXRlIHdpdGguYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFudXBFZmZlY3QoZSkge1xuICBjb25zdCB7IGNsZWFudXAgfSA9IGU7XG4gIGUuY2xlYW51cCA9IHZvaWQgMDtcbiAgaWYgKGNsZWFudXApIHtcbiAgICBjb25zdCBwcmV2U3ViID0gYWN0aXZlU3ViO1xuICAgIGFjdGl2ZVN1YiA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhY3RpdmVTdWIgPSBwcmV2U3ViO1xuICAgIH1cbiAgfVxufVxuXG5sZXQgZ2xvYmFsVmVyc2lvbiA9IDA7XG5jbGFzcyBEZXAge1xuICBjb25zdHJ1Y3Rvcihjb21wdXRlZCkge1xuICAgIHRoaXMuY29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICB0aGlzLnZlcnNpb24gPSAwO1xuICAgIC8qKlxuICAgICAqIExpbmsgYmV0d2VlbiB0aGlzIGRlcCBhbmQgdGhlIGN1cnJlbnQgYWN0aXZlIGVmZmVjdFxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlTGluayA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBEb3VibHkgbGlua2VkIGxpc3QgcmVwcmVzZW50aW5nIHRoZSBzdWJzY3JpYmluZyBlZmZlY3RzICh0YWlsKVxuICAgICAqL1xuICAgIHRoaXMuc3VicyA9IHZvaWQgMDtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdGhpcy5zdWJzSGVhZCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgdHJhY2soZGVidWdJbmZvKSB7XG4gICAgaWYgKCFhY3RpdmVTdWIgfHwgIXNob3VsZFRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBsaW5rID0gdGhpcy5hY3RpdmVMaW5rO1xuICAgIGlmIChsaW5rID09PSB2b2lkIDAgfHwgbGluay5zdWIgIT09IGFjdGl2ZVN1Yikge1xuICAgICAgbGluayA9IHRoaXMuYWN0aXZlTGluayA9IHtcbiAgICAgICAgZGVwOiB0aGlzLFxuICAgICAgICBzdWI6IGFjdGl2ZVN1YixcbiAgICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxuICAgICAgICBuZXh0RGVwOiB2b2lkIDAsXG4gICAgICAgIHByZXZEZXA6IHZvaWQgMCxcbiAgICAgICAgbmV4dFN1Yjogdm9pZCAwLFxuICAgICAgICBwcmV2U3ViOiB2b2lkIDAsXG4gICAgICAgIHByZXZBY3RpdmVMaW5rOiB2b2lkIDBcbiAgICAgIH07XG4gICAgICBpZiAoIWFjdGl2ZVN1Yi5kZXBzKSB7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzID0gYWN0aXZlU3ViLmRlcHNUYWlsID0gbGluaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmsucHJldkRlcCA9IGFjdGl2ZVN1Yi5kZXBzVGFpbDtcbiAgICAgICAgYWN0aXZlU3ViLmRlcHNUYWlsLm5leHREZXAgPSBsaW5rO1xuICAgICAgICBhY3RpdmVTdWIuZGVwc1RhaWwgPSBsaW5rO1xuICAgICAgfVxuICAgICAgaWYgKGFjdGl2ZVN1Yi5mbGFncyAmIDQpIHtcbiAgICAgICAgYWRkU3ViKGxpbmspO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGluay52ZXJzaW9uID09PSAtMSkge1xuICAgICAgbGluay52ZXJzaW9uID0gdGhpcy52ZXJzaW9uO1xuICAgICAgaWYgKGxpbmsubmV4dERlcCkge1xuICAgICAgICBjb25zdCBuZXh0ID0gbGluay5uZXh0RGVwO1xuICAgICAgICBuZXh0LnByZXZEZXAgPSBsaW5rLnByZXZEZXA7XG4gICAgICAgIGlmIChsaW5rLnByZXZEZXApIHtcbiAgICAgICAgICBsaW5rLnByZXZEZXAubmV4dERlcCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGluay5wcmV2RGVwID0gYWN0aXZlU3ViLmRlcHNUYWlsO1xuICAgICAgICBsaW5rLm5leHREZXAgPSB2b2lkIDA7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzVGFpbC5uZXh0RGVwID0gbGluaztcbiAgICAgICAgYWN0aXZlU3ViLmRlcHNUYWlsID0gbGluaztcbiAgICAgICAgaWYgKGFjdGl2ZVN1Yi5kZXBzID09PSBsaW5rKSB7XG4gICAgICAgICAgYWN0aXZlU3ViLmRlcHMgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGFjdGl2ZVN1Yi5vblRyYWNrKSB7XG4gICAgICBhY3RpdmVTdWIub25UcmFjayhcbiAgICAgICAgZXh0ZW5kKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVmZmVjdDogYWN0aXZlU3ViXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWJ1Z0luZm9cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbms7XG4gIH1cbiAgdHJpZ2dlcihkZWJ1Z0luZm8pIHtcbiAgICB0aGlzLnZlcnNpb24rKztcbiAgICBnbG9iYWxWZXJzaW9uKys7XG4gICAgdGhpcy5ub3RpZnkoZGVidWdJbmZvKTtcbiAgfVxuICBub3RpZnkoZGVidWdJbmZvKSB7XG4gICAgc3RhcnRCYXRjaCgpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBmb3IgKGxldCBoZWFkID0gdGhpcy5zdWJzSGVhZDsgaGVhZDsgaGVhZCA9IGhlYWQubmV4dFN1Yikge1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGhlYWQuc3ViLm9uVHJpZ2dlciAmJiAhKGhlYWQuc3ViLmZsYWdzICYgOCkpIHtcbiAgICAgICAgICAgIGhlYWQuc3ViLm9uVHJpZ2dlcihcbiAgICAgICAgICAgICAgZXh0ZW5kKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGVmZmVjdDogaGVhZC5zdWJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlYnVnSW5mb1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgbGluayA9IHRoaXMuc3ViczsgbGluazsgbGluayA9IGxpbmsucHJldlN1Yikge1xuICAgICAgICBsaW5rLnN1Yi5ub3RpZnkoKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFN1YihsaW5rKSB7XG4gIGNvbnN0IGNvbXB1dGVkID0gbGluay5kZXAuY29tcHV0ZWQ7XG4gIGlmIChjb21wdXRlZCAmJiAhbGluay5kZXAuc3Vicykge1xuICAgIGNvbXB1dGVkLmZsYWdzIHw9IDQgfCAxNjtcbiAgICBmb3IgKGxldCBsID0gY29tcHV0ZWQuZGVwczsgbDsgbCA9IGwubmV4dERlcCkge1xuICAgICAgYWRkU3ViKGwpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjdXJyZW50VGFpbCA9IGxpbmsuZGVwLnN1YnM7XG4gIGlmIChjdXJyZW50VGFpbCAhPT0gbGluaykge1xuICAgIGxpbmsucHJldlN1YiA9IGN1cnJlbnRUYWlsO1xuICAgIGlmIChjdXJyZW50VGFpbCkgY3VycmVudFRhaWwubmV4dFN1YiA9IGxpbms7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbGluay5kZXAuc3Vic0hlYWQgPT09IHZvaWQgMCkge1xuICAgIGxpbmsuZGVwLnN1YnNIZWFkID0gbGluaztcbiAgfVxuICBsaW5rLmRlcC5zdWJzID0gbGluaztcbn1cbmNvbnN0IHRhcmdldE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgSVRFUkFURV9LRVkgPSBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIk9iamVjdCBpdGVyYXRlXCIgOiBcIlwiXG4pO1xuY29uc3QgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IFwiTWFwIGtleXMgaXRlcmF0ZVwiIDogXCJcIlxuKTtcbmNvbnN0IEFSUkFZX0lURVJBVEVfS0VZID0gU3ltYm9sKFxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJBcnJheSBpdGVyYXRlXCIgOiBcIlwiXG4pO1xuZnVuY3Rpb24gdHJhY2sodGFyZ2V0LCB0eXBlLCBrZXkpIHtcbiAgaWYgKHNob3VsZFRyYWNrICYmIGFjdGl2ZVN1Yikge1xuICAgIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICAgIGlmICghZGVwc01hcCkge1xuICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQsIGRlcHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XG4gICAgaWYgKCFkZXApIHtcbiAgICAgIGRlcHNNYXAuc2V0KGtleSwgZGVwID0gbmV3IERlcCgpKTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGRlcC50cmFjayh7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAga2V5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVwLnRyYWNrKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyKHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCkge1xuICBjb25zdCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICBpZiAoIWRlcHNNYXApIHtcbiAgICBnbG9iYWxWZXJzaW9uKys7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBkZXBzID0gW107XG4gIGlmICh0eXBlID09PSBcImNsZWFyXCIpIHtcbiAgICBkZXBzID0gWy4uLmRlcHNNYXAudmFsdWVzKCldO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRhcmdldElzQXJyYXkgPSBpc0FycmF5KHRhcmdldCk7XG4gICAgY29uc3QgaXNBcnJheUluZGV4ID0gdGFyZ2V0SXNBcnJheSAmJiBpc0ludGVnZXJLZXkoa2V5KTtcbiAgICBpZiAodGFyZ2V0SXNBcnJheSAmJiBrZXkgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IE51bWJlcihuZXdWYWx1ZSk7XG4gICAgICBkZXBzTWFwLmZvckVhY2goKGRlcCwga2V5MikgPT4ge1xuICAgICAgICBpZiAoa2V5MiA9PT0gXCJsZW5ndGhcIiB8fCBrZXkyID09PSBBUlJBWV9JVEVSQVRFX0tFWSB8fCAhaXNTeW1ib2woa2V5MikgJiYga2V5MiA+PSBuZXdMZW5ndGgpIHtcbiAgICAgICAgICBkZXBzLnB1c2goZGVwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHB1c2ggPSAoZGVwKSA9PiBkZXAgJiYgZGVwcy5wdXNoKGRlcCk7XG4gICAgICBpZiAoa2V5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgcHVzaChkZXBzTWFwLmdldChrZXkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5SW5kZXgpIHtcbiAgICAgICAgcHVzaChkZXBzTWFwLmdldChBUlJBWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJhZGRcIjpcbiAgICAgICAgICBpZiAoIXRhcmdldElzQXJyYXkpIHtcbiAgICAgICAgICAgIHB1c2goZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgIHB1c2goZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUluZGV4KSB7XG4gICAgICAgICAgICBwdXNoKGRlcHNNYXAuZ2V0KFwibGVuZ3RoXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgICBpZiAoIXRhcmdldElzQXJyYXkpIHtcbiAgICAgICAgICAgIHB1c2goZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgIHB1c2goZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICBwdXNoKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGFydEJhdGNoKCk7XG4gIGZvciAoY29uc3QgZGVwIG9mIGRlcHMpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgZGVwLnRyaWdnZXIoe1xuICAgICAgICB0YXJnZXQsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGtleSxcbiAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgIG9sZFZhbHVlLFxuICAgICAgICBvbGRUYXJnZXRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXAudHJpZ2dlcigpO1xuICAgIH1cbiAgfVxuICBlbmRCYXRjaCgpO1xufVxuZnVuY3Rpb24gZ2V0RGVwRnJvbVJlYWN0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IHRhcmdldE1hcC5nZXQob2JqZWN0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldChrZXkpO1xufVxuXG5mdW5jdGlvbiByZWFjdGl2ZVJlYWRBcnJheShhcnJheSkge1xuICBjb25zdCByYXcgPSB0b1JhdyhhcnJheSk7XG4gIGlmIChyYXcgPT09IGFycmF5KSByZXR1cm4gcmF3O1xuICB0cmFjayhyYXcsIFwiaXRlcmF0ZVwiLCBBUlJBWV9JVEVSQVRFX0tFWSk7XG4gIHJldHVybiBpc1NoYWxsb3coYXJyYXkpID8gcmF3IDogcmF3Lm1hcCh0b1JlYWN0aXZlKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWFkQXJyYXkoYXJyKSB7XG4gIHRyYWNrKGFyciA9IHRvUmF3KGFyciksIFwiaXRlcmF0ZVwiLCBBUlJBWV9JVEVSQVRFX0tFWSk7XG4gIHJldHVybiBhcnI7XG59XG5jb25zdCBhcnJheUluc3RydW1lbnRhdGlvbnMgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yKHRoaXMsIFN5bWJvbC5pdGVyYXRvciwgdG9SZWFjdGl2ZSk7XG4gIH0sXG4gIGNvbmNhdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlUmVhZEFycmF5KHRoaXMpLmNvbmNhdChcbiAgICAgIC4uLmFyZ3MubWFwKCh4KSA9PiByZWFjdGl2ZVJlYWRBcnJheSh4KSlcbiAgICApO1xuICB9LFxuICBlbnRyaWVzKCkge1xuICAgIHJldHVybiBpdGVyYXRvcih0aGlzLCBcImVudHJpZXNcIiwgKHZhbHVlKSA9PiB7XG4gICAgICB2YWx1ZVsxXSA9IHRvUmVhY3RpdmUodmFsdWVbMV0pO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuICB9LFxuICBldmVyeShmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImV2ZXJ5XCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZpbHRlcihmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbHRlclwiLCBmbiwgdGhpc0FyZywgKHYpID0+IHYubWFwKHRvUmVhY3RpdmUpLCBhcmd1bWVudHMpO1xuICB9LFxuICBmaW5kKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmluZFwiLCBmbiwgdGhpc0FyZywgdG9SZWFjdGl2ZSwgYXJndW1lbnRzKTtcbiAgfSxcbiAgZmluZEluZGV4KGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmluZEluZGV4XCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZpbmRMYXN0KGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmluZExhc3RcIiwgZm4sIHRoaXNBcmcsIHRvUmVhY3RpdmUsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZpbmRMYXN0SW5kZXgoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmaW5kTGFzdEluZGV4XCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIC8vIGZsYXQsIGZsYXRNYXAgY291bGQgYmVuZWZpdCBmcm9tIEFSUkFZX0lURVJBVEUgYnV0IGFyZSBub3Qgc3RyYWlnaHQtZm9yd2FyZCB0byBpbXBsZW1lbnRcbiAgZm9yRWFjaChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZvckVhY2hcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgaW5jbHVkZXMoLi4uYXJncykge1xuICAgIHJldHVybiBzZWFyY2hQcm94eSh0aGlzLCBcImluY2x1ZGVzXCIsIGFyZ3MpO1xuICB9LFxuICBpbmRleE9mKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gc2VhcmNoUHJveHkodGhpcywgXCJpbmRleE9mXCIsIGFyZ3MpO1xuICB9LFxuICBqb2luKHNlcGFyYXRvcikge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS5qb2luKHNlcGFyYXRvcik7XG4gIH0sXG4gIC8vIGtleXMoKSBpdGVyYXRvciBvbmx5IHJlYWRzIGBsZW5ndGhgLCBubyBvcHRpbWlzYXRpb24gcmVxdWlyZWRcbiAgbGFzdEluZGV4T2YoLi4uYXJncykge1xuICAgIHJldHVybiBzZWFyY2hQcm94eSh0aGlzLCBcImxhc3RJbmRleE9mXCIsIGFyZ3MpO1xuICB9LFxuICBtYXAoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJtYXBcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgcG9wKCkge1xuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwicG9wXCIpO1xuICB9LFxuICBwdXNoKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInB1c2hcIiwgYXJncyk7XG4gIH0sXG4gIHJlZHVjZShmbiwgLi4uYXJncykge1xuICAgIHJldHVybiByZWR1Y2UodGhpcywgXCJyZWR1Y2VcIiwgZm4sIGFyZ3MpO1xuICB9LFxuICByZWR1Y2VSaWdodChmbiwgLi4uYXJncykge1xuICAgIHJldHVybiByZWR1Y2UodGhpcywgXCJyZWR1Y2VSaWdodFwiLCBmbiwgYXJncyk7XG4gIH0sXG4gIHNoaWZ0KCkge1xuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwic2hpZnRcIik7XG4gIH0sXG4gIC8vIHNsaWNlIGNvdWxkIHVzZSBBUlJBWV9JVEVSQVRFIGJ1dCBhbHNvIHNlZW1zIHRvIGJlZyBmb3IgcmFuZ2UgdHJhY2tpbmdcbiAgc29tZShmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcInNvbWVcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgc3BsaWNlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInNwbGljZVwiLCBhcmdzKTtcbiAgfSxcbiAgdG9SZXZlcnNlZCgpIHtcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykudG9SZXZlcnNlZCgpO1xuICB9LFxuICB0b1NvcnRlZChjb21wYXJlcikge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS50b1NvcnRlZChjb21wYXJlcik7XG4gIH0sXG4gIHRvU3BsaWNlZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlUmVhZEFycmF5KHRoaXMpLnRvU3BsaWNlZCguLi5hcmdzKTtcbiAgfSxcbiAgdW5zaGlmdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5vVHJhY2tpbmcodGhpcywgXCJ1bnNoaWZ0XCIsIGFyZ3MpO1xuICB9LFxuICB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yKHRoaXMsIFwidmFsdWVzXCIsIHRvUmVhY3RpdmUpO1xuICB9XG59O1xuZnVuY3Rpb24gaXRlcmF0b3Ioc2VsZiwgbWV0aG9kLCB3cmFwVmFsdWUpIHtcbiAgY29uc3QgYXJyID0gc2hhbGxvd1JlYWRBcnJheShzZWxmKTtcbiAgY29uc3QgaXRlciA9IGFyclttZXRob2RdKCk7XG4gIGlmIChhcnIgIT09IHNlbGYgJiYgIWlzU2hhbGxvdyhzZWxmKSkge1xuICAgIGl0ZXIuX25leHQgPSBpdGVyLm5leHQ7XG4gICAgaXRlci5uZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gaXRlci5fbmV4dCgpO1xuICAgICAgaWYgKHJlc3VsdC52YWx1ZSkge1xuICAgICAgICByZXN1bHQudmFsdWUgPSB3cmFwVmFsdWUocmVzdWx0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gaXRlcjtcbn1cbmNvbnN0IGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5mdW5jdGlvbiBhcHBseShzZWxmLCBtZXRob2QsIGZuLCB0aGlzQXJnLCB3cmFwcGVkUmV0Rm4sIGFyZ3MpIHtcbiAgY29uc3QgYXJyID0gc2hhbGxvd1JlYWRBcnJheShzZWxmKTtcbiAgY29uc3QgbmVlZHNXcmFwID0gYXJyICE9PSBzZWxmICYmICFpc1NoYWxsb3coc2VsZik7XG4gIGNvbnN0IG1ldGhvZEZuID0gYXJyW21ldGhvZF07XG4gIGlmIChtZXRob2RGbiAhPT0gYXJyYXlQcm90b1ttZXRob2RdKSB7XG4gICAgY29uc3QgcmVzdWx0MiA9IG1ldGhvZEZuLmFwcGx5KGFyciwgYXJncyk7XG4gICAgcmV0dXJuIG5lZWRzV3JhcCA/IHRvUmVhY3RpdmUocmVzdWx0MikgOiByZXN1bHQyO1xuICB9XG4gIGxldCB3cmFwcGVkRm4gPSBmbjtcbiAgaWYgKGFyciAhPT0gc2VsZikge1xuICAgIGlmIChuZWVkc1dyYXApIHtcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIHRvUmVhY3RpdmUoaXRlbSksIGluZGV4LCBzZWxmKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmbi5sZW5ndGggPiAyKSB7XG4gICAgICB3cmFwcGVkRm4gPSBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBpdGVtLCBpbmRleCwgc2VsZik7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBjb25zdCByZXN1bHQgPSBtZXRob2RGbi5jYWxsKGFyciwgd3JhcHBlZEZuLCB0aGlzQXJnKTtcbiAgcmV0dXJuIG5lZWRzV3JhcCAmJiB3cmFwcGVkUmV0Rm4gPyB3cmFwcGVkUmV0Rm4ocmVzdWx0KSA6IHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJlZHVjZShzZWxmLCBtZXRob2QsIGZuLCBhcmdzKSB7XG4gIGNvbnN0IGFyciA9IHNoYWxsb3dSZWFkQXJyYXkoc2VsZik7XG4gIGxldCB3cmFwcGVkRm4gPSBmbjtcbiAgaWYgKGFyciAhPT0gc2VsZikge1xuICAgIGlmICghaXNTaGFsbG93KHNlbGYpKSB7XG4gICAgICB3cmFwcGVkRm4gPSBmdW5jdGlvbihhY2MsIGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGFjYywgdG9SZWFjdGl2ZShpdGVtKSwgaW5kZXgsIHNlbGYpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZuLmxlbmd0aCA+IDMpIHtcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGFjYywgaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYWNjLCBpdGVtLCBpbmRleCwgc2VsZik7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyW21ldGhvZF0od3JhcHBlZEZuLCAuLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIHNlYXJjaFByb3h5KHNlbGYsIG1ldGhvZCwgYXJncykge1xuICBjb25zdCBhcnIgPSB0b1JhdyhzZWxmKTtcbiAgdHJhY2soYXJyLCBcIml0ZXJhdGVcIiwgQVJSQVlfSVRFUkFURV9LRVkpO1xuICBjb25zdCByZXMgPSBhcnJbbWV0aG9kXSguLi5hcmdzKTtcbiAgaWYgKChyZXMgPT09IC0xIHx8IHJlcyA9PT0gZmFsc2UpICYmIGlzUHJveHkoYXJnc1swXSkpIHtcbiAgICBhcmdzWzBdID0gdG9SYXcoYXJnc1swXSk7XG4gICAgcmV0dXJuIGFyclttZXRob2RdKC4uLmFyZ3MpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBub1RyYWNraW5nKHNlbGYsIG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gIHBhdXNlVHJhY2tpbmcoKTtcbiAgc3RhcnRCYXRjaCgpO1xuICBjb25zdCByZXMgPSB0b1JhdyhzZWxmKVttZXRob2RdLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICBlbmRCYXRjaCgpO1xuICByZXNldFRyYWNraW5nKCk7XG4gIHJldHVybiByZXM7XG59XG5cbmNvbnN0IGlzTm9uVHJhY2thYmxlS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKGBfX3Byb3RvX18sX192X2lzUmVmLF9faXNWdWVgKTtcbmNvbnN0IGJ1aWx0SW5TeW1ib2xzID0gbmV3IFNldChcbiAgLyogQF9fUFVSRV9fICovIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFN5bWJvbCkuZmlsdGVyKChrZXkpID0+IGtleSAhPT0gXCJhcmd1bWVudHNcIiAmJiBrZXkgIT09IFwiY2FsbGVyXCIpLm1hcCgoa2V5KSA9PiBTeW1ib2xba2V5XSkuZmlsdGVyKGlzU3ltYm9sKVxuKTtcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KGtleSkge1xuICBpZiAoIWlzU3ltYm9sKGtleSkpIGtleSA9IFN0cmluZyhrZXkpO1xuICBjb25zdCBvYmogPSB0b1Jhdyh0aGlzKTtcbiAgdHJhY2sob2JqLCBcImhhc1wiLCBrZXkpO1xuICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KGtleSk7XG59XG5jbGFzcyBCYXNlUmVhY3RpdmVIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoX2lzUmVhZG9ubHkgPSBmYWxzZSwgX2lzU2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgdGhpcy5faXNSZWFkb25seSA9IF9pc1JlYWRvbmx5O1xuICAgIHRoaXMuX2lzU2hhbGxvdyA9IF9pc1NoYWxsb3c7XG4gIH1cbiAgZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikge1xuICAgIGNvbnN0IGlzUmVhZG9ubHkyID0gdGhpcy5faXNSZWFkb25seSwgaXNTaGFsbG93MiA9IHRoaXMuX2lzU2hhbGxvdztcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcbiAgICAgIHJldHVybiAhaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIikge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1NoYWxsb3dcIikge1xuICAgICAgcmV0dXJuIGlzU2hhbGxvdzI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiKSB7XG4gICAgICBpZiAocmVjZWl2ZXIgPT09IChpc1JlYWRvbmx5MiA/IGlzU2hhbGxvdzIgPyBzaGFsbG93UmVhZG9ubHlNYXAgOiByZWFkb25seU1hcCA6IGlzU2hhbGxvdzIgPyBzaGFsbG93UmVhY3RpdmVNYXAgOiByZWFjdGl2ZU1hcCkuZ2V0KHRhcmdldCkgfHwgLy8gcmVjZWl2ZXIgaXMgbm90IHRoZSByZWFjdGl2ZSBwcm94eSwgYnV0IGhhcyB0aGUgc2FtZSBwcm90b3R5cGVcbiAgICAgIC8vIHRoaXMgbWVhbnMgdGhlIHJlY2VpdmVyIGlzIGEgdXNlciBwcm94eSBvZiB0aGUgcmVhY3RpdmUgcHJveHlcbiAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocmVjZWl2ZXIpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldElzQXJyYXkgPSBpc0FycmF5KHRhcmdldCk7XG4gICAgaWYgKCFpc1JlYWRvbmx5Mikge1xuICAgICAgbGV0IGZuO1xuICAgICAgaWYgKHRhcmdldElzQXJyYXkgJiYgKGZuID0gYXJyYXlJbnN0cnVtZW50YXRpb25zW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09IFwiaGFzT3duUHJvcGVydHlcIikge1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IFJlZmxlY3QuZ2V0KFxuICAgICAgdGFyZ2V0LFxuICAgICAga2V5LFxuICAgICAgLy8gaWYgdGhpcyBpcyBhIHByb3h5IHdyYXBwaW5nIGEgcmVmLCByZXR1cm4gbWV0aG9kcyB1c2luZyB0aGUgcmF3IHJlZlxuICAgICAgLy8gYXMgcmVjZWl2ZXIgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNhbGwgYHRvUmF3YCBvbiB0aGUgcmVmIGluIGFsbFxuICAgICAgLy8gaXRzIGNsYXNzIG1ldGhvZHNcbiAgICAgIGlzUmVmKHRhcmdldCkgPyB0YXJnZXQgOiByZWNlaXZlclxuICAgICk7XG4gICAgaWYgKGlzU3ltYm9sKGtleSkgPyBidWlsdEluU3ltYm9scy5oYXMoa2V5KSA6IGlzTm9uVHJhY2thYmxlS2V5cyhrZXkpKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBpZiAoIWlzUmVhZG9ubHkyKSB7XG4gICAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIsIGtleSk7XG4gICAgfVxuICAgIGlmIChpc1NoYWxsb3cyKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBpZiAoaXNSZWYocmVzKSkge1xuICAgICAgcmV0dXJuIHRhcmdldElzQXJyYXkgJiYgaXNJbnRlZ2VyS2V5KGtleSkgPyByZXMgOiByZXMudmFsdWU7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seTIgPyByZWFkb25seShyZXMpIDogcmVhY3RpdmUocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxufVxuY2xhc3MgTXV0YWJsZVJlYWN0aXZlSGFuZGxlciBleHRlbmRzIEJhc2VSZWFjdGl2ZUhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihpc1NoYWxsb3cyID0gZmFsc2UpIHtcbiAgICBzdXBlcihmYWxzZSwgaXNTaGFsbG93Mik7XG4gIH1cbiAgc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICBsZXQgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICBpZiAoIXRoaXMuX2lzU2hhbGxvdykge1xuICAgICAgY29uc3QgaXNPbGRWYWx1ZVJlYWRvbmx5ID0gaXNSZWFkb25seShvbGRWYWx1ZSk7XG4gICAgICBpZiAoIWlzU2hhbGxvdyh2YWx1ZSkgJiYgIWlzUmVhZG9ubHkodmFsdWUpKSB7XG4gICAgICAgIG9sZFZhbHVlID0gdG9SYXcob2xkVmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpICYmIGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICAgIGlmIChpc09sZFZhbHVlUmVhZG9ubHkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoYWRLZXkgPSBpc0FycmF5KHRhcmdldCkgJiYgaXNJbnRlZ2VyS2V5KGtleSkgPyBOdW1iZXIoa2V5KSA8IHRhcmdldC5sZW5ndGggOiBoYXNPd24odGFyZ2V0LCBrZXkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgIGlmICh0YXJnZXQgPT09IHRvUmF3KHJlY2VpdmVyKSkge1xuICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIsIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IGhhZEtleSA9IGhhc093bih0YXJnZXQsIGtleSk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KTtcbiAgICBpZiAocmVzdWx0ICYmIGhhZEtleSkge1xuICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIsIGtleSwgdm9pZCAwLCBvbGRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaGFzKHRhcmdldCwga2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5oYXModGFyZ2V0LCBrZXkpO1xuICAgIGlmICghaXNTeW1ib2woa2V5KSB8fCAhYnVpbHRJblN5bWJvbHMuaGFzKGtleSkpIHtcbiAgICAgIHRyYWNrKHRhcmdldCwgXCJoYXNcIiwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBvd25LZXlzKHRhcmdldCkge1xuICAgIHRyYWNrKFxuICAgICAgdGFyZ2V0LFxuICAgICAgXCJpdGVyYXRlXCIsXG4gICAgICBpc0FycmF5KHRhcmdldCkgPyBcImxlbmd0aFwiIDogSVRFUkFURV9LRVlcbiAgICApO1xuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgfVxufVxuY2xhc3MgUmVhZG9ubHlSZWFjdGl2ZUhhbmRsZXIgZXh0ZW5kcyBCYXNlUmVhY3RpdmVIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoaXNTaGFsbG93MiA9IGZhbHNlKSB7XG4gICAgc3VwZXIodHJ1ZSwgaXNTaGFsbG93Mik7XG4gIH1cbiAgc2V0KHRhcmdldCwga2V5KSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBTZXQgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRGVsZXRlIG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsXG4gICAgICAgIHRhcmdldFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNvbnN0IG11dGFibGVIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTXV0YWJsZVJlYWN0aXZlSGFuZGxlcigpO1xuY29uc3QgcmVhZG9ubHlIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVhZG9ubHlSZWFjdGl2ZUhhbmRsZXIoKTtcbmNvbnN0IHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNdXRhYmxlUmVhY3RpdmVIYW5kbGVyKHRydWUpO1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlYWRvbmx5UmVhY3RpdmVIYW5kbGVyKHRydWUpO1xuXG5jb25zdCB0b1NoYWxsb3cgPSAodmFsdWUpID0+IHZhbHVlO1xuY29uc3QgZ2V0UHJvdG8gPSAodikgPT4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZih2KTtcbmZ1bmN0aW9uIGdldCh0YXJnZXQsIGtleSwgaXNSZWFkb25seTIgPSBmYWxzZSwgaXNTaGFsbG93MiA9IGZhbHNlKSB7XG4gIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIl07XG4gIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gIGlmICghaXNSZWFkb25seTIpIHtcbiAgICBpZiAoaGFzQ2hhbmdlZChrZXksIHJhd0tleSkpIHtcbiAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiwga2V5KTtcbiAgICB9XG4gICAgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCByYXdLZXkpO1xuICB9XG4gIGNvbnN0IHsgaGFzOiBoYXMyIH0gPSBnZXRQcm90byhyYXdUYXJnZXQpO1xuICBjb25zdCB3cmFwID0gaXNTaGFsbG93MiA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkyID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gIGlmIChoYXMyLmNhbGwocmF3VGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChrZXkpKTtcbiAgfSBlbHNlIGlmIChoYXMyLmNhbGwocmF3VGFyZ2V0LCByYXdLZXkpKSB7XG4gICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChyYXdLZXkpKTtcbiAgfSBlbHNlIGlmICh0YXJnZXQgIT09IHJhd1RhcmdldCkge1xuICAgIHRhcmdldC5nZXQoa2V5KTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzKGtleSwgaXNSZWFkb25seTIgPSBmYWxzZSkge1xuICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgaWYgKCFpc1JlYWRvbmx5Mikge1xuICAgIGlmIChoYXNDaGFuZ2VkKGtleSwgcmF3S2V5KSkge1xuICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiLCBrZXkpO1xuICAgIH1cbiAgICB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIHJhd0tleSk7XG4gIH1cbiAgcmV0dXJuIGtleSA9PT0gcmF3S2V5ID8gdGFyZ2V0LmhhcyhrZXkpIDogdGFyZ2V0LmhhcyhrZXkpIHx8IHRhcmdldC5oYXMocmF3S2V5KTtcbn1cbmZ1bmN0aW9uIHNpemUodGFyZ2V0LCBpc1JlYWRvbmx5MiA9IGZhbHNlKSB7XG4gIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIl07XG4gICFpc1JlYWRvbmx5MiAmJiB0cmFjayh0b1Jhdyh0YXJnZXQpLCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xuICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBcInNpemVcIiwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGFkZCh2YWx1ZSwgX2lzU2hhbGxvdyA9IGZhbHNlKSB7XG4gIGlmICghX2lzU2hhbGxvdyAmJiAhaXNTaGFsbG93KHZhbHVlKSAmJiAhaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgfVxuICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgY29uc3QgcHJvdG8gPSBnZXRQcm90byh0YXJnZXQpO1xuICBjb25zdCBoYWRLZXkgPSBwcm90by5oYXMuY2FsbCh0YXJnZXQsIHZhbHVlKTtcbiAgaWYgKCFoYWRLZXkpIHtcbiAgICB0YXJnZXQuYWRkKHZhbHVlKTtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwgdmFsdWUsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlLCBfaXNTaGFsbG93ID0gZmFsc2UpIHtcbiAgaWYgKCFfaXNTaGFsbG93ICYmICFpc1NoYWxsb3codmFsdWUpICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICBjb25zdCB7IGhhczogaGFzMiwgZ2V0OiBnZXQyIH0gPSBnZXRQcm90byh0YXJnZXQpO1xuICBsZXQgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgaWYgKCFoYWRLZXkpIHtcbiAgICBrZXkgPSB0b1JhdyhrZXkpO1xuICAgIGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzMiwga2V5KTtcbiAgfVxuICBjb25zdCBvbGRWYWx1ZSA9IGdldDIuY2FsbCh0YXJnZXQsIGtleSk7XG4gIHRhcmdldC5zZXQoa2V5LCB2YWx1ZSk7XG4gIGlmICghaGFkS2V5KSB7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBkZWxldGVFbnRyeShrZXkpIHtcbiAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gIGNvbnN0IHsgaGFzOiBoYXMyLCBnZXQ6IGdldDIgfSA9IGdldFByb3RvKHRhcmdldCk7XG4gIGxldCBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICBpZiAoIWhhZEtleSkge1xuICAgIGtleSA9IHRvUmF3KGtleSk7XG4gICAgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMyLCBrZXkpO1xuICB9XG4gIGNvbnN0IG9sZFZhbHVlID0gZ2V0MiA/IGdldDIuY2FsbCh0YXJnZXQsIGtleSkgOiB2b2lkIDA7XG4gIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5kZWxldGUoa2V5KTtcbiAgaWYgKGhhZEtleSkge1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiLCBrZXksIHZvaWQgMCwgb2xkVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gIGNvbnN0IGhhZEl0ZW1zID0gdGFyZ2V0LnNpemUgIT09IDA7XG4gIGNvbnN0IG9sZFRhcmdldCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBpc01hcCh0YXJnZXQpID8gbmV3IE1hcCh0YXJnZXQpIDogbmV3IFNldCh0YXJnZXQpIDogdm9pZCAwO1xuICBjb25zdCByZXN1bHQgPSB0YXJnZXQuY2xlYXIoKTtcbiAgaWYgKGhhZEl0ZW1zKSB7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiY2xlYXJcIiwgdm9pZCAwLCB2b2lkIDAsIG9sZFRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZvckVhY2goaXNSZWFkb25seTIsIGlzU2hhbGxvdzIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBjb25zdCBvYnNlcnZlZCA9IHRoaXM7XG4gICAgY29uc3QgdGFyZ2V0ID0gb2JzZXJ2ZWRbXCJfX3ZfcmF3XCJdO1xuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdzIgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5MiA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICFpc1JlYWRvbmx5MiAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiLCBJVEVSQVRFX0tFWSk7XG4gICAgcmV0dXJuIHRhcmdldC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB3cmFwKHZhbHVlKSwgd3JhcChrZXkpLCBvYnNlcnZlZCk7XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGlzUmVhZG9ubHkyLCBpc1NoYWxsb3cyKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICBjb25zdCB0YXJnZXRJc01hcCA9IGlzTWFwKHJhd1RhcmdldCk7XG4gICAgY29uc3QgaXNQYWlyID0gbWV0aG9kID09PSBcImVudHJpZXNcIiB8fCBtZXRob2QgPT09IFN5bWJvbC5pdGVyYXRvciAmJiB0YXJnZXRJc01hcDtcbiAgICBjb25zdCBpc0tleU9ubHkgPSBtZXRob2QgPT09IFwia2V5c1wiICYmIHRhcmdldElzTWFwO1xuICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0YXJnZXRbbWV0aG9kXSguLi5hcmdzKTtcbiAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93MiA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkyID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgIWlzUmVhZG9ubHkyICYmIHRyYWNrKFxuICAgICAgcmF3VGFyZ2V0LFxuICAgICAgXCJpdGVyYXRlXCIsXG4gICAgICBpc0tleU9ubHkgPyBNQVBfS0VZX0lURVJBVEVfS0VZIDogSVRFUkFURV9LRVlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBpdGVyYXRvciBwcm90b2NvbFxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBkb25lID8geyB2YWx1ZSwgZG9uZSB9IDoge1xuICAgICAgICAgIHZhbHVlOiBpc1BhaXIgPyBbd3JhcCh2YWx1ZVswXSksIHdyYXAodmFsdWVbMV0pXSA6IHdyYXAodmFsdWUpLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICAvLyBpdGVyYWJsZSBwcm90b2NvbFxuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFkb25seU1ldGhvZCh0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF0gPyBgb24ga2V5IFwiJHthcmdzWzBdfVwiIGAgOiBgYDtcbiAgICAgIHdhcm4oXG4gICAgICAgIGAke2NhcGl0YWxpemUodHlwZSl9IG9wZXJhdGlvbiAke2tleX1mYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgICB0b1Jhdyh0aGlzKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGUgPT09IFwiZGVsZXRlXCIgPyBmYWxzZSA6IHR5cGUgPT09IFwiY2xlYXJcIiA/IHZvaWQgMCA6IHRoaXM7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25zKCkge1xuICBjb25zdCBtdXRhYmxlSW5zdHJ1bWVudGF0aW9uczIgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCBrZXkpO1xuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcbiAgICB9LFxuICAgIGhhcyxcbiAgICBhZGQsXG4gICAgc2V0LFxuICAgIGRlbGV0ZTogZGVsZXRlRW50cnksXG4gICAgY2xlYXIsXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaChmYWxzZSwgZmFsc2UpXG4gIH07XG4gIGNvbnN0IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zMiA9IHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgZmFsc2UsIHRydWUpO1xuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcbiAgICB9LFxuICAgIGhhcyxcbiAgICBhZGQodmFsdWUpIHtcbiAgICAgIHJldHVybiBhZGQuY2FsbCh0aGlzLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHNldC5jYWxsKHRoaXMsIGtleSwgdmFsdWUsIHRydWUpO1xuICAgIH0sXG4gICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcbiAgICBjbGVhcixcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCB0cnVlKVxuICB9O1xuICBjb25zdCByZWFkb25seUluc3RydW1lbnRhdGlvbnMyID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywga2V5LCB0cnVlKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gaGFzLmNhbGwodGhpcywga2V5LCB0cnVlKTtcbiAgICB9LFxuICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiksXG4gICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiKSxcbiAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIpLFxuICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIpLFxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgZmFsc2UpXG4gIH07XG4gIGNvbnN0IHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMyID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywga2V5LCB0cnVlLCB0cnVlKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gaGFzLmNhbGwodGhpcywga2V5LCB0cnVlKTtcbiAgICB9LFxuICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiksXG4gICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiKSxcbiAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIpLFxuICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIpLFxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgdHJ1ZSlcbiAgfTtcbiAgY29uc3QgaXRlcmF0b3JNZXRob2RzID0gW1xuICAgIFwia2V5c1wiLFxuICAgIFwidmFsdWVzXCIsXG4gICAgXCJlbnRyaWVzXCIsXG4gICAgU3ltYm9sLml0ZXJhdG9yXG4gIF07XG4gIGl0ZXJhdG9yTWV0aG9kcy5mb3JFYWNoKChtZXRob2QpID0+IHtcbiAgICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9uczJbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcbiAgICByZWFkb25seUluc3RydW1lbnRhdGlvbnMyW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHRydWUsIGZhbHNlKTtcbiAgICBzaGFsbG93SW5zdHJ1bWVudGF0aW9uczJbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgZmFsc2UsIHRydWUpO1xuICAgIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMyW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChcbiAgICAgIG1ldGhvZCxcbiAgICAgIHRydWUsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfSk7XG4gIHJldHVybiBbXG4gICAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMyLFxuICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczIsXG4gICAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMyLFxuICAgIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMyXG4gIF07XG59XG5jb25zdCBbXG4gIG11dGFibGVJbnN0cnVtZW50YXRpb25zLFxuICByZWFkb25seUluc3RydW1lbnRhdGlvbnMsXG4gIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zLFxuICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXG5dID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoKTtcbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihpc1JlYWRvbmx5Miwgc2hhbGxvdykge1xuICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0gc2hhbGxvdyA/IGlzUmVhZG9ubHkyID8gc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA6IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zIDogaXNSZWFkb25seTIgPyByZWFkb25seUluc3RydW1lbnRhdGlvbnMgOiBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucztcbiAgcmV0dXJuICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHtcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcbiAgICAgIHJldHVybiAhaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIikge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIikge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0KFxuICAgICAgaGFzT3duKGluc3RydW1lbnRhdGlvbnMsIGtleSkgJiYga2V5IGluIHRhcmdldCA/IGluc3RydW1lbnRhdGlvbnMgOiB0YXJnZXQsXG4gICAgICBrZXksXG4gICAgICByZWNlaXZlclxuICAgICk7XG4gIH07XG59XG5jb25zdCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIGZhbHNlKVxufTtcbmNvbnN0IHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgdHJ1ZSlcbn07XG5jb25zdCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIGZhbHNlKVxufTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIHRydWUpXG59O1xuZnVuY3Rpb24gY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMyLCBrZXkpIHtcbiAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgaWYgKHJhd0tleSAhPT0ga2V5ICYmIGhhczIuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcbiAgICBjb25zdCB0eXBlID0gdG9SYXdUeXBlKHRhcmdldCk7XG4gICAgd2FybihcbiAgICAgIGBSZWFjdGl2ZSAke3R5cGV9IGNvbnRhaW5zIGJvdGggdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgdGhlIHNhbWUgb2JqZWN0JHt0eXBlID09PSBgTWFwYCA/IGAgYXMga2V5c2AgOiBgYH0sIHdoaWNoIGNhbiBsZWFkIHRvIGluY29uc2lzdGVuY2llcy4gQXZvaWQgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgYW4gb2JqZWN0IGFuZCBvbmx5IHVzZSB0aGUgcmVhY3RpdmUgdmVyc2lvbiBpZiBwb3NzaWJsZS5gXG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCByZWFjdGl2ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2hhbGxvd1JlYWN0aXZlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZWFkb25seU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB0YXJnZXRUeXBlTWFwKHJhd1R5cGUpIHtcbiAgc3dpdGNoIChyYXdUeXBlKSB7XG4gICAgY2FzZSBcIk9iamVjdFwiOlxuICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgcmV0dXJuIDEgLyogQ09NTU9OICovO1xuICAgIGNhc2UgXCJNYXBcIjpcbiAgICBjYXNlIFwiU2V0XCI6XG4gICAgY2FzZSBcIldlYWtNYXBcIjpcbiAgICBjYXNlIFwiV2Vha1NldFwiOlxuICAgICAgcmV0dXJuIDIgLyogQ09MTEVDVElPTiAqLztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDAgLyogSU5WQUxJRCAqLztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0VHlwZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWVbXCJfX3Zfc2tpcFwiXSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgPyAwIC8qIElOVkFMSUQgKi8gOiB0YXJnZXRUeXBlTWFwKHRvUmF3VHlwZSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gcmVhY3RpdmUodGFyZ2V0KSB7XG4gIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgZmFsc2UsXG4gICAgbXV0YWJsZUhhbmRsZXJzLFxuICAgIG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgcmVhY3RpdmVNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWFjdGl2ZSh0YXJnZXQpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICBmYWxzZSxcbiAgICBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyxcbiAgICBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHNoYWxsb3dSZWFjdGl2ZU1hcFxuICApO1xufVxuZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgdHJ1ZSxcbiAgICByZWFkb25seUhhbmRsZXJzLFxuICAgIHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHJlYWRvbmx5TWFwXG4gICk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVhZG9ubHkodGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgdHJ1ZSxcbiAgICBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyxcbiAgICBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgc2hhbGxvd1JlYWRvbmx5TWFwXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGlzUmVhZG9ubHkyLCBiYXNlSGFuZGxlcnMsIGNvbGxlY3Rpb25IYW5kbGVycywgcHJveHlNYXApIHtcbiAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSAke2lzUmVhZG9ubHkyID8gXCJyZWFkb25seVwiIDogXCJyZWFjdGl2ZVwifTogJHtTdHJpbmcoXG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgICl9YFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBpZiAodGFyZ2V0W1wiX192X3Jhd1wiXSAmJiAhKGlzUmVhZG9ubHkyICYmIHRhcmdldFtcIl9fdl9pc1JlYWN0aXZlXCJdKSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHByb3h5TWFwLmdldCh0YXJnZXQpO1xuICBpZiAoZXhpc3RpbmdQcm94eSkge1xuICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xuICB9XG4gIGNvbnN0IHRhcmdldFR5cGUgPSBnZXRUYXJnZXRUeXBlKHRhcmdldCk7XG4gIGlmICh0YXJnZXRUeXBlID09PSAwIC8qIElOVkFMSUQgKi8pIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KFxuICAgIHRhcmdldCxcbiAgICB0YXJnZXRUeXBlID09PSAyIC8qIENPTExFQ1RJT04gKi8gPyBjb2xsZWN0aW9uSGFuZGxlcnMgOiBiYXNlSGFuZGxlcnNcbiAgKTtcbiAgcHJveHlNYXAuc2V0KHRhcmdldCwgcHJveHkpO1xuICByZXR1cm4gcHJveHk7XG59XG5mdW5jdGlvbiBpc1JlYWN0aXZlKHZhbHVlKSB7XG4gIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlW1wiX192X3Jhd1wiXSk7XG4gIH1cbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhY3RpdmVcIl0pO1xufVxuZnVuY3Rpb24gaXNSZWFkb25seSh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFkb25seVwiXSk7XG59XG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzU2hhbGxvd1wiXSk7XG59XG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/ICEhdmFsdWVbXCJfX3ZfcmF3XCJdIDogZmFsc2U7XG59XG5mdW5jdGlvbiB0b1JhdyhvYnNlcnZlZCkge1xuICBjb25zdCByYXcgPSBvYnNlcnZlZCAmJiBvYnNlcnZlZFtcIl9fdl9yYXdcIl07XG4gIHJldHVybiByYXcgPyB0b1JhdyhyYXcpIDogb2JzZXJ2ZWQ7XG59XG5mdW5jdGlvbiBtYXJrUmF3KHZhbHVlKSB7XG4gIGlmIChPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSkge1xuICAgIGRlZih2YWx1ZSwgXCJfX3Zfc2tpcFwiLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCB0b1JlYWN0aXZlID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFjdGl2ZSh2YWx1ZSkgOiB2YWx1ZTtcbmNvbnN0IHRvUmVhZG9ubHkgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWRvbmx5KHZhbHVlKSA6IHZhbHVlO1xuXG5mdW5jdGlvbiBpc1JlZihyKSB7XG4gIHJldHVybiByID8gcltcIl9fdl9pc1JlZlwiXSA9PT0gdHJ1ZSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gcmVmKHZhbHVlKSB7XG4gIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWYodmFsdWUpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWYocmF3VmFsdWUsIHNoYWxsb3cpIHtcbiAgaWYgKGlzUmVmKHJhd1ZhbHVlKSkge1xuICAgIHJldHVybiByYXdWYWx1ZTtcbiAgfVxuICByZXR1cm4gbmV3IFJlZkltcGwocmF3VmFsdWUsIHNoYWxsb3cpO1xufVxuY2xhc3MgUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBpc1NoYWxsb3cyKSB7XG4gICAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gICAgdGhpc1tcIl9fdl9pc1JlZlwiXSA9IHRydWU7XG4gICAgdGhpc1tcIl9fdl9pc1NoYWxsb3dcIl0gPSBmYWxzZTtcbiAgICB0aGlzLl9yYXdWYWx1ZSA9IGlzU2hhbGxvdzIgPyB2YWx1ZSA6IHRvUmF3KHZhbHVlKTtcbiAgICB0aGlzLl92YWx1ZSA9IGlzU2hhbGxvdzIgPyB2YWx1ZSA6IHRvUmVhY3RpdmUodmFsdWUpO1xuICAgIHRoaXNbXCJfX3ZfaXNTaGFsbG93XCJdID0gaXNTaGFsbG93MjtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHRoaXMuZGVwLnRyYWNrKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICB0eXBlOiBcImdldFwiLFxuICAgICAgICBrZXk6IFwidmFsdWVcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVwLnRyYWNrKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX3Jhd1ZhbHVlO1xuICAgIGNvbnN0IHVzZURpcmVjdFZhbHVlID0gdGhpc1tcIl9fdl9pc1NoYWxsb3dcIl0gfHwgaXNTaGFsbG93KG5ld1ZhbHVlKSB8fCBpc1JlYWRvbmx5KG5ld1ZhbHVlKTtcbiAgICBuZXdWYWx1ZSA9IHVzZURpcmVjdFZhbHVlID8gbmV3VmFsdWUgOiB0b1JhdyhuZXdWYWx1ZSk7XG4gICAgaWYgKGhhc0NoYW5nZWQobmV3VmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgdGhpcy5fcmF3VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gdXNlRGlyZWN0VmFsdWUgPyBuZXdWYWx1ZSA6IHRvUmVhY3RpdmUobmV3VmFsdWUpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgdGhpcy5kZXAudHJpZ2dlcih7XG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAga2V5OiBcInZhbHVlXCIsXG4gICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgb2xkVmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlcC50cmlnZ2VyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyUmVmKHJlZjIpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICByZWYyLmRlcC50cmlnZ2VyKHtcbiAgICAgIHRhcmdldDogcmVmMixcbiAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICBrZXk6IFwidmFsdWVcIixcbiAgICAgIG5ld1ZhbHVlOiByZWYyLl92YWx1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJlZjIuZGVwLnRyaWdnZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gdW5yZWYocmVmMikge1xuICByZXR1cm4gaXNSZWYocmVmMikgPyByZWYyLnZhbHVlIDogcmVmMjtcbn1cbmZ1bmN0aW9uIHRvVmFsdWUoc291cmNlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHNvdXJjZSkgPyBzb3VyY2UoKSA6IHVucmVmKHNvdXJjZSk7XG59XG5jb25zdCBzaGFsbG93VW53cmFwSGFuZGxlcnMgPSB7XG4gIGdldDogKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4gdW5yZWYoUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSksXG4gIHNldDogKHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpID0+IHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gcHJveHlSZWZzKG9iamVjdFdpdGhSZWZzKSB7XG4gIHJldHVybiBpc1JlYWN0aXZlKG9iamVjdFdpdGhSZWZzKSA/IG9iamVjdFdpdGhSZWZzIDogbmV3IFByb3h5KG9iamVjdFdpdGhSZWZzLCBzaGFsbG93VW53cmFwSGFuZGxlcnMpO1xufVxuY2xhc3MgQ3VzdG9tUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKGZhY3RvcnkpIHtcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcbiAgICB0aGlzLl92YWx1ZSA9IHZvaWQgMDtcbiAgICBjb25zdCBkZXAgPSB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgICBjb25zdCB7IGdldCwgc2V0IH0gPSBmYWN0b3J5KGRlcC50cmFjay5iaW5kKGRlcCksIGRlcC50cmlnZ2VyLmJpbmQoZGVwKSk7XG4gICAgdGhpcy5fZ2V0ID0gZ2V0O1xuICAgIHRoaXMuX3NldCA9IHNldDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdGhpcy5fZ2V0KCk7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgIHRoaXMuX3NldChuZXdWYWwpO1xuICB9XG59XG5mdW5jdGlvbiBjdXN0b21SZWYoZmFjdG9yeSkge1xuICByZXR1cm4gbmV3IEN1c3RvbVJlZkltcGwoZmFjdG9yeSk7XG59XG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc1Byb3h5KG9iamVjdCkpIHtcbiAgICB3YXJuKGB0b1JlZnMoKSBleHBlY3RzIGEgcmVhY3RpdmUgb2JqZWN0IGJ1dCByZWNlaXZlZCBhIHBsYWluIG9uZS5gKTtcbiAgfVxuICBjb25zdCByZXQgPSBpc0FycmF5KG9iamVjdCkgPyBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCkgOiB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgcmV0W2tleV0gPSBwcm9wZXJ0eVRvUmVmKG9iamVjdCwga2V5KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuY2xhc3MgT2JqZWN0UmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKF9vYmplY3QsIF9rZXksIF9kZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLl9vYmplY3QgPSBfb2JqZWN0O1xuICAgIHRoaXMuX2tleSA9IF9rZXk7XG4gICAgdGhpcy5fZGVmYXVsdFZhbHVlID0gX2RlZmF1bHRWYWx1ZTtcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcbiAgICB0aGlzLl92YWx1ZSA9IHZvaWQgMDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy5fb2JqZWN0W3RoaXMuX2tleV07XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdmFsID09PSB2b2lkIDAgPyB0aGlzLl9kZWZhdWx0VmFsdWUgOiB2YWw7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgIHRoaXMuX29iamVjdFt0aGlzLl9rZXldID0gbmV3VmFsO1xuICB9XG4gIGdldCBkZXAoKSB7XG4gICAgcmV0dXJuIGdldERlcEZyb21SZWFjdGl2ZSh0b1Jhdyh0aGlzLl9vYmplY3QpLCB0aGlzLl9rZXkpO1xuICB9XG59XG5jbGFzcyBHZXR0ZXJSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoX2dldHRlcikge1xuICAgIHRoaXMuX2dldHRlciA9IF9nZXR0ZXI7XG4gICAgdGhpc1tcIl9fdl9pc1JlZlwiXSA9IHRydWU7XG4gICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCJdID0gdHJ1ZTtcbiAgICB0aGlzLl92YWx1ZSA9IHZvaWQgMDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdGhpcy5fZ2V0dGVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvUmVmKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgIHJldHVybiBuZXcgR2V0dGVyUmVmSW1wbChzb3VyY2UpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gcHJvcGVydHlUb1JlZihzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVmKHNvdXJjZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3BlcnR5VG9SZWYoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICBjb25zdCB2YWwgPSBzb3VyY2Vba2V5XTtcbiAgcmV0dXJuIGlzUmVmKHZhbCkgPyB2YWwgOiBuZXcgT2JqZWN0UmVmSW1wbChzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKTtcbn1cblxuY2xhc3MgQ29tcHV0ZWRSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoZm4sIHNldHRlciwgaXNTU1IpIHtcbiAgICB0aGlzLmZuID0gZm47XG4gICAgdGhpcy5zZXR0ZXIgPSBzZXR0ZXI7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fdmFsdWUgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5kZXAgPSBuZXcgRGVwKHRoaXMpO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICAvLyBUT0RPIGlzb2xhdGVkRGVjbGFyYXRpb25zIFwiX192X2lzUmVhZG9ubHlcIlxuICAgIC8vIEEgY29tcHV0ZWQgaXMgYWxzbyBhIHN1YnNjcmliZXIgdGhhdCB0cmFja3Mgb3RoZXIgZGVwc1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwcyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlcHNUYWlsID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZmxhZ3MgPSAxNjtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmdsb2JhbFZlcnNpb24gPSBnbG9iYWxWZXJzaW9uIC0gMTtcbiAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgIHRoaXMuZWZmZWN0ID0gdGhpcztcbiAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIl0gPSAhc2V0dGVyO1xuICAgIHRoaXMuaXNTU1IgPSBpc1NTUjtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBub3RpZnkoKSB7XG4gICAgaWYgKGFjdGl2ZVN1YiAhPT0gdGhpcykge1xuICAgICAgdGhpcy5mbGFncyB8PSAxNjtcbiAgICAgIHRoaXMuZGVwLm5vdGlmeSgpO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkgO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBjb25zdCBsaW5rID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHRoaXMuZGVwLnRyYWNrKHtcbiAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgIHR5cGU6IFwiZ2V0XCIsXG4gICAgICBrZXk6IFwidmFsdWVcIlxuICAgIH0pIDogdGhpcy5kZXAudHJhY2soKTtcbiAgICByZWZyZXNoQ29tcHV0ZWQodGhpcyk7XG4gICAgaWYgKGxpbmspIHtcbiAgICAgIGxpbmsudmVyc2lvbiA9IHRoaXMuZGVwLnZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICBpZiAodGhpcy5zZXR0ZXIpIHtcbiAgICAgIHRoaXMuc2V0dGVyKG5ld1ZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXCJXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCB2YWx1ZSBpcyByZWFkb25seVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVkKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc1NTUiA9IGZhbHNlKSB7XG4gIGxldCBnZXR0ZXI7XG4gIGxldCBzZXR0ZXI7XG4gIGlmIChpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucykpIHtcbiAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnM7XG4gIH0gZWxzZSB7XG4gICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcbiAgICBzZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuc2V0O1xuICB9XG4gIGNvbnN0IGNSZWYgPSBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBpc1NTUik7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGRlYnVnT3B0aW9ucyAmJiAhaXNTU1IpIHtcbiAgICBjUmVmLm9uVHJhY2sgPSBkZWJ1Z09wdGlvbnMub25UcmFjaztcbiAgICBjUmVmLm9uVHJpZ2dlciA9IGRlYnVnT3B0aW9ucy5vblRyaWdnZXI7XG4gIH1cbiAgcmV0dXJuIGNSZWY7XG59XG5cbmNvbnN0IFRyYWNrT3BUeXBlcyA9IHtcbiAgXCJHRVRcIjogXCJnZXRcIixcbiAgXCJIQVNcIjogXCJoYXNcIixcbiAgXCJJVEVSQVRFXCI6IFwiaXRlcmF0ZVwiXG59O1xuY29uc3QgVHJpZ2dlck9wVHlwZXMgPSB7XG4gIFwiU0VUXCI6IFwic2V0XCIsXG4gIFwiQUREXCI6IFwiYWRkXCIsXG4gIFwiREVMRVRFXCI6IFwiZGVsZXRlXCIsXG4gIFwiQ0xFQVJcIjogXCJjbGVhclwiXG59O1xuY29uc3QgUmVhY3RpdmVGbGFncyA9IHtcbiAgXCJTS0lQXCI6IFwiX192X3NraXBcIixcbiAgXCJJU19SRUFDVElWRVwiOiBcIl9fdl9pc1JlYWN0aXZlXCIsXG4gIFwiSVNfUkVBRE9OTFlcIjogXCJfX3ZfaXNSZWFkb25seVwiLFxuICBcIklTX1NIQUxMT1dcIjogXCJfX3ZfaXNTaGFsbG93XCIsXG4gIFwiUkFXXCI6IFwiX192X3Jhd1wiLFxuICBcIklTX1JFRlwiOiBcIl9fdl9pc1JlZlwiXG59O1xuXG5jb25zdCBXYXRjaEVycm9yQ29kZXMgPSB7XG4gIFwiV0FUQ0hfR0VUVEVSXCI6IDIsXG4gIFwiMlwiOiBcIldBVENIX0dFVFRFUlwiLFxuICBcIldBVENIX0NBTExCQUNLXCI6IDMsXG4gIFwiM1wiOiBcIldBVENIX0NBTExCQUNLXCIsXG4gIFwiV0FUQ0hfQ0xFQU5VUFwiOiA0LFxuICBcIjRcIjogXCJXQVRDSF9DTEVBTlVQXCJcbn07XG5jb25zdCBJTklUSUFMX1dBVENIRVJfVkFMVUUgPSB7fTtcbmNvbnN0IGNsZWFudXBNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmxldCBhY3RpdmVXYXRjaGVyID0gdm9pZCAwO1xuZnVuY3Rpb24gZ2V0Q3VycmVudFdhdGNoZXIoKSB7XG4gIHJldHVybiBhY3RpdmVXYXRjaGVyO1xufVxuZnVuY3Rpb24gb25XYXRjaGVyQ2xlYW51cChjbGVhbnVwRm4sIGZhaWxTaWxlbnRseSA9IGZhbHNlLCBvd25lciA9IGFjdGl2ZVdhdGNoZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgbGV0IGNsZWFudXBzID0gY2xlYW51cE1hcC5nZXQob3duZXIpO1xuICAgIGlmICghY2xlYW51cHMpIGNsZWFudXBNYXAuc2V0KG93bmVyLCBjbGVhbnVwcyA9IFtdKTtcbiAgICBjbGVhbnVwcy5wdXNoKGNsZWFudXBGbik7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZmFpbFNpbGVudGx5KSB7XG4gICAgd2FybihcbiAgICAgIGBvbldhdGNoZXJDbGVhbnVwKCkgd2FzIGNhbGxlZCB3aGVuIHRoZXJlIHdhcyBubyBhY3RpdmUgd2F0Y2hlciB0byBhc3NvY2lhdGUgd2l0aC5gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyA9IEVNUFRZX09CSikge1xuICBjb25zdCB7IGltbWVkaWF0ZSwgZGVlcCwgb25jZSwgc2NoZWR1bGVyLCBhdWdtZW50Sm9iLCBjYWxsIH0gPSBvcHRpb25zO1xuICBjb25zdCB3YXJuSW52YWxpZFNvdXJjZSA9IChzKSA9PiB7XG4gICAgKG9wdGlvbnMub25XYXJuIHx8IHdhcm4pKFxuICAgICAgYEludmFsaWQgd2F0Y2ggc291cmNlOiBgLFxuICAgICAgcyxcbiAgICAgIGBBIHdhdGNoIHNvdXJjZSBjYW4gb25seSBiZSBhIGdldHRlci9lZmZlY3QgZnVuY3Rpb24sIGEgcmVmLCBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuYFxuICAgICk7XG4gIH07XG4gIGNvbnN0IHJlYWN0aXZlR2V0dGVyID0gKHNvdXJjZTIpID0+IHtcbiAgICBpZiAoZGVlcCkgcmV0dXJuIHNvdXJjZTI7XG4gICAgaWYgKGlzU2hhbGxvdyhzb3VyY2UyKSB8fCBkZWVwID09PSBmYWxzZSB8fCBkZWVwID09PSAwKVxuICAgICAgcmV0dXJuIHRyYXZlcnNlKHNvdXJjZTIsIDEpO1xuICAgIHJldHVybiB0cmF2ZXJzZShzb3VyY2UyKTtcbiAgfTtcbiAgbGV0IGVmZmVjdDtcbiAgbGV0IGdldHRlcjtcbiAgbGV0IGNsZWFudXA7XG4gIGxldCBib3VuZENsZWFudXA7XG4gIGxldCBmb3JjZVRyaWdnZXIgPSBmYWxzZTtcbiAgbGV0IGlzTXVsdGlTb3VyY2UgPSBmYWxzZTtcbiAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcbiAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UudmFsdWU7XG4gICAgZm9yY2VUcmlnZ2VyID0gaXNTaGFsbG93KHNvdXJjZSk7XG4gIH0gZWxzZSBpZiAoaXNSZWFjdGl2ZShzb3VyY2UpKSB7XG4gICAgZ2V0dGVyID0gKCkgPT4gcmVhY3RpdmVHZXR0ZXIoc291cmNlKTtcbiAgICBmb3JjZVRyaWdnZXIgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIGlzTXVsdGlTb3VyY2UgPSB0cnVlO1xuICAgIGZvcmNlVHJpZ2dlciA9IHNvdXJjZS5zb21lKChzKSA9PiBpc1JlYWN0aXZlKHMpIHx8IGlzU2hhbGxvdyhzKSk7XG4gICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLm1hcCgocykgPT4ge1xuICAgICAgaWYgKGlzUmVmKHMpKSB7XG4gICAgICAgIHJldHVybiBzLnZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWN0aXZlKHMpKSB7XG4gICAgICAgIHJldHVybiByZWFjdGl2ZUdldHRlcihzKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzKSkge1xuICAgICAgICByZXR1cm4gY2FsbCA/IGNhbGwocywgMikgOiBzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm5JbnZhbGlkU291cmNlKHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgIGlmIChjYikge1xuICAgICAgZ2V0dGVyID0gY2FsbCA/ICgpID0+IGNhbGwoc291cmNlLCAyKSA6IHNvdXJjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2V0dGVyID0gKCkgPT4ge1xuICAgICAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRFZmZlY3QgPSBhY3RpdmVXYXRjaGVyO1xuICAgICAgICBhY3RpdmVXYXRjaGVyID0gZWZmZWN0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBjYWxsID8gY2FsbChzb3VyY2UsIDMsIFtib3VuZENsZWFudXBdKSA6IHNvdXJjZShib3VuZENsZWFudXApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGFjdGl2ZVdhdGNoZXIgPSBjdXJyZW50RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBnZXR0ZXIgPSBOT09QO1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybkludmFsaWRTb3VyY2Uoc291cmNlKTtcbiAgfVxuICBpZiAoY2IgJiYgZGVlcCkge1xuICAgIGNvbnN0IGJhc2VHZXR0ZXIgPSBnZXR0ZXI7XG4gICAgY29uc3QgZGVwdGggPSBkZWVwID09PSB0cnVlID8gSW5maW5pdHkgOiBkZWVwO1xuICAgIGdldHRlciA9ICgpID0+IHRyYXZlcnNlKGJhc2VHZXR0ZXIoKSwgZGVwdGgpO1xuICB9XG4gIGlmIChvbmNlKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjb25zdCBfY2IgPSBjYjtcbiAgICAgIGNiID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgX2NiKC4uLmFyZ3MpO1xuICAgICAgICBlZmZlY3Quc3RvcCgpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgX2dldHRlciA9IGdldHRlcjtcbiAgICAgIGdldHRlciA9ICgpID0+IHtcbiAgICAgICAgX2dldHRlcigpO1xuICAgICAgICBlZmZlY3Quc3RvcCgpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgbGV0IG9sZFZhbHVlID0gaXNNdWx0aVNvdXJjZSA/IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKS5maWxsKElOSVRJQUxfV0FUQ0hFUl9WQUxVRSkgOiBJTklUSUFMX1dBVENIRVJfVkFMVUU7XG4gIGNvbnN0IGpvYiA9IChpbW1lZGlhdGVGaXJzdFJ1bikgPT4ge1xuICAgIGlmICghKGVmZmVjdC5mbGFncyAmIDEpIHx8ICFlZmZlY3QuZGlydHkgJiYgIWltbWVkaWF0ZUZpcnN0UnVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYikge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBlZmZlY3QucnVuKCk7XG4gICAgICBpZiAoZGVlcCB8fCBmb3JjZVRyaWdnZXIgfHwgKGlzTXVsdGlTb3VyY2UgPyBuZXdWYWx1ZS5zb21lKCh2LCBpKSA9PiBoYXNDaGFuZ2VkKHYsIG9sZFZhbHVlW2ldKSkgOiBoYXNDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpKSB7XG4gICAgICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRXYXRjaGVyID0gYWN0aXZlV2F0Y2hlcjtcbiAgICAgICAgYWN0aXZlV2F0Y2hlciA9IGVmZmVjdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgICAvLyBwYXNzIHVuZGVmaW5lZCBhcyB0aGUgb2xkIHZhbHVlIHdoZW4gaXQncyBjaGFuZ2VkIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgb2xkVmFsdWUgPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IHZvaWQgMCA6IGlzTXVsdGlTb3VyY2UgJiYgb2xkVmFsdWVbMF0gPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IFtdIDogb2xkVmFsdWUsXG4gICAgICAgICAgICBib3VuZENsZWFudXBcbiAgICAgICAgICBdO1xuICAgICAgICAgIGNhbGwgPyBjYWxsKGNiLCAzLCBhcmdzKSA6IChcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGNiKC4uLmFyZ3MpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGFjdGl2ZVdhdGNoZXIgPSBjdXJyZW50V2F0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZmZlY3QucnVuKCk7XG4gICAgfVxuICB9O1xuICBpZiAoYXVnbWVudEpvYikge1xuICAgIGF1Z21lbnRKb2Ioam9iKTtcbiAgfVxuICBlZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZ2V0dGVyKTtcbiAgZWZmZWN0LnNjaGVkdWxlciA9IHNjaGVkdWxlciA/ICgpID0+IHNjaGVkdWxlcihqb2IsIGZhbHNlKSA6IGpvYjtcbiAgYm91bmRDbGVhbnVwID0gKGZuKSA9PiBvbldhdGNoZXJDbGVhbnVwKGZuLCBmYWxzZSwgZWZmZWN0KTtcbiAgY2xlYW51cCA9IGVmZmVjdC5vblN0b3AgPSAoKSA9PiB7XG4gICAgY29uc3QgY2xlYW51cHMgPSBjbGVhbnVwTWFwLmdldChlZmZlY3QpO1xuICAgIGlmIChjbGVhbnVwcykge1xuICAgICAgaWYgKGNhbGwpIHtcbiAgICAgICAgY2FsbChjbGVhbnVwcywgNCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGNsZWFudXAyIG9mIGNsZWFudXBzKSBjbGVhbnVwMigpO1xuICAgICAgfVxuICAgICAgY2xlYW51cE1hcC5kZWxldGUoZWZmZWN0KTtcbiAgICB9XG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgZWZmZWN0Lm9uVHJhY2sgPSBvcHRpb25zLm9uVHJhY2s7XG4gICAgZWZmZWN0Lm9uVHJpZ2dlciA9IG9wdGlvbnMub25UcmlnZ2VyO1xuICB9XG4gIGlmIChjYikge1xuICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgIGpvYih0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkVmFsdWUgPSBlZmZlY3QucnVuKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNjaGVkdWxlcikge1xuICAgIHNjaGVkdWxlcihqb2IuYmluZChudWxsLCB0cnVlKSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZWZmZWN0LnJ1bigpO1xuICB9XG4gIGNvbnN0IHNjb3BlID0gZ2V0Q3VycmVudFNjb3BlKCk7XG4gIGNvbnN0IHdhdGNoSGFuZGxlID0gKCkgPT4ge1xuICAgIGVmZmVjdC5zdG9wKCk7XG4gICAgaWYgKHNjb3BlKSB7XG4gICAgICByZW1vdmUoc2NvcGUuZWZmZWN0cywgZWZmZWN0KTtcbiAgICB9XG4gIH07XG4gIHdhdGNoSGFuZGxlLnBhdXNlID0gZWZmZWN0LnBhdXNlLmJpbmQoZWZmZWN0KTtcbiAgd2F0Y2hIYW5kbGUucmVzdW1lID0gZWZmZWN0LnJlc3VtZS5iaW5kKGVmZmVjdCk7XG4gIHdhdGNoSGFuZGxlLnN0b3AgPSB3YXRjaEhhbmRsZTtcbiAgcmV0dXJuIHdhdGNoSGFuZGxlO1xufVxuZnVuY3Rpb24gdHJhdmVyc2UodmFsdWUsIGRlcHRoID0gSW5maW5pdHksIHNlZW4pIHtcbiAgaWYgKGRlcHRoIDw9IDAgfHwgIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZVtcIl9fdl9za2lwXCJdKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgc2Vlbi5hZGQodmFsdWUpO1xuICBkZXB0aC0tO1xuICBpZiAoaXNSZWYodmFsdWUpKSB7XG4gICAgdHJhdmVyc2UodmFsdWUudmFsdWUsIGRlcHRoLCBzZWVuKTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlW2ldLCBkZXB0aCwgc2Vlbik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzU2V0KHZhbHVlKSB8fCBpc01hcCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICB0cmF2ZXJzZSh2LCBkZXB0aCwgc2Vlbik7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgdHJhdmVyc2UodmFsdWVba2V5XSwgZGVwdGgsIHNlZW4pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgICB0cmF2ZXJzZSh2YWx1ZVtrZXldLCBkZXB0aCwgc2Vlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IHsgQVJSQVlfSVRFUkFURV9LRVksIEVmZmVjdEZsYWdzLCBFZmZlY3RTY29wZSwgSVRFUkFURV9LRVksIE1BUF9LRVlfSVRFUkFURV9LRVksIFJlYWN0aXZlRWZmZWN0LCBSZWFjdGl2ZUZsYWdzLCBUcmFja09wVHlwZXMsIFRyaWdnZXJPcFR5cGVzLCBXYXRjaEVycm9yQ29kZXMsIGNvbXB1dGVkLCBjdXN0b21SZWYsIGVmZmVjdCwgZWZmZWN0U2NvcGUsIGVuYWJsZVRyYWNraW5nLCBnZXRDdXJyZW50U2NvcGUsIGdldEN1cnJlbnRXYXRjaGVyLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgaXNTaGFsbG93LCBtYXJrUmF3LCBvbkVmZmVjdENsZWFudXAsIG9uU2NvcGVEaXNwb3NlLCBvbldhdGNoZXJDbGVhbnVwLCBwYXVzZVRyYWNraW5nLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFjdGl2ZVJlYWRBcnJheSwgcmVhZG9ubHksIHJlZiwgcmVzZXRUcmFja2luZywgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZEFycmF5LCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlYWN0aXZlLCB0b1JlYWRvbmx5LCB0b1JlZiwgdG9SZWZzLCB0b1ZhbHVlLCB0cmFjaywgdHJhdmVyc2UsIHRyaWdnZXIsIHRyaWdnZXJSZWYsIHVucmVmLCB3YXRjaCB9O1xuIiwiLyoqXG4qIEB2dWUvc2hhcmVkIHYzLjUuMC1iZXRhLjNcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBleHBlY3RzTG93ZXJDYXNlKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoc3RyLnNwbGl0KFwiLFwiKSk7XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlID8gKHZhbCkgPT4gc2V0Lmhhcyh2YWwudG9Mb3dlckNhc2UoKSkgOiAodmFsKSA9PiBzZXQuaGFzKHZhbCk7XG59XG5cbmNvbnN0IEVNUFRZX09CSiA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBPYmplY3QuZnJlZXplKHt9KSA6IHt9O1xuY29uc3QgRU1QVFlfQVJSID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XG5jb25zdCBOT09QID0gKCkgPT4ge1xufTtcbmNvbnN0IE5PID0gKCkgPT4gZmFsc2U7XG5jb25zdCBpc09uID0gKGtleSkgPT4ga2V5LmNoYXJDb2RlQXQoMCkgPT09IDExMSAmJiBrZXkuY2hhckNvZGVBdCgxKSA9PT0gMTEwICYmIC8vIHVwcGVyY2FzZSBsZXR0ZXJcbihrZXkuY2hhckNvZGVBdCgyKSA+IDEyMiB8fCBrZXkuY2hhckNvZGVBdCgyKSA8IDk3KTtcbmNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKFwib25VcGRhdGU6XCIpO1xuY29uc3QgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbjtcbmNvbnN0IHJlbW92ZSA9IChhcnIsIGVsKSA9PiB7XG4gIGNvbnN0IGkgPSBhcnIuaW5kZXhPZihlbCk7XG4gIGlmIChpID4gLTEpIHtcbiAgICBhcnIuc3BsaWNlKGksIDEpO1xuICB9XG59O1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuY29uc3QgaGFzT3duID0gKHZhbCwga2V5KSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwga2V5KTtcbmNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuY29uc3QgaXNNYXAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IE1hcF1cIjtcbmNvbnN0IGlzU2V0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBTZXRdXCI7XG5jb25zdCBpc0RhdGUgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IERhdGVdXCI7XG5jb25zdCBpc1JlZ0V4cCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgUmVnRXhwXVwiO1xuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGlzU3RyaW5nID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIjtcbmNvbnN0IGlzU3ltYm9sID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJzeW1ib2xcIjtcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCI7XG5jb25zdCBpc1Byb21pc2UgPSAodmFsKSA9PiB7XG4gIHJldHVybiAoaXNPYmplY3QodmFsKSB8fCBpc0Z1bmN0aW9uKHZhbCkpICYmIGlzRnVuY3Rpb24odmFsLnRoZW4pICYmIGlzRnVuY3Rpb24odmFsLmNhdGNoKTtcbn07XG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCB0b1R5cGVTdHJpbmcgPSAodmFsdWUpID0+IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuY29uc3QgdG9SYXdUeXBlID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB0b1R5cGVTdHJpbmcodmFsdWUpLnNsaWNlKDgsIC0xKTtcbn07XG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG5jb25zdCBpc0ludGVnZXJLZXkgPSAoa2V5KSA9PiBpc1N0cmluZyhrZXkpICYmIGtleSAhPT0gXCJOYU5cIiAmJiBrZXlbMF0gIT09IFwiLVwiICYmIFwiXCIgKyBwYXJzZUludChrZXksIDEwKSA9PT0ga2V5O1xuY29uc3QgaXNSZXNlcnZlZFByb3AgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgLy8gdGhlIGxlYWRpbmcgY29tbWEgaXMgaW50ZW50aW9uYWwgc28gZW1wdHkgc3RyaW5nIFwiXCIgaXMgYWxzbyBpbmNsdWRlZFxuICBcIixrZXkscmVmLHJlZl9mb3IscmVmX2tleSxvblZub2RlQmVmb3JlTW91bnQsb25Wbm9kZU1vdW50ZWQsb25Wbm9kZUJlZm9yZVVwZGF0ZSxvblZub2RlVXBkYXRlZCxvblZub2RlQmVmb3JlVW5tb3VudCxvblZub2RlVW5tb3VudGVkXCJcbik7XG5jb25zdCBpc0J1aWx0SW5EaXJlY3RpdmUgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgXCJiaW5kLGNsb2FrLGVsc2UtaWYsZWxzZSxmb3IsaHRtbCxpZixtb2RlbCxvbixvbmNlLHByZSxzaG93LHNsb3QsdGV4dCxtZW1vXCJcbik7XG5jb25zdCBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoc3RyKSA9PiB7XG4gICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XG4gIH07XG59O1xuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbmNvbnN0IGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4ge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gYyA/IGMudG9VcHBlckNhc2UoKSA6IFwiXCIpO1xuICB9XG4pO1xuY29uc3QgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKClcbik7XG5jb25zdCBjYXBpdGFsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59KTtcbmNvbnN0IHRvSGFuZGxlcktleSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXG4gIChzdHIpID0+IHtcbiAgICBjb25zdCBzID0gc3RyID8gYG9uJHtjYXBpdGFsaXplKHN0cil9YCA6IGBgO1xuICAgIHJldHVybiBzO1xuICB9XG4pO1xuY29uc3QgaGFzQ2hhbmdlZCA9ICh2YWx1ZSwgb2xkVmFsdWUpID0+ICFPYmplY3QuaXModmFsdWUsIG9sZFZhbHVlKTtcbmNvbnN0IGludm9rZUFycmF5Rm5zID0gKGZucywgLi4uYXJnKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZm5zW2ldKC4uLmFyZyk7XG4gIH1cbn07XG5jb25zdCBkZWYgPSAob2JqLCBrZXksIHZhbHVlLCB3cml0YWJsZSA9IGZhbHNlKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZSxcbiAgICB2YWx1ZVxuICB9KTtcbn07XG5jb25zdCBsb29zZVRvTnVtYmVyID0gKHZhbCkgPT4ge1xuICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xufTtcbmNvbnN0IHRvTnVtYmVyID0gKHZhbCkgPT4ge1xuICBjb25zdCBuID0gaXNTdHJpbmcodmFsKSA/IE51bWJlcih2YWwpIDogTmFOO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xufTtcbmxldCBfZ2xvYmFsVGhpcztcbmNvbnN0IGdldEdsb2JhbFRoaXMgPSAoKSA9PiB7XG4gIHJldHVybiBfZ2xvYmFsVGhpcyB8fCAoX2dsb2JhbFRoaXMgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KTtcbn07XG5jb25zdCBpZGVudFJFID0gL15bXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVtfJGEtekEtWjAtOVxceEEwLVxcdUZGRkZdKiQvO1xuZnVuY3Rpb24gZ2VuUHJvcHNBY2Nlc3NFeHAobmFtZSkge1xuICByZXR1cm4gaWRlbnRSRS50ZXN0KG5hbWUpID8gYF9fcHJvcHMuJHtuYW1lfWAgOiBgX19wcm9wc1ske0pTT04uc3RyaW5naWZ5KG5hbWUpfV1gO1xufVxuXG5jb25zdCBQYXRjaEZsYWdzID0ge1xuICBcIlRFWFRcIjogMSxcbiAgXCIxXCI6IFwiVEVYVFwiLFxuICBcIkNMQVNTXCI6IDIsXG4gIFwiMlwiOiBcIkNMQVNTXCIsXG4gIFwiU1RZTEVcIjogNCxcbiAgXCI0XCI6IFwiU1RZTEVcIixcbiAgXCJQUk9QU1wiOiA4LFxuICBcIjhcIjogXCJQUk9QU1wiLFxuICBcIkZVTExfUFJPUFNcIjogMTYsXG4gIFwiMTZcIjogXCJGVUxMX1BST1BTXCIsXG4gIFwiTkVFRF9IWURSQVRJT05cIjogMzIsXG4gIFwiMzJcIjogXCJORUVEX0hZRFJBVElPTlwiLFxuICBcIlNUQUJMRV9GUkFHTUVOVFwiOiA2NCxcbiAgXCI2NFwiOiBcIlNUQUJMRV9GUkFHTUVOVFwiLFxuICBcIktFWUVEX0ZSQUdNRU5UXCI6IDEyOCxcbiAgXCIxMjhcIjogXCJLRVlFRF9GUkFHTUVOVFwiLFxuICBcIlVOS0VZRURfRlJBR01FTlRcIjogMjU2LFxuICBcIjI1NlwiOiBcIlVOS0VZRURfRlJBR01FTlRcIixcbiAgXCJORUVEX1BBVENIXCI6IDUxMixcbiAgXCI1MTJcIjogXCJORUVEX1BBVENIXCIsXG4gIFwiRFlOQU1JQ19TTE9UU1wiOiAxMDI0LFxuICBcIjEwMjRcIjogXCJEWU5BTUlDX1NMT1RTXCIsXG4gIFwiREVWX1JPT1RfRlJBR01FTlRcIjogMjA0OCxcbiAgXCIyMDQ4XCI6IFwiREVWX1JPT1RfRlJBR01FTlRcIixcbiAgXCJDQUNIRURcIjogLTEsXG4gIFwiLTFcIjogXCJDQUNIRURcIixcbiAgXCJCQUlMXCI6IC0yLFxuICBcIi0yXCI6IFwiQkFJTFwiXG59O1xuY29uc3QgUGF0Y2hGbGFnTmFtZXMgPSB7XG4gIFsxXTogYFRFWFRgLFxuICBbMl06IGBDTEFTU2AsXG4gIFs0XTogYFNUWUxFYCxcbiAgWzhdOiBgUFJPUFNgLFxuICBbMTZdOiBgRlVMTF9QUk9QU2AsXG4gIFszMl06IGBORUVEX0hZRFJBVElPTmAsXG4gIFs2NF06IGBTVEFCTEVfRlJBR01FTlRgLFxuICBbMTI4XTogYEtFWUVEX0ZSQUdNRU5UYCxcbiAgWzI1Nl06IGBVTktFWUVEX0ZSQUdNRU5UYCxcbiAgWzUxMl06IGBORUVEX1BBVENIYCxcbiAgWzEwMjRdOiBgRFlOQU1JQ19TTE9UU2AsXG4gIFsyMDQ4XTogYERFVl9ST09UX0ZSQUdNRU5UYCxcbiAgWy0xXTogYEhPSVNURURgLFxuICBbLTJdOiBgQkFJTGBcbn07XG5cbmNvbnN0IFNoYXBlRmxhZ3MgPSB7XG4gIFwiRUxFTUVOVFwiOiAxLFxuICBcIjFcIjogXCJFTEVNRU5UXCIsXG4gIFwiRlVOQ1RJT05BTF9DT01QT05FTlRcIjogMixcbiAgXCIyXCI6IFwiRlVOQ1RJT05BTF9DT01QT05FTlRcIixcbiAgXCJTVEFURUZVTF9DT01QT05FTlRcIjogNCxcbiAgXCI0XCI6IFwiU1RBVEVGVUxfQ09NUE9ORU5UXCIsXG4gIFwiVEVYVF9DSElMRFJFTlwiOiA4LFxuICBcIjhcIjogXCJURVhUX0NISUxEUkVOXCIsXG4gIFwiQVJSQVlfQ0hJTERSRU5cIjogMTYsXG4gIFwiMTZcIjogXCJBUlJBWV9DSElMRFJFTlwiLFxuICBcIlNMT1RTX0NISUxEUkVOXCI6IDMyLFxuICBcIjMyXCI6IFwiU0xPVFNfQ0hJTERSRU5cIixcbiAgXCJURUxFUE9SVFwiOiA2NCxcbiAgXCI2NFwiOiBcIlRFTEVQT1JUXCIsXG4gIFwiU1VTUEVOU0VcIjogMTI4LFxuICBcIjEyOFwiOiBcIlNVU1BFTlNFXCIsXG4gIFwiQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFXCI6IDI1NixcbiAgXCIyNTZcIjogXCJDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkVcIixcbiAgXCJDT01QT05FTlRfS0VQVF9BTElWRVwiOiA1MTIsXG4gIFwiNTEyXCI6IFwiQ09NUE9ORU5UX0tFUFRfQUxJVkVcIixcbiAgXCJDT01QT05FTlRcIjogNixcbiAgXCI2XCI6IFwiQ09NUE9ORU5UXCJcbn07XG5cbmNvbnN0IFNsb3RGbGFncyA9IHtcbiAgXCJTVEFCTEVcIjogMSxcbiAgXCIxXCI6IFwiU1RBQkxFXCIsXG4gIFwiRFlOQU1JQ1wiOiAyLFxuICBcIjJcIjogXCJEWU5BTUlDXCIsXG4gIFwiRk9SV0FSREVEXCI6IDMsXG4gIFwiM1wiOiBcIkZPUldBUkRFRFwiXG59O1xuY29uc3Qgc2xvdEZsYWdzVGV4dCA9IHtcbiAgWzFdOiBcIlNUQUJMRVwiLFxuICBbMl06IFwiRFlOQU1JQ1wiLFxuICBbM106IFwiRk9SV0FSREVEXCJcbn07XG5cbmNvbnN0IEdMT0JBTFNfQUxMT1dFRCA9IFwiSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTixwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCxNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50LGNvbnNvbGUsRXJyb3IsU3ltYm9sXCI7XG5jb25zdCBpc0dsb2JhbGx5QWxsb3dlZCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKEdMT0JBTFNfQUxMT1dFRCk7XG5jb25zdCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQgPSBpc0dsb2JhbGx5QWxsb3dlZDtcblxuY29uc3QgcmFuZ2UgPSAyO1xuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUoc291cmNlLCBzdGFydCA9IDAsIGVuZCA9IHNvdXJjZS5sZW5ndGgpIHtcbiAgc3RhcnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzdGFydCwgc291cmNlLmxlbmd0aCkpO1xuICBlbmQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihlbmQsIHNvdXJjZS5sZW5ndGgpKTtcbiAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gXCJcIjtcbiAgbGV0IGxpbmVzID0gc291cmNlLnNwbGl0KC8oXFxyP1xcbikvKTtcbiAgY29uc3QgbmV3bGluZVNlcXVlbmNlcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAxKTtcbiAgbGluZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMCk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgKG5ld2xpbmVTZXF1ZW5jZXNbaV0gJiYgbmV3bGluZVNlcXVlbmNlc1tpXS5sZW5ndGggfHwgMCk7XG4gICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XG4gICAgICBmb3IgKGxldCBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XG4gICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aCkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBqICsgMTtcbiAgICAgICAgcmVzLnB1c2goXG4gICAgICAgICAgYCR7bGluZX0ke1wiIFwiLnJlcGVhdChNYXRoLm1heCgzIC0gU3RyaW5nKGxpbmUpLmxlbmd0aCwgMCkpfXwgICR7bGluZXNbal19YFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICBjb25zdCBuZXdMaW5lU2VxTGVuZ3RoID0gbmV3bGluZVNlcXVlbmNlc1tqXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2pdLmxlbmd0aCB8fCAwO1xuICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgIGNvbnN0IHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gKGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoKSk7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnRcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgXCIgXCIucmVwZWF0KHBhZCkgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKSwgMSk7XG4gICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIFwiXlwiLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtpXTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBpc1N0cmluZyhpdGVtKSA/IHBhcnNlU3RyaW5nU3R5bGUoaXRlbSkgOiBub3JtYWxpemVTdHlsZShpdGVtKTtcbiAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmNvbnN0IGxpc3REZWxpbWl0ZXJSRSA9IC87KD8hW14oXSpcXCkpL2c7XG5jb25zdCBwcm9wZXJ0eURlbGltaXRlclJFID0gLzooW15dKykvO1xuY29uc3Qgc3R5bGVDb21tZW50UkUgPSAvXFwvXFwqW15dKj9cXCpcXC8vZztcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCkge1xuICBjb25zdCByZXQgPSB7fTtcbiAgY3NzVGV4dC5yZXBsYWNlKHN0eWxlQ29tbWVudFJFLCBcIlwiKS5zcGxpdChsaXN0RGVsaW1pdGVyUkUpLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlclJFKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXRbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGUoc3R5bGVzKSB7XG4gIGxldCByZXQgPSBcIlwiO1xuICBpZiAoIXN0eWxlcyB8fCBpc1N0cmluZyhzdHlsZXMpKSB7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1trZXldO1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnN0YXJ0c1dpdGgoYC0tYCkgPyBrZXkgOiBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIHJldCArPSBgJHtub3JtYWxpemVkS2V5fToke3ZhbHVlfTtgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3ModmFsdWUpIHtcbiAgbGV0IHJlcyA9IFwiXCI7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXMgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVDbGFzcyh2YWx1ZVtpXSk7XG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICByZXMgKz0gbm9ybWFsaXplZCArIFwiIFwiO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xuICAgICAgICByZXMgKz0gbmFtZSArIFwiIFwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzKHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHJldHVybiBudWxsO1xuICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcbiAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcbiAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcbiAgfVxuICBpZiAoc3R5bGUpIHtcbiAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgfVxuICByZXR1cm4gcHJvcHM7XG59XG5cbmNvbnN0IEhUTUxfVEFHUyA9IFwiaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaGdyb3VwLGgxLGgyLGgzLGg0LGg1LGg2LG5hdixzZWN0aW9uLGRpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLGEsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydWJ5LHMsc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLGVtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLGNhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLGJ1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSxkZXRhaWxzLGRpYWxvZyxtZW51LHN1bW1hcnksdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3RcIjtcbmNvbnN0IFNWR19UQUdTID0gXCJzdmcsYW5pbWF0ZSxhbmltYXRlTW90aW9uLGFuaW1hdGVUcmFuc2Zvcm0sY2lyY2xlLGNsaXBQYXRoLGNvbG9yLXByb2ZpbGUsZGVmcyxkZXNjLGRpc2NhcmQsZWxsaXBzZSxmZUJsZW5kLGZlQ29sb3JNYXRyaXgsZmVDb21wb25lbnRUcmFuc2ZlcixmZUNvbXBvc2l0ZSxmZUNvbnZvbHZlTWF0cml4LGZlRGlmZnVzZUxpZ2h0aW5nLGZlRGlzcGxhY2VtZW50TWFwLGZlRGlzdGFudExpZ2h0LGZlRHJvcFNoYWRvdyxmZUZsb29kLGZlRnVuY0EsZmVGdW5jQixmZUZ1bmNHLGZlRnVuY1IsZmVHYXVzc2lhbkJsdXIsZmVJbWFnZSxmZU1lcmdlLGZlTWVyZ2VOb2RlLGZlTW9ycGhvbG9neSxmZU9mZnNldCxmZVBvaW50TGlnaHQsZmVTcGVjdWxhckxpZ2h0aW5nLGZlU3BvdExpZ2h0LGZlVGlsZSxmZVR1cmJ1bGVuY2UsZmlsdGVyLGZvcmVpZ25PYmplY3QsZyxoYXRjaCxoYXRjaHBhdGgsaW1hZ2UsbGluZSxsaW5lYXJHcmFkaWVudCxtYXJrZXIsbWFzayxtZXNoLG1lc2hncmFkaWVudCxtZXNocGF0Y2gsbWVzaHJvdyxtZXRhZGF0YSxtcGF0aCxwYXRoLHBhdHRlcm4scG9seWdvbixwb2x5bGluZSxyYWRpYWxHcmFkaWVudCxyZWN0LHNldCxzb2xpZGNvbG9yLHN0b3Asc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRQYXRoLHRpdGxlLHRzcGFuLHVua25vd24sdXNlLHZpZXdcIjtcbmNvbnN0IE1BVEhfVEFHUyA9IFwiYW5ub3RhdGlvbixhbm5vdGF0aW9uLXhtbCxtYWN0aW9uLG1hbGlnbmdyb3VwLG1hbGlnbm1hcmssbWF0aCxtZW5jbG9zZSxtZXJyb3IsbWZlbmNlZCxtZnJhYyxtZnJhY3Rpb24sbWdseXBoLG1pLG1sYWJlbGVkdHIsbWxvbmdkaXYsbW11bHRpc2NyaXB0cyxtbixtbyxtb3ZlcixtcGFkZGVkLG1waGFudG9tLG1wcmVzY3JpcHRzLG1yb290LG1yb3csbXMsbXNjYXJyaWVzLG1zY2FycnksbXNncm91cCxtc2xpbmUsbXNwYWNlLG1zcXJ0LG1zcm93LG1zdGFjayxtc3R5bGUsbXN1Yixtc3Vic3VwLG1zdXAsbXRhYmxlLG10ZCxtdGV4dCxtdHIsbXVuZGVyLG11bmRlcm92ZXIsbm9uZSxzZW1hbnRpY3NcIjtcbmNvbnN0IFZPSURfVEFHUyA9IFwiYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnJcIjtcbmNvbnN0IGlzSFRNTFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKEhUTUxfVEFHUyk7XG5jb25zdCBpc1NWR1RhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFNWR19UQUdTKTtcbmNvbnN0IGlzTWF0aE1MVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoTUFUSF9UQUdTKTtcbmNvbnN0IGlzVm9pZFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFZPSURfVEFHUyk7XG5cbmNvbnN0IHNwZWNpYWxCb29sZWFuQXR0cnMgPSBgaXRlbXNjb3BlLGFsbG93ZnVsbHNjcmVlbixmb3Jtbm92YWxpZGF0ZSxpc21hcCxub21vZHVsZSxub3ZhbGlkYXRlLHJlYWRvbmx5YDtcbmNvbnN0IGlzU3BlY2lhbEJvb2xlYW5BdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyk7XG5jb25zdCBpc0Jvb2xlYW5BdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIHNwZWNpYWxCb29sZWFuQXR0cnMgKyBgLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjb250cm9scyxkZWZhdWx0LGRlZmVyLGRpc2FibGVkLGhpZGRlbixpbmVydCxsb29wLG9wZW4scmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLGNoZWNrZWQsbXV0ZWQsbXVsdGlwbGUsc2VsZWN0ZWRgXG4pO1xuZnVuY3Rpb24gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlIHx8IHZhbHVlID09PSBcIlwiO1xufVxuY29uc3QgdW5zYWZlQXR0ckNoYXJSRSA9IC9bPi89XCInXFx1MDAwOVxcdTAwMGFcXHUwMDBjXFx1MDAyMF0vO1xuY29uc3QgYXR0clZhbGlkYXRpb25DYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNTU1JTYWZlQXR0ck5hbWUobmFtZSkge1xuICBpZiAoYXR0clZhbGlkYXRpb25DYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdO1xuICB9XG4gIGNvbnN0IGlzVW5zYWZlID0gdW5zYWZlQXR0ckNoYXJSRS50ZXN0KG5hbWUpO1xuICBpZiAoaXNVbnNhZmUpIHtcbiAgICBjb25zb2xlLmVycm9yKGB1bnNhZmUgYXR0cmlidXRlIG5hbWU6ICR7bmFtZX1gKTtcbiAgfVxuICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXSA9ICFpc1Vuc2FmZTtcbn1cbmNvbnN0IHByb3BzVG9BdHRyTWFwID0ge1xuICBhY2NlcHRDaGFyc2V0OiBcImFjY2VwdC1jaGFyc2V0XCIsXG4gIGNsYXNzTmFtZTogXCJjbGFzc1wiLFxuICBodG1sRm9yOiBcImZvclwiLFxuICBodHRwRXF1aXY6IFwiaHR0cC1lcXVpdlwiXG59O1xuY29uc3QgaXNLbm93bkh0bWxBdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIGBhY2NlcHQsYWNjZXB0LWNoYXJzZXQsYWNjZXNza2V5LGFjdGlvbixhbGlnbixhbGxvdyxhbHQsYXN5bmMsYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLGF1dG9mb2N1cyxhdXRvcGxheSxiYWNrZ3JvdW5kLGJnY29sb3IsYm9yZGVyLGJ1ZmZlcmVkLGNhcHR1cmUsY2hhbGxlbmdlLGNoYXJzZXQsY2hlY2tlZCxjaXRlLGNsYXNzLGNvZGUsY29kZWJhc2UsY29sb3IsY29scyxjb2xzcGFuLGNvbnRlbnQsY29udGVudGVkaXRhYmxlLGNvbnRleHRtZW51LGNvbnRyb2xzLGNvb3Jkcyxjcm9zc29yaWdpbixjc3AsZGF0YSxkYXRldGltZSxkZWNvZGluZyxkZWZhdWx0LGRlZmVyLGRpcixkaXJuYW1lLGRpc2FibGVkLGRvd25sb2FkLGRyYWdnYWJsZSxkcm9wem9uZSxlbmN0eXBlLGVudGVya2V5aGludCxmb3IsZm9ybSxmb3JtYWN0aW9uLGZvcm1lbmN0eXBlLGZvcm1tZXRob2QsZm9ybW5vdmFsaWRhdGUsZm9ybXRhcmdldCxoZWFkZXJzLGhlaWdodCxoaWRkZW4saGlnaCxocmVmLGhyZWZsYW5nLGh0dHAtZXF1aXYsaWNvbixpZCxpbXBvcnRhbmNlLGluZXJ0LGludGVncml0eSxpc21hcCxpdGVtcHJvcCxrZXl0eXBlLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb2FkaW5nLGxpc3QsbG9vcCxsb3csbWFuaWZlc3QsbWF4LG1heGxlbmd0aCxtaW5sZW5ndGgsbWVkaWEsbWluLG11bHRpcGxlLG11dGVkLG5hbWUsbm92YWxpZGF0ZSxvcGVuLG9wdGltdW0scGF0dGVybixwaW5nLHBsYWNlaG9sZGVyLHBvc3RlcixwcmVsb2FkLHJhZGlvZ3JvdXAscmVhZG9ubHkscmVmZXJyZXJwb2xpY3kscmVsLHJlcXVpcmVkLHJldmVyc2VkLHJvd3Mscm93c3BhbixzYW5kYm94LHNjb3BlLHNjb3BlZCxzZWxlY3RlZCxzaGFwZSxzaXplLHNpemVzLHNsb3Qsc3BhbixzcGVsbGNoZWNrLHNyYyxzcmNkb2Msc3JjbGFuZyxzcmNzZXQsc3RhcnQsc3RlcCxzdHlsZSxzdW1tYXJ5LHRhYmluZGV4LHRhcmdldCx0aXRsZSx0cmFuc2xhdGUsdHlwZSx1c2VtYXAsdmFsdWUsd2lkdGgsd3JhcGBcbik7XG5jb25zdCBpc0tub3duU3ZnQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgeG1sbnMsYWNjZW50LWhlaWdodCxhY2N1bXVsYXRlLGFkZGl0aXZlLGFsaWdubWVudC1iYXNlbGluZSxhbHBoYWJldGljLGFtcGxpdHVkZSxhcmFiaWMtZm9ybSxhc2NlbnQsYXR0cmlidXRlTmFtZSxhdHRyaWJ1dGVUeXBlLGF6aW11dGgsYmFzZUZyZXF1ZW5jeSxiYXNlbGluZS1zaGlmdCxiYXNlUHJvZmlsZSxiYm94LGJlZ2luLGJpYXMsYnksY2FsY01vZGUsY2FwLWhlaWdodCxjbGFzcyxjbGlwLGNsaXBQYXRoVW5pdHMsY2xpcC1wYXRoLGNsaXAtcnVsZSxjb2xvcixjb2xvci1pbnRlcnBvbGF0aW9uLGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyxjb2xvci1wcm9maWxlLGNvbG9yLXJlbmRlcmluZyxjb250ZW50U2NyaXB0VHlwZSxjb250ZW50U3R5bGVUeXBlLGNyb3Nzb3JpZ2luLGN1cnNvcixjeCxjeSxkLGRlY2VsZXJhdGUsZGVzY2VudCxkaWZmdXNlQ29uc3RhbnQsZGlyZWN0aW9uLGRpc3BsYXksZGl2aXNvcixkb21pbmFudC1iYXNlbGluZSxkdXIsZHgsZHksZWRnZU1vZGUsZWxldmF0aW9uLGVuYWJsZS1iYWNrZ3JvdW5kLGVuZCxleHBvbmVudCxmaWxsLGZpbGwtb3BhY2l0eSxmaWxsLXJ1bGUsZmlsdGVyLGZpbHRlclJlcyxmaWx0ZXJVbml0cyxmbG9vZC1jb2xvcixmbG9vZC1vcGFjaXR5LGZvbnQtZmFtaWx5LGZvbnQtc2l6ZSxmb250LXNpemUtYWRqdXN0LGZvbnQtc3RyZXRjaCxmb250LXN0eWxlLGZvbnQtdmFyaWFudCxmb250LXdlaWdodCxmb3JtYXQsZnJvbSxmcixmeCxmeSxnMSxnMixnbHlwaC1uYW1lLGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwsZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwsZ2x5cGhSZWYsZ3JhZGllbnRUcmFuc2Zvcm0sZ3JhZGllbnRVbml0cyxoYW5naW5nLGhlaWdodCxocmVmLGhyZWZsYW5nLGhvcml6LWFkdi14LGhvcml6LW9yaWdpbi14LGlkLGlkZW9ncmFwaGljLGltYWdlLXJlbmRlcmluZyxpbixpbjIsaW50ZXJjZXB0LGssazEsazIsazMsazQsa2VybmVsTWF0cml4LGtlcm5lbFVuaXRMZW5ndGgsa2VybmluZyxrZXlQb2ludHMsa2V5U3BsaW5lcyxrZXlUaW1lcyxsYW5nLGxlbmd0aEFkanVzdCxsZXR0ZXItc3BhY2luZyxsaWdodGluZy1jb2xvcixsaW1pdGluZ0NvbmVBbmdsZSxsb2NhbCxtYXJrZXItZW5kLG1hcmtlci1taWQsbWFya2VyLXN0YXJ0LG1hcmtlckhlaWdodCxtYXJrZXJVbml0cyxtYXJrZXJXaWR0aCxtYXNrLG1hc2tDb250ZW50VW5pdHMsbWFza1VuaXRzLG1hdGhlbWF0aWNhbCxtYXgsbWVkaWEsbWV0aG9kLG1pbixtb2RlLG5hbWUsbnVtT2N0YXZlcyxvZmZzZXQsb3BhY2l0eSxvcGVyYXRvcixvcmRlcixvcmllbnQsb3JpZW50YXRpb24sb3JpZ2luLG92ZXJmbG93LG92ZXJsaW5lLXBvc2l0aW9uLG92ZXJsaW5lLXRoaWNrbmVzcyxwYW5vc2UtMSxwYWludC1vcmRlcixwYXRoLHBhdGhMZW5ndGgscGF0dGVybkNvbnRlbnRVbml0cyxwYXR0ZXJuVHJhbnNmb3JtLHBhdHRlcm5Vbml0cyxwaW5nLHBvaW50ZXItZXZlbnRzLHBvaW50cyxwb2ludHNBdFgscG9pbnRzQXRZLHBvaW50c0F0WixwcmVzZXJ2ZUFscGhhLHByZXNlcnZlQXNwZWN0UmF0aW8scHJpbWl0aXZlVW5pdHMscixyYWRpdXMscmVmZXJyZXJQb2xpY3kscmVmWCxyZWZZLHJlbCxyZW5kZXJpbmctaW50ZW50LHJlcGVhdENvdW50LHJlcGVhdER1cixyZXF1aXJlZEV4dGVuc2lvbnMscmVxdWlyZWRGZWF0dXJlcyxyZXN0YXJ0LHJlc3VsdCxyb3RhdGUscngscnksc2NhbGUsc2VlZCxzaGFwZS1yZW5kZXJpbmcsc2xvcGUsc3BhY2luZyxzcGVjdWxhckNvbnN0YW50LHNwZWN1bGFyRXhwb25lbnQsc3BlZWQsc3ByZWFkTWV0aG9kLHN0YXJ0T2Zmc2V0LHN0ZERldmlhdGlvbixzdGVtaCxzdGVtdixzdGl0Y2hUaWxlcyxzdG9wLWNvbG9yLHN0b3Atb3BhY2l0eSxzdHJpa2V0aHJvdWdoLXBvc2l0aW9uLHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzLHN0cmluZyxzdHJva2Usc3Ryb2tlLWRhc2hhcnJheSxzdHJva2UtZGFzaG9mZnNldCxzdHJva2UtbGluZWNhcCxzdHJva2UtbGluZWpvaW4sc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksc3Ryb2tlLXdpZHRoLHN0eWxlLHN1cmZhY2VTY2FsZSxzeXN0ZW1MYW5ndWFnZSx0YWJpbmRleCx0YWJsZVZhbHVlcyx0YXJnZXQsdGFyZ2V0WCx0YXJnZXRZLHRleHQtYW5jaG9yLHRleHQtZGVjb3JhdGlvbix0ZXh0LXJlbmRlcmluZyx0ZXh0TGVuZ3RoLHRvLHRyYW5zZm9ybSx0cmFuc2Zvcm0tb3JpZ2luLHR5cGUsdTEsdTIsdW5kZXJsaW5lLXBvc2l0aW9uLHVuZGVybGluZS10aGlja25lc3MsdW5pY29kZSx1bmljb2RlLWJpZGksdW5pY29kZS1yYW5nZSx1bml0cy1wZXItZW0sdi1hbHBoYWJldGljLHYtaGFuZ2luZyx2LWlkZW9ncmFwaGljLHYtbWF0aGVtYXRpY2FsLHZhbHVlcyx2ZWN0b3ItZWZmZWN0LHZlcnNpb24sdmVydC1hZHYteSx2ZXJ0LW9yaWdpbi14LHZlcnQtb3JpZ2luLXksdmlld0JveCx2aWV3VGFyZ2V0LHZpc2liaWxpdHksd2lkdGgsd2lkdGhzLHdvcmQtc3BhY2luZyx3cml0aW5nLW1vZGUseCx4LWhlaWdodCx4MSx4Mix4Q2hhbm5lbFNlbGVjdG9yLHhsaW5rOmFjdHVhdGUseGxpbms6YXJjcm9sZSx4bGluazpocmVmLHhsaW5rOnJvbGUseGxpbms6c2hvdyx4bGluazp0aXRsZSx4bGluazp0eXBlLHhtbG5zOnhsaW5rLHhtbDpiYXNlLHhtbDpsYW5nLHhtbDpzcGFjZSx5LHkxLHkyLHlDaGFubmVsU2VsZWN0b3Iseix6b29tQW5kUGFuYFxuKTtcbmZ1bmN0aW9uIGlzUmVuZGVyYWJsZUF0dHJWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiO1xufVxuXG5jb25zdCBlc2NhcGVSRSA9IC9bXCInJjw+XS87XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICBjb25zdCBzdHIgPSBcIlwiICsgc3RyaW5nO1xuICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgbGV0IGh0bWwgPSBcIlwiO1xuICBsZXQgZXNjYXBlZDtcbiAgbGV0IGluZGV4O1xuICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgZXNjYXBlZCA9IFwiJnF1b3Q7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmFtcDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM5OlxuICAgICAgICBlc2NhcGVkID0gXCImIzM5O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZsdDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYyOlxuICAgICAgICBlc2NhcGVkID0gXCImZ3Q7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XG4gICAgICBodG1sICs9IHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgIGh0bWwgKz0gZXNjYXBlZDtcbiAgfVxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufVxuY29uc3QgY29tbWVudFN0cmlwUkUgPSAvXi0/Pnw8IS0tfC0tPnwtLSE+fDwhLSQvZztcbmZ1bmN0aW9uIGVzY2FwZUh0bWxDb21tZW50KHNyYykge1xuICByZXR1cm4gc3JjLnJlcGxhY2UoY29tbWVudFN0cmlwUkUsIFwiXCIpO1xufVxuXG5mdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGxldCBlcXVhbCA9IHRydWU7XG4gIGZvciAobGV0IGkgPSAwOyBlcXVhbCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcbiAgfVxuICByZXR1cm4gZXF1YWw7XG59XG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICBsZXQgYVZhbGlkVHlwZSA9IGlzRGF0ZShhKTtcbiAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpIDogZmFsc2U7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzU3ltYm9sKGEpO1xuICBiVmFsaWRUeXBlID0gaXNTeW1ib2woYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNBcnJheShhKTtcbiAgYlZhbGlkVHlwZSA9IGlzQXJyYXkoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzT2JqZWN0KGEpO1xuICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICBpZiAoIWFWYWxpZFR5cGUgfHwgIWJWYWxpZFR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYUtleXNDb3VudCA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcbiAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xuICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICAgIGNvbnN0IGFIYXNLZXkgPSBhLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgaWYgKGFIYXNLZXkgJiYgIWJIYXNLZXkgfHwgIWFIYXNLZXkgJiYgYkhhc0tleSB8fCAhbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG59XG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcbiAgcmV0dXJuIGFyci5maW5kSW5kZXgoKGl0ZW0pID0+IGxvb3NlRXF1YWwoaXRlbSwgdmFsKSk7XG59XG5cbmNvbnN0IGlzUmVmID0gKHZhbCkgPT4ge1xuICByZXR1cm4gISEodmFsICYmIHZhbFtcIl9fdl9pc1JlZlwiXSA9PT0gdHJ1ZSk7XG59O1xuY29uc3QgdG9EaXNwbGF5U3RyaW5nID0gKHZhbCkgPT4ge1xuICByZXR1cm4gaXNTdHJpbmcodmFsKSA/IHZhbCA6IHZhbCA9PSBudWxsID8gXCJcIiA6IGlzQXJyYXkodmFsKSB8fCBpc09iamVjdCh2YWwpICYmICh2YWwudG9TdHJpbmcgPT09IG9iamVjdFRvU3RyaW5nIHx8ICFpc0Z1bmN0aW9uKHZhbC50b1N0cmluZykpID8gaXNSZWYodmFsKSA/IHRvRGlzcGxheVN0cmluZyh2YWwudmFsdWUpIDogSlNPTi5zdHJpbmdpZnkodmFsLCByZXBsYWNlciwgMikgOiBTdHJpbmcodmFsKTtcbn07XG5jb25zdCByZXBsYWNlciA9IChfa2V5LCB2YWwpID0+IHtcbiAgaWYgKGlzUmVmKHZhbCkpIHtcbiAgICByZXR1cm4gcmVwbGFjZXIoX2tleSwgdmFsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgTWFwKCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLmVudHJpZXMoKV0ucmVkdWNlKFxuICAgICAgICAoZW50cmllcywgW2tleSwgdmFsMl0sIGkpID0+IHtcbiAgICAgICAgICBlbnRyaWVzW3N0cmluZ2lmeVN5bWJvbChrZXksIGkpICsgXCIgPT5cIl0gPSB2YWwyO1xuICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgICAgICB9LFxuICAgICAgICB7fVxuICAgICAgKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBbYFNldCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC52YWx1ZXMoKV0ubWFwKCh2KSA9PiBzdHJpbmdpZnlTeW1ib2wodikpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc1N5bWJvbCh2YWwpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVN5bWJvbCh2YWwpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWwpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuY29uc3Qgc3RyaW5naWZ5U3ltYm9sID0gKHYsIGkgPSBcIlwiKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChcbiAgICAvLyBTeW1ib2wuZGVzY3JpcHRpb24gaW4gZXMyMDE5KyBzbyB3ZSBuZWVkIHRvIGNhc3QgaGVyZSB0byBwYXNzXG4gICAgLy8gdGhlIGxpYjogZXMyMDE2IGNoZWNrXG4gICAgaXNTeW1ib2wodikgPyBgU3ltYm9sKCR7KF9hID0gdi5kZXNjcmlwdGlvbikgIT0gbnVsbCA/IF9hIDogaX0pYCA6IHZcbiAgKTtcbn07XG5cbmV4cG9ydCB7IEVNUFRZX0FSUiwgRU1QVFlfT0JKLCBOTywgTk9PUCwgUGF0Y2hGbGFnTmFtZXMsIFBhdGNoRmxhZ3MsIFNoYXBlRmxhZ3MsIFNsb3RGbGFncywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuUHJvcHNBY2Nlc3NFeHAsIGdlbmVyYXRlQ29kZUZyYW1lLCBnZXRHbG9iYWxUaGlzLCBoYXNDaGFuZ2VkLCBoYXNPd24sIGh5cGhlbmF0ZSwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpbnZva2VBcnJheUZucywgaXNBcnJheSwgaXNCb29sZWFuQXR0ciwgaXNCdWlsdEluRGlyZWN0aXZlLCBpc0RhdGUsIGlzRnVuY3Rpb24sIGlzR2xvYmFsbHlBbGxvd2VkLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQsIGlzSFRNTFRhZywgaXNJbnRlZ2VyS2V5LCBpc0tub3duSHRtbEF0dHIsIGlzS25vd25TdmdBdHRyLCBpc01hcCwgaXNNYXRoTUxUYWcsIGlzTW9kZWxMaXN0ZW5lciwgaXNPYmplY3QsIGlzT24sIGlzUGxhaW5PYmplY3QsIGlzUHJvbWlzZSwgaXNSZWdFeHAsIGlzUmVuZGVyYWJsZUF0dHJWYWx1ZSwgaXNSZXNlcnZlZFByb3AsIGlzU1NSU2FmZUF0dHJOYW1lLCBpc1NWR1RhZywgaXNTZXQsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpc1N0cmluZywgaXNTeW1ib2wsIGlzVm9pZFRhZywgbG9vc2VFcXVhbCwgbG9vc2VJbmRleE9mLCBsb29zZVRvTnVtYmVyLCBtYWtlTWFwLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCBvYmplY3RUb1N0cmluZywgcGFyc2VTdHJpbmdTdHlsZSwgcHJvcHNUb0F0dHJNYXAsIHJlbW92ZSwgc2xvdEZsYWdzVGV4dCwgc3RyaW5naWZ5U3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5LCB0b051bWJlciwgdG9SYXdUeXBlLCB0b1R5cGVTdHJpbmcgfTtcbiIsIi8qKlxuKiBAdnVlL3J1bnRpbWUtY29yZSB2My41LjAtYmV0YS4zXG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG5pbXBvcnQgeyBwYXVzZVRyYWNraW5nLCByZXNldFRyYWNraW5nLCBpc1JlZiwgdG9SYXcsIHRyYXZlcnNlLCBpc1JlYWN0aXZlLCByZWYsIHNoYWxsb3dSZWFkQXJyYXksIHRvUmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgdHJhY2ssIHJlYWN0aXZlLCBzaGFsbG93UmVhY3RpdmUsIHRyaWdnZXIsIFJlYWN0aXZlRWZmZWN0LCB3YXRjaCBhcyB3YXRjaCQxLCBjdXN0b21SZWYsIGlzUHJveHksIHByb3h5UmVmcywgbWFya1JhdywgRWZmZWN0U2NvcGUsIGNvbXB1dGVkIGFzIGNvbXB1dGVkJDEsIHNoYWxsb3dSZWYsIHJlYWRvbmx5LCBpc1NoYWxsb3csIGlzUmVhZG9ubHkgfSBmcm9tICdAdnVlL3JlYWN0aXZpdHknO1xuZXhwb3J0IHsgRWZmZWN0U2NvcGUsIFJlYWN0aXZlRWZmZWN0LCBUcmFja09wVHlwZXMsIFRyaWdnZXJPcFR5cGVzLCBjdXN0b21SZWYsIGVmZmVjdCwgZWZmZWN0U2NvcGUsIGdldEN1cnJlbnRTY29wZSwgZ2V0Q3VycmVudFdhdGNoZXIsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uU2NvcGVEaXNwb3NlLCBvbldhdGNoZXJDbGVhbnVwLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRvVmFsdWUsIHRyaWdnZXJSZWYsIHVucmVmIH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0Z1bmN0aW9uLCBpc1Byb21pc2UsIGlzQXJyYXksIEVNUFRZX09CSiwgTk9PUCwgZ2V0R2xvYmFsVGhpcywgZXh0ZW5kLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGhhc093biwgcmVtb3ZlLCBkZWYsIGlzT24sIGlzUmVzZXJ2ZWRQcm9wLCBub3JtYWxpemVDbGFzcywgc3RyaW5naWZ5U3R5bGUsIG5vcm1hbGl6ZVN0eWxlLCBpc0tub3duU3ZnQXR0ciwgaXNCb29sZWFuQXR0ciwgaXNLbm93bkh0bWxBdHRyLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGlzUmVuZGVyYWJsZUF0dHJWYWx1ZSwgaXNPYmplY3QsIGlzUmVnRXhwLCBpbnZva2VBcnJheUZucywgdG9IYW5kbGVyS2V5LCBjYXBpdGFsaXplLCBjYW1lbGl6ZSwgaXNHbG9iYWxseUFsbG93ZWQsIE5PLCBoeXBoZW5hdGUsIEVNUFRZX0FSUiwgdG9SYXdUeXBlLCBtYWtlTWFwLCBoYXNDaGFuZ2VkLCBsb29zZVRvTnVtYmVyLCBpc01vZGVsTGlzdGVuZXIsIHRvTnVtYmVyIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuZXhwb3J0IHsgY2FtZWxpemUsIGNhcGl0YWxpemUsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5IH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBzdGFjayA9IFtdO1xuZnVuY3Rpb24gcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlKSB7XG4gIHN0YWNrLnB1c2godm5vZGUpO1xufVxuZnVuY3Rpb24gcG9wV2FybmluZ0NvbnRleHQoKSB7XG4gIHN0YWNrLnBvcCgpO1xufVxubGV0IGlzV2FybmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gd2FybiQxKG1zZywgLi4uYXJncykge1xuICBpZiAoaXNXYXJuaW5nKSByZXR1cm47XG4gIGlzV2FybmluZyA9IHRydWU7XG4gIHBhdXNlVHJhY2tpbmcoKTtcbiAgY29uc3QgaW5zdGFuY2UgPSBzdGFjay5sZW5ndGggPyBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5jb21wb25lbnQgOiBudWxsO1xuICBjb25zdCBhcHBXYXJuSGFuZGxlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLndhcm5IYW5kbGVyO1xuICBjb25zdCB0cmFjZSA9IGdldENvbXBvbmVudFRyYWNlKCk7XG4gIGlmIChhcHBXYXJuSGFuZGxlcikge1xuICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcbiAgICAgIGFwcFdhcm5IYW5kbGVyLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICAxMSxcbiAgICAgIFtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIG1zZyArIGFyZ3MubWFwKChhKSA9PiB7XG4gICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gYS50b1N0cmluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoYSkpICE9IG51bGwgPyBfYiA6IEpTT04uc3RyaW5naWZ5KGEpO1xuICAgICAgICB9KS5qb2luKFwiXCIpLFxuICAgICAgICBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eSxcbiAgICAgICAgdHJhY2UubWFwKFxuICAgICAgICAgICh7IHZub2RlIH0pID0+IGBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCB2bm9kZS50eXBlKX0+YFxuICAgICAgICApLmpvaW4oXCJcXG5cIiksXG4gICAgICAgIHRyYWNlXG4gICAgICBdXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB3YXJuQXJncyA9IFtgW1Z1ZSB3YXJuXTogJHttc2d9YCwgLi4uYXJnc107XG4gICAgaWYgKHRyYWNlLmxlbmd0aCAmJiAvLyBhdm9pZCBzcGFtbWluZyBjb25zb2xlIGR1cmluZyB0ZXN0c1xuICAgIHRydWUpIHtcbiAgICAgIHdhcm5BcmdzLnB1c2goYFxuYCwgLi4uZm9ybWF0VHJhY2UodHJhY2UpKTtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKC4uLndhcm5BcmdzKTtcbiAgfVxuICByZXNldFRyYWNraW5nKCk7XG4gIGlzV2FybmluZyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VHJhY2UoKSB7XG4gIGxldCBjdXJyZW50Vk5vZGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgaWYgKCFjdXJyZW50Vk5vZGUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZFN0YWNrID0gW107XG4gIHdoaWxlIChjdXJyZW50Vk5vZGUpIHtcbiAgICBjb25zdCBsYXN0ID0gbm9ybWFsaXplZFN0YWNrWzBdO1xuICAgIGlmIChsYXN0ICYmIGxhc3Qudm5vZGUgPT09IGN1cnJlbnRWTm9kZSkge1xuICAgICAgbGFzdC5yZWN1cnNlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplZFN0YWNrLnB1c2goe1xuICAgICAgICB2bm9kZTogY3VycmVudFZOb2RlLFxuICAgICAgICByZWN1cnNlQ291bnQ6IDBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IGN1cnJlbnRWTm9kZS5jb21wb25lbnQgJiYgY3VycmVudFZOb2RlLmNvbXBvbmVudC5wYXJlbnQ7XG4gICAgY3VycmVudFZOb2RlID0gcGFyZW50SW5zdGFuY2UgJiYgcGFyZW50SW5zdGFuY2Uudm5vZGU7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWRTdGFjaztcbn1cbmZ1bmN0aW9uIGZvcm1hdFRyYWNlKHRyYWNlKSB7XG4gIGNvbnN0IGxvZ3MgPSBbXTtcbiAgdHJhY2UuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcbiAgICBsb2dzLnB1c2goLi4uaSA9PT0gMCA/IFtdIDogW2BcbmBdLCAuLi5mb3JtYXRUcmFjZUVudHJ5KGVudHJ5KSk7XG4gIH0pO1xuICByZXR1cm4gbG9ncztcbn1cbmZ1bmN0aW9uIGZvcm1hdFRyYWNlRW50cnkoeyB2bm9kZSwgcmVjdXJzZUNvdW50IH0pIHtcbiAgY29uc3QgcG9zdGZpeCA9IHJlY3Vyc2VDb3VudCA+IDAgPyBgLi4uICgke3JlY3Vyc2VDb3VudH0gcmVjdXJzaXZlIGNhbGxzKWAgOiBgYDtcbiAgY29uc3QgaXNSb290ID0gdm5vZGUuY29tcG9uZW50ID8gdm5vZGUuY29tcG9uZW50LnBhcmVudCA9PSBudWxsIDogZmFsc2U7XG4gIGNvbnN0IG9wZW4gPSBgIGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUoXG4gICAgdm5vZGUuY29tcG9uZW50LFxuICAgIHZub2RlLnR5cGUsXG4gICAgaXNSb290XG4gICl9YDtcbiAgY29uc3QgY2xvc2UgPSBgPmAgKyBwb3N0Zml4O1xuICByZXR1cm4gdm5vZGUucHJvcHMgPyBbb3BlbiwgLi4uZm9ybWF0UHJvcHModm5vZGUucHJvcHMpLCBjbG9zZV0gOiBbb3BlbiArIGNsb3NlXTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFByb3BzKHByb3BzKSB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICBrZXlzLnNsaWNlKDAsIDMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHJlcy5wdXNoKC4uLmZvcm1hdFByb3Aoa2V5LCBwcm9wc1trZXldKSk7XG4gIH0pO1xuICBpZiAoa2V5cy5sZW5ndGggPiAzKSB7XG4gICAgcmVzLnB1c2goYCAuLi5gKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZm9ybWF0UHJvcChrZXksIHZhbHVlLCByYXcpIHtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XG4gIH0gZWxzZSBpZiAoaXNSZWYodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBmb3JtYXRQcm9wKGtleSwgdG9SYXcodmFsdWUudmFsdWUpLCB0cnVlKTtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1SZWY8YCwgdmFsdWUsIGA+YF07XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gW2Ake2tleX09Zm4ke3ZhbHVlLm5hbWUgPyBgPCR7dmFsdWUubmFtZX0+YCA6IGBgfWBdO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PWAsIHZhbHVlXTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKHZhbCwgdHlwZSkge1xuICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHJldHVybjtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgIT09IFwibnVtYmVyXCIpIHtcbiAgICB3YXJuJDEoYCR7dHlwZX0gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsKX0uYCk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4kMShgJHt0eXBlfSBpcyBOYU4gLSB0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuYCk7XG4gIH1cbn1cblxuY29uc3QgRXJyb3JDb2RlcyA9IHtcbiAgXCJTRVRVUF9GVU5DVElPTlwiOiAwLFxuICBcIjBcIjogXCJTRVRVUF9GVU5DVElPTlwiLFxuICBcIlJFTkRFUl9GVU5DVElPTlwiOiAxLFxuICBcIjFcIjogXCJSRU5ERVJfRlVOQ1RJT05cIixcbiAgXCJOQVRJVkVfRVZFTlRfSEFORExFUlwiOiA1LFxuICBcIjVcIjogXCJOQVRJVkVfRVZFTlRfSEFORExFUlwiLFxuICBcIkNPTVBPTkVOVF9FVkVOVF9IQU5ETEVSXCI6IDYsXG4gIFwiNlwiOiBcIkNPTVBPTkVOVF9FVkVOVF9IQU5ETEVSXCIsXG4gIFwiVk5PREVfSE9PS1wiOiA3LFxuICBcIjdcIjogXCJWTk9ERV9IT09LXCIsXG4gIFwiRElSRUNUSVZFX0hPT0tcIjogOCxcbiAgXCI4XCI6IFwiRElSRUNUSVZFX0hPT0tcIixcbiAgXCJUUkFOU0lUSU9OX0hPT0tcIjogOSxcbiAgXCI5XCI6IFwiVFJBTlNJVElPTl9IT09LXCIsXG4gIFwiQVBQX0VSUk9SX0hBTkRMRVJcIjogMTAsXG4gIFwiMTBcIjogXCJBUFBfRVJST1JfSEFORExFUlwiLFxuICBcIkFQUF9XQVJOX0hBTkRMRVJcIjogMTEsXG4gIFwiMTFcIjogXCJBUFBfV0FSTl9IQU5ETEVSXCIsXG4gIFwiRlVOQ1RJT05fUkVGXCI6IDEyLFxuICBcIjEyXCI6IFwiRlVOQ1RJT05fUkVGXCIsXG4gIFwiQVNZTkNfQ09NUE9ORU5UX0xPQURFUlwiOiAxMyxcbiAgXCIxM1wiOiBcIkFTWU5DX0NPTVBPTkVOVF9MT0FERVJcIixcbiAgXCJTQ0hFRFVMRVJcIjogMTQsXG4gIFwiMTRcIjogXCJTQ0hFRFVMRVJcIixcbiAgXCJDT01QT05FTlRfVVBEQVRFXCI6IDE1LFxuICBcIjE1XCI6IFwiQ09NUE9ORU5UX1VQREFURVwiLFxuICBcIkFQUF9VTk1PVU5UX0NMRUFOVVBcIjogMTYsXG4gIFwiMTZcIjogXCJBUFBfVU5NT1VOVF9DTEVBTlVQXCJcbn07XG5jb25zdCBFcnJvclR5cGVTdHJpbmdzJDEgPSB7XG4gIFtcInNwXCJdOiBcInNlcnZlclByZWZldGNoIGhvb2tcIixcbiAgW1wiYmNcIl06IFwiYmVmb3JlQ3JlYXRlIGhvb2tcIixcbiAgW1wiY1wiXTogXCJjcmVhdGVkIGhvb2tcIixcbiAgW1wiYm1cIl06IFwiYmVmb3JlTW91bnQgaG9va1wiLFxuICBbXCJtXCJdOiBcIm1vdW50ZWQgaG9va1wiLFxuICBbXCJidVwiXTogXCJiZWZvcmVVcGRhdGUgaG9va1wiLFxuICBbXCJ1XCJdOiBcInVwZGF0ZWRcIixcbiAgW1wiYnVtXCJdOiBcImJlZm9yZVVubW91bnQgaG9va1wiLFxuICBbXCJ1bVwiXTogXCJ1bm1vdW50ZWQgaG9va1wiLFxuICBbXCJhXCJdOiBcImFjdGl2YXRlZCBob29rXCIsXG4gIFtcImRhXCJdOiBcImRlYWN0aXZhdGVkIGhvb2tcIixcbiAgW1wiZWNcIl06IFwiZXJyb3JDYXB0dXJlZCBob29rXCIsXG4gIFtcInJ0Y1wiXTogXCJyZW5kZXJUcmFja2VkIGhvb2tcIixcbiAgW1wicnRnXCJdOiBcInJlbmRlclRyaWdnZXJlZCBob29rXCIsXG4gIFswXTogXCJzZXR1cCBmdW5jdGlvblwiLFxuICBbMV06IFwicmVuZGVyIGZ1bmN0aW9uXCIsXG4gIFsyXTogXCJ3YXRjaGVyIGdldHRlclwiLFxuICBbM106IFwid2F0Y2hlciBjYWxsYmFja1wiLFxuICBbNF06IFwid2F0Y2hlciBjbGVhbnVwIGZ1bmN0aW9uXCIsXG4gIFs1XTogXCJuYXRpdmUgZXZlbnQgaGFuZGxlclwiLFxuICBbNl06IFwiY29tcG9uZW50IGV2ZW50IGhhbmRsZXJcIixcbiAgWzddOiBcInZub2RlIGhvb2tcIixcbiAgWzhdOiBcImRpcmVjdGl2ZSBob29rXCIsXG4gIFs5XTogXCJ0cmFuc2l0aW9uIGhvb2tcIixcbiAgWzEwXTogXCJhcHAgZXJyb3JIYW5kbGVyXCIsXG4gIFsxMV06IFwiYXBwIHdhcm5IYW5kbGVyXCIsXG4gIFsxMl06IFwicmVmIGZ1bmN0aW9uXCIsXG4gIFsxM106IFwiYXN5bmMgY29tcG9uZW50IGxvYWRlclwiLFxuICBbMTRdOiBcInNjaGVkdWxlciBmbHVzaFwiLFxuICBbMTVdOiBcImNvbXBvbmVudCB1cGRhdGVcIixcbiAgWzE2XTogXCJhcHAgdW5tb3VudCBjbGVhbnVwIGZ1bmN0aW9uXCJcbn07XG5mdW5jdGlvbiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGFyZ3MgPyBmbiguLi5hcmdzKSA6IGZuKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcbiAgaWYgKGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgY29uc3QgcmVzID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncyk7XG4gICAgaWYgKHJlcyAmJiBpc1Byb21pc2UocmVzKSkge1xuICAgICAgcmVzLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZiAoaXNBcnJheShmbikpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXMucHVzaChjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbltpXSwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKFxuICAgICAgYEludmFsaWQgdmFsdWUgdHlwZSBwYXNzZWQgdG8gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoKTogJHt0eXBlb2YgZm59YFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XG4gIGNvbnN0IGNvbnRleHRWTm9kZSA9IGluc3RhbmNlID8gaW5zdGFuY2Uudm5vZGUgOiBudWxsO1xuICBjb25zdCB7IGVycm9ySGFuZGxlciwgdGhyb3dVbmhhbmRsZWRFcnJvckluUHJvZHVjdGlvbiB9ID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcgfHwgRU1QVFlfT0JKO1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBsZXQgY3VyID0gaW5zdGFuY2UucGFyZW50O1xuICAgIGNvbnN0IGV4cG9zZWRJbnN0YW5jZSA9IGluc3RhbmNlLnByb3h5O1xuICAgIGNvbnN0IGVycm9ySW5mbyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBFcnJvclR5cGVTdHJpbmdzJDFbdHlwZV0gOiBgaHR0cHM6Ly92dWVqcy5vcmcvZXJyb3ItcmVmZXJlbmNlLyNydW50aW1lLSR7dHlwZX1gO1xuICAgIHdoaWxlIChjdXIpIHtcbiAgICAgIGNvbnN0IGVycm9yQ2FwdHVyZWRIb29rcyA9IGN1ci5lYztcbiAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvckNhcHR1cmVkSG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzW2ldKGVyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm8pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICB9XG4gICAgaWYgKGVycm9ySGFuZGxlcikge1xuICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGVycm9ySGFuZGxlciwgbnVsbCwgMTAsIFtcbiAgICAgICAgZXJyLFxuICAgICAgICBleHBvc2VkSW5zdGFuY2UsXG4gICAgICAgIGVycm9ySW5mb1xuICAgICAgXSk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2LCB0aHJvd1VuaGFuZGxlZEVycm9ySW5Qcm9kdWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2ID0gdHJ1ZSwgdGhyb3dJblByb2QgPSBmYWxzZSkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGluZm8gPSBFcnJvclR5cGVTdHJpbmdzJDFbdHlwZV07XG4gICAgaWYgKGNvbnRleHRWTm9kZSkge1xuICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGNvbnRleHRWTm9kZSk7XG4gICAgfVxuICAgIHdhcm4kMShgVW5oYW5kbGVkIGVycm9yJHtpbmZvID8gYCBkdXJpbmcgZXhlY3V0aW9uIG9mICR7aW5mb31gIDogYGB9YCk7XG4gICAgaWYgKGNvbnRleHRWTm9kZSkge1xuICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICB9XG4gICAgaWYgKHRocm93SW5EZXYpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aHJvd0luUHJvZCkge1xuICAgIHRocm93IGVycjtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxubGV0IGlzRmx1c2hpbmcgPSBmYWxzZTtcbmxldCBpc0ZsdXNoUGVuZGluZyA9IGZhbHNlO1xuY29uc3QgcXVldWUgPSBbXTtcbmxldCBmbHVzaEluZGV4ID0gMDtcbmNvbnN0IHBlbmRpbmdQb3N0Rmx1c2hDYnMgPSBbXTtcbmxldCBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xubGV0IHBvc3RGbHVzaEluZGV4ID0gMDtcbmNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcbmxldCBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcbmNvbnN0IFJFQ1VSU0lPTl9MSU1JVCA9IDEwMDtcbmZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gIGNvbnN0IHAgPSBjdXJyZW50Rmx1c2hQcm9taXNlIHx8IHJlc29sdmVkUHJvbWlzZTtcbiAgcmV0dXJuIGZuID8gcC50aGVuKHRoaXMgPyBmbi5iaW5kKHRoaXMpIDogZm4pIDogcDtcbn1cbmZ1bmN0aW9uIGZpbmRJbnNlcnRpb25JbmRleChpZCkge1xuICBsZXQgc3RhcnQgPSBpc0ZsdXNoaW5nID8gZmx1c2hJbmRleCArIDEgOiAwO1xuICBsZXQgZW5kID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICBjb25zdCBtaWRkbGUgPSBzdGFydCArIGVuZCA+Pj4gMTtcbiAgICBjb25zdCBtaWRkbGVKb2IgPSBxdWV1ZVttaWRkbGVdO1xuICAgIGNvbnN0IG1pZGRsZUpvYklkID0gZ2V0SWQobWlkZGxlSm9iKTtcbiAgICBpZiAobWlkZGxlSm9iSWQgPCBpZCB8fCBtaWRkbGVKb2JJZCA9PT0gaWQgJiYgbWlkZGxlSm9iLmZsYWdzICYgMikge1xuICAgICAgc3RhcnQgPSBtaWRkbGUgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSBtaWRkbGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFydDtcbn1cbmZ1bmN0aW9uIHF1ZXVlSm9iKGpvYikge1xuICBpZiAoIShqb2IuZmxhZ3MgJiAxKSkge1xuICAgIGNvbnN0IGpvYklkID0gZ2V0SWQoam9iKTtcbiAgICBjb25zdCBsYXN0Sm9iID0gcXVldWVbcXVldWUubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFsYXN0Sm9iIHx8IC8vIGZhc3QgcGF0aCB3aGVuIHRoZSBqb2IgaWQgaXMgbGFyZ2VyIHRoYW4gdGhlIHRhaWxcbiAgICAhKGpvYi5mbGFncyAmIDIpICYmIGpvYklkID49IGdldElkKGxhc3RKb2IpKSB7XG4gICAgICBxdWV1ZS5wdXNoKGpvYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlLnNwbGljZShmaW5kSW5zZXJ0aW9uSW5kZXgoam9iSWQpLCAwLCBqb2IpO1xuICAgIH1cbiAgICBpZiAoIShqb2IuZmxhZ3MgJiA0KSkge1xuICAgICAgam9iLmZsYWdzIHw9IDE7XG4gICAgfVxuICAgIHF1ZXVlRmx1c2goKTtcbiAgfVxufVxuZnVuY3Rpb24gcXVldWVGbHVzaCgpIHtcbiAgaWYgKCFpc0ZsdXNoaW5nICYmICFpc0ZsdXNoUGVuZGluZykge1xuICAgIGlzRmx1c2hQZW5kaW5nID0gdHJ1ZTtcbiAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gcmVzb2x2ZWRQcm9taXNlLnRoZW4oZmx1c2hKb2JzKTtcbiAgfVxufVxuZnVuY3Rpb24gcXVldWVQb3N0Rmx1c2hDYihjYikge1xuICBpZiAoIWlzQXJyYXkoY2IpKSB7XG4gICAgaWYgKGFjdGl2ZVBvc3RGbHVzaENicyAmJiBjYi5pZCA9PT0gLTEpIHtcbiAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5zcGxpY2UocG9zdEZsdXNoSW5kZXggKyAxLCAwLCBjYik7XG4gICAgfSBlbHNlIGlmICghKGNiLmZsYWdzICYgMSkpIHtcbiAgICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMucHVzaChjYik7XG4gICAgICBpZiAoIShjYi5mbGFncyAmIDQpKSB7XG4gICAgICAgIGNiLmZsYWdzIHw9IDE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMucHVzaCguLi5jYik7XG4gIH1cbiAgcXVldWVGbHVzaCgpO1xufVxuZnVuY3Rpb24gZmx1c2hQcmVGbHVzaENicyhpbnN0YW5jZSwgc2VlbiwgaSA9IGlzRmx1c2hpbmcgPyBmbHVzaEluZGV4ICsgMSA6IDApIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjYiA9IHF1ZXVlW2ldO1xuICAgIGlmIChjYiAmJiBjYi5mbGFncyAmIDIpIHtcbiAgICAgIGlmIChpbnN0YW5jZSAmJiBjYi5pZCAhPT0gaW5zdGFuY2UudWlkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGNiKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICAgIGktLTtcbiAgICAgIGNiKCk7XG4gICAgICBjYi5mbGFncyAmPSB+MTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pIHtcbiAgaWYgKHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XG4gICAgY29uc3QgZGVkdXBlZCA9IFsuLi5uZXcgU2V0KHBlbmRpbmdQb3N0Rmx1c2hDYnMpXS5zb3J0KFxuICAgICAgKGEsIGIpID0+IGdldElkKGEpIC0gZ2V0SWQoYilcbiAgICApO1xuICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoID0gMDtcbiAgICBpZiAoYWN0aXZlUG9zdEZsdXNoQ2JzKSB7XG4gICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMucHVzaCguLi5kZWR1cGVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gZGVkdXBlZDtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZm9yIChwb3N0Rmx1c2hJbmRleCA9IDA7IHBvc3RGbHVzaEluZGV4IDwgYWN0aXZlUG9zdEZsdXNoQ2JzLmxlbmd0aDsgcG9zdEZsdXNoSW5kZXgrKykge1xuICAgICAgY29uc3QgY2IgPSBhY3RpdmVQb3N0Rmx1c2hDYnNbcG9zdEZsdXNoSW5kZXhdO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGNiKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghKGNiLmZsYWdzICYgOCkpIGNiKCk7XG4gICAgICBjYi5mbGFncyAmPSB+MTtcbiAgICB9XG4gICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcbiAgICBwb3N0Rmx1c2hJbmRleCA9IDA7XG4gIH1cbn1cbmNvbnN0IGdldElkID0gKGpvYikgPT4gam9iLmlkID09IG51bGwgPyBqb2IuZmxhZ3MgJiAyID8gLTEgOiBJbmZpbml0eSA6IGpvYi5pZDtcbmZ1bmN0aW9uIGZsdXNoSm9icyhzZWVuKSB7XG4gIGlzRmx1c2hQZW5kaW5nID0gZmFsc2U7XG4gIGlzRmx1c2hpbmcgPSB0cnVlO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgY29uc3QgY2hlY2sgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gKGpvYikgPT4gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGpvYikgOiBOT09QO1xuICB0cnkge1xuICAgIGZvciAoZmx1c2hJbmRleCA9IDA7IGZsdXNoSW5kZXggPCBxdWV1ZS5sZW5ndGg7IGZsdXNoSW5kZXgrKykge1xuICAgICAgY29uc3Qgam9iID0gcXVldWVbZmx1c2hJbmRleF07XG4gICAgICBpZiAoam9iICYmICEoam9iLmZsYWdzICYgOCkpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2soam9iKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcbiAgICAgICAgICBqb2IsXG4gICAgICAgICAgam9iLmksXG4gICAgICAgICAgam9iLmkgPyAxNSA6IDE0XG4gICAgICAgICk7XG4gICAgICAgIGpvYi5mbGFncyAmPSB+MTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgZmx1c2hJbmRleCA9IDA7XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBmbHVzaFBvc3RGbHVzaENicyhzZWVuKTtcbiAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XG4gICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCB8fCBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xuICAgICAgZmx1c2hKb2JzKHNlZW4pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGZuKSB7XG4gIGlmICghc2Vlbi5oYXMoZm4pKSB7XG4gICAgc2Vlbi5zZXQoZm4sIDEpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvdW50ID0gc2Vlbi5nZXQoZm4pO1xuICAgIGlmIChjb3VudCA+IFJFQ1VSU0lPTl9MSU1JVCkge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBmbi5pO1xuICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGluc3RhbmNlICYmIGdldENvbXBvbmVudE5hbWUoaW5zdGFuY2UudHlwZSk7XG4gICAgICBoYW5kbGVFcnJvcihcbiAgICAgICAgYE1heGltdW0gcmVjdXJzaXZlIHVwZGF0ZXMgZXhjZWVkZWQke2NvbXBvbmVudE5hbWUgPyBgIGluIGNvbXBvbmVudCA8JHtjb21wb25lbnROYW1lfT5gIDogYGB9LiBUaGlzIG1lYW5zIHlvdSBoYXZlIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgaXMgbXV0YXRpbmcgaXRzIG93biBkZXBlbmRlbmNpZXMgYW5kIHRodXMgcmVjdXJzaXZlbHkgdHJpZ2dlcmluZyBpdHNlbGYuIFBvc3NpYmxlIHNvdXJjZXMgaW5jbHVkZSBjb21wb25lbnQgdGVtcGxhdGUsIHJlbmRlciBmdW5jdGlvbiwgdXBkYXRlZCBob29rIG9yIHdhdGNoZXIgc291cmNlIGZ1bmN0aW9uLmAsXG4gICAgICAgIG51bGwsXG4gICAgICAgIDEwXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlZW4uc2V0KGZuLCBjb3VudCArIDEpO1xuICAgIH1cbiAgfVxufVxuXG5sZXQgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xuY29uc3QgaG1yRGlydHlDb21wb25lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9ITVJfUlVOVElNRV9fID0ge1xuICAgIGNyZWF0ZVJlY29yZDogdHJ5V3JhcChjcmVhdGVSZWNvcmQpLFxuICAgIHJlcmVuZGVyOiB0cnlXcmFwKHJlcmVuZGVyKSxcbiAgICByZWxvYWQ6IHRyeVdyYXAocmVsb2FkKVxuICB9O1xufVxuY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XG4gIGNvbnN0IGlkID0gaW5zdGFuY2UudHlwZS5fX2htcklkO1xuICBsZXQgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIGlmICghcmVjb3JkKSB7XG4gICAgY3JlYXRlUmVjb3JkKGlkLCBpbnN0YW5jZS50eXBlKTtcbiAgICByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgfVxuICByZWNvcmQuaW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XG4gIG1hcC5nZXQoaW5zdGFuY2UudHlwZS5fX2htcklkKS5pbnN0YW5jZXMuZGVsZXRlKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlY29yZChpZCwgaW5pdGlhbERlZikge1xuICBpZiAobWFwLmhhcyhpZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWFwLnNldChpZCwge1xuICAgIGluaXRpYWxEZWY6IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluaXRpYWxEZWYpLFxuICAgIGluc3RhbmNlczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICB9KTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSA/IGNvbXBvbmVudC5fX3ZjY09wdHMgOiBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiByZXJlbmRlcihpZCwgbmV3UmVuZGVyKSB7XG4gIGNvbnN0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICBpZiAoIXJlY29yZCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZWNvcmQuaW5pdGlhbERlZi5yZW5kZXIgPSBuZXdSZW5kZXI7XG4gIFsuLi5yZWNvcmQuaW5zdGFuY2VzXS5mb3JFYWNoKChpbnN0YW5jZSkgPT4ge1xuICAgIGlmIChuZXdSZW5kZXIpIHtcbiAgICAgIGluc3RhbmNlLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgICAgIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgICB9XG4gICAgaW5zdGFuY2UucmVuZGVyQ2FjaGUgPSBbXTtcbiAgICBpc0htclVwZGF0aW5nID0gdHJ1ZTtcbiAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICBpc0htclVwZGF0aW5nID0gZmFsc2U7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVsb2FkKGlkLCBuZXdDb21wKSB7XG4gIGNvbnN0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICBpZiAoIXJlY29yZCkgcmV0dXJuO1xuICBuZXdDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQobmV3Q29tcCk7XG4gIHVwZGF0ZUNvbXBvbmVudERlZihyZWNvcmQuaW5pdGlhbERlZiwgbmV3Q29tcCk7XG4gIGNvbnN0IGluc3RhbmNlcyA9IFsuLi5yZWNvcmQuaW5zdGFuY2VzXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpXTtcbiAgICBjb25zdCBvbGRDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSk7XG4gICAgbGV0IGRpcnR5SW5zdGFuY2VzID0gaG1yRGlydHlDb21wb25lbnRzLmdldChvbGRDb21wKTtcbiAgICBpZiAoIWRpcnR5SW5zdGFuY2VzKSB7XG4gICAgICBpZiAob2xkQ29tcCAhPT0gcmVjb3JkLmluaXRpYWxEZWYpIHtcbiAgICAgICAgdXBkYXRlQ29tcG9uZW50RGVmKG9sZENvbXAsIG5ld0NvbXApO1xuICAgICAgfVxuICAgICAgaG1yRGlydHlDb21wb25lbnRzLnNldChvbGRDb21wLCBkaXJ0eUluc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIH1cbiAgICBkaXJ0eUluc3RhbmNlcy5hZGQoaW5zdGFuY2UpO1xuICAgIGluc3RhbmNlLmFwcENvbnRleHQucHJvcHNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XG4gICAgaW5zdGFuY2UuYXBwQ29udGV4dC5lbWl0c0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcbiAgICBpbnN0YW5jZS5hcHBDb250ZXh0Lm9wdGlvbnNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XG4gICAgaWYgKGluc3RhbmNlLmNlUmVsb2FkKSB7XG4gICAgICBkaXJ0eUluc3RhbmNlcy5hZGQoaW5zdGFuY2UpO1xuICAgICAgaW5zdGFuY2UuY2VSZWxvYWQobmV3Q29tcC5zdHlsZXMpO1xuICAgICAgZGlydHlJbnN0YW5jZXMuZGVsZXRlKGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLnBhcmVudCkge1xuICAgICAgcXVldWVKb2IoKCkgPT4ge1xuICAgICAgICBpbnN0YW5jZS5wYXJlbnQudXBkYXRlKCk7XG4gICAgICAgIGRpcnR5SW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKSB7XG4gICAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiW0hNUl0gUm9vdCBvciBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlIG1vZGlmaWVkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLnJvb3QuY2UgJiYgaW5zdGFuY2UgIT09IGluc3RhbmNlLnJvb3QpIHtcbiAgICAgIGluc3RhbmNlLnJvb3QuY2UuX3JlbW92ZUNoaWxkU3R5bGUob2xkQ29tcCk7XG4gICAgfVxuICB9XG4gIHF1ZXVlUG9zdEZsdXNoQ2IoKCkgPT4ge1xuICAgIGhtckRpcnR5Q29tcG9uZW50cy5jbGVhcigpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKSB7XG4gIGV4dGVuZChvbGRDb21wLCBuZXdDb21wKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2xkQ29tcCkge1xuICAgIGlmIChrZXkgIT09IFwiX19maWxlXCIgJiYgIShrZXkgaW4gbmV3Q29tcCkpIHtcbiAgICAgIGRlbGV0ZSBvbGRDb21wW2tleV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cnlXcmFwKGZuKSB7XG4gIHJldHVybiAoaWQsIGFyZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oaWQsIGFyZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFtITVJdIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBWdWUgY29tcG9uZW50IGhvdC1yZWxvYWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLmBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG5sZXQgZGV2dG9vbHMkMTtcbmxldCBidWZmZXIgPSBbXTtcbmxldCBkZXZ0b29sc05vdEluc3RhbGxlZCA9IGZhbHNlO1xuZnVuY3Rpb24gZW1pdCQxKGV2ZW50LCAuLi5hcmdzKSB7XG4gIGlmIChkZXZ0b29scyQxKSB7XG4gICAgZGV2dG9vbHMkMS5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfSBlbHNlIGlmICghZGV2dG9vbHNOb3RJbnN0YWxsZWQpIHtcbiAgICBidWZmZXIucHVzaCh7IGV2ZW50LCBhcmdzIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzZXREZXZ0b29sc0hvb2skMShob29rLCB0YXJnZXQpIHtcbiAgdmFyIF9hLCBfYjtcbiAgZGV2dG9vbHMkMSA9IGhvb2s7XG4gIGlmIChkZXZ0b29scyQxKSB7XG4gICAgZGV2dG9vbHMkMS5lbmFibGVkID0gdHJ1ZTtcbiAgICBidWZmZXIuZm9yRWFjaCgoeyBldmVudCwgYXJncyB9KSA9PiBkZXZ0b29scyQxLmVtaXQoZXZlbnQsIC4uLmFyZ3MpKTtcbiAgICBidWZmZXIgPSBbXTtcbiAgfSBlbHNlIGlmIChcbiAgICAvLyBoYW5kbGUgbGF0ZSBkZXZ0b29scyBpbmplY3Rpb24gLSBvbmx5IGRvIHRoaXMgaWYgd2UgYXJlIGluIGFuIGFjdHVhbFxuICAgIC8vIGJyb3dzZXIgZW52aXJvbm1lbnQgdG8gYXZvaWQgdGhlIHRpbWVyIGhhbmRsZSBzdGFsbGluZyB0ZXN0IHJ1bm5lciBleGl0XG4gICAgLy8gKCM0ODE1KVxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgLy8gc29tZSBlbnZzIG1vY2sgd2luZG93IGJ1dCBub3QgZnVsbHlcbiAgICB3aW5kb3cuSFRNTEVsZW1lbnQgJiYgLy8gYWxzbyBleGNsdWRlIGpzZG9tXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgISgoX2IgPSAoX2EgPSB3aW5kb3cubmF2aWdhdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EudXNlckFnZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoXCJqc2RvbVwiKSlcbiAgKSB7XG4gICAgY29uc3QgcmVwbGF5ID0gdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPSB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyB8fCBbXTtcbiAgICByZXBsYXkucHVzaCgobmV3SG9vaykgPT4ge1xuICAgICAgc2V0RGV2dG9vbHNIb29rJDEobmV3SG9vaywgdGFyZ2V0KTtcbiAgICB9KTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghZGV2dG9vbHMkMSkge1xuICAgICAgICB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyA9IG51bGw7XG4gICAgICAgIGRldnRvb2xzTm90SW5zdGFsbGVkID0gdHJ1ZTtcbiAgICAgICAgYnVmZmVyID0gW107XG4gICAgICB9XG4gICAgfSwgM2UzKTtcbiAgfSBlbHNlIHtcbiAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XG4gICAgYnVmZmVyID0gW107XG4gIH1cbn1cbmZ1bmN0aW9uIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pIHtcbiAgZW1pdCQxKFwiYXBwOmluaXRcIiAvKiBBUFBfSU5JVCAqLywgYXBwLCB2ZXJzaW9uLCB7XG4gICAgRnJhZ21lbnQsXG4gICAgVGV4dCxcbiAgICBDb21tZW50LFxuICAgIFN0YXRpY1xuICB9KTtcbn1cbmZ1bmN0aW9uIGRldnRvb2xzVW5tb3VudEFwcChhcHApIHtcbiAgZW1pdCQxKFwiYXBwOnVubW91bnRcIiAvKiBBUFBfVU5NT1VOVCAqLywgYXBwKTtcbn1cbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50QWRkZWQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OmFkZGVkXCIgLyogQ09NUE9ORU5UX0FEREVEICovKTtcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6dXBkYXRlZFwiIC8qIENPTVBPTkVOVF9VUERBVEVEICovKTtcbmNvbnN0IF9kZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFxuICBcImNvbXBvbmVudDpyZW1vdmVkXCIgLyogQ09NUE9ORU5UX1JFTU9WRUQgKi9cbik7XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSAoY29tcG9uZW50KSA9PiB7XG4gIGlmIChkZXZ0b29scyQxICYmIHR5cGVvZiBkZXZ0b29scyQxLmNsZWFudXBCdWZmZXIgPT09IFwiZnVuY3Rpb25cIiAmJiAvLyByZW1vdmUgdGhlIGNvbXBvbmVudCBpZiBpdCB3YXNuJ3QgYnVmZmVyZWRcbiAgIWRldnRvb2xzJDEuY2xlYW51cEJ1ZmZlcihjb21wb25lbnQpKSB7XG4gICAgX2RldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChjb21wb25lbnQpO1xuICB9XG59O1xuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKGhvb2spIHtcbiAgcmV0dXJuIChjb21wb25lbnQpID0+IHtcbiAgICBlbWl0JDEoXG4gICAgICBob29rLFxuICAgICAgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLFxuICAgICAgY29tcG9uZW50LnVpZCxcbiAgICAgIGNvbXBvbmVudC5wYXJlbnQgPyBjb21wb25lbnQucGFyZW50LnVpZCA6IHZvaWQgMCxcbiAgICAgIGNvbXBvbmVudFxuICAgICk7XG4gIH07XG59XG5jb25zdCBkZXZ0b29sc1BlcmZTdGFydCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhcInBlcmY6c3RhcnRcIiAvKiBQRVJGT1JNQU5DRV9TVEFSVCAqLyk7XG5jb25zdCBkZXZ0b29sc1BlcmZFbmQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOmVuZFwiIC8qIFBFUkZPUk1BTkNFX0VORCAqLyk7XG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhob29rKSB7XG4gIHJldHVybiAoY29tcG9uZW50LCB0eXBlLCB0aW1lKSA9PiB7XG4gICAgZW1pdCQxKGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LCB0eXBlLCB0aW1lKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRldnRvb2xzQ29tcG9uZW50RW1pdChjb21wb25lbnQsIGV2ZW50LCBwYXJhbXMpIHtcbiAgZW1pdCQxKFxuICAgIFwiY29tcG9uZW50OmVtaXRcIiAvKiBDT01QT05FTlRfRU1JVCAqLyxcbiAgICBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsXG4gICAgY29tcG9uZW50LFxuICAgIGV2ZW50LFxuICAgIHBhcmFtc1xuICApO1xufVxuXG5sZXQgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbmxldCBjdXJyZW50U2NvcGVJZCA9IG51bGw7XG5mdW5jdGlvbiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgY29uc3QgcHJldiA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gaW5zdGFuY2U7XG4gIGN1cnJlbnRTY29wZUlkID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UudHlwZS5fX3Njb3BlSWQgfHwgbnVsbDtcbiAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiBwdXNoU2NvcGVJZChpZCkge1xuICBjdXJyZW50U2NvcGVJZCA9IGlkO1xufVxuZnVuY3Rpb24gcG9wU2NvcGVJZCgpIHtcbiAgY3VycmVudFNjb3BlSWQgPSBudWxsO1xufVxuY29uc3Qgd2l0aFNjb3BlSWQgPSAoX2lkKSA9PiB3aXRoQ3R4O1xuZnVuY3Rpb24gd2l0aEN0eChmbiwgY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLCBpc05vblNjb3BlZFNsb3QpIHtcbiAgaWYgKCFjdHgpIHJldHVybiBmbjtcbiAgaWYgKGZuLl9uKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG4gIGNvbnN0IHJlbmRlckZuV2l0aENvbnRleHQgPSAoLi4uYXJncykgPT4ge1xuICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XG4gICAgICBzZXRCbG9ja1RyYWNraW5nKC0xKTtcbiAgICB9XG4gICAgY29uc3QgcHJldkluc3RhbmNlID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGN0eCk7XG4gICAgbGV0IHJlcztcbiAgICB0cnkge1xuICAgICAgcmVzID0gZm4oLi4uYXJncyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2SW5zdGFuY2UpO1xuICAgICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcbiAgICAgICAgc2V0QmxvY2tUcmFja2luZygxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoY3R4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgcmVuZGVyRm5XaXRoQ29udGV4dC5fbiA9IHRydWU7XG4gIHJlbmRlckZuV2l0aENvbnRleHQuX2MgPSB0cnVlO1xuICByZW5kZXJGbldpdGhDb250ZXh0Ll9kID0gdHJ1ZTtcbiAgcmV0dXJuIHJlbmRlckZuV2l0aENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKSB7XG4gIGlmIChpc0J1aWx0SW5EaXJlY3RpdmUobmFtZSkpIHtcbiAgICB3YXJuJDEoXCJEbyBub3QgdXNlIGJ1aWx0LWluIGRpcmVjdGl2ZSBpZHMgYXMgY3VzdG9tIGRpcmVjdGl2ZSBpZDogXCIgKyBuYW1lKTtcbiAgfVxufVxuZnVuY3Rpb24gd2l0aERpcmVjdGl2ZXModm5vZGUsIGRpcmVjdGl2ZXMpIHtcbiAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKGB3aXRoRGlyZWN0aXZlcyBjYW4gb25seSBiZSB1c2VkIGluc2lkZSByZW5kZXIgZnVuY3Rpb25zLmApO1xuICAgIHJldHVybiB2bm9kZTtcbiAgfVxuICBjb25zdCBpbnN0YW5jZSA9IGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSk7XG4gIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycyB8fCAodm5vZGUuZGlycyA9IFtdKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IFtkaXIsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyA9IEVNUFRZX09CSl0gPSBkaXJlY3RpdmVzW2ldO1xuICAgIGlmIChkaXIpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGRpcikpIHtcbiAgICAgICAgZGlyID0ge1xuICAgICAgICAgIG1vdW50ZWQ6IGRpcixcbiAgICAgICAgICB1cGRhdGVkOiBkaXJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXIuZGVlcCkge1xuICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBiaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgZGlyLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG9sZFZhbHVlOiB2b2lkIDAsXG4gICAgICAgIGFyZyxcbiAgICAgICAgbW9kaWZpZXJzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZub2RlO1xufVxuZnVuY3Rpb24gaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgcHJldlZOb2RlLCBpbnN0YW5jZSwgbmFtZSkge1xuICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnM7XG4gIGNvbnN0IG9sZEJpbmRpbmdzID0gcHJldlZOb2RlICYmIHByZXZWTm9kZS5kaXJzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgIGlmIChvbGRCaW5kaW5ncykge1xuICAgICAgYmluZGluZy5vbGRWYWx1ZSA9IG9sZEJpbmRpbmdzW2ldLnZhbHVlO1xuICAgIH1cbiAgICBsZXQgaG9vayA9IGJpbmRpbmcuZGlyW25hbWVdO1xuICAgIGlmIChob29rKSB7XG4gICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOCwgW1xuICAgICAgICB2bm9kZS5lbCxcbiAgICAgICAgYmluZGluZyxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIHByZXZWTm9kZVxuICAgICAgXSk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFRlbGVwb3J0RW5kS2V5ID0gU3ltYm9sKFwiX3Z0ZVwiKTtcbmNvbnN0IGlzVGVsZXBvcnQgPSAodHlwZSkgPT4gdHlwZS5fX2lzVGVsZXBvcnQ7XG5jb25zdCBpc1RlbGVwb3J0RGlzYWJsZWQgPSAocHJvcHMpID0+IHByb3BzICYmIChwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5kaXNhYmxlZCA9PT0gXCJcIik7XG5jb25zdCBpc1RlbGVwb3J0RGVmZXJyZWQgPSAocHJvcHMpID0+IHByb3BzICYmIChwcm9wcy5kZWZlciB8fCBwcm9wcy5kZWZlciA9PT0gXCJcIik7XG5jb25zdCBpc1RhcmdldFNWRyA9ICh0YXJnZXQpID0+IHR5cGVvZiBTVkdFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XG5jb25zdCBpc1RhcmdldE1hdGhNTCA9ICh0YXJnZXQpID0+IHR5cGVvZiBNYXRoTUxFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgdGFyZ2V0IGluc3RhbmNlb2YgTWF0aE1MRWxlbWVudDtcbmNvbnN0IHJlc29sdmVUYXJnZXQgPSAocHJvcHMsIHNlbGVjdCkgPT4ge1xuICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IHByb3BzICYmIHByb3BzLnRvO1xuICBpZiAoaXNTdHJpbmcodGFyZ2V0U2VsZWN0b3IpKSB7XG4gICAgaWYgKCFzZWxlY3QpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKFxuICAgICAgICBgQ3VycmVudCByZW5kZXJlciBkb2VzIG5vdCBzdXBwb3J0IHN0cmluZyB0YXJnZXQgZm9yIFRlbGVwb3J0cy4gKG1pc3NpbmcgcXVlcnlTZWxlY3RvciByZW5kZXJlciBvcHRpb24pYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBzZWxlY3QodGFyZ2V0U2VsZWN0b3IpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXRhcmdldCAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYEZhaWxlZCB0byBsb2NhdGUgVGVsZXBvcnQgdGFyZ2V0IHdpdGggc2VsZWN0b3IgXCIke3RhcmdldFNlbGVjdG9yfVwiLiBOb3RlIHRoZSB0YXJnZXQgZWxlbWVudCBtdXN0IGV4aXN0IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgLSBpLmUuIHRoZSB0YXJnZXQgY2Fubm90IGJlIHJlbmRlcmVkIGJ5IHRoZSBjb21wb25lbnQgaXRzZWxmLCBhbmQgaWRlYWxseSBzaG91bGQgYmUgb3V0c2lkZSBvZiB0aGUgZW50aXJlIFZ1ZSBjb21wb25lbnQgdHJlZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhdGFyZ2V0U2VsZWN0b3IgJiYgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICAgIHdhcm4kMShgSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQ6ICR7dGFyZ2V0U2VsZWN0b3J9YCk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRTZWxlY3RvcjtcbiAgfVxufTtcbmNvbnN0IFRlbGVwb3J0SW1wbCA9IHtcbiAgbmFtZTogXCJUZWxlcG9ydFwiLFxuICBfX2lzVGVsZXBvcnQ6IHRydWUsXG4gIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgaW50ZXJuYWxzKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWM6IG1vdW50Q2hpbGRyZW4sXG4gICAgICBwYzogcGF0Y2hDaGlsZHJlbixcbiAgICAgIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLFxuICAgICAgbzogeyBpbnNlcnQsIHF1ZXJ5U2VsZWN0b3IsIGNyZWF0ZVRleHQsIGNyZWF0ZUNvbW1lbnQgfVxuICAgIH0gPSBpbnRlcm5hbHM7XG4gICAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjIucHJvcHMpO1xuICAgIGxldCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiB9ID0gbjI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBuMi5lbCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVDb21tZW50KFwidGVsZXBvcnQgc3RhcnRcIikgOiBjcmVhdGVUZXh0KFwiXCIpO1xuICAgICAgY29uc3QgbWFpbkFuY2hvciA9IG4yLmFuY2hvciA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVDb21tZW50KFwidGVsZXBvcnQgZW5kXCIpIDogY3JlYXRlVGV4dChcIlwiKTtcbiAgICAgIGluc2VydChwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KG1haW5BbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGNvbnN0IG1vdW50ID0gKGNvbnRhaW5lcjIsIGFuY2hvcjIpID0+IHtcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgY29udGFpbmVyMixcbiAgICAgICAgICAgIGFuY2hvcjIsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBtb3VudFRvVGFyZ2V0ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBuMi50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KG4yLnByb3BzLCBxdWVyeVNlbGVjdG9yKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0QW5jaG9yID0gcHJlcGFyZUFuY2hvcih0YXJnZXQsIG4yLCBjcmVhdGVUZXh0LCBpbnNlcnQpO1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgaWYgKG5hbWVzcGFjZSAhPT0gXCJzdmdcIiAmJiBpc1RhcmdldFNWRyh0YXJnZXQpKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBcInN2Z1wiO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlICE9PSBcIm1hdGhtbFwiICYmIGlzVGFyZ2V0TWF0aE1MKHRhcmdldCkpIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IFwibWF0aG1sXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIG1vdW50KHRhcmdldCwgdGFyZ2V0QW5jaG9yKTtcbiAgICAgICAgICAgIHVwZGF0ZUNzc1ZhcnMobjIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFkaXNhYmxlZCkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIFwiSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gbW91bnQ6XCIsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBgKCR7dHlwZW9mIHRhcmdldH0pYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgbW91bnQoY29udGFpbmVyLCBtYWluQW5jaG9yKTtcbiAgICAgICAgdXBkYXRlQ3NzVmFycyhuMik7XG4gICAgICB9XG4gICAgICBpZiAoaXNUZWxlcG9ydERlZmVycmVkKG4yLnByb3BzKSkge1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QobW91bnRUb1RhcmdldCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRUb1RhcmdldCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgbjIudGFyZ2V0U3RhcnQgPSBuMS50YXJnZXRTdGFydDtcbiAgICAgIGNvbnN0IG1haW5BbmNob3IgPSBuMi5hbmNob3IgPSBuMS5hbmNob3I7XG4gICAgICBjb25zdCB0YXJnZXQgPSBuMi50YXJnZXQgPSBuMS50YXJnZXQ7XG4gICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSBuMi50YXJnZXRBbmNob3IgPSBuMS50YXJnZXRBbmNob3I7XG4gICAgICBjb25zdCB3YXNEaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZChuMS5wcm9wcyk7XG4gICAgICBjb25zdCBjdXJyZW50Q29udGFpbmVyID0gd2FzRGlzYWJsZWQgPyBjb250YWluZXIgOiB0YXJnZXQ7XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yID0gd2FzRGlzYWJsZWQgPyBtYWluQW5jaG9yIDogdGFyZ2V0QW5jaG9yO1xuICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJzdmdcIiB8fCBpc1RhcmdldFNWRyh0YXJnZXQpKSB7XG4gICAgICAgIG5hbWVzcGFjZSA9IFwic3ZnXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWVzcGFjZSA9PT0gXCJtYXRobWxcIiB8fCBpc1RhcmdldE1hdGhNTCh0YXJnZXQpKSB7XG4gICAgICAgIG5hbWVzcGFjZSA9IFwibWF0aG1sXCI7XG4gICAgICB9XG4gICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihcbiAgICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGN1cnJlbnRDb250YWluZXIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICAgKTtcbiAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmICghb3B0aW1pemVkKSB7XG4gICAgICAgIHBhdGNoQ2hpbGRyZW4oXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY3VycmVudENvbnRhaW5lcixcbiAgICAgICAgICBjdXJyZW50QW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgaWYgKCF3YXNEaXNhYmxlZCkge1xuICAgICAgICAgIG1vdmVUZWxlcG9ydChcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgbWFpbkFuY2hvcixcbiAgICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChuMi5wcm9wcyAmJiBuMS5wcm9wcyAmJiBuMi5wcm9wcy50byAhPT0gbjEucHJvcHMudG8pIHtcbiAgICAgICAgICAgIG4yLnByb3BzLnRvID0gbjEucHJvcHMudG87XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKG4yLnByb3BzICYmIG4yLnByb3BzLnRvKSAhPT0gKG4xLnByb3BzICYmIG4xLnByb3BzLnRvKSkge1xuICAgICAgICAgIGNvbnN0IG5leHRUYXJnZXQgPSBuMi50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KFxuICAgICAgICAgICAgbjIucHJvcHMsXG4gICAgICAgICAgICBxdWVyeVNlbGVjdG9yXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobmV4dFRhcmdldCkge1xuICAgICAgICAgICAgbW92ZVRlbGVwb3J0KFxuICAgICAgICAgICAgICBuMixcbiAgICAgICAgICAgICAgbmV4dFRhcmdldCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBcIkludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIHVwZGF0ZTpcIixcbiAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICBgKCR7dHlwZW9mIHRhcmdldH0pYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod2FzRGlzYWJsZWQpIHtcbiAgICAgICAgICBtb3ZlVGVsZXBvcnQoXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHRhcmdldEFuY2hvcixcbiAgICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1cGRhdGVDc3NWYXJzKG4yKTtcbiAgICB9XG4gIH0sXG4gIHJlbW92ZSh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgeyB1bTogdW5tb3VudCwgbzogeyByZW1vdmU6IGhvc3RSZW1vdmUgfSB9LCBkb1JlbW92ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNoYXBlRmxhZyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgYW5jaG9yLFxuICAgICAgdGFyZ2V0U3RhcnQsXG4gICAgICB0YXJnZXRBbmNob3IsXG4gICAgICB0YXJnZXQsXG4gICAgICBwcm9wc1xuICAgIH0gPSB2bm9kZTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICBob3N0UmVtb3ZlKHRhcmdldFN0YXJ0KTtcbiAgICAgIGhvc3RSZW1vdmUodGFyZ2V0QW5jaG9yKTtcbiAgICB9XG4gICAgZG9SZW1vdmUgJiYgaG9zdFJlbW92ZShhbmNob3IpO1xuICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgY29uc3Qgc2hvdWxkUmVtb3ZlID0gZG9SZW1vdmUgfHwgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIHVubW91bnQoXG4gICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNob3VsZFJlbW92ZSxcbiAgICAgICAgICAhIWNoaWxkLmR5bmFtaWNDaGlsZHJlblxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW92ZTogbW92ZVRlbGVwb3J0LFxuICBoeWRyYXRlOiBoeWRyYXRlVGVsZXBvcnRcbn07XG5mdW5jdGlvbiBtb3ZlVGVsZXBvcnQodm5vZGUsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCB7IG86IHsgaW5zZXJ0IH0sIG06IG1vdmUgfSwgbW92ZVR5cGUgPSAyKSB7XG4gIGlmIChtb3ZlVHlwZSA9PT0gMCkge1xuICAgIGluc2VydCh2bm9kZS50YXJnZXRBbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgfVxuICBjb25zdCB7IGVsLCBhbmNob3IsIHNoYXBlRmxhZywgY2hpbGRyZW4sIHByb3BzIH0gPSB2bm9kZTtcbiAgY29uc3QgaXNSZW9yZGVyID0gbW92ZVR5cGUgPT09IDI7XG4gIGlmIChpc1Jlb3JkZXIpIHtcbiAgICBpbnNlcnQoZWwsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgfVxuICBpZiAoIWlzUmVvcmRlciB8fCBpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1vdmUoXG4gICAgICAgICAgY2hpbGRyZW5baV0sXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIHBhcmVudEFuY2hvcixcbiAgICAgICAgICAyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpc1Jlb3JkZXIpIHtcbiAgICBpbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGh5ZHJhdGVUZWxlcG9ydChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHtcbiAgbzogeyBuZXh0U2libGluZywgcGFyZW50Tm9kZSwgcXVlcnlTZWxlY3RvciwgaW5zZXJ0LCBjcmVhdGVUZXh0IH1cbn0sIGh5ZHJhdGVDaGlsZHJlbikge1xuICBjb25zdCB0YXJnZXQgPSB2bm9kZS50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KFxuICAgIHZub2RlLnByb3BzLFxuICAgIHF1ZXJ5U2VsZWN0b3JcbiAgKTtcbiAgaWYgKHRhcmdldCkge1xuICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0YXJnZXQuX2xwYSB8fCB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIGlmIChpc1RlbGVwb3J0RGlzYWJsZWQodm5vZGUucHJvcHMpKSB7XG4gICAgICAgIHZub2RlLmFuY2hvciA9IGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgICAgICBuZXh0U2libGluZyhub2RlKSxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBwYXJlbnROb2RlKG5vZGUpLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHZub2RlLnRhcmdldFN0YXJ0ID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZSAmJiBuZXh0U2libGluZyh0YXJnZXROb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmFuY2hvciA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICBsZXQgdGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgd2hpbGUgKHRhcmdldEFuY2hvcikge1xuICAgICAgICAgIGlmICh0YXJnZXRBbmNob3IgJiYgdGFyZ2V0QW5jaG9yLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0QW5jaG9yLmRhdGEgPT09IFwidGVsZXBvcnQgc3RhcnQgYW5jaG9yXCIpIHtcbiAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0U3RhcnQgPSB0YXJnZXRBbmNob3I7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldEFuY2hvci5kYXRhID09PSBcInRlbGVwb3J0IGFuY2hvclwiKSB7XG4gICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IHRhcmdldEFuY2hvcjtcbiAgICAgICAgICAgICAgdGFyZ2V0Ll9scGEgPSB2bm9kZS50YXJnZXRBbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUudGFyZ2V0QW5jaG9yKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldEFuY2hvciA9IG5leHRTaWJsaW5nKHRhcmdldEFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2bm9kZS50YXJnZXRBbmNob3IpIHtcbiAgICAgICAgICBwcmVwYXJlQW5jaG9yKHRhcmdldCwgdm5vZGUsIGNyZWF0ZVRleHQsIGluc2VydCk7XG4gICAgICAgIH1cbiAgICAgICAgaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgICAgIHRhcmdldE5vZGUgJiYgbmV4dFNpYmxpbmcodGFyZ2V0Tm9kZSksXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUNzc1ZhcnModm5vZGUpO1xuICB9XG4gIHJldHVybiB2bm9kZS5hbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yKTtcbn1cbmNvbnN0IFRlbGVwb3J0ID0gVGVsZXBvcnRJbXBsO1xuZnVuY3Rpb24gdXBkYXRlQ3NzVmFycyh2bm9kZSkge1xuICBjb25zdCBjdHggPSB2bm9kZS5jdHg7XG4gIGlmIChjdHggJiYgY3R4LnV0KSB7XG4gICAgbGV0IG5vZGUgPSB2bm9kZS50YXJnZXRTdGFydDtcbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSB2bm9kZS50YXJnZXRBbmNob3IpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSBub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtdi1vd25lclwiLCBjdHgudWlkKTtcbiAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBjdHgudXQoKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZUFuY2hvcih0YXJnZXQsIHZub2RlLCBjcmVhdGVUZXh0LCBpbnNlcnQpIHtcbiAgY29uc3QgdGFyZ2V0U3RhcnQgPSB2bm9kZS50YXJnZXRTdGFydCA9IGNyZWF0ZVRleHQoXCJcIik7XG4gIGNvbnN0IHRhcmdldEFuY2hvciA9IHZub2RlLnRhcmdldEFuY2hvciA9IGNyZWF0ZVRleHQoXCJcIik7XG4gIHRhcmdldFN0YXJ0W1RlbGVwb3J0RW5kS2V5XSA9IHRhcmdldEFuY2hvcjtcbiAgaWYgKHRhcmdldCkge1xuICAgIGluc2VydCh0YXJnZXRTdGFydCwgdGFyZ2V0KTtcbiAgICBpbnNlcnQodGFyZ2V0QW5jaG9yLCB0YXJnZXQpO1xuICB9XG4gIHJldHVybiB0YXJnZXRBbmNob3I7XG59XG5cbmNvbnN0IGxlYXZlQ2JLZXkgPSBTeW1ib2woXCJfbGVhdmVDYlwiKTtcbmNvbnN0IGVudGVyQ2JLZXkgPSBTeW1ib2woXCJfZW50ZXJDYlwiKTtcbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdGF0ZSgpIHtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICBpc0xlYXZpbmc6IGZhbHNlLFxuICAgIGlzVW5tb3VudGluZzogZmFsc2UsXG4gICAgbGVhdmluZ1ZOb2RlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICB9O1xuICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgIHN0YXRlLmlzTW91bnRlZCA9IHRydWU7XG4gIH0pO1xuICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xuICAgIHN0YXRlLmlzVW5tb3VudGluZyA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gc3RhdGU7XG59XG5jb25zdCBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvciA9IFtGdW5jdGlvbiwgQXJyYXldO1xuY29uc3QgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XG4gIG1vZGU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBwZXJzaXN0ZWQ6IEJvb2xlYW4sXG4gIC8vIGVudGVyXG4gIG9uQmVmb3JlRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BZnRlckVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25FbnRlckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIC8vIGxlYXZlXG4gIG9uQmVmb3JlTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BZnRlckxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25MZWF2ZUNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIC8vIGFwcGVhclxuICBvbkJlZm9yZUFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BZnRlckFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQXBwZWFyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvclxufTtcbmNvbnN0IHJlY3Vyc2l2ZUdldFN1YnRyZWUgPSAoaW5zdGFuY2UpID0+IHtcbiAgY29uc3Qgc3ViVHJlZSA9IGluc3RhbmNlLnN1YlRyZWU7XG4gIHJldHVybiBzdWJUcmVlLmNvbXBvbmVudCA/IHJlY3Vyc2l2ZUdldFN1YnRyZWUoc3ViVHJlZS5jb21wb25lbnQpIDogc3ViVHJlZTtcbn07XG5jb25zdCBCYXNlVHJhbnNpdGlvbkltcGwgPSB7XG4gIG5hbWU6IGBCYXNlVHJhbnNpdGlvbmAsXG4gIHByb3BzOiBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyxcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ICYmIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihzbG90cy5kZWZhdWx0KCksIHRydWUpO1xuICAgICAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkID0gZmluZE5vbkNvbW1lbnRDaGlsZChjaGlsZHJlbik7XG4gICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICAgIGNvbnN0IHsgbW9kZSB9ID0gcmF3UHJvcHM7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBtb2RlICYmIG1vZGUgIT09IFwiaW4tb3V0XCIgJiYgbW9kZSAhPT0gXCJvdXQtaW5cIiAmJiBtb2RlICE9PSBcImRlZmF1bHRcIikge1xuICAgICAgICB3YXJuJDEoYGludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICR7bW9kZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5pc0xlYXZpbmcpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5uZXJDaGlsZCA9IGdldElubmVyQ2hpbGQkMShjaGlsZCk7XG4gICAgICBpZiAoIWlubmVyQ2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xuICAgICAgfVxuICAgICAgbGV0IGVudGVySG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICBpbm5lckNoaWxkLFxuICAgICAgICByYXdQcm9wcyxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICAvLyAjMTEwNjEsIGVuc3VyZSBlbnRlckhvb2tzIGlzIGZyZXNoIGFmdGVyIGNsb25lXG4gICAgICAgIChob29rcykgPT4gZW50ZXJIb29rcyA9IGhvb2tzXG4gICAgICApO1xuICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIGVudGVySG9va3MpO1xuICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBpbnN0YW5jZS5zdWJUcmVlO1xuICAgICAgY29uc3Qgb2xkSW5uZXJDaGlsZCA9IG9sZENoaWxkICYmIGdldElubmVyQ2hpbGQkMShvbGRDaGlsZCk7XG4gICAgICBpZiAob2xkSW5uZXJDaGlsZCAmJiBvbGRJbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQgJiYgIWlzU2FtZVZOb2RlVHlwZShpbm5lckNoaWxkLCBvbGRJbm5lckNoaWxkKSAmJiByZWN1cnNpdmVHZXRTdWJ0cmVlKGluc3RhbmNlKS50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgIGNvbnN0IGxlYXZpbmdIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgb2xkSW5uZXJDaGlsZCxcbiAgICAgICAgICByYXdQcm9wcyxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICApO1xuICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgbGVhdmluZ0hvb2tzKTtcbiAgICAgICAgaWYgKG1vZGUgPT09IFwib3V0LWluXCIgJiYgaW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgICBsZWF2aW5nSG9va3MuYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCEoaW5zdGFuY2Uuam9iLmZsYWdzICYgOCkpIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJpbi1vdXRcIiAmJiBpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgICBsZWF2aW5nSG9va3MuZGVsYXlMZWF2ZSA9IChlbCwgZWFybHlSZW1vdmUsIGRlbGF5ZWRMZWF2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIG9sZElubmVyQ2hpbGRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVbU3RyaW5nKG9sZElubmVyQ2hpbGQua2V5KV0gPSBvbGRJbm5lckNoaWxkO1xuICAgICAgICAgICAgZWxbbGVhdmVDYktleV0gPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGVhcmx5UmVtb3ZlKCk7XG4gICAgICAgICAgICAgIGVsW2xlYXZlQ2JLZXldID0gdm9pZCAwO1xuICAgICAgICAgICAgICBkZWxldGUgZW50ZXJIb29rcy5kZWxheWVkTGVhdmU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZW50ZXJIb29rcy5kZWxheWVkTGVhdmUgPSBkZWxheWVkTGVhdmU7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBmaW5kTm9uQ29tbWVudENoaWxkKGNoaWxkcmVuKSB7XG4gIGxldCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgIGxldCBoYXNGb3VuZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgYyBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKGMudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBoYXNGb3VuZCkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIFwiPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudCBvciBjb21wb25lbnQuIFVzZSA8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IGM7XG4gICAgICAgIGhhc0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkO1xufVxuY29uc3QgQmFzZVRyYW5zaXRpb24gPSBCYXNlVHJhbnNpdGlvbkltcGw7XG5mdW5jdGlvbiBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSkge1xuICBjb25zdCB7IGxlYXZpbmdWTm9kZXMgfSA9IHN0YXRlO1xuICBsZXQgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gbGVhdmluZ1ZOb2Rlcy5nZXQodm5vZGUudHlwZSk7XG4gIGlmICghbGVhdmluZ1ZOb2Rlc0NhY2hlKSB7XG4gICAgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGVhdmluZ1ZOb2Rlcy5zZXQodm5vZGUudHlwZSwgbGVhdmluZ1ZOb2Rlc0NhY2hlKTtcbiAgfVxuICByZXR1cm4gbGVhdmluZ1ZOb2Rlc0NhY2hlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyh2bm9kZSwgcHJvcHMsIHN0YXRlLCBpbnN0YW5jZSwgcG9zdENsb25lKSB7XG4gIGNvbnN0IHtcbiAgICBhcHBlYXIsXG4gICAgbW9kZSxcbiAgICBwZXJzaXN0ZWQgPSBmYWxzZSxcbiAgICBvbkJlZm9yZUVudGVyLFxuICAgIG9uRW50ZXIsXG4gICAgb25BZnRlckVudGVyLFxuICAgIG9uRW50ZXJDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVMZWF2ZSxcbiAgICBvbkxlYXZlLFxuICAgIG9uQWZ0ZXJMZWF2ZSxcbiAgICBvbkxlYXZlQ2FuY2VsbGVkLFxuICAgIG9uQmVmb3JlQXBwZWFyLFxuICAgIG9uQXBwZWFyLFxuICAgIG9uQWZ0ZXJBcHBlYXIsXG4gICAgb25BcHBlYXJDYW5jZWxsZWRcbiAgfSA9IHByb3BzO1xuICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcbiAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpO1xuICBjb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzKSA9PiB7XG4gICAgaG9vayAmJiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIGhvb2ssXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDksXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgY2FsbEFzeW5jSG9vayA9IChob29rLCBhcmdzKSA9PiB7XG4gICAgY29uc3QgZG9uZSA9IGFyZ3NbMV07XG4gICAgY2FsbEhvb2soaG9vaywgYXJncyk7XG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICAgIGlmIChob29rLmV2ZXJ5KChob29rMikgPT4gaG9vazIubGVuZ3RoIDw9IDEpKSBkb25lKCk7XG4gICAgfSBlbHNlIGlmIChob29rLmxlbmd0aCA8PSAxKSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBob29rcyA9IHtcbiAgICBtb2RlLFxuICAgIHBlcnNpc3RlZCxcbiAgICBiZWZvcmVFbnRlcihlbCkge1xuICAgICAgbGV0IGhvb2sgPSBvbkJlZm9yZUVudGVyO1xuICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgaWYgKGFwcGVhcikge1xuICAgICAgICAgIGhvb2sgPSBvbkJlZm9yZUFwcGVhciB8fCBvbkJlZm9yZUVudGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVsW2xlYXZlQ2JLZXldKSB7XG4gICAgICAgIGVsW2xlYXZlQ2JLZXldKFxuICAgICAgICAgIHRydWVcbiAgICAgICAgICAvKiBjYW5jZWxsZWQgKi9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZSA9IGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xuICAgICAgaWYgKGxlYXZpbmdWTm9kZSAmJiBpc1NhbWVWTm9kZVR5cGUodm5vZGUsIGxlYXZpbmdWTm9kZSkgJiYgbGVhdmluZ1ZOb2RlLmVsW2xlYXZlQ2JLZXldKSB7XG4gICAgICAgIGxlYXZpbmdWTm9kZS5lbFtsZWF2ZUNiS2V5XSgpO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2soaG9vaywgW2VsXSk7XG4gICAgfSxcbiAgICBlbnRlcihlbCkge1xuICAgICAgbGV0IGhvb2sgPSBvbkVudGVyO1xuICAgICAgbGV0IGFmdGVySG9vayA9IG9uQWZ0ZXJFbnRlcjtcbiAgICAgIGxldCBjYW5jZWxIb29rID0gb25FbnRlckNhbmNlbGxlZDtcbiAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgIGlmIChhcHBlYXIpIHtcbiAgICAgICAgICBob29rID0gb25BcHBlYXIgfHwgb25FbnRlcjtcbiAgICAgICAgICBhZnRlckhvb2sgPSBvbkFmdGVyQXBwZWFyIHx8IG9uQWZ0ZXJFbnRlcjtcbiAgICAgICAgICBjYW5jZWxIb29rID0gb25BcHBlYXJDYW5jZWxsZWQgfHwgb25FbnRlckNhbmNlbGxlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGRvbmUgPSBlbFtlbnRlckNiS2V5XSA9IChjYW5jZWxsZWQpID0+IHtcbiAgICAgICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgY2FsbEhvb2soY2FuY2VsSG9vaywgW2VsXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbEhvb2soYWZ0ZXJIb29rLCBbZWxdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MuZGVsYXllZExlYXZlKSB7XG4gICAgICAgICAgaG9va3MuZGVsYXllZExlYXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxbZW50ZXJDYktleV0gPSB2b2lkIDA7XG4gICAgICB9O1xuICAgICAgaWYgKGhvb2spIHtcbiAgICAgICAgY2FsbEFzeW5jSG9vayhob29rLCBbZWwsIGRvbmVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxlYXZlKGVsLCByZW1vdmUpIHtcbiAgICAgIGNvbnN0IGtleTIgPSBTdHJpbmcodm5vZGUua2V5KTtcbiAgICAgIGlmIChlbFtlbnRlckNiS2V5XSkge1xuICAgICAgICBlbFtlbnRlckNiS2V5XShcbiAgICAgICAgICB0cnVlXG4gICAgICAgICAgLyogY2FuY2VsbGVkICovXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaXNVbm1vdW50aW5nKSB7XG4gICAgICAgIHJldHVybiByZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlTGVhdmUsIFtlbF0pO1xuICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgZG9uZSA9IGVsW2xlYXZlQ2JLZXldID0gKGNhbmNlbGxlZCkgPT4ge1xuICAgICAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIHJlbW92ZSgpO1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgY2FsbEhvb2sob25MZWF2ZUNhbmNlbGxlZCwgW2VsXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbEhvb2sob25BZnRlckxlYXZlLCBbZWxdKTtcbiAgICAgICAgfVxuICAgICAgICBlbFtsZWF2ZUNiS2V5XSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGxlYXZpbmdWTm9kZXNDYWNoZVtrZXkyXSA9PT0gdm5vZGUpIHtcbiAgICAgICAgICBkZWxldGUgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleTJdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleTJdID0gdm5vZGU7XG4gICAgICBpZiAob25MZWF2ZSkge1xuICAgICAgICBjYWxsQXN5bmNIb29rKG9uTGVhdmUsIFtlbCwgZG9uZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xvbmUodm5vZGUyKSB7XG4gICAgICBjb25zdCBob29rczIgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICB2bm9kZTIsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIHBvc3RDbG9uZVxuICAgICAgKTtcbiAgICAgIGlmIChwb3N0Q2xvbmUpIHBvc3RDbG9uZShob29rczIpO1xuICAgICAgcmV0dXJuIGhvb2tzMjtcbiAgICB9XG4gIH07XG4gIHJldHVybiBob29rcztcbn1cbmZ1bmN0aW9uIGVtcHR5UGxhY2Vob2xkZXIodm5vZGUpIHtcbiAgaWYgKGlzS2VlcEFsaXZlKHZub2RlKSkge1xuICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgdm5vZGUuY2hpbGRyZW4gPSBudWxsO1xuICAgIHJldHVybiB2bm9kZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SW5uZXJDaGlsZCQxKHZub2RlKSB7XG4gIGlmICghaXNLZWVwQWxpdmUodm5vZGUpKSB7XG4gICAgaWYgKGlzVGVsZXBvcnQodm5vZGUudHlwZSkgJiYgdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBmaW5kTm9uQ29tbWVudENoaWxkKHZub2RlLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHZub2RlLmNvbXBvbmVudCkge1xuICAgIHJldHVybiB2bm9kZS5jb21wb25lbnQuc3ViVHJlZTtcbiAgfVxuICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlblswXTtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDMyICYmIGlzRnVuY3Rpb24oY2hpbGRyZW4uZGVmYXVsdCkpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbi5kZWZhdWx0KCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIGhvb2tzKSB7XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2ICYmIHZub2RlLmNvbXBvbmVudCkge1xuICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgaG9va3MpO1xuICB9IGVsc2UgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgIHZub2RlLnNzQ29udGVudC50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NDb250ZW50KTtcbiAgICB2bm9kZS5zc0ZhbGxiYWNrLnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0ZhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICB2bm9kZS50cmFuc2l0aW9uID0gaG9va3M7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZHJlbiwga2VlcENvbW1lbnQgPSBmYWxzZSwgcGFyZW50S2V5KSB7XG4gIGxldCByZXQgPSBbXTtcbiAgbGV0IGtleWVkRnJhZ21lbnRDb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXkgPT0gbnVsbCA/IGNoaWxkLmtleSA6IFN0cmluZyhwYXJlbnRLZXkpICsgU3RyaW5nKGNoaWxkLmtleSAhPSBudWxsID8gY2hpbGQua2V5IDogaSk7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICBpZiAoY2hpbGQucGF0Y2hGbGFnICYgMTI4KSBrZXllZEZyYWdtZW50Q291bnQrKztcbiAgICAgIHJldCA9IHJldC5jb25jYXQoXG4gICAgICAgIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZC5jaGlsZHJlbiwga2VlcENvbW1lbnQsIGtleSlcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChrZWVwQ29tbWVudCB8fCBjaGlsZC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICByZXQucHVzaChrZXkgIT0gbnVsbCA/IGNsb25lVk5vZGUoY2hpbGQsIHsga2V5IH0pIDogY2hpbGQpO1xuICAgIH1cbiAgfVxuICBpZiAoa2V5ZWRGcmFnbWVudENvdW50ID4gMSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXRbaV0ucGF0Y2hGbGFnID0gLTI7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChvcHRpb25zLCBleHRyYU9wdGlvbnMpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24ob3B0aW9ucykgPyAoXG4gICAgLy8gIzgzMjY6IGV4dGVuZCBjYWxsIGFuZCBvcHRpb25zLm5hbWUgYWNjZXNzIGFyZSBjb25zaWRlcmVkIHNpZGUtZWZmZWN0c1xuICAgIC8vIGJ5IFJvbGx1cCwgc28gd2UgaGF2ZSB0byB3cmFwIGl0IGluIGEgcHVyZS1hbm5vdGF0ZWQgSUlGRS5cbiAgICAvKiBAX19QVVJFX18gKi8gKCgpID0+IGV4dGVuZCh7IG5hbWU6IG9wdGlvbnMubmFtZSB9LCBleHRyYU9wdGlvbnMsIHsgc2V0dXA6IG9wdGlvbnMgfSkpKClcbiAgKSA6IG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHVzZUlkKCkge1xuICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmIChpKSB7XG4gICAgcmV0dXJuIChpLmFwcENvbnRleHQuY29uZmlnLmlkUHJlZml4IHx8IFwidlwiKSArIFwiOlwiICsgaS5pZHNbMF0gKyBpLmlkc1sxXSsrO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgdXNlSWQoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya0FzeW5jQm91bmRhcnkoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UuaWRzID0gW2luc3RhbmNlLmlkc1swXSArIGluc3RhbmNlLmlkc1syXSsrICsgXCItXCIsIDAsIDBdO1xufVxuXG5mdW5jdGlvbiBzZXRSZWYocmF3UmVmLCBvbGRSYXdSZWYsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgaXNVbm1vdW50ID0gZmFsc2UpIHtcbiAgaWYgKGlzQXJyYXkocmF3UmVmKSkge1xuICAgIHJhd1JlZi5mb3JFYWNoKFxuICAgICAgKHIsIGkpID0+IHNldFJlZihcbiAgICAgICAgcixcbiAgICAgICAgb2xkUmF3UmVmICYmIChpc0FycmF5KG9sZFJhd1JlZikgPyBvbGRSYXdSZWZbaV0gOiBvbGRSYXdSZWYpLFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGlzVW5tb3VudFxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkgJiYgIWlzVW5tb3VudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZWZWYWx1ZSA9IHZub2RlLnNoYXBlRmxhZyAmIDQgPyBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZSh2bm9kZS5jb21wb25lbnQpIDogdm5vZGUuZWw7XG4gIGNvbnN0IHZhbHVlID0gaXNVbm1vdW50ID8gbnVsbCA6IHJlZlZhbHVlO1xuICBjb25zdCB7IGk6IG93bmVyLCByOiByZWYgfSA9IHJhd1JlZjtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIW93bmVyKSB7XG4gICAgd2FybiQxKFxuICAgICAgYE1pc3NpbmcgcmVmIG93bmVyIGNvbnRleHQuIHJlZiBjYW5ub3QgYmUgdXNlZCBvbiBob2lzdGVkIHZub2Rlcy4gQSB2bm9kZSB3aXRoIHJlZiBtdXN0IGJlIGNyZWF0ZWQgaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24uYFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9sZFJlZiA9IG9sZFJhd1JlZiAmJiBvbGRSYXdSZWYucjtcbiAgY29uc3QgcmVmcyA9IG93bmVyLnJlZnMgPT09IEVNUFRZX09CSiA/IG93bmVyLnJlZnMgPSB7fSA6IG93bmVyLnJlZnM7XG4gIGNvbnN0IHNldHVwU3RhdGUgPSBvd25lci5zZXR1cFN0YXRlO1xuICBpZiAob2xkUmVmICE9IG51bGwgJiYgb2xkUmVmICE9PSByZWYpIHtcbiAgICBpZiAoaXNTdHJpbmcob2xkUmVmKSkge1xuICAgICAgcmVmc1tvbGRSZWZdID0gbnVsbDtcbiAgICAgIGlmIChoYXNPd24oc2V0dXBTdGF0ZSwgb2xkUmVmKSkge1xuICAgICAgICBzZXR1cFN0YXRlW29sZFJlZl0gPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNSZWYob2xkUmVmKSkge1xuICAgICAgb2xkUmVmLnZhbHVlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24ocmVmKSkge1xuICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhyZWYsIG93bmVyLCAxMiwgW3ZhbHVlLCByZWZzXSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgX2lzU3RyaW5nID0gaXNTdHJpbmcocmVmKTtcbiAgICBjb25zdCBfaXNSZWYgPSBpc1JlZihyZWYpO1xuICAgIGlmIChfaXNTdHJpbmcgfHwgX2lzUmVmKSB7XG4gICAgICBjb25zdCBkb1NldCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHJhd1JlZi5mKSB7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBfaXNTdHJpbmcgPyBoYXNPd24oc2V0dXBTdGF0ZSwgcmVmKSA/IHNldHVwU3RhdGVbcmVmXSA6IHJlZnNbcmVmXSA6IHJlZi52YWx1ZTtcbiAgICAgICAgICBpZiAoaXNVbm1vdW50KSB7XG4gICAgICAgICAgICBpc0FycmF5KGV4aXN0aW5nKSAmJiByZW1vdmUoZXhpc3RpbmcsIHJlZlZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpc0FycmF5KGV4aXN0aW5nKSkge1xuICAgICAgICAgICAgICBpZiAoX2lzU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVmc1tyZWZdID0gW3JlZlZhbHVlXTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duKHNldHVwU3RhdGUsIHJlZikpIHtcbiAgICAgICAgICAgICAgICAgIHNldHVwU3RhdGVbcmVmXSA9IHJlZnNbcmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gW3JlZlZhbHVlXTtcbiAgICAgICAgICAgICAgICBpZiAocmF3UmVmLmspIHJlZnNbcmF3UmVmLmtdID0gcmVmLnZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFleGlzdGluZy5pbmNsdWRlcyhyZWZWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgZXhpc3RpbmcucHVzaChyZWZWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgIHJlZnNbcmVmXSA9IHZhbHVlO1xuICAgICAgICAgIGlmIChoYXNPd24oc2V0dXBTdGF0ZSwgcmVmKSkge1xuICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9pc1JlZikge1xuICAgICAgICAgIHJlZi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGlmIChyYXdSZWYuaykgcmVmc1tyYXdSZWYua10gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFwiSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTpcIiwgcmVmLCBgKCR7dHlwZW9mIHJlZn0pYCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZG9TZXQuaWQgPSAtMTtcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGRvU2V0LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb1NldCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKFwiSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTpcIiwgcmVmLCBgKCR7dHlwZW9mIHJlZn0pYCk7XG4gICAgfVxuICB9XG59XG5cbmxldCBoYXNMb2dnZWRNaXNtYXRjaEVycm9yID0gZmFsc2U7XG5jb25zdCBsb2dNaXNtYXRjaEVycm9yID0gKCkgPT4ge1xuICBpZiAoaGFzTG9nZ2VkTWlzbWF0Y2hFcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLmVycm9yKFwiSHlkcmF0aW9uIGNvbXBsZXRlZCBidXQgY29udGFpbnMgbWlzbWF0Y2hlcy5cIik7XG4gIGhhc0xvZ2dlZE1pc21hdGNoRXJyb3IgPSB0cnVlO1xufTtcbmNvbnN0IGlzU1ZHQ29udGFpbmVyID0gKGNvbnRhaW5lcikgPT4gY29udGFpbmVyLm5hbWVzcGFjZVVSSS5pbmNsdWRlcyhcInN2Z1wiKSAmJiBjb250YWluZXIudGFnTmFtZSAhPT0gXCJmb3JlaWduT2JqZWN0XCI7XG5jb25zdCBpc01hdGhNTENvbnRhaW5lciA9IChjb250YWluZXIpID0+IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkuaW5jbHVkZXMoXCJNYXRoTUxcIik7XG5jb25zdCBnZXRDb250YWluZXJUeXBlID0gKGNvbnRhaW5lcikgPT4ge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlICE9PSAxKSByZXR1cm4gdm9pZCAwO1xuICBpZiAoaXNTVkdDb250YWluZXIoY29udGFpbmVyKSkgcmV0dXJuIFwic3ZnXCI7XG4gIGlmIChpc01hdGhNTENvbnRhaW5lcihjb250YWluZXIpKSByZXR1cm4gXCJtYXRobWxcIjtcbiAgcmV0dXJuIHZvaWQgMDtcbn07XG5jb25zdCBpc0NvbW1lbnQgPSAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gODtcbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyhyZW5kZXJlckludGVybmFscykge1xuICBjb25zdCB7XG4gICAgbXQ6IG1vdW50Q29tcG9uZW50LFxuICAgIHA6IHBhdGNoLFxuICAgIG86IHtcbiAgICAgIHBhdGNoUHJvcCxcbiAgICAgIGNyZWF0ZVRleHQsXG4gICAgICBuZXh0U2libGluZyxcbiAgICAgIHBhcmVudE5vZGUsXG4gICAgICByZW1vdmUsXG4gICAgICBpbnNlcnQsXG4gICAgICBjcmVhdGVDb21tZW50XG4gICAgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGNvbnN0IGh5ZHJhdGUgPSAodm5vZGUsIGNvbnRhaW5lcikgPT4ge1xuICAgIGlmICghY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiB3YXJuJDEoXG4gICAgICAgIGBBdHRlbXB0aW5nIHRvIGh5ZHJhdGUgZXhpc3RpbmcgbWFya3VwIGJ1dCBjb250YWluZXIgaXMgZW1wdHkuIFBlcmZvcm1pbmcgZnVsbCBtb3VudCBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyKTtcbiAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGh5ZHJhdGVOb2RlKGNvbnRhaW5lci5maXJzdENoaWxkLCB2bm9kZSwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVOb2RlID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgIGNvbnN0IGlzRnJhZ21lbnRTdGFydCA9IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwiW1wiO1xuICAgIGNvbnN0IG9uTWlzbWF0Y2ggPSAoKSA9PiBoYW5kbGVNaXNtYXRjaChcbiAgICAgIG5vZGUsXG4gICAgICB2bm9kZSxcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgaXNGcmFnbWVudFN0YXJ0XG4gICAgKTtcbiAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnLCBwYXRjaEZsYWcgfSA9IHZub2RlO1xuICAgIGxldCBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgICB2bm9kZS5lbCA9IG5vZGU7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBkZWYobm9kZSwgXCJfX3Zub2RlXCIsIHZub2RlLCB0cnVlKTtcbiAgICAgIGRlZihub2RlLCBcIl9fdnVlUGFyZW50Q29tcG9uZW50XCIsIHBhcmVudENvbXBvbmVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgPT09IC0yKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGxldCBuZXh0Tm9kZSA9IG51bGw7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFRleHQ6XG4gICAgICAgIGlmIChkb21UeXBlICE9PSAzKSB7XG4gICAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuID09PSBcIlwiKSB7XG4gICAgICAgICAgICBpbnNlcnQodm5vZGUuZWwgPSBjcmVhdGVUZXh0KFwiXCIpLCBwYXJlbnROb2RlKG5vZGUpLCBub2RlKTtcbiAgICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChub2RlLmRhdGEgIT09IHZub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIHdhcm4kMShcbiAgICAgICAgICAgICAgYEh5ZHJhdGlvbiB0ZXh0IG1pc21hdGNoIGluYCxcbiAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICBgXG4gIC0gcmVuZGVyZWQgb24gc2VydmVyOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIG5vZGUuZGF0YVxuICAgICAgICAgICAgICApfVxuICAtIGV4cGVjdGVkIG9uIGNsaWVudDogJHtKU09OLnN0cmluZ2lmeSh2bm9kZS5jaGlsZHJlbil9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb21tZW50OlxuICAgICAgICBpZiAoaXNUZW1wbGF0ZU5vZGUobm9kZSkpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIHJlcGxhY2VOb2RlKFxuICAgICAgICAgICAgdm5vZGUuZWwgPSBub2RlLmNvbnRlbnQuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKGRvbVR5cGUgIT09IDggfHwgaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGljOlxuICAgICAgICBpZiAoaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIGRvbVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb21UeXBlID09PSAxIHx8IGRvbVR5cGUgPT09IDMpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgY29uc3QgbmVlZFRvQWRvcHRDb250ZW50ID0gIXZub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLnN0YXRpY0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZWVkVG9BZG9wdENvbnRlbnQpXG4gICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuICs9IG5leHROb2RlLm5vZGVUeXBlID09PSAxID8gbmV4dE5vZGUub3V0ZXJIVE1MIDogbmV4dE5vZGUuZGF0YTtcbiAgICAgICAgICAgIGlmIChpID09PSB2bm9kZS5zdGF0aWNDb3VudCAtIDEpIHtcbiAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5leHROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlzRnJhZ21lbnRTdGFydCA/IG5leHRTaWJsaW5nKG5leHROb2RlKSA6IG5leHROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIGlmICghaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRnJhZ21lbnQoXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSkge1xuICAgICAgICAgIGlmICgoZG9tVHlwZSAhPT0gMSB8fCB2bm9kZS50eXBlLnRvTG93ZXJDYXNlKCkgIT09IG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSAmJiAhaXNUZW1wbGF0ZU5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVFbGVtZW50KFxuICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgICAgICB2bm9kZS5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XG4gICAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICAgICAgICBpZiAoaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IGxvY2F0ZUNsb3NpbmdBbmNob3Iobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcInRlbGVwb3J0IHN0YXJ0XCIpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gbG9jYXRlQ2xvc2luZ0FuY2hvcihub2RlLCBub2RlLmRhdGEsIFwidGVsZXBvcnQgZW5kXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb3VudENvbXBvbmVudChcbiAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgZ2V0Q29udGFpbmVyVHlwZShjb250YWluZXIpLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpKSB7XG4gICAgICAgICAgICBsZXQgc3ViVHJlZTtcbiAgICAgICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICAgICAgc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgc3ViVHJlZS5hbmNob3IgPSBuZXh0Tm9kZSA/IG5leHROb2RlLnByZXZpb3VzU2libGluZyA6IGNvbnRhaW5lci5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdWJUcmVlID0gbm9kZS5ub2RlVHlwZSA9PT0gMyA/IGNyZWF0ZVRleHRWTm9kZShcIlwiKSA6IGNyZWF0ZVZOb2RlKFwiZGl2XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViVHJlZS5lbCA9IG5vZGU7XG4gICAgICAgICAgICB2bm9kZS5jb21wb25lbnQuc3ViVHJlZSA9IHN1YlRyZWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDgpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgICByZW5kZXJlckludGVybmFscyxcbiAgICAgICAgICAgICAgaHlkcmF0ZUNoaWxkcmVuXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgZ2V0Q29udGFpbmVyVHlwZShwYXJlbnROb2RlKG5vZGUpKSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIHJlbmRlcmVySW50ZXJuYWxzLFxuICAgICAgICAgICAgaHlkcmF0ZU5vZGVcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSB7XG4gICAgICAgICAgd2FybiQxKFwiSW52YWxpZCBIb3N0Vk5vZGUgdHlwZTpcIiwgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZUVsZW1lbnQgPSAoZWwsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXZub2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgICBjb25zdCB7IHR5cGUsIHByb3BzLCBwYXRjaEZsYWcsIHNoYXBlRmxhZywgZGlycywgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XG4gICAgY29uc3QgZm9yY2VQYXRjaCA9IHR5cGUgPT09IFwiaW5wdXRcIiB8fCB0eXBlID09PSBcIm9wdGlvblwiO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IGZvcmNlUGF0Y2ggfHwgcGF0Y2hGbGFnICE9PSAtMSkge1xuICAgICAgaWYgKGRpcnMpIHtcbiAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImNyZWF0ZWRcIik7XG4gICAgICB9XG4gICAgICBsZXQgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSBmYWxzZTtcbiAgICAgIGlmIChpc1RlbXBsYXRlTm9kZShlbCkpIHtcbiAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSBuZWVkVHJhbnNpdGlvbihwYXJlbnRTdXNwZW5zZSwgdHJhbnNpdGlvbikgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC52bm9kZS5wcm9wcyAmJiBwYXJlbnRDb21wb25lbnQudm5vZGUucHJvcHMuYXBwZWFyO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gZWwuY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICBpZiAobmVlZENhbGxUcmFuc2l0aW9uSG9va3MpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJlcGxhY2VOb2RlKGNvbnRlbnQsIGVsLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICB2bm9kZS5lbCA9IGVsID0gY29udGVudDtcbiAgICAgIH1cbiAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAmJiAvLyBza2lwIGlmIGVsZW1lbnQgaGFzIGlubmVySFRNTCAvIHRleHRDb250ZW50XG4gICAgICAhKHByb3BzICYmIChwcm9wcy5pbm5lckhUTUwgfHwgcHJvcHMudGV4dENvbnRlbnQpKSkge1xuICAgICAgICBsZXQgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgICAgICBlbC5maXJzdENoaWxkLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKG5leHQpIHtcbiAgICAgICAgICBpZiAoIWlzTWlzbWF0Y2hBbGxvd2VkKGVsLCAxIC8qIENISUxEUkVOICovKSkge1xuICAgICAgICAgICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgIWhhc1dhcm5lZCkge1xuICAgICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgICAgYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBvbmAsXG4gICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgYFxuU2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgbW9yZSBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY3VyID0gbmV4dDtcbiAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgICAgICByZW1vdmUoY3VyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA4KSB7XG4gICAgICAgIGlmIChlbC50ZXh0Q29udGVudCAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoIWlzTWlzbWF0Y2hBbGxvd2VkKGVsLCAwIC8qIFRFWFQgKi8pKSB7XG4gICAgICAgICAgICAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIHdhcm4kMShcbiAgICAgICAgICAgICAgYEh5ZHJhdGlvbiB0ZXh0IGNvbnRlbnQgbWlzbWF0Y2ggb25gLFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgYFxuICAtIHJlbmRlcmVkIG9uIHNlcnZlcjogJHtlbC50ZXh0Q29udGVudH1cbiAgLSBleHBlY3RlZCBvbiBjbGllbnQ6ICR7dm5vZGUuY2hpbGRyZW59YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWwudGV4dENvbnRlbnQgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXyB8fCBmb3JjZVBhdGNoIHx8ICFvcHRpbWl6ZWQgfHwgcGF0Y2hGbGFnICYgKDE2IHwgMzIpKSB7XG4gICAgICAgICAgY29uc3QgaXNDdXN0b21FbGVtZW50ID0gZWwudGFnTmFtZS5pbmNsdWRlcyhcIi1cIik7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGlmICgoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIC8vICMxMTE4OSBza2lwIGlmIHRoaXMgbm9kZSBoYXMgZGlyZWN0aXZlcyB0aGF0IGhhdmUgY3JlYXRlZCBob29rc1xuICAgICAgICAgICAgLy8gYXMgaXQgY291bGQgaGF2ZSBtdXRhdGVkIHRoZSBET00gaW4gYW55IHBvc3NpYmxlIHdheVxuICAgICAgICAgICAgIShkaXJzICYmIGRpcnMuc29tZSgoZCkgPT4gZC5kaXIuY3JlYXRlZCkpICYmIHByb3BIYXNNaXNtYXRjaChlbCwga2V5LCBwcm9wc1trZXldLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50KSkge1xuICAgICAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9yY2VQYXRjaCAmJiAoa2V5LmVuZHNXaXRoKFwidmFsdWVcIikgfHwga2V5ID09PSBcImluZGV0ZXJtaW5hdGVcIikgfHwgaXNPbihrZXkpICYmICFpc1Jlc2VydmVkUHJvcChrZXkpIHx8IC8vIGZvcmNlIGh5ZHJhdGUgdi1iaW5kIHdpdGggLnByb3AgbW9kaWZpZXJzXG4gICAgICAgICAgICBrZXlbMF0gPT09IFwiLlwiIHx8IGlzQ3VzdG9tRWxlbWVudCkge1xuICAgICAgICAgICAgICBwYXRjaFByb3AoZWwsIGtleSwgbnVsbCwgcHJvcHNba2V5XSwgdm9pZCAwLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5vbkNsaWNrKSB7XG4gICAgICAgICAgcGF0Y2hQcm9wKFxuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBcIm9uQ2xpY2tcIixcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwcm9wcy5vbkNsaWNrLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXRjaEZsYWcgJiA0ICYmIGlzUmVhY3RpdmUocHJvcHMuc3R5bGUpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMuc3R5bGUpIHByb3BzLnN0eWxlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCB2bm9kZUhvb2tzO1xuICAgICAgaWYgKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpIHtcbiAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKGRpcnMpIHtcbiAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZU1vdW50XCIpO1xuICAgICAgfVxuICAgICAgaWYgKCh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8IGRpcnMgfHwgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MpIHtcbiAgICAgICAgcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoKCkgPT4ge1xuICAgICAgICAgIHZub2RlSG9va3MgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcIm1vdW50ZWRcIik7XG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsLm5leHRTaWJsaW5nO1xuICB9O1xuICBjb25zdCBoeWRyYXRlQ2hpbGRyZW4gPSAobm9kZSwgcGFyZW50Vk5vZGUsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISFwYXJlbnRWTm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRWTm9kZS5jaGlsZHJlbjtcbiAgICBjb25zdCBsID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3Qgdm5vZGUgPSBvcHRpbWl6ZWQgPyBjaGlsZHJlbltpXSA6IGNoaWxkcmVuW2ldID0gbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pO1xuICAgICAgY29uc3QgaXNUZXh0ID0gdm5vZGUudHlwZSA9PT0gVGV4dDtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIGlmIChpc1RleHQgJiYgIW9wdGltaXplZCkge1xuICAgICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5baSArIDFdO1xuICAgICAgICAgIGlmIChuZXh0ICYmIChuZXh0ID0gbm9ybWFsaXplVk5vZGUobmV4dCkpLnR5cGUgPT09IFRleHQpIHtcbiAgICAgICAgICAgIGluc2VydChcbiAgICAgICAgICAgICAgY3JlYXRlVGV4dChcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEuc2xpY2Uodm5vZGUuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICAgIG5leHRTaWJsaW5nKG5vZGUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBoeWRyYXRlTm9kZShcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGlzVGV4dCAmJiAhdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgaW5zZXJ0KHZub2RlLmVsID0gY3JlYXRlVGV4dChcIlwiKSwgY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaXNNaXNtYXRjaEFsbG93ZWQoY29udGFpbmVyLCAxIC8qIENISUxEUkVOICovKSkge1xuICAgICAgICAgIGlmICgoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmICFoYXNXYXJuZWQpIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBvbmAsXG4gICAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgYFxuU2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgZmV3ZXIgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGdldENvbnRhaW5lclR5cGUoY29udGFpbmVyKSxcbiAgICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVGcmFnbWVudCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCB7IHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IHZub2RlO1xuICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xuICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcykgOiBmcmFnbWVudFNsb3RTY29wZUlkcztcbiAgICB9XG4gICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICBjb25zdCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgbmV4dFNpYmxpbmcobm9kZSksXG4gICAgICB2bm9kZSxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgb3B0aW1pemVkXG4gICAgKTtcbiAgICBpZiAobmV4dCAmJiBpc0NvbW1lbnQobmV4dCkgJiYgbmV4dC5kYXRhID09PSBcIl1cIikge1xuICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKHZub2RlLmFuY2hvciA9IG5leHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICBpbnNlcnQodm5vZGUuYW5jaG9yID0gY3JlYXRlQ29tbWVudChgXWApLCBjb250YWluZXIsIG5leHQpO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICB9O1xuICBjb25zdCBoYW5kbGVNaXNtYXRjaCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBpc0ZyYWdtZW50KSA9PiB7XG4gICAgaWYgKCFpc01pc21hdGNoQWxsb3dlZChub2RlLnBhcmVudEVsZW1lbnQsIDEgLyogQ0hJTERSRU4gKi8pKSB7XG4gICAgICAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIHdhcm4kMShcbiAgICAgICAgYEh5ZHJhdGlvbiBub2RlIG1pc21hdGNoOlxuLSByZW5kZXJlZCBvbiBzZXJ2ZXI6YCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gMyA/IGAodGV4dClgIDogaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gXCJbXCIgPyBgKHN0YXJ0IG9mIGZyYWdtZW50KWAgOiBgYCxcbiAgICAgICAgYFxuLSBleHBlY3RlZCBvbiBjbGllbnQ6YCxcbiAgICAgICAgdm5vZGUudHlwZVxuICAgICAgKTtcbiAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICB9XG4gICAgdm5vZGUuZWwgPSBudWxsO1xuICAgIGlmIChpc0ZyYWdtZW50KSB7XG4gICAgICBjb25zdCBlbmQgPSBsb2NhdGVDbG9zaW5nQW5jaG9yKG5vZGUpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgbmV4dDIgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgaWYgKG5leHQyICYmIG5leHQyICE9PSBlbmQpIHtcbiAgICAgICAgICByZW1vdmUobmV4dDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgIHJlbW92ZShub2RlKTtcbiAgICBwYXRjaChcbiAgICAgIG51bGwsXG4gICAgICB2bm9kZSxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG5leHQsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgIGdldENvbnRhaW5lclR5cGUoY29udGFpbmVyKSxcbiAgICAgIHNsb3RTY29wZUlkc1xuICAgICk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH07XG4gIGNvbnN0IGxvY2F0ZUNsb3NpbmdBbmNob3IgPSAobm9kZSwgb3BlbiA9IFwiW1wiLCBjbG9zZSA9IFwiXVwiKSA9PiB7XG4gICAgbGV0IG1hdGNoID0gMDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgaWYgKG5vZGUgJiYgaXNDb21tZW50KG5vZGUpKSB7XG4gICAgICAgIGlmIChub2RlLmRhdGEgPT09IG9wZW4pIG1hdGNoKys7XG4gICAgICAgIGlmIChub2RlLmRhdGEgPT09IGNsb3NlKSB7XG4gICAgICAgICAgaWYgKG1hdGNoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9O1xuICBjb25zdCByZXBsYWNlTm9kZSA9IChuZXdOb2RlLCBvbGROb2RlLCBwYXJlbnRDb21wb25lbnQpID0+IHtcbiAgICBjb25zdCBwYXJlbnROb2RlMiA9IG9sZE5vZGUucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZTIpIHtcbiAgICAgIHBhcmVudE5vZGUyLnJlcGxhY2VDaGlsZChuZXdOb2RlLCBvbGROb2RlKTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IHBhcmVudENvbXBvbmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LnZub2RlLmVsID09PSBvbGROb2RlKSB7XG4gICAgICAgIHBhcmVudC52bm9kZS5lbCA9IHBhcmVudC5zdWJUcmVlLmVsID0gbmV3Tm9kZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9O1xuICBjb25zdCBpc1RlbXBsYXRlTm9kZSA9IChub2RlKSA9PiB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidGVtcGxhdGVcIjtcbiAgfTtcbiAgcmV0dXJuIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV07XG59XG5mdW5jdGlvbiBwcm9wSGFzTWlzbWF0Y2goZWwsIGtleSwgY2xpZW50VmFsdWUsIHZub2RlLCBpbnN0YW5jZSkge1xuICBsZXQgbWlzbWF0Y2hUeXBlO1xuICBsZXQgbWlzbWF0Y2hLZXk7XG4gIGxldCBhY3R1YWw7XG4gIGxldCBleHBlY3RlZDtcbiAgaWYgKGtleSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgYWN0dWFsID0gZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgZXhwZWN0ZWQgPSBub3JtYWxpemVDbGFzcyhjbGllbnRWYWx1ZSk7XG4gICAgaWYgKCFpc1NldEVxdWFsKHRvQ2xhc3NTZXQoYWN0dWFsIHx8IFwiXCIpLCB0b0NsYXNzU2V0KGV4cGVjdGVkKSkpIHtcbiAgICAgIG1pc21hdGNoVHlwZSA9IDIgLyogQ0xBU1MgKi87XG4gICAgICBtaXNtYXRjaEtleSA9IGBjbGFzc2A7XG4gICAgfVxuICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgYWN0dWFsID0gZWwuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikgfHwgXCJcIjtcbiAgICBleHBlY3RlZCA9IGlzU3RyaW5nKGNsaWVudFZhbHVlKSA/IGNsaWVudFZhbHVlIDogc3RyaW5naWZ5U3R5bGUobm9ybWFsaXplU3R5bGUoY2xpZW50VmFsdWUpKTtcbiAgICBjb25zdCBhY3R1YWxNYXAgPSB0b1N0eWxlTWFwKGFjdHVhbCk7XG4gICAgY29uc3QgZXhwZWN0ZWRNYXAgPSB0b1N0eWxlTWFwKGV4cGVjdGVkKTtcbiAgICBpZiAodm5vZGUuZGlycykge1xuICAgICAgZm9yIChjb25zdCB7IGRpciwgdmFsdWUgfSBvZiB2bm9kZS5kaXJzKSB7XG4gICAgICAgIGlmIChkaXIubmFtZSA9PT0gXCJzaG93XCIgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgZXhwZWN0ZWRNYXAuc2V0KFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICByZXNvbHZlQ3NzVmFycyhpbnN0YW5jZSwgdm5vZGUsIGV4cGVjdGVkTWFwKTtcbiAgICB9XG4gICAgaWYgKCFpc01hcEVxdWFsKGFjdHVhbE1hcCwgZXhwZWN0ZWRNYXApKSB7XG4gICAgICBtaXNtYXRjaFR5cGUgPSAzIC8qIFNUWUxFICovO1xuICAgICAgbWlzbWF0Y2hLZXkgPSBcInN0eWxlXCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKGVsIGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiBpc0tub3duU3ZnQXR0cihrZXkpIHx8IGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgKGlzQm9vbGVhbkF0dHIoa2V5KSB8fCBpc0tub3duSHRtbEF0dHIoa2V5KSkpIHtcbiAgICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgICBhY3R1YWwgPSBlbC5oYXNBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIGV4cGVjdGVkID0gaW5jbHVkZUJvb2xlYW5BdHRyKGNsaWVudFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGNsaWVudFZhbHVlID09IG51bGwpIHtcbiAgICAgIGFjdHVhbCA9IGVsLmhhc0F0dHJpYnV0ZShrZXkpO1xuICAgICAgZXhwZWN0ZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZShrZXkpKSB7XG4gICAgICAgIGFjdHVhbCA9IGVsLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwidmFsdWVcIiAmJiBlbC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIpIHtcbiAgICAgICAgYWN0dWFsID0gZWwudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3R1YWwgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGV4cGVjdGVkID0gaXNSZW5kZXJhYmxlQXR0clZhbHVlKGNsaWVudFZhbHVlKSA/IFN0cmluZyhjbGllbnRWYWx1ZSkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgIG1pc21hdGNoVHlwZSA9IDQgLyogQVRUUklCVVRFICovO1xuICAgICAgbWlzbWF0Y2hLZXkgPSBrZXk7XG4gICAgfVxuICB9XG4gIGlmIChtaXNtYXRjaFR5cGUgIT0gbnVsbCAmJiAhaXNNaXNtYXRjaEFsbG93ZWQoZWwsIG1pc21hdGNoVHlwZSkpIHtcbiAgICBjb25zdCBmb3JtYXQgPSAodikgPT4gdiA9PT0gZmFsc2UgPyBgKG5vdCByZW5kZXJlZClgIDogYCR7bWlzbWF0Y2hLZXl9PVwiJHt2fVwiYDtcbiAgICBjb25zdCBwcmVTZWdtZW50ID0gYEh5ZHJhdGlvbiAke01pc21hdGNoVHlwZVN0cmluZ1ttaXNtYXRjaFR5cGVdfSBtaXNtYXRjaCBvbmA7XG4gICAgY29uc3QgcG9zdFNlZ21lbnQgPSBgXG4gIC0gcmVuZGVyZWQgb24gc2VydmVyOiAke2Zvcm1hdChhY3R1YWwpfVxuICAtIGV4cGVjdGVkIG9uIGNsaWVudDogJHtmb3JtYXQoZXhwZWN0ZWQpfVxuICBOb3RlOiB0aGlzIG1pc21hdGNoIGlzIGNoZWNrLW9ubHkuIFRoZSBET00gd2lsbCBub3QgYmUgcmVjdGlmaWVkIGluIHByb2R1Y3Rpb24gZHVlIHRvIHBlcmZvcm1hbmNlIG92ZXJoZWFkLlxuICBZb3Ugc2hvdWxkIGZpeCB0aGUgc291cmNlIG9mIHRoZSBtaXNtYXRjaC5gO1xuICAgIHtcbiAgICAgIHdhcm4kMShwcmVTZWdtZW50LCBlbCwgcG9zdFNlZ21lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB0b0NsYXNzU2V0KHN0cikge1xuICByZXR1cm4gbmV3IFNldChzdHIudHJpbSgpLnNwbGl0KC9cXHMrLykpO1xufVxuZnVuY3Rpb24gaXNTZXRFcXVhbChhLCBiKSB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IHMgb2YgYSkge1xuICAgIGlmICghYi5oYXMocykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB0b1N0eWxlTWFwKHN0cikge1xuICBjb25zdCBzdHlsZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBzdHIuc3BsaXQoXCI7XCIpKSB7XG4gICAgbGV0IFtrZXksIHZhbHVlXSA9IGl0ZW0uc3BsaXQoXCI6XCIpO1xuICAgIGtleSA9IGtleS50cmltKCk7XG4gICAgdmFsdWUgPSB2YWx1ZSAmJiB2YWx1ZS50cmltKCk7XG4gICAgaWYgKGtleSAmJiB2YWx1ZSkge1xuICAgICAgc3R5bGVNYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVNYXA7XG59XG5mdW5jdGlvbiBpc01hcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGEpIHtcbiAgICBpZiAodmFsdWUgIT09IGIuZ2V0KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZXNvbHZlQ3NzVmFycyhpbnN0YW5jZSwgdm5vZGUsIGV4cGVjdGVkTWFwKSB7XG4gIGNvbnN0IHJvb3QgPSBpbnN0YW5jZS5zdWJUcmVlO1xuICBpZiAoaW5zdGFuY2UuZ2V0Q3NzVmFycyAmJiAodm5vZGUgPT09IHJvb3QgfHwgcm9vdCAmJiByb290LnR5cGUgPT09IEZyYWdtZW50ICYmIHJvb3QuY2hpbGRyZW4uaW5jbHVkZXModm5vZGUpKSkge1xuICAgIGNvbnN0IGNzc1ZhcnMgPSBpbnN0YW5jZS5nZXRDc3NWYXJzKCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY3NzVmFycykge1xuICAgICAgZXhwZWN0ZWRNYXAuc2V0KGAtLSR7a2V5fWAsIFN0cmluZyhjc3NWYXJzW2tleV0pKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZub2RlID09PSByb290ICYmIGluc3RhbmNlLnBhcmVudCkge1xuICAgIHJlc29sdmVDc3NWYXJzKGluc3RhbmNlLnBhcmVudCwgaW5zdGFuY2Uudm5vZGUsIGV4cGVjdGVkTWFwKTtcbiAgfVxufVxuY29uc3QgYWxsb3dNaXNtYXRjaEF0dHIgPSBcImRhdGEtYWxsb3ctbWlzbWF0Y2hcIjtcbmNvbnN0IE1pc21hdGNoVHlwZVN0cmluZyA9IHtcbiAgWzAgLyogVEVYVCAqL106IFwidGV4dFwiLFxuICBbMSAvKiBDSElMRFJFTiAqL106IFwiY2hpbGRyZW5cIixcbiAgWzIgLyogQ0xBU1MgKi9dOiBcImNsYXNzXCIsXG4gIFszIC8qIFNUWUxFICovXTogXCJzdHlsZVwiLFxuICBbNCAvKiBBVFRSSUJVVEUgKi9dOiBcImF0dHJpYnV0ZVwiXG59O1xuZnVuY3Rpb24gaXNNaXNtYXRjaEFsbG93ZWQoZWwsIGFsbG93ZWRUeXBlKSB7XG4gIGlmIChhbGxvd2VkVHlwZSA9PT0gMCAvKiBURVhUICovIHx8IGFsbG93ZWRUeXBlID09PSAxIC8qIENISUxEUkVOICovKSB7XG4gICAgd2hpbGUgKGVsICYmICFlbC5oYXNBdHRyaWJ1dGUoYWxsb3dNaXNtYXRjaEF0dHIpKSB7XG4gICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICB9XG4gIGNvbnN0IGFsbG93ZWRBdHRyID0gZWwgJiYgZWwuZ2V0QXR0cmlidXRlKGFsbG93TWlzbWF0Y2hBdHRyKTtcbiAgaWYgKGFsbG93ZWRBdHRyID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoYWxsb3dlZEF0dHIgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsaXN0ID0gYWxsb3dlZEF0dHIuc3BsaXQoXCIsXCIpO1xuICAgIGlmIChhbGxvd2VkVHlwZSA9PT0gMCAvKiBURVhUICovICYmIGxpc3QuaW5jbHVkZXMoXCJjaGlsZHJlblwiKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhbGxvd2VkQXR0ci5zcGxpdChcIixcIikuaW5jbHVkZXMoTWlzbWF0Y2hUeXBlU3RyaW5nW2FsbG93ZWRUeXBlXSk7XG4gIH1cbn1cblxuY29uc3QgaHlkcmF0ZU9uSWRsZSA9ICh0aW1lb3V0ID0gMWU0KSA9PiAoaHlkcmF0ZSkgPT4ge1xuICBjb25zdCBpZCA9IHJlcXVlc3RJZGxlQ2FsbGJhY2soaHlkcmF0ZSwgeyB0aW1lb3V0IH0pO1xuICByZXR1cm4gKCkgPT4gY2FuY2VsSWRsZUNhbGxiYWNrKGlkKTtcbn07XG5jb25zdCBoeWRyYXRlT25WaXNpYmxlID0gKG9wdHMpID0+IChoeWRyYXRlLCBmb3JFYWNoKSA9PiB7XG4gIGNvbnN0IG9iID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgIGlmICghZS5pc0ludGVyc2VjdGluZykgY29udGludWU7XG4gICAgICBvYi5kaXNjb25uZWN0KCk7XG4gICAgICBoeWRyYXRlKCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0sIG9wdHMpO1xuICBmb3JFYWNoKChlbCkgPT4gb2Iub2JzZXJ2ZShlbCkpO1xuICByZXR1cm4gKCkgPT4gb2IuZGlzY29ubmVjdCgpO1xufTtcbmNvbnN0IGh5ZHJhdGVPbk1lZGlhUXVlcnkgPSAocXVlcnkpID0+IChoeWRyYXRlKSA9PiB7XG4gIGlmIChxdWVyeSkge1xuICAgIGNvbnN0IG1xbCA9IG1hdGNoTWVkaWEocXVlcnkpO1xuICAgIGlmIChtcWwubWF0Y2hlcykge1xuICAgICAgaHlkcmF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtcWwuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoeWRyYXRlLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICByZXR1cm4gKCkgPT4gbXFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaHlkcmF0ZSk7XG4gICAgfVxuICB9XG59O1xuY29uc3QgaHlkcmF0ZU9uSW50ZXJhY3Rpb24gPSAoaW50ZXJhY3Rpb25zID0gW10pID0+IChoeWRyYXRlLCBmb3JFYWNoKSA9PiB7XG4gIGlmIChpc1N0cmluZyhpbnRlcmFjdGlvbnMpKSBpbnRlcmFjdGlvbnMgPSBbaW50ZXJhY3Rpb25zXTtcbiAgbGV0IGhhc0h5ZHJhdGVkID0gZmFsc2U7XG4gIGNvbnN0IGRvSHlkcmF0ZSA9IChlKSA9PiB7XG4gICAgaWYgKCFoYXNIeWRyYXRlZCkge1xuICAgICAgaGFzSHlkcmF0ZWQgPSB0cnVlO1xuICAgICAgdGVhcmRvd24oKTtcbiAgICAgIGh5ZHJhdGUoKTtcbiAgICAgIGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IGUuY29uc3RydWN0b3IoZS50eXBlLCBlKSk7XG4gICAgfVxuICB9O1xuICBjb25zdCB0ZWFyZG93biA9ICgpID0+IHtcbiAgICBmb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBpIG9mIGludGVyYWN0aW9ucykge1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGksIGRvSHlkcmF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvckVhY2goKGVsKSA9PiB7XG4gICAgZm9yIChjb25zdCBpIG9mIGludGVyYWN0aW9ucykge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihpLCBkb0h5ZHJhdGUsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGVhcmRvd247XG59O1xuZnVuY3Rpb24gZm9yRWFjaEVsZW1lbnQobm9kZSwgY2IpIHtcbiAgaWYgKGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwiW1wiKSB7XG4gICAgbGV0IGRlcHRoID0gMTtcbiAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgd2hpbGUgKG5leHQpIHtcbiAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIGNiKG5leHQpO1xuICAgICAgfSBlbHNlIGlmIChpc0NvbW1lbnQobmV4dCkpIHtcbiAgICAgICAgaWYgKG5leHQuZGF0YSA9PT0gXCJdXCIpIHtcbiAgICAgICAgICBpZiAoLS1kZXB0aCA9PT0gMCkgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dC5kYXRhID09PSBcIltcIikge1xuICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjYihub2RlKTtcbiAgfVxufVxuXG5jb25zdCBpc0FzeW5jV3JhcHBlciA9IChpKSA9PiAhIWkudHlwZS5fX2FzeW5jTG9hZGVyO1xuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZGVmaW5lQXN5bmNDb21wb25lbnQoc291cmNlKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcbiAgICBzb3VyY2UgPSB7IGxvYWRlcjogc291cmNlIH07XG4gIH1cbiAgY29uc3Qge1xuICAgIGxvYWRlcixcbiAgICBsb2FkaW5nQ29tcG9uZW50LFxuICAgIGVycm9yQ29tcG9uZW50LFxuICAgIGRlbGF5ID0gMjAwLFxuICAgIGh5ZHJhdGU6IGh5ZHJhdGVTdHJhdGVneSxcbiAgICB0aW1lb3V0LFxuICAgIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxuICAgIHN1c3BlbnNpYmxlID0gdHJ1ZSxcbiAgICBvbkVycm9yOiB1c2VyT25FcnJvclxuICB9ID0gc291cmNlO1xuICBsZXQgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICBsZXQgcmVzb2x2ZWRDb21wO1xuICBsZXQgcmV0cmllcyA9IDA7XG4gIGNvbnN0IHJldHJ5ID0gKCkgPT4ge1xuICAgIHJldHJpZXMrKztcbiAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgcmV0dXJuIGxvYWQoKTtcbiAgfTtcbiAgY29uc3QgbG9hZCA9ICgpID0+IHtcbiAgICBsZXQgdGhpc1JlcXVlc3Q7XG4gICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0IHx8ICh0aGlzUmVxdWVzdCA9IHBlbmRpbmdSZXF1ZXN0ID0gbG9hZGVyKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgZXJyID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoU3RyaW5nKGVycikpO1xuICAgICAgaWYgKHVzZXJPbkVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgdXNlclJldHJ5ID0gKCkgPT4gcmVzb2x2ZShyZXRyeSgpKTtcbiAgICAgICAgICBjb25zdCB1c2VyRmFpbCA9ICgpID0+IHJlamVjdChlcnIpO1xuICAgICAgICAgIHVzZXJPbkVycm9yKGVyciwgdXNlclJldHJ5LCB1c2VyRmFpbCwgcmV0cmllcyArIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9KS50aGVuKChjb21wKSA9PiB7XG4gICAgICBpZiAodGhpc1JlcXVlc3QgIT09IHBlbmRpbmdSZXF1ZXN0ICYmIHBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBwZW5kaW5nUmVxdWVzdDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFjb21wKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgQXN5bmMgY29tcG9uZW50IGxvYWRlciByZXNvbHZlZCB0byB1bmRlZmluZWQuIElmIHlvdSBhcmUgdXNpbmcgcmV0cnkoKSwgbWFrZSBzdXJlIHRvIHJldHVybiBpdHMgcmV0dXJuIHZhbHVlLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wICYmIChjb21wLl9fZXNNb2R1bGUgfHwgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIk1vZHVsZVwiKSkge1xuICAgICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29tcCAmJiAhaXNPYmplY3QoY29tcCkgJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFzeW5jIGNvbXBvbmVudCBsb2FkIHJlc3VsdDogJHtjb21wfWApO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZWRDb21wID0gY29tcDtcbiAgICAgIHJldHVybiBjb21wO1xuICAgIH0pKTtcbiAgfTtcbiAgcmV0dXJuIGRlZmluZUNvbXBvbmVudCh7XG4gICAgbmFtZTogXCJBc3luY0NvbXBvbmVudFdyYXBwZXJcIixcbiAgICBfX2FzeW5jTG9hZGVyOiBsb2FkLFxuICAgIF9fYXN5bmNIeWRyYXRlKGVsLCBpbnN0YW5jZSwgaHlkcmF0ZSkge1xuICAgICAgY29uc3QgZG9IeWRyYXRlID0gaHlkcmF0ZVN0cmF0ZWd5ID8gKCkgPT4ge1xuICAgICAgICBjb25zdCB0ZWFyZG93biA9IGh5ZHJhdGVTdHJhdGVneShcbiAgICAgICAgICBoeWRyYXRlLFxuICAgICAgICAgIChjYikgPT4gZm9yRWFjaEVsZW1lbnQoZWwsIGNiKVxuICAgICAgICApO1xuICAgICAgICBpZiAodGVhcmRvd24pIHtcbiAgICAgICAgICAoaW5zdGFuY2UuYnVtIHx8IChpbnN0YW5jZS5idW0gPSBbXSkpLnB1c2godGVhcmRvd24pO1xuICAgICAgICB9XG4gICAgICB9IDogaHlkcmF0ZTtcbiAgICAgIGlmIChyZXNvbHZlZENvbXApIHtcbiAgICAgICAgZG9IeWRyYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkKCkudGhlbigoKSA9PiAhaW5zdGFuY2UuaXNVbm1vdW50ZWQgJiYgZG9IeWRyYXRlKCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IF9fYXN5bmNSZXNvbHZlZCgpIHtcbiAgICAgIHJldHVybiByZXNvbHZlZENvbXA7XG4gICAgfSxcbiAgICBzZXR1cCgpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgbWFya0FzeW5jQm91bmRhcnkoaW5zdGFuY2UpO1xuICAgICAgaWYgKHJlc29sdmVkQ29tcCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICAgICAgICBoYW5kbGVFcnJvcihcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgMTMsXG4gICAgICAgICAgIWVycm9yQ29tcG9uZW50XG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgaWYgKHN1c3BlbnNpYmxlICYmIGluc3RhbmNlLnN1c3BlbnNlIHx8IGlzSW5TU1JDb21wb25lbnRTZXR1cCkge1xuICAgICAgICByZXR1cm4gbG9hZCgpLnRoZW4oKGNvbXApID0+IHtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKGNvbXAsIGluc3RhbmNlKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gZXJyb3JDb21wb25lbnQgPyBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xuICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgIH0pIDogbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZWQgPSByZWYoZmFsc2UpO1xuICAgICAgY29uc3QgZXJyb3IgPSByZWYoKTtcbiAgICAgIGNvbnN0IGRlbGF5ZWQgPSByZWYoISFkZWxheSk7XG4gICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgZGVsYXllZC52YWx1ZSA9IGZhbHNlO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICB9XG4gICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICghbG9hZGVkLnZhbHVlICYmICFlcnJvci52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgQXN5bmMgY29tcG9uZW50IHRpbWVkIG91dCBhZnRlciAke3RpbWVvdXR9bXMuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9XG4gICAgICBsb2FkKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGxvYWRlZC52YWx1ZSA9IHRydWU7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQgJiYgaXNLZWVwQWxpdmUoaW5zdGFuY2UucGFyZW50LnZub2RlKSkge1xuICAgICAgICAgIHF1ZXVlSm9iKGluc3RhbmNlLnBhcmVudC51cGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChsb2FkZWQudmFsdWUgJiYgcmVzb2x2ZWRDb21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci52YWx1ZSAmJiBlcnJvckNvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xuICAgICAgICAgICAgZXJyb3I6IGVycm9yLnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9hZGluZ0NvbXBvbmVudCAmJiAhZGVsYXllZC52YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShsb2FkaW5nQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5uZXJDb21wKGNvbXAsIHBhcmVudCkge1xuICBjb25zdCB7IHJlZjogcmVmMiwgcHJvcHMsIGNoaWxkcmVuLCBjZSB9ID0gcGFyZW50LnZub2RlO1xuICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKGNvbXAsIHByb3BzLCBjaGlsZHJlbik7XG4gIHZub2RlLnJlZiA9IHJlZjI7XG4gIHZub2RlLmNlID0gY2U7XG4gIGRlbGV0ZSBwYXJlbnQudm5vZGUuY2U7XG4gIHJldHVybiB2bm9kZTtcbn1cblxuY29uc3QgaXNLZWVwQWxpdmUgPSAodm5vZGUpID0+IHZub2RlLnR5cGUuX19pc0tlZXBBbGl2ZTtcbmNvbnN0IEtlZXBBbGl2ZUltcGwgPSB7XG4gIG5hbWU6IGBLZWVwQWxpdmVgLFxuICAvLyBNYXJrZXIgZm9yIHNwZWNpYWwgaGFuZGxpbmcgaW5zaWRlIHRoZSByZW5kZXJlci4gV2UgYXJlIG5vdCB1c2luZyBhID09PVxuICAvLyBjaGVjayBkaXJlY3RseSBvbiBLZWVwQWxpdmUgaW4gdGhlIHJlbmRlcmVyLCBiZWNhdXNlIGltcG9ydGluZyBpdCBkaXJlY3RseVxuICAvLyB3b3VsZCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgdHJlZS1zaGFrZW4uXG4gIF9faXNLZWVwQWxpdmU6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXG4gICAgZXhjbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IHNoYXJlZENvbnRleHQgPSBpbnN0YW5jZS5jdHg7XG4gICAgaWYgKCFzaGFyZWRDb250ZXh0LnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgc2xvdHMuZGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxID8gY2hpbGRyZW5bMF0gOiBjaGlsZHJlbjtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBrZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgY3VycmVudCA9IG51bGw7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBpbnN0YW5jZS5fX3ZfY2FjaGUgPSBjYWNoZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50U3VzcGVuc2UgPSBpbnN0YW5jZS5zdXNwZW5zZTtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJlcjoge1xuICAgICAgICBwOiBwYXRjaCxcbiAgICAgICAgbTogbW92ZSxcbiAgICAgICAgdW06IF91bm1vdW50LFxuICAgICAgICBvOiB7IGNyZWF0ZUVsZW1lbnQgfVxuICAgICAgfVxuICAgIH0gPSBzaGFyZWRDb250ZXh0O1xuICAgIGNvbnN0IHN0b3JhZ2VDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHNoYXJlZENvbnRleHQuYWN0aXZhdGUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBuYW1lc3BhY2UsIG9wdGltaXplZCkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UyID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgbW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIDAsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBpbnN0YW5jZTIudm5vZGUsXG4gICAgICAgIHZub2RlLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgaW5zdGFuY2UyLFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICB2bm9kZS5zbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGluc3RhbmNlMi5pc0RlYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChpbnN0YW5jZTIuYSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGluc3RhbmNlMi5hKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlTW91bnRlZDtcbiAgICAgICAgaWYgKHZub2RlSG9vaykge1xuICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIGluc3RhbmNlMi5wYXJlbnQsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNoYXJlZENvbnRleHQuZGVhY3RpdmF0ZSA9ICh2bm9kZSkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UyID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgaW52YWxpZGF0ZU1vdW50KGluc3RhbmNlMi5tKTtcbiAgICAgIGludmFsaWRhdGVNb3VudChpbnN0YW5jZTIuYSk7XG4gICAgICBtb3ZlKHZub2RlLCBzdG9yYWdlQ29udGFpbmVyLCBudWxsLCAxLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaW5zdGFuY2UyLmRhKSB7XG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UyLmRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlVW5tb3VudGVkO1xuICAgICAgICBpZiAodm5vZGVIb29rKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UyLnBhcmVudCwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlMi5pc0RlYWN0aXZhdGVkID0gdHJ1ZTtcbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlMik7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiB1bm1vdW50KHZub2RlKSB7XG4gICAgICByZXNldFNoYXBlRmxhZyh2bm9kZSk7XG4gICAgICBfdW5tb3VudCh2bm9kZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJ1bmVDYWNoZShmaWx0ZXIpIHtcbiAgICAgIGNhY2hlLmZvckVhY2goKHZub2RlLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodm5vZGUudHlwZSk7XG4gICAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeShrZXkpIHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKGNhY2hlZCAmJiAoIWN1cnJlbnQgfHwgIWlzU2FtZVZOb2RlVHlwZShjYWNoZWQsIGN1cnJlbnQpKSkge1xuICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgcmVzZXRTaGFwZUZsYWcoY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgIGtleXMuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIHdhdGNoKFxuICAgICAgKCkgPT4gW3Byb3BzLmluY2x1ZGUsIHByb3BzLmV4Y2x1ZGVdLFxuICAgICAgKFtpbmNsdWRlLCBleGNsdWRlXSkgPT4ge1xuICAgICAgICBpbmNsdWRlICYmIHBydW5lQ2FjaGUoKG5hbWUpID0+IG1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpO1xuICAgICAgICBleGNsdWRlICYmIHBydW5lQ2FjaGUoKG5hbWUpID0+ICFtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKTtcbiAgICAgIH0sXG4gICAgICAvLyBwcnVuZSBwb3N0LXJlbmRlciBhZnRlciBgY3VycmVudGAgaGFzIGJlZW4gdXBkYXRlZFxuICAgICAgeyBmbHVzaDogXCJwb3N0XCIsIGRlZXA6IHRydWUgfVxuICAgICk7XG4gICAgbGV0IHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XG4gICAgY29uc3QgY2FjaGVTdWJ0cmVlID0gKCkgPT4ge1xuICAgICAgaWYgKHBlbmRpbmdDYWNoZUtleSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc1N1c3BlbnNlKGluc3RhbmNlLnN1YlRyZWUudHlwZSkpIHtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY2FjaGUuc2V0KHBlbmRpbmdDYWNoZUtleSwgZ2V0SW5uZXJDaGlsZChpbnN0YW5jZS5zdWJUcmVlKSk7XG4gICAgICAgICAgfSwgaW5zdGFuY2Uuc3ViVHJlZS5zdXNwZW5zZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGUuc2V0KHBlbmRpbmdDYWNoZUtleSwgZ2V0SW5uZXJDaGlsZChpbnN0YW5jZS5zdWJUcmVlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIG9uTW91bnRlZChjYWNoZVN1YnRyZWUpO1xuICAgIG9uVXBkYXRlZChjYWNoZVN1YnRyZWUpO1xuICAgIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XG4gICAgICBjYWNoZS5mb3JFYWNoKChjYWNoZWQpID0+IHtcbiAgICAgICAgY29uc3QgeyBzdWJUcmVlLCBzdXNwZW5zZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGNvbnN0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChzdWJUcmVlKTtcbiAgICAgICAgaWYgKGNhY2hlZC50eXBlID09PSB2bm9kZS50eXBlICYmIGNhY2hlZC5rZXkgPT09IHZub2RlLmtleSkge1xuICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcbiAgICAgICAgICBjb25zdCBkYSA9IHZub2RlLmNvbXBvbmVudC5kYTtcbiAgICAgICAgICBkYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZGEsIHN1c3BlbnNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdW5tb3VudChjYWNoZWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XG4gICAgICBpZiAoIXNsb3RzLmRlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHJhd1ZOb2RlID0gY2hpbGRyZW5bMF07XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShgS2VlcEFsaXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIGNvbXBvbmVudCBjaGlsZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgfSBlbHNlIGlmICghaXNWTm9kZShyYXdWTm9kZSkgfHwgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiA0KSAmJiAhKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCkpIHtcbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgIH1cbiAgICAgIGxldCB2bm9kZSA9IGdldElubmVyQ2hpbGQocmF3Vk5vZGUpO1xuICAgICAgaWYgKHZub2RlLnR5cGUgPT09IENvbW1lbnQpIHtcbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiB2bm9kZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbXAgPSB2bm9kZS50eXBlO1xuICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoXG4gICAgICAgIGlzQXN5bmNXcmFwcGVyKHZub2RlKSA/IHZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkIHx8IHt9IDogY29tcFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHsgaW5jbHVkZSwgZXhjbHVkZSwgbWF4IH0gPSBwcm9wcztcbiAgICAgIGlmIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkgfHwgZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpIHtcbiAgICAgICAgY3VycmVudCA9IHZub2RlO1xuICAgICAgICByZXR1cm4gcmF3Vk5vZGU7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbCA/IGNvbXAgOiB2bm9kZS5rZXk7XG4gICAgICBjb25zdCBjYWNoZWRWTm9kZSA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKHZub2RlLmVsKSB7XG4gICAgICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgICAgIGlmIChyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgICByYXdWTm9kZS5zc0NvbnRlbnQgPSB2bm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVuZGluZ0NhY2hlS2V5ID0ga2V5O1xuICAgICAgaWYgKGNhY2hlZFZOb2RlKSB7XG4gICAgICAgIHZub2RlLmVsID0gY2FjaGVkVk5vZGUuZWw7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudCA9IGNhY2hlZFZOb2RlLmNvbXBvbmVudDtcbiAgICAgICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIHZub2RlLnRyYW5zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSA1MTI7XG4gICAgICAgIGtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgICBpZiAobWF4ICYmIGtleXMuc2l6ZSA+IHBhcnNlSW50KG1heCwgMTApKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGtleXMudmFsdWVzKCkubmV4dCgpLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDI1NjtcbiAgICAgIGN1cnJlbnQgPSB2bm9kZTtcbiAgICAgIHJldHVybiBpc1N1c3BlbnNlKHJhd1ZOb2RlLnR5cGUpID8gcmF3Vk5vZGUgOiB2bm9kZTtcbiAgICB9O1xuICB9XG59O1xuY29uc3QgS2VlcEFsaXZlID0gS2VlcEFsaXZlSW1wbDtcbmZ1bmN0aW9uIG1hdGNoZXMocGF0dGVybiwgbmFtZSkge1xuICBpZiAoaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnNvbWUoKHApID0+IG1hdGNoZXMocCwgbmFtZSkpO1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoXCIsXCIpLmluY2x1ZGVzKG5hbWUpO1xuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gb25BY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XG4gIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCBcImFcIiwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIG9uRGVhY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XG4gIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCBcImRhXCIsIHRhcmdldCk7XG59XG5mdW5jdGlvbiByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgdHlwZSwgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSB7XG4gIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dkYyB8fCAoaG9vay5fX3dkYyA9ICgpID0+IHtcbiAgICBsZXQgY3VycmVudCA9IHRhcmdldDtcbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgaWYgKGN1cnJlbnQuaXNEZWFjdGl2YXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBob29rKCk7XG4gIH0pO1xuICBpbmplY3RIb29rKHR5cGUsIHdyYXBwZWRIb29rLCB0YXJnZXQpO1xuICBpZiAodGFyZ2V0KSB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQucGFyZW50O1xuICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQucGFyZW50KSB7XG4gICAgICBpZiAoaXNLZWVwQWxpdmUoY3VycmVudC5wYXJlbnQudm5vZGUpKSB7XG4gICAgICAgIGluamVjdFRvS2VlcEFsaXZlUm9vdCh3cmFwcGVkSG9vaywgdHlwZSwgdGFyZ2V0LCBjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGluamVjdFRvS2VlcEFsaXZlUm9vdChob29rLCB0eXBlLCB0YXJnZXQsIGtlZXBBbGl2ZVJvb3QpIHtcbiAgY29uc3QgaW5qZWN0ZWQgPSBpbmplY3RIb29rKFxuICAgIHR5cGUsXG4gICAgaG9vayxcbiAgICBrZWVwQWxpdmVSb290LFxuICAgIHRydWVcbiAgICAvKiBwcmVwZW5kICovXG4gICk7XG4gIG9uVW5tb3VudGVkKCgpID0+IHtcbiAgICByZW1vdmUoa2VlcEFsaXZlUm9vdFt0eXBlXSwgaW5qZWN0ZWQpO1xuICB9LCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gcmVzZXRTaGFwZUZsYWcodm5vZGUpIHtcbiAgdm5vZGUuc2hhcGVGbGFnICY9IH4yNTY7XG4gIHZub2RlLnNoYXBlRmxhZyAmPSB+NTEyO1xufVxuZnVuY3Rpb24gZ2V0SW5uZXJDaGlsZCh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuc2hhcGVGbGFnICYgMTI4ID8gdm5vZGUuc3NDb250ZW50IDogdm5vZGU7XG59XG5cbmZ1bmN0aW9uIGluamVjdEhvb2sodHlwZSwgaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlLCBwcmVwZW5kID0gZmFsc2UpIHtcbiAgaWYgKHRhcmdldCkge1xuICAgIGNvbnN0IGhvb2tzID0gdGFyZ2V0W3R5cGVdIHx8ICh0YXJnZXRbdHlwZV0gPSBbXSk7XG4gICAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2VoIHx8IChob29rLl9fd2VoID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKHRhcmdldCk7XG4gICAgICBjb25zdCByZXMgPSBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCB0YXJnZXQsIHR5cGUsIGFyZ3MpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gICAgaWYgKHByZXBlbmQpIHtcbiAgICAgIGhvb2tzLnVuc2hpZnQod3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBob29rcy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZWRIb29rO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBhcGlOYW1lID0gdG9IYW5kbGVyS2V5KEVycm9yVHlwZVN0cmluZ3MkMVt0eXBlXS5yZXBsYWNlKC8gaG9vayQvLCBcIlwiKSk7XG4gICAgd2FybiQxKFxuICAgICAgYCR7YXBpTmFtZX0gaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBhc3NvY2lhdGVkIHdpdGguIExpZmVjeWNsZSBpbmplY3Rpb24gQVBJcyBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBleGVjdXRpb24gb2Ygc2V0dXAoKS5gICsgKGAgSWYgeW91IGFyZSB1c2luZyBhc3luYyBzZXR1cCgpLCBtYWtlIHN1cmUgdG8gcmVnaXN0ZXIgbGlmZWN5Y2xlIGhvb2tzIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQgc3RhdGVtZW50LmAgKVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IGNyZWF0ZUhvb2sgPSAobGlmZWN5Y2xlKSA9PiAoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSA9PiB7XG4gIGlmICghaXNJblNTUkNvbXBvbmVudFNldHVwIHx8IGxpZmVjeWNsZSA9PT0gXCJzcFwiKSB7XG4gICAgaW5qZWN0SG9vayhsaWZlY3ljbGUsICguLi5hcmdzKSA9PiBob29rKC4uLmFyZ3MpLCB0YXJnZXQpO1xuICB9XG59O1xuY29uc3Qgb25CZWZvcmVNb3VudCA9IGNyZWF0ZUhvb2soXCJibVwiKTtcbmNvbnN0IG9uTW91bnRlZCA9IGNyZWF0ZUhvb2soXCJtXCIpO1xuY29uc3Qgb25CZWZvcmVVcGRhdGUgPSBjcmVhdGVIb29rKFxuICBcImJ1XCJcbik7XG5jb25zdCBvblVwZGF0ZWQgPSBjcmVhdGVIb29rKFwidVwiKTtcbmNvbnN0IG9uQmVmb3JlVW5tb3VudCA9IGNyZWF0ZUhvb2soXG4gIFwiYnVtXCJcbik7XG5jb25zdCBvblVubW91bnRlZCA9IGNyZWF0ZUhvb2soXCJ1bVwiKTtcbmNvbnN0IG9uU2VydmVyUHJlZmV0Y2ggPSBjcmVhdGVIb29rKFxuICBcInNwXCJcbik7XG5jb25zdCBvblJlbmRlclRyaWdnZXJlZCA9IGNyZWF0ZUhvb2soXCJydGdcIik7XG5jb25zdCBvblJlbmRlclRyYWNrZWQgPSBjcmVhdGVIb29rKFwicnRjXCIpO1xuZnVuY3Rpb24gb25FcnJvckNhcHR1cmVkKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xuICBpbmplY3RIb29rKFwiZWNcIiwgaG9vaywgdGFyZ2V0KTtcbn1cblxuY29uc3QgQ09NUE9ORU5UUyA9IFwiY29tcG9uZW50c1wiO1xuY29uc3QgRElSRUNUSVZFUyA9IFwiZGlyZWN0aXZlc1wiO1xuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudChuYW1lLCBtYXliZVNlbGZSZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBuYW1lLCB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UpIHx8IG5hbWU7XG59XG5jb25zdCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sLmZvcihcInYtbmRjXCIpO1xuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIGlmIChpc1N0cmluZyhjb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBjb21wb25lbnQsIGZhbHNlKSB8fCBjb21wb25lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudCB8fCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlRGlyZWN0aXZlKG5hbWUpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldChESVJFQ1RJVkVTLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCh0eXBlLCBuYW1lLCB3YXJuTWlzc2luZyA9IHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSA9IGZhbHNlKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIHx8IGN1cnJlbnRJbnN0YW5jZTtcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gQ09NUE9ORU5UUykge1xuICAgICAgY29uc3Qgc2VsZk5hbWUgPSBnZXRDb21wb25lbnROYW1lKFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgaWYgKHNlbGZOYW1lICYmIChzZWxmTmFtZSA9PT0gbmFtZSB8fCBzZWxmTmFtZSA9PT0gY2FtZWxpemUobmFtZSkgfHwgc2VsZk5hbWUgPT09IGNhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpKSkge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSAoXG4gICAgICAvLyBsb2NhbCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGNoZWNrIGluc3RhbmNlW3R5cGVdIGZpcnN0IHdoaWNoIGlzIHJlc29sdmVkIGZvciBvcHRpb25zIEFQSVxuICAgICAgcmVzb2x2ZShpbnN0YW5jZVt0eXBlXSB8fCBDb21wb25lbnRbdHlwZV0sIG5hbWUpIHx8IC8vIGdsb2JhbCByZWdpc3RyYXRpb25cbiAgICAgIHJlc29sdmUoaW5zdGFuY2UuYXBwQ29udGV4dFt0eXBlXSwgbmFtZSlcbiAgICApO1xuICAgIGlmICghcmVzICYmIG1heWJlU2VsZlJlZmVyZW5jZSkge1xuICAgICAgcmV0dXJuIENvbXBvbmVudDtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgICAgY29uc3QgZXh0cmEgPSB0eXBlID09PSBDT01QT05FTlRTID8gYFxuSWYgdGhpcyBpcyBhIG5hdGl2ZSBjdXN0b20gZWxlbWVudCwgbWFrZSBzdXJlIHRvIGV4Y2x1ZGUgaXQgZnJvbSBjb21wb25lbnQgcmVzb2x1dGlvbiB2aWEgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudC5gIDogYGA7XG4gICAgICB3YXJuJDEoYEZhaWxlZCB0byByZXNvbHZlICR7dHlwZS5zbGljZSgwLCAtMSl9OiAke25hbWV9JHtleHRyYX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKFxuICAgICAgYHJlc29sdmUke2NhcGl0YWxpemUodHlwZS5zbGljZSgwLCAtMSkpfSBjYW4gb25seSBiZSB1c2VkIGluIHJlbmRlcigpIG9yIHNldHVwKCkuYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmUocmVnaXN0cnksIG5hbWUpIHtcbiAgcmV0dXJuIHJlZ2lzdHJ5ICYmIChyZWdpc3RyeVtuYW1lXSB8fCByZWdpc3RyeVtjYW1lbGl6ZShuYW1lKV0gfHwgcmVnaXN0cnlbY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSldKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTGlzdChzb3VyY2UsIHJlbmRlckl0ZW0sIGNhY2hlLCBpbmRleCkge1xuICBsZXQgcmV0O1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZSAmJiBjYWNoZVtpbmRleF07XG4gIGNvbnN0IHNvdXJjZUlzQXJyYXkgPSBpc0FycmF5KHNvdXJjZSk7XG4gIGlmIChzb3VyY2VJc0FycmF5IHx8IGlzU3RyaW5nKHNvdXJjZSkpIHtcbiAgICBjb25zdCBzb3VyY2VJc1JlYWN0aXZlQXJyYXkgPSBzb3VyY2VJc0FycmF5ICYmIGlzUmVhY3RpdmUoc291cmNlKTtcbiAgICBpZiAoc291cmNlSXNSZWFjdGl2ZUFycmF5KSB7XG4gICAgICBzb3VyY2UgPSBzaGFsbG93UmVhZEFycmF5KHNvdXJjZSk7XG4gICAgfVxuICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oXG4gICAgICAgIHNvdXJjZUlzUmVhY3RpdmVBcnJheSA/IHRvUmVhY3RpdmUoc291cmNlW2ldKSA6IHNvdXJjZVtpXSxcbiAgICAgICAgaSxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBjYWNoZWQgJiYgY2FjaGVkW2ldXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIU51bWJlci5pc0ludGVnZXIoc291cmNlKSkge1xuICAgICAgd2FybiQxKGBUaGUgdi1mb3IgcmFuZ2UgZXhwZWN0IGFuIGludGVnZXIgdmFsdWUgYnV0IGdvdCAke3NvdXJjZX0uYCk7XG4gICAgfVxuICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oaSArIDEsIGksIHZvaWQgMCwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBpZiAoc291cmNlW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IEFycmF5LmZyb20oXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgKGl0ZW0sIGkpID0+IHJlbmRlckl0ZW0oaXRlbSwgaSwgdm9pZCAwLCBjYWNoZWQgJiYgY2FjaGVkW2ldKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtrZXldLCBrZXksIGksIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXQgPSBbXTtcbiAgfVxuICBpZiAoY2FjaGUpIHtcbiAgICBjYWNoZVtpbmRleF0gPSByZXQ7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2xvdHMoc2xvdHMsIGR5bmFtaWNTbG90cykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGR5bmFtaWNTbG90cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNsb3QgPSBkeW5hbWljU2xvdHNbaV07XG4gICAgaWYgKGlzQXJyYXkoc2xvdCkpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xvdC5sZW5ndGg7IGorKykge1xuICAgICAgICBzbG90c1tzbG90W2pdLm5hbWVdID0gc2xvdFtqXS5mbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNsb3QpIHtcbiAgICAgIHNsb3RzW3Nsb3QubmFtZV0gPSBzbG90LmtleSA/ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHNsb3QuZm4oLi4uYXJncyk7XG4gICAgICAgIGlmIChyZXMpIHJlcy5rZXkgPSBzbG90LmtleTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0gOiBzbG90LmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHM7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclNsb3Qoc2xvdHMsIG5hbWUsIHByb3BzID0ge30sIGZhbGxiYWNrLCBub1Nsb3R0ZWQpIHtcbiAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50ICYmIGlzQXN5bmNXcmFwcGVyKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQpICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQuY2UpIHtcbiAgICBpZiAobmFtZSAhPT0gXCJkZWZhdWx0XCIpIHByb3BzLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiBvcGVuQmxvY2soKSwgY3JlYXRlQmxvY2soXG4gICAgICBGcmFnbWVudCxcbiAgICAgIG51bGwsXG4gICAgICBbY3JlYXRlVk5vZGUoXCJzbG90XCIsIHByb3BzLCBmYWxsYmFjayAmJiBmYWxsYmFjaygpKV0sXG4gICAgICA2NFxuICAgICk7XG4gIH1cbiAgbGV0IHNsb3QgPSBzbG90c1tuYW1lXTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2xvdCAmJiBzbG90Lmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgU1NSLW9wdGltaXplZCBzbG90IGZ1bmN0aW9uIGRldGVjdGVkIGluIGEgbm9uLVNTUi1vcHRpbWl6ZWQgcmVuZGVyIGZ1bmN0aW9uLiBZb3UgbmVlZCB0byBtYXJrIHRoaXMgY29tcG9uZW50IHdpdGggJGR5bmFtaWMtc2xvdHMgaW4gdGhlIHBhcmVudCB0ZW1wbGF0ZS5gXG4gICAgKTtcbiAgICBzbG90ID0gKCkgPT4gW107XG4gIH1cbiAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xuICAgIHNsb3QuX2QgPSBmYWxzZTtcbiAgfVxuICBvcGVuQmxvY2soKTtcbiAgY29uc3QgdmFsaWRTbG90Q29udGVudCA9IHNsb3QgJiYgZW5zdXJlVmFsaWRWTm9kZShzbG90KHByb3BzKSk7XG4gIGNvbnN0IHJlbmRlcmVkID0gY3JlYXRlQmxvY2soXG4gICAgRnJhZ21lbnQsXG4gICAge1xuICAgICAga2V5OiAocHJvcHMua2V5IHx8IC8vIHNsb3QgY29udGVudCBhcnJheSBvZiBhIGR5bmFtaWMgY29uZGl0aW9uYWwgc2xvdCBtYXkgaGF2ZSBhIGJyYW5jaFxuICAgICAgLy8ga2V5IGF0dGFjaGVkIGluIHRoZSBgY3JlYXRlU2xvdHNgIGhlbHBlciwgcmVzcGVjdCB0aGF0XG4gICAgICB2YWxpZFNsb3RDb250ZW50ICYmIHZhbGlkU2xvdENvbnRlbnQua2V5IHx8IGBfJHtuYW1lfWApICsgLy8gIzcyNTYgZm9yY2UgZGlmZmVyZW50aWF0ZSBmYWxsYmFjayBjb250ZW50IGZyb20gYWN0dWFsIGNvbnRlbnRcbiAgICAgICghdmFsaWRTbG90Q29udGVudCAmJiBmYWxsYmFjayA/IFwiX2ZiXCIgOiBcIlwiKVxuICAgIH0sXG4gICAgdmFsaWRTbG90Q29udGVudCB8fCAoZmFsbGJhY2sgPyBmYWxsYmFjaygpIDogW10pLFxuICAgIHZhbGlkU2xvdENvbnRlbnQgJiYgc2xvdHMuXyA9PT0gMSA/IDY0IDogLTJcbiAgKTtcbiAgaWYgKCFub1Nsb3R0ZWQgJiYgcmVuZGVyZWQuc2NvcGVJZCkge1xuICAgIHJlbmRlcmVkLnNsb3RTY29wZUlkcyA9IFtyZW5kZXJlZC5zY29wZUlkICsgXCItc1wiXTtcbiAgfVxuICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XG4gICAgc2xvdC5fZCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlbmRlcmVkO1xufVxuZnVuY3Rpb24gZW5zdXJlVmFsaWRWTm9kZSh2bm9kZXMpIHtcbiAgcmV0dXJuIHZub2Rlcy5zb21lKChjaGlsZCkgPT4ge1xuICAgIGlmICghaXNWTm9kZShjaGlsZCkpIHJldHVybiB0cnVlO1xuICAgIGlmIChjaGlsZC50eXBlID09PSBDb21tZW50KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50ICYmICFlbnN1cmVWYWxpZFZOb2RlKGNoaWxkLmNoaWxkcmVuKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkgPyB2bm9kZXMgOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0b0hhbmRsZXJzKG9iaiwgcHJlc2VydmVDYXNlSWZOZWNlc3NhcnkpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc09iamVjdChvYmopKSB7XG4gICAgd2FybiQxKGB2LW9uIHdpdGggbm8gYXJndW1lbnQgZXhwZWN0cyBhbiBvYmplY3QgdmFsdWUuYCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICByZXRbcHJlc2VydmVDYXNlSWZOZWNlc3NhcnkgJiYgL1tBLVpdLy50ZXN0KGtleSkgPyBgb246JHtrZXl9YCA6IHRvSGFuZGxlcktleShrZXkpXSA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmNvbnN0IGdldFB1YmxpY0luc3RhbmNlID0gKGkpID0+IHtcbiAgaWYgKCFpKSByZXR1cm4gbnVsbDtcbiAgaWYgKGlzU3RhdGVmdWxDb21wb25lbnQoaSkpIHJldHVybiBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZShpKTtcbiAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KTtcbn07XG5jb25zdCBwdWJsaWNQcm9wZXJ0aWVzTWFwID0gKFxuICAvLyBNb3ZlIFBVUkUgbWFya2VyIHRvIG5ldyBsaW5lIHRvIHdvcmthcm91bmQgY29tcGlsZXIgZGlzY2FyZGluZyBpdFxuICAvLyBkdWUgdG8gdHlwZSBhbm5vdGF0aW9uXG4gIC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAkOiAoaSkgPT4gaSxcbiAgICAkZWw6IChpKSA9PiBpLnZub2RlLmVsLFxuICAgICRkYXRhOiAoaSkgPT4gaS5kYXRhLFxuICAgICRwcm9wczogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5wcm9wcykgOiBpLnByb3BzLFxuICAgICRhdHRyczogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5hdHRycykgOiBpLmF0dHJzLFxuICAgICRzbG90czogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5zbG90cykgOiBpLnNsb3RzLFxuICAgICRyZWZzOiAoaSkgPT4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpLnJlZnMpIDogaS5yZWZzLFxuICAgICRwYXJlbnQ6IChpKSA9PiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCksXG4gICAgJHJvb3Q6IChpKSA9PiBnZXRQdWJsaWNJbnN0YW5jZShpLnJvb3QpLFxuICAgICRob3N0OiAoaSkgPT4gaS5jZSxcbiAgICAkZW1pdDogKGkpID0+IGkuZW1pdCxcbiAgICAkb3B0aW9uczogKGkpID0+IF9fVlVFX09QVElPTlNfQVBJX18gPyByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpKSA6IGkudHlwZSxcbiAgICAkZm9yY2VVcGRhdGU6IChpKSA9PiBpLmYgfHwgKGkuZiA9ICgpID0+IHtcbiAgICAgIHF1ZXVlSm9iKGkudXBkYXRlKTtcbiAgICB9KSxcbiAgICAkbmV4dFRpY2s6IChpKSA9PiBpLm4gfHwgKGkubiA9IG5leHRUaWNrLmJpbmQoaS5wcm94eSkpLFxuICAgICR3YXRjaDogKGkpID0+IF9fVlVFX09QVElPTlNfQVBJX18gPyBpbnN0YW5jZVdhdGNoLmJpbmQoaSkgOiBOT09QXG4gIH0pXG4pO1xuY29uc3QgaXNSZXNlcnZlZFByZWZpeCA9IChrZXkpID0+IGtleSA9PT0gXCJfXCIgfHwga2V5ID09PSBcIiRcIjtcbmNvbnN0IGhhc1NldHVwQmluZGluZyA9IChzdGF0ZSwga2V5KSA9PiBzdGF0ZSAhPT0gRU1QVFlfT0JKICYmICFzdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiYgaGFzT3duKHN0YXRlLCBrZXkpO1xuY29uc3QgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0ge1xuICBnZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXkpIHtcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9za2lwXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSwgZGF0YSwgcHJvcHMsIGFjY2Vzc0NhY2hlLCB0eXBlLCBhcHBDb250ZXh0IH0gPSBpbnN0YW5jZTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgPT09IFwiX19pc1Z1ZVwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG5vcm1hbGl6ZWRQcm9wcztcbiAgICBpZiAoa2V5WzBdICE9PSBcIiRcIikge1xuICAgICAgY29uc3QgbiA9IGFjY2Vzc0NhY2hlW2tleV07XG4gICAgICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICAgIGNhc2UgMSAvKiBTRVRVUCAqLzpcbiAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XG4gICAgICAgICAgY2FzZSAyIC8qIERBVEEgKi86XG4gICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgICAgIGNhc2UgNCAvKiBDT05URVhUICovOlxuICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgICAgICAgIGNhc2UgMyAvKiBQUk9QUyAqLzpcbiAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhc1NldHVwQmluZGluZyhzZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAxIC8qIFNFVFVQICovO1xuICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xuICAgICAgfSBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDIgLyogREFUQSAqLztcbiAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIC8vIG9ubHkgY2FjaGUgb3RoZXIgcHJvcGVydGllcyB3aGVuIGluc3RhbmNlIGhhcyBkZWNsYXJlZCAodGh1cyBzdGFibGUpXG4gICAgICAgIC8vIHByb3BzXG4gICAgICAgIChub3JtYWxpemVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pICYmIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSlcbiAgICAgICkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMyAvKiBQUk9QUyAqLztcbiAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICB9IGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDQgLyogQ09OVEVYVCAqLztcbiAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgICAgfSBlbHNlIGlmICghX19WVUVfT1BUSU9OU19BUElfXyB8fCBzaG91bGRDYWNoZUFjY2Vzcykge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMCAvKiBPVEhFUiAqLztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHVibGljR2V0dGVyID0gcHVibGljUHJvcGVydGllc01hcFtrZXldO1xuICAgIGxldCBjc3NNb2R1bGUsIGdsb2JhbFByb3BlcnRpZXM7XG4gICAgaWYgKHB1YmxpY0dldHRlcikge1xuICAgICAgaWYgKGtleSA9PT0gXCIkYXR0cnNcIikge1xuICAgICAgICB0cmFjayhpbnN0YW5jZS5hdHRycywgXCJnZXRcIiwgXCJcIik7XG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgPT09IFwiJHNsb3RzXCIpIHtcbiAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHVibGljR2V0dGVyKGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gY3NzIG1vZHVsZSAoaW5qZWN0ZWQgYnkgdnVlLWxvYWRlcilcbiAgICAgIChjc3NNb2R1bGUgPSB0eXBlLl9fY3NzTW9kdWxlcykgJiYgKGNzc01vZHVsZSA9IGNzc01vZHVsZVtrZXldKVxuICAgICkge1xuICAgICAgcmV0dXJuIGNzc01vZHVsZTtcbiAgICB9IGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcbiAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIENPTlRFWFQgKi87XG4gICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8vIGdsb2JhbCBwcm9wZXJ0aWVzXG4gICAgICBnbG9iYWxQcm9wZXJ0aWVzID0gYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcywgaGFzT3duKGdsb2JhbFByb3BlcnRpZXMsIGtleSlcbiAgICApIHtcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFByb3BlcnRpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlICYmICghaXNTdHJpbmcoa2V5KSB8fCAvLyAjMTA5MSBhdm9pZCBpbnRlcm5hbCBpc1JlZi9pc1ZOb2RlIGNoZWNrcyBvbiBjb21wb25lbnQgaW5zdGFuY2UgbGVhZGluZ1xuICAgIC8vIHRvIGluZmluaXRlIHdhcm5pbmcgbG9vcFxuICAgIGtleS5pbmRleE9mKFwiX192XCIpICE9PSAwKSkge1xuICAgICAgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBpc1Jlc2VydmVkUHJlZml4KGtleVswXSkgJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgKX0gbXVzdCBiZSBhY2Nlc3NlZCB2aWEgJGRhdGEgYmVjYXVzZSBpdCBzdGFydHMgd2l0aCBhIHJlc2VydmVkIGNoYXJhY3RlciAoXCIkXCIgb3IgXCJfXCIpIGFuZCBpcyBub3QgcHJveGllZCBvbiB0aGUgcmVuZGVyIGNvbnRleHQuYFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChpbnN0YW5jZSA9PT0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSB3YXMgYWNjZXNzZWQgZHVyaW5nIHJlbmRlciBidXQgaXMgbm90IGRlZmluZWQgb24gaW5zdGFuY2UuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2V0KHsgXzogaW5zdGFuY2UgfSwga2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHsgZGF0YSwgc2V0dXBTdGF0ZSwgY3R4IH0gPSBpbnN0YW5jZTtcbiAgICBpZiAoaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgIHNldHVwU3RhdGVba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwICYmIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICB3YXJuJDEoYENhbm5vdCBtdXRhdGUgPHNjcmlwdCBzZXR1cD4gYmluZGluZyBcIiR7a2V5fVwiIGZyb20gT3B0aW9ucyBBUEkuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChoYXNPd24oaW5zdGFuY2UucHJvcHMsIGtleSkpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwcm9wIFwiJHtrZXl9XCIuIFByb3BzIGFyZSByZWFkb25seS5gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGtleVswXSA9PT0gXCIkXCIgJiYga2V5LnNsaWNlKDEpIGluIGluc3RhbmNlKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShcbiAgICAgICAgYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHB1YmxpYyBwcm9wZXJ0eSBcIiR7a2V5fVwiLiBQcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggJCBhcmUgcmVzZXJ2ZWQgYW5kIHJlYWRvbmx5LmBcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleSBpbiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGhhcyh7XG4gICAgXzogeyBkYXRhLCBzZXR1cFN0YXRlLCBhY2Nlc3NDYWNoZSwgY3R4LCBhcHBDb250ZXh0LCBwcm9wc09wdGlvbnMgfVxuICB9LCBrZXkpIHtcbiAgICBsZXQgbm9ybWFsaXplZFByb3BzO1xuICAgIHJldHVybiAhIWFjY2Vzc0NhY2hlW2tleV0gfHwgZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpIHx8IGhhc1NldHVwQmluZGluZyhzZXR1cFN0YXRlLCBrZXkpIHx8IChub3JtYWxpemVkUHJvcHMgPSBwcm9wc09wdGlvbnNbMF0pICYmIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSkgfHwgaGFzT3duKGN0eCwga2V5KSB8fCBoYXNPd24ocHVibGljUHJvcGVydGllc01hcCwga2V5KSB8fCBoYXNPd24oYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcywga2V5KTtcbiAgfSxcbiAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgICBpZiAoZGVzY3JpcHRvci5nZXQgIT0gbnVsbCkge1xuICAgICAgdGFyZ2V0Ll8uYWNjZXNzQ2FjaGVba2V5XSA9IDA7XG4gICAgfSBlbHNlIGlmIChoYXNPd24oZGVzY3JpcHRvciwgXCJ2YWx1ZVwiKSkge1xuICAgICAgdGhpcy5zZXQodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IudmFsdWUsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn07XG5pZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0cnVlKSB7XG4gIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5vd25LZXlzID0gKHRhcmdldCkgPT4ge1xuICAgIHdhcm4kMShcbiAgICAgIGBBdm9pZCBhcHAgbG9naWMgdGhhdCByZWxpZXMgb24gZW51bWVyYXRpbmcga2V5cyBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhlIGtleXMgd2lsbCBiZSBlbXB0eSBpbiBwcm9kdWN0aW9uIG1vZGUgdG8gYXZvaWQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuYFxuICAgICk7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICB9O1xufVxuY29uc3QgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIGV4dGVuZCh7fSwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLCB7XG4gIGdldCh0YXJnZXQsIGtleSkge1xuICAgIGlmIChrZXkgPT09IFN5bWJvbC51bnNjb3BhYmxlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmdldCh0YXJnZXQsIGtleSwgdGFyZ2V0KTtcbiAgfSxcbiAgaGFzKF8sIGtleSkge1xuICAgIGNvbnN0IGhhcyA9IGtleVswXSAhPT0gXCJfXCIgJiYgIWlzR2xvYmFsbHlBbGxvd2VkKGtleSk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWhhcyAmJiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuaGFzKF8sIGtleSkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAga2V5XG4gICAgICAgICl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBfIHdoaWNoIGlzIGEgcmVzZXJ2ZWQgcHJlZml4IGZvciBWdWUgaW50ZXJuYWxzLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBoYXM7XG4gIH1cbn0pO1xuZnVuY3Rpb24gY3JlYXRlRGV2UmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgYF9gLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogKCkgPT4gaW5zdGFuY2VcbiAgfSk7XG4gIE9iamVjdC5rZXlzKHB1YmxpY1Byb3BlcnRpZXNNYXApLmZvckVhY2goKGtleSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6ICgpID0+IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSksXG4gICAgICAvLyBpbnRlcmNlcHRlZCBieSB0aGUgcHJveHkgc28gbm8gbmVlZCBmb3IgaW1wbGVtZW50YXRpb24sXG4gICAgICAvLyBidXQgbmVlZGVkIHRvIHByZXZlbnQgc2V0IGVycm9yc1xuICAgICAgc2V0OiBOT09QXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3Qge1xuICAgIGN0eCxcbiAgICBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdXG4gIH0gPSBpbnN0YW5jZTtcbiAgaWYgKHByb3BzT3B0aW9ucykge1xuICAgIE9iamVjdC5rZXlzKHByb3BzT3B0aW9ucykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlLnByb3BzW2tleV0sXG4gICAgICAgIHNldDogTk9PUFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUgfSA9IGluc3RhbmNlO1xuICBPYmplY3Qua2V5cyh0b1JhdyhzZXR1cFN0YXRlKSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKCFzZXR1cFN0YXRlLl9faXNTY3JpcHRTZXR1cCkge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYHNldHVwKCkgcmV0dXJuIHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgICApfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXCIkXCIgb3IgXCJfXCIgd2hpY2ggYXJlIHJlc2VydmVkIHByZWZpeGVzIGZvciBWdWUgaW50ZXJuYWxzLmBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBzZXR1cFN0YXRlW2tleV0sXG4gICAgICAgIHNldDogTk9PUFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3Qgd2FyblJ1bnRpbWVVc2FnZSA9IChtZXRob2QpID0+IHdhcm4kMShcbiAgYCR7bWV0aG9kfSgpIGlzIGEgY29tcGlsZXItaGludCBoZWxwZXIgdGhhdCBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgPHNjcmlwdCBzZXR1cD4gb2YgYSBzaW5nbGUgZmlsZSBjb21wb25lbnQuIEl0cyBhcmd1bWVudHMgc2hvdWxkIGJlIGNvbXBpbGVkIGF3YXkgYW5kIHBhc3NpbmcgaXQgYXQgcnVudGltZSBoYXMgbm8gZWZmZWN0LmBcbik7XG5mdW5jdGlvbiBkZWZpbmVQcm9wcygpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVQcm9wc2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGVmaW5lRW1pdHMoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRW1pdHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZmluZUV4cG9zZShleHBvc2VkKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRXhwb3NlYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZU9wdGlvbnMob3B0aW9ucykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZU9wdGlvbnNgKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lU2xvdHMoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lU2xvdHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZmluZU1vZGVsKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoXCJkZWZpbmVNb2RlbFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gd2l0aERlZmF1bHRzKHByb3BzLCBkZWZhdWx0cykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYHdpdGhEZWZhdWx0c2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdXNlU2xvdHMoKSB7XG4gIHJldHVybiBnZXRDb250ZXh0KCkuc2xvdHM7XG59XG5mdW5jdGlvbiB1c2VBdHRycygpIHtcbiAgcmV0dXJuIGdldENvbnRleHQoKS5hdHRycztcbn1cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWkpIHtcbiAgICB3YXJuJDEoYHVzZUNvbnRleHQoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XG4gIH1cbiAgcmV0dXJuIGkuc2V0dXBDb250ZXh0IHx8IChpLnNldHVwQ29udGV4dCA9IGNyZWF0ZVNldHVwQ29udGV4dChpKSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wc09yRW1pdHMocHJvcHMpIHtcbiAgcmV0dXJuIGlzQXJyYXkocHJvcHMpID8gcHJvcHMucmVkdWNlKFxuICAgIChub3JtYWxpemVkLCBwKSA9PiAobm9ybWFsaXplZFtwXSA9IG51bGwsIG5vcm1hbGl6ZWQpLFxuICAgIHt9XG4gICkgOiBwcm9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMocmF3LCBkZWZhdWx0cykge1xuICBjb25zdCBwcm9wcyA9IG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhyYXcpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0cykge1xuICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIl9fc2tpcFwiKSkgY29udGludWU7XG4gICAgbGV0IG9wdCA9IHByb3BzW2tleV07XG4gICAgaWYgKG9wdCkge1xuICAgICAgaWYgKGlzQXJyYXkob3B0KSB8fCBpc0Z1bmN0aW9uKG9wdCkpIHtcbiAgICAgICAgb3B0ID0gcHJvcHNba2V5XSA9IHsgdHlwZTogb3B0LCBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHQuZGVmYXVsdCA9IGRlZmF1bHRzW2tleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHQgPT09IG51bGwpIHtcbiAgICAgIG9wdCA9IHByb3BzW2tleV0gPSB7IGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4kMShgcHJvcHMgZGVmYXVsdCBrZXkgXCIke2tleX1cIiBoYXMgbm8gY29ycmVzcG9uZGluZyBkZWNsYXJhdGlvbi5gKTtcbiAgICB9XG4gICAgaWYgKG9wdCAmJiBkZWZhdWx0c1tgX19za2lwXyR7a2V5fWBdKSB7XG4gICAgICBvcHQuc2tpcEZhY3RvcnkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcHM7XG59XG5mdW5jdGlvbiBtZXJnZU1vZGVscyhhLCBiKSB7XG4gIGlmICghYSB8fCAhYikgcmV0dXJuIGEgfHwgYjtcbiAgaWYgKGlzQXJyYXkoYSkgJiYgaXNBcnJheShiKSkgcmV0dXJuIGEuY29uY2F0KGIpO1xuICByZXR1cm4gZXh0ZW5kKHt9LCBub3JtYWxpemVQcm9wc09yRW1pdHMoYSksIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhiKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9wc1Jlc3RQcm94eShwcm9wcywgZXhjbHVkZWRLZXlzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgIGlmICghZXhjbHVkZWRLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXQsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHByb3BzW2tleV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gd2l0aEFzeW5jQ29udGV4dChnZXRBd2FpdGFibGUpIHtcbiAgY29uc3QgY3R4ID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFjdHgpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgd2l0aEFzeW5jQ29udGV4dCBjYWxsZWQgd2l0aG91dCBhY3RpdmUgY3VycmVudCBpbnN0YW5jZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcuYFxuICAgICk7XG4gIH1cbiAgbGV0IGF3YWl0YWJsZSA9IGdldEF3YWl0YWJsZSgpO1xuICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoaXNQcm9taXNlKGF3YWl0YWJsZSkpIHtcbiAgICBhd2FpdGFibGUgPSBhd2FpdGFibGUuY2F0Y2goKGUpID0+IHtcbiAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShjdHgpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gW2F3YWl0YWJsZSwgKCkgPT4gc2V0Q3VycmVudEluc3RhbmNlKGN0eCldO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKHR5cGUsIGtleSkgPT4ge1xuICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICB3YXJuJDEoYCR7dHlwZX0gcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gJHtjYWNoZVtrZXldfS5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVba2V5XSA9IHR5cGU7XG4gICAgfVxuICB9O1xufVxubGV0IHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcbmZ1bmN0aW9uIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSkge1xuICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpO1xuICBjb25zdCBwdWJsaWNUaGlzID0gaW5zdGFuY2UucHJveHk7XG4gIGNvbnN0IGN0eCA9IGluc3RhbmNlLmN0eDtcbiAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSBmYWxzZTtcbiAgaWYgKG9wdGlvbnMuYmVmb3JlQ3JlYXRlKSB7XG4gICAgY2FsbEhvb2sob3B0aW9ucy5iZWZvcmVDcmVhdGUsIGluc3RhbmNlLCBcImJjXCIpO1xuICB9XG4gIGNvbnN0IHtcbiAgICAvLyBzdGF0ZVxuICAgIGRhdGE6IGRhdGFPcHRpb25zLFxuICAgIGNvbXB1dGVkOiBjb21wdXRlZE9wdGlvbnMsXG4gICAgbWV0aG9kcyxcbiAgICB3YXRjaDogd2F0Y2hPcHRpb25zLFxuICAgIHByb3ZpZGU6IHByb3ZpZGVPcHRpb25zLFxuICAgIGluamVjdDogaW5qZWN0T3B0aW9ucyxcbiAgICAvLyBsaWZlY3ljbGVcbiAgICBjcmVhdGVkLFxuICAgIGJlZm9yZU1vdW50LFxuICAgIG1vdW50ZWQsXG4gICAgYmVmb3JlVXBkYXRlLFxuICAgIHVwZGF0ZWQsXG4gICAgYWN0aXZhdGVkLFxuICAgIGRlYWN0aXZhdGVkLFxuICAgIGJlZm9yZURlc3Ryb3ksXG4gICAgYmVmb3JlVW5tb3VudCxcbiAgICBkZXN0cm95ZWQsXG4gICAgdW5tb3VudGVkLFxuICAgIHJlbmRlcixcbiAgICByZW5kZXJUcmFja2VkLFxuICAgIHJlbmRlclRyaWdnZXJlZCxcbiAgICBlcnJvckNhcHR1cmVkLFxuICAgIHNlcnZlclByZWZldGNoLFxuICAgIC8vIHB1YmxpYyBBUElcbiAgICBleHBvc2UsXG4gICAgaW5oZXJpdEF0dHJzLFxuICAgIC8vIGFzc2V0c1xuICAgIGNvbXBvbmVudHMsXG4gICAgZGlyZWN0aXZlcyxcbiAgICBmaWx0ZXJzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIDogbnVsbDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBbcHJvcHNPcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgICBpZiAocHJvcHNPcHRpb25zKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wc09wdGlvbnMpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiUHJvcHNcIiAvKiBQUk9QUyAqLywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGluamVjdE9wdGlvbnMpIHtcbiAgICByZXNvbHZlSW5qZWN0aW9ucyhpbmplY3RPcHRpb25zLCBjdHgsIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyk7XG4gIH1cbiAgaWYgKG1ldGhvZHMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBjb25zdCBtZXRob2RIYW5kbGVyID0gbWV0aG9kc1trZXldO1xuICAgICAgaWYgKGlzRnVuY3Rpb24obWV0aG9kSGFuZGxlcikpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyksXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHhba2V5XSA9IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIk1ldGhvZHNcIiAvKiBNRVRIT0RTICovLCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBNZXRob2QgXCIke2tleX1cIiBoYXMgdHlwZSBcIiR7dHlwZW9mIG1ldGhvZEhhbmRsZXJ9XCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P2BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGRhdGFPcHRpb25zKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRnVuY3Rpb24oZGF0YU9wdGlvbnMpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBUaGUgZGF0YSBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uLiBQbGFpbiBvYmplY3QgdXNhZ2UgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC5gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gZGF0YU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc1Byb21pc2UoZGF0YSkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYGRhdGEoKSByZXR1cm5lZCBhIFByb21pc2UgLSBub3RlIGRhdGEoKSBjYW5ub3QgYmUgYXN5bmM7IElmIHlvdSBpbnRlbmQgdG8gcGVyZm9ybSBkYXRhIGZldGNoaW5nIGJlZm9yZSBjb21wb25lbnQgcmVuZGVycywgdXNlIGFzeW5jIHNldHVwKCkgKyA8U3VzcGVuc2U+LmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKGBkYXRhKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLmRhdGEgPSByZWFjdGl2ZShkYXRhKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJEYXRhXCIgLyogREFUQSAqLywga2V5KTtcbiAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBkYXRhW2tleV0sXG4gICAgICAgICAgICAgIHNldDogTk9PUFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcbiAgaWYgKGNvbXB1dGVkT3B0aW9ucykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkT3B0aW9ucykge1xuICAgICAgY29uc3Qgb3B0ID0gY29tcHV0ZWRPcHRpb25zW2tleV07XG4gICAgICBjb25zdCBnZXQgPSBpc0Z1bmN0aW9uKG9wdCkgPyBvcHQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKSA6IGlzRnVuY3Rpb24ob3B0LmdldCkgPyBvcHQuZ2V0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcykgOiBOT09QO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgZ2V0ID09PSBOT09QKSB7XG4gICAgICAgIHdhcm4kMShgQ29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBoYXMgbm8gZ2V0dGVyLmApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2V0ID0gIWlzRnVuY3Rpb24ob3B0KSAmJiBpc0Z1bmN0aW9uKG9wdC5zZXQpID8gb3B0LnNldC5iaW5kKHB1YmxpY1RoaXMpIDogISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/ICgpID0+IHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIHJlYWRvbmx5LmBcbiAgICAgICAgKTtcbiAgICAgIH0gOiBOT09QO1xuICAgICAgY29uc3QgYyA9IGNvbXB1dGVkKHtcbiAgICAgICAgZ2V0LFxuICAgICAgICBzZXRcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBjLnZhbHVlLFxuICAgICAgICBzZXQ6ICh2KSA9PiBjLnZhbHVlID0gdlxuICAgICAgfSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJDb21wdXRlZFwiIC8qIENPTVBVVEVEICovLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAod2F0Y2hPcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gd2F0Y2hPcHRpb25zKSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHdhdGNoT3B0aW9uc1trZXldLCBjdHgsIHB1YmxpY1RoaXMsIGtleSk7XG4gICAgfVxuICB9XG4gIGlmIChwcm92aWRlT3B0aW9ucykge1xuICAgIGNvbnN0IHByb3ZpZGVzID0gaXNGdW5jdGlvbihwcm92aWRlT3B0aW9ucykgPyBwcm92aWRlT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMpIDogcHJvdmlkZU9wdGlvbnM7XG4gICAgUmVmbGVjdC5vd25LZXlzKHByb3ZpZGVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHByb3ZpZGUoa2V5LCBwcm92aWRlc1trZXldKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoY3JlYXRlZCkge1xuICAgIGNhbGxIb29rKGNyZWF0ZWQsIGluc3RhbmNlLCBcImNcIik7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJMaWZlY3ljbGVIb29rKHJlZ2lzdGVyLCBob29rKSB7XG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICAgIGhvb2suZm9yRWFjaCgoX2hvb2spID0+IHJlZ2lzdGVyKF9ob29rLmJpbmQocHVibGljVGhpcykpKTtcbiAgICB9IGVsc2UgaWYgKGhvb2spIHtcbiAgICAgIHJlZ2lzdGVyKGhvb2suYmluZChwdWJsaWNUaGlzKSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZU1vdW50LCBiZWZvcmVNb3VudCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbk1vdW50ZWQsIG1vdW50ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVcGRhdGUsIGJlZm9yZVVwZGF0ZSk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVwZGF0ZWQsIHVwZGF0ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25BY3RpdmF0ZWQsIGFjdGl2YXRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkRlYWN0aXZhdGVkLCBkZWFjdGl2YXRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkVycm9yQ2FwdHVyZWQsIGVycm9yQ2FwdHVyZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmFja2VkLCByZW5kZXJUcmFja2VkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJpZ2dlcmVkLCByZW5kZXJUcmlnZ2VyZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVbm1vdW50LCBiZWZvcmVVbm1vdW50KTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uVW5tb3VudGVkLCB1bm1vdW50ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25TZXJ2ZXJQcmVmZXRjaCwgc2VydmVyUHJlZmV0Y2gpO1xuICBpZiAoaXNBcnJheShleHBvc2UpKSB7XG4gICAgaWYgKGV4cG9zZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGV4cG9zZWQgPSBpbnN0YW5jZS5leHBvc2VkIHx8IChpbnN0YW5jZS5leHBvc2VkID0ge30pO1xuICAgICAgZXhwb3NlLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3NlZCwga2V5LCB7XG4gICAgICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNUaGlzW2tleV0sXG4gICAgICAgICAgc2V0OiAodmFsKSA9PiBwdWJsaWNUaGlzW2tleV0gPSB2YWxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgICBpbnN0YW5jZS5leHBvc2VkID0ge307XG4gICAgfVxuICB9XG4gIGlmIChyZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QKSB7XG4gICAgaW5zdGFuY2UucmVuZGVyID0gcmVuZGVyO1xuICB9XG4gIGlmIChpbmhlcml0QXR0cnMgIT0gbnVsbCkge1xuICAgIGluc3RhbmNlLmluaGVyaXRBdHRycyA9IGluaGVyaXRBdHRycztcbiAgfVxuICBpZiAoY29tcG9uZW50cykgaW5zdGFuY2UuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gIGlmIChkaXJlY3RpdmVzKSBpbnN0YW5jZS5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgaWYgKHNlcnZlclByZWZldGNoKSB7XG4gICAgbWFya0FzeW5jQm91bmRhcnkoaW5zdGFuY2UpO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0aW9ucyhpbmplY3RPcHRpb25zLCBjdHgsIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9IE5PT1ApIHtcbiAgaWYgKGlzQXJyYXkoaW5qZWN0T3B0aW9ucykpIHtcbiAgICBpbmplY3RPcHRpb25zID0gbm9ybWFsaXplSW5qZWN0KGluamVjdE9wdGlvbnMpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGluamVjdE9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHQgPSBpbmplY3RPcHRpb25zW2tleV07XG4gICAgbGV0IGluamVjdGVkO1xuICAgIGlmIChpc09iamVjdChvcHQpKSB7XG4gICAgICBpZiAoXCJkZWZhdWx0XCIgaW4gb3B0KSB7XG4gICAgICAgIGluamVjdGVkID0gaW5qZWN0KFxuICAgICAgICAgIG9wdC5mcm9tIHx8IGtleSxcbiAgICAgICAgICBvcHQuZGVmYXVsdCxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQuZnJvbSB8fCBrZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmplY3RlZCA9IGluamVjdChvcHQpO1xuICAgIH1cbiAgICBpZiAoaXNSZWYoaW5qZWN0ZWQpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGluamVjdGVkLnZhbHVlLFxuICAgICAgICBzZXQ6ICh2KSA9PiBpbmplY3RlZC52YWx1ZSA9IHZcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHhba2V5XSA9IGluamVjdGVkO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiSW5qZWN0XCIgLyogSU5KRUNUICovLCBrZXkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2FsbEhvb2soaG9vaywgaW5zdGFuY2UsIHR5cGUpIHtcbiAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgaXNBcnJheShob29rKSA/IGhvb2subWFwKChoKSA9PiBoLmJpbmQoaW5zdGFuY2UucHJveHkpKSA6IGhvb2suYmluZChpbnN0YW5jZS5wcm94eSksXG4gICAgaW5zdGFuY2UsXG4gICAgdHlwZVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlcihyYXcsIGN0eCwgcHVibGljVGhpcywga2V5KSB7XG4gIGxldCBnZXR0ZXIgPSBrZXkuaW5jbHVkZXMoXCIuXCIpID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBrZXkpIDogKCkgPT4gcHVibGljVGhpc1trZXldO1xuICBpZiAoaXNTdHJpbmcocmF3KSkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBjdHhbcmF3XTtcbiAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAge1xuICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3fVwiYCwgaGFuZGxlcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocmF3KSkge1xuICAgIHtcbiAgICAgIHdhdGNoKGdldHRlciwgcmF3LmJpbmQocHVibGljVGhpcykpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChyYXcpKSB7XG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgICAgcmF3LmZvckVhY2goKHIpID0+IGNyZWF0ZVdhdGNoZXIociwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGlzRnVuY3Rpb24ocmF3LmhhbmRsZXIpID8gcmF3LmhhbmRsZXIuYmluZChwdWJsaWNUaGlzKSA6IGN0eFtyYXcuaGFuZGxlcl07XG4gICAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIsIHJhdyk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgd2FybiQxKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3LmhhbmRsZXJ9XCJgLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShgSW52YWxpZCB3YXRjaCBvcHRpb246IFwiJHtrZXl9XCJgLCByYXcpO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkge1xuICBjb25zdCBiYXNlID0gaW5zdGFuY2UudHlwZTtcbiAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBiYXNlO1xuICBjb25zdCB7XG4gICAgbWl4aW5zOiBnbG9iYWxNaXhpbnMsXG4gICAgb3B0aW9uc0NhY2hlOiBjYWNoZSxcbiAgICBjb25maWc6IHsgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzIH1cbiAgfSA9IGluc3RhbmNlLmFwcENvbnRleHQ7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChiYXNlKTtcbiAgbGV0IHJlc29sdmVkO1xuICBpZiAoY2FjaGVkKSB7XG4gICAgcmVzb2x2ZWQgPSBjYWNoZWQ7XG4gIH0gZWxzZSBpZiAoIWdsb2JhbE1peGlucy5sZW5ndGggJiYgIW1peGlucyAmJiAhZXh0ZW5kc09wdGlvbnMpIHtcbiAgICB7XG4gICAgICByZXNvbHZlZCA9IGJhc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc29sdmVkID0ge307XG4gICAgaWYgKGdsb2JhbE1peGlucy5sZW5ndGgpIHtcbiAgICAgIGdsb2JhbE1peGlucy5mb3JFYWNoKFxuICAgICAgICAobSkgPT4gbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBtLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMsIHRydWUpXG4gICAgICApO1xuICAgIH1cbiAgICBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIGJhc2UsIG9wdGlvbk1lcmdlU3RyYXRlZ2llcyk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGJhc2UpKSB7XG4gICAgY2FjaGUuc2V0KGJhc2UsIHJlc29sdmVkKTtcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG5mdW5jdGlvbiBtZXJnZU9wdGlvbnModG8sIGZyb20sIHN0cmF0cywgYXNNaXhpbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gZnJvbTtcbiAgaWYgKGV4dGVuZHNPcHRpb25zKSB7XG4gICAgbWVyZ2VPcHRpb25zKHRvLCBleHRlbmRzT3B0aW9ucywgc3RyYXRzLCB0cnVlKTtcbiAgfVxuICBpZiAobWl4aW5zKSB7XG4gICAgbWl4aW5zLmZvckVhY2goXG4gICAgICAobSkgPT4gbWVyZ2VPcHRpb25zKHRvLCBtLCBzdHJhdHMsIHRydWUpXG4gICAgKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgaWYgKGFzTWl4aW4gJiYga2V5ID09PSBcImV4cG9zZVwiKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShcbiAgICAgICAgYFwiZXhwb3NlXCIgb3B0aW9uIGlzIGlnbm9yZWQgd2hlbiBkZWNsYXJlZCBpbiBtaXhpbnMgb3IgZXh0ZW5kcy4gSXQgc2hvdWxkIG9ubHkgYmUgZGVjbGFyZWQgaW4gdGhlIGJhc2UgY29tcG9uZW50IGl0c2VsZi5gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHJhdCA9IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHNba2V5XSB8fCBzdHJhdHMgJiYgc3RyYXRzW2tleV07XG4gICAgICB0b1trZXldID0gc3RyYXQgPyBzdHJhdCh0b1trZXldLCBmcm9tW2tleV0pIDogZnJvbVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5jb25zdCBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzID0ge1xuICBkYXRhOiBtZXJnZURhdGFGbixcbiAgcHJvcHM6IG1lcmdlRW1pdHNPclByb3BzT3B0aW9ucyxcbiAgZW1pdHM6IG1lcmdlRW1pdHNPclByb3BzT3B0aW9ucyxcbiAgLy8gb2JqZWN0c1xuICBtZXRob2RzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIGNvbXB1dGVkOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIC8vIGxpZmVjeWNsZVxuICBiZWZvcmVDcmVhdGU6IG1lcmdlQXNBcnJheSxcbiAgY3JlYXRlZDogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVNb3VudDogbWVyZ2VBc0FycmF5LFxuICBtb3VudGVkOiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZVVwZGF0ZTogbWVyZ2VBc0FycmF5LFxuICB1cGRhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZURlc3Ryb3k6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlVW5tb3VudDogbWVyZ2VBc0FycmF5LFxuICBkZXN0cm95ZWQ6IG1lcmdlQXNBcnJheSxcbiAgdW5tb3VudGVkOiBtZXJnZUFzQXJyYXksXG4gIGFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxuICBkZWFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxuICBlcnJvckNhcHR1cmVkOiBtZXJnZUFzQXJyYXksXG4gIHNlcnZlclByZWZldGNoOiBtZXJnZUFzQXJyYXksXG4gIC8vIGFzc2V0c1xuICBjb21wb25lbnRzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIGRpcmVjdGl2ZXM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgLy8gd2F0Y2hcbiAgd2F0Y2g6IG1lcmdlV2F0Y2hPcHRpb25zLFxuICAvLyBwcm92aWRlIC8gaW5qZWN0XG4gIHByb3ZpZGU6IG1lcmdlRGF0YUZuLFxuICBpbmplY3Q6IG1lcmdlSW5qZWN0XG59O1xuZnVuY3Rpb24gbWVyZ2VEYXRhRm4odG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7XG4gICAgcmV0dXJuIHRvO1xuICB9XG4gIGlmICghdG8pIHtcbiAgICByZXR1cm4gZnJvbTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xuICAgIHJldHVybiAoZXh0ZW5kKShcbiAgICAgIGlzRnVuY3Rpb24odG8pID8gdG8uY2FsbCh0aGlzLCB0aGlzKSA6IHRvLFxuICAgICAgaXNGdW5jdGlvbihmcm9tKSA/IGZyb20uY2FsbCh0aGlzLCB0aGlzKSA6IGZyb21cbiAgICApO1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VJbmplY3QodG8sIGZyb20pIHtcbiAgcmV0dXJuIG1lcmdlT2JqZWN0T3B0aW9ucyhub3JtYWxpemVJbmplY3QodG8pLCBub3JtYWxpemVJbmplY3QoZnJvbSkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0KHJhdykge1xuICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tyYXdbaV1dID0gcmF3W2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHJldHVybiByYXc7XG59XG5mdW5jdGlvbiBtZXJnZUFzQXJyYXkodG8sIGZyb20pIHtcbiAgcmV0dXJuIHRvID8gWy4uLm5ldyBTZXQoW10uY29uY2F0KHRvLCBmcm9tKSldIDogZnJvbTtcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0T3B0aW9ucyh0bywgZnJvbSkge1xuICByZXR1cm4gdG8gPyBleHRlbmQoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRvLCBmcm9tKSA6IGZyb207XG59XG5mdW5jdGlvbiBtZXJnZUVtaXRzT3JQcm9wc09wdGlvbnModG8sIGZyb20pIHtcbiAgaWYgKHRvKSB7XG4gICAgaWYgKGlzQXJyYXkodG8pICYmIGlzQXJyYXkoZnJvbSkpIHtcbiAgICAgIHJldHVybiBbLi4uLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLnRvLCAuLi5mcm9tXSldO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5kKFxuICAgICAgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBub3JtYWxpemVQcm9wc09yRW1pdHModG8pLFxuICAgICAgbm9ybWFsaXplUHJvcHNPckVtaXRzKGZyb20gIT0gbnVsbCA/IGZyb20gOiB7fSlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcm9tO1xuICB9XG59XG5mdW5jdGlvbiBtZXJnZVdhdGNoT3B0aW9ucyh0bywgZnJvbSkge1xuICBpZiAoIXRvKSByZXR1cm4gZnJvbTtcbiAgaWYgKCFmcm9tKSByZXR1cm4gdG87XG4gIGNvbnN0IG1lcmdlZCA9IGV4dGVuZCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8pO1xuICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgbWVyZ2VkW2tleV0gPSBtZXJnZUFzQXJyYXkodG9ba2V5XSwgZnJvbVtrZXldKTtcbiAgfVxuICByZXR1cm4gbWVyZ2VkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcHBDb250ZXh0KCkge1xuICByZXR1cm4ge1xuICAgIGFwcDogbnVsbCxcbiAgICBjb25maWc6IHtcbiAgICAgIGlzTmF0aXZlVGFnOiBOTyxcbiAgICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcbiAgICAgIGdsb2JhbFByb3BlcnRpZXM6IHt9LFxuICAgICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiB7fSxcbiAgICAgIGVycm9ySGFuZGxlcjogdm9pZCAwLFxuICAgICAgd2FybkhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIGNvbXBpbGVyT3B0aW9uczoge31cbiAgICB9LFxuICAgIG1peGluczogW10sXG4gICAgY29tcG9uZW50czoge30sXG4gICAgZGlyZWN0aXZlczoge30sXG4gICAgcHJvdmlkZXM6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIG9wdGlvbnNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksXG4gICAgcHJvcHNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksXG4gICAgZW1pdHNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKClcbiAgfTtcbn1cbmxldCB1aWQkMSA9IDA7XG5mdW5jdGlvbiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcHAocm9vdENvbXBvbmVudCwgcm9vdFByb3BzID0gbnVsbCkge1xuICAgIGlmICghaXNGdW5jdGlvbihyb290Q29tcG9uZW50KSkge1xuICAgICAgcm9vdENvbXBvbmVudCA9IGV4dGVuZCh7fSwgcm9vdENvbXBvbmVudCk7XG4gICAgfVxuICAgIGlmIChyb290UHJvcHMgIT0gbnVsbCAmJiAhaXNPYmplY3Qocm9vdFByb3BzKSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYHJvb3QgcHJvcHMgcGFzc2VkIHRvIGFwcC5tb3VudCgpIG11c3QgYmUgYW4gb2JqZWN0LmApO1xuICAgICAgcm9vdFByb3BzID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcbiAgICBjb25zdCBpbnN0YWxsZWRQbHVnaW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgY29uc3QgcGx1Z2luQ2xlYW51cEZucyA9IFtdO1xuICAgIGxldCBpc01vdW50ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBhcHAgPSBjb250ZXh0LmFwcCA9IHtcbiAgICAgIF91aWQ6IHVpZCQxKyssXG4gICAgICBfY29tcG9uZW50OiByb290Q29tcG9uZW50LFxuICAgICAgX3Byb3BzOiByb290UHJvcHMsXG4gICAgICBfY29udGFpbmVyOiBudWxsLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfaW5zdGFuY2U6IG51bGwsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgZ2V0IGNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uZmlnO1xuICAgICAgfSxcbiAgICAgIHNldCBjb25maWcodikge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBhcHAuY29uZmlnIGNhbm5vdCBiZSByZXBsYWNlZC4gTW9kaWZ5IGluZGl2aWR1YWwgb3B0aW9ucyBpbnN0ZWFkLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlKHBsdWdpbiwgLi4ub3B0aW9ucykge1xuICAgICAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5oYXMocGx1Z2luKSkge1xuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKGBQbHVnaW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHAuYCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGx1Z2luICYmIGlzRnVuY3Rpb24ocGx1Z2luLmluc3RhbGwpKSB7XG4gICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcbiAgICAgICAgICBwbHVnaW4uaW5zdGFsbChhcHAsIC4uLm9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocGx1Z2luKSkge1xuICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XG4gICAgICAgICAgcGx1Z2luKGFwcCwgLi4ub3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBBIHBsdWdpbiBtdXN0IGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCB3aXRoIGFuIFwiaW5zdGFsbFwiIGZ1bmN0aW9uLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgbWl4aW4obWl4aW4pIHtcbiAgICAgICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18pIHtcbiAgICAgICAgICBpZiAoIWNvbnRleHQubWl4aW5zLmluY2x1ZGVzKG1peGluKSkge1xuICAgICAgICAgICAgY29udGV4dC5taXhpbnMucHVzaChtaXhpbik7XG4gICAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIFwiTWl4aW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHBcIiArIChtaXhpbi5uYW1lID8gYDogJHttaXhpbi5uYW1lfWAgOiBcIlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcIk1peGlucyBhcmUgb25seSBhdmFpbGFibGUgaW4gYnVpbGRzIHN1cHBvcnRpbmcgT3B0aW9ucyBBUElcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBjb21wb25lbnQobmFtZSwgY29tcG9uZW50KSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIGNvbnRleHQuY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29udGV4dC5jb21wb25lbnRzW25hbWVdKSB7XG4gICAgICAgICAgd2FybiQxKGBDb21wb25lbnQgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jb21wb25lbnRzW25hbWVdID0gY29tcG9uZW50O1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIGRpcmVjdGl2ZShuYW1lLCBkaXJlY3RpdmUpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkaXJlY3RpdmUpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXJlY3RpdmVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSkge1xuICAgICAgICAgIHdhcm4kMShgRGlyZWN0aXZlIFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBtb3VudChyb290Q29udGFpbmVyLCBpc0h5ZHJhdGUsIG5hbWVzcGFjZSkge1xuICAgICAgICBpZiAoIWlzTW91bnRlZCkge1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHJvb3RDb250YWluZXIuX192dWVfYXBwX18pIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgYFRoZXJlIGlzIGFscmVhZHkgYW4gYXBwIGluc3RhbmNlIG1vdW50ZWQgb24gdGhlIGhvc3QgY29udGFpbmVyLlxuIElmIHlvdSB3YW50IHRvIG1vdW50IGFub3RoZXIgYXBwIG9uIHRoZSBzYW1lIGhvc3QgY29udGFpbmVyLCB5b3UgbmVlZCB0byB1bm1vdW50IHRoZSBwcmV2aW91cyBhcHAgYnkgY2FsbGluZyBcXGBhcHAudW5tb3VudCgpXFxgIGZpcnN0LmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHZub2RlID0gYXBwLl9jZVZOb2RlIHx8IGNyZWF0ZVZOb2RlKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyk7XG4gICAgICAgICAgdm5vZGUuYXBwQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gXCJzdmdcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbWVzcGFjZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIGNvbnRleHQucmVsb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICByZW5kZXIoXG4gICAgICAgICAgICAgICAgY2xvbmVWTm9kZSh2bm9kZSksXG4gICAgICAgICAgICAgICAgcm9vdENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0h5ZHJhdGUgJiYgaHlkcmF0ZSkge1xuICAgICAgICAgICAgaHlkcmF0ZSh2bm9kZSwgcm9vdENvbnRhaW5lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlcih2bm9kZSwgcm9vdENvbnRhaW5lciwgbmFtZXNwYWNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICBhcHAuX2NvbnRhaW5lciA9IHJvb3RDb250YWluZXI7XG4gICAgICAgICAgcm9vdENvbnRhaW5lci5fX3Z1ZV9hcHBfXyA9IGFwcDtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgIGFwcC5faW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICAgICAgICBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKHZub2RlLmNvbXBvbmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBBcHAgaGFzIGFscmVhZHkgYmVlbiBtb3VudGVkLlxuSWYgeW91IHdhbnQgdG8gcmVtb3VudCB0aGUgc2FtZSBhcHAsIG1vdmUgeW91ciBhcHAgY3JlYXRpb24gbG9naWMgaW50byBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIGNyZWF0ZSBmcmVzaCBhcHAgaW5zdGFuY2VzIGZvciBlYWNoIG1vdW50IC0gZS5nLiBcXGBjb25zdCBjcmVhdGVNeUFwcCA9ICgpID0+IGNyZWF0ZUFwcChBcHApXFxgYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblVubW91bnQoY2xlYW51cEZuKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHR5cGVvZiBjbGVhbnVwRm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBFeHBlY3RlZCBmdW5jdGlvbiBhcyBmaXJzdCBhcmd1bWVudCB0byBhcHAub25Vbm1vdW50KCksIGJ1dCBnb3QgJHt0eXBlb2YgY2xlYW51cEZufWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHBsdWdpbkNsZWFudXBGbnMucHVzaChjbGVhbnVwRm4pO1xuICAgICAgfSxcbiAgICAgIHVubW91bnQoKSB7XG4gICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgICAgICAgIHBsdWdpbkNsZWFudXBGbnMsXG4gICAgICAgICAgICBhcHAuX2luc3RhbmNlLFxuICAgICAgICAgICAgMTZcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlbmRlcihudWxsLCBhcHAuX2NvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIGRldnRvb2xzVW5tb3VudEFwcChhcHApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgYXBwLl9jb250YWluZXIuX192dWVfYXBwX187XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShgQ2Fubm90IHVubW91bnQgYW4gYXBwIHRoYXQgaXMgbm90IG1vdW50ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5IGluIGNvbnRleHQucHJvdmlkZXMpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgQXBwIGFscmVhZHkgcHJvdmlkZXMgcHJvcGVydHkgd2l0aCBrZXkgXCIke1N0cmluZyhrZXkpfVwiLiBJdCB3aWxsIGJlIG92ZXJ3cml0dGVuIHdpdGggdGhlIG5ldyB2YWx1ZS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBydW5XaXRoQ29udGV4dChmbikge1xuICAgICAgICBjb25zdCBsYXN0QXBwID0gY3VycmVudEFwcDtcbiAgICAgICAgY3VycmVudEFwcCA9IGFwcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBjdXJyZW50QXBwID0gbGFzdEFwcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFwcDtcbiAgfTtcbn1cbmxldCBjdXJyZW50QXBwID0gbnVsbDtcblxuZnVuY3Rpb24gcHJvdmlkZShrZXksIHZhbHVlKSB7XG4gIGlmICghY3VycmVudEluc3RhbmNlKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4kMShgcHJvdmlkZSgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkuYCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBwcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wcm92aWRlcztcbiAgICBjb25zdCBwYXJlbnRQcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQgJiYgY3VycmVudEluc3RhbmNlLnBhcmVudC5wcm92aWRlcztcbiAgICBpZiAocGFyZW50UHJvdmlkZXMgPT09IHByb3ZpZGVzKSB7XG4gICAgICBwcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wcm92aWRlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50UHJvdmlkZXMpO1xuICAgIH1cbiAgICBwcm92aWRlc1trZXldID0gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGluamVjdChrZXksIGRlZmF1bHRWYWx1ZSwgdHJlYXREZWZhdWx0QXNGYWN0b3J5ID0gZmFsc2UpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBpZiAoaW5zdGFuY2UgfHwgY3VycmVudEFwcCkge1xuICAgIGNvbnN0IHByb3ZpZGVzID0gY3VycmVudEFwcCA/IGN1cnJlbnRBcHAuX2NvbnRleHQucHJvdmlkZXMgOiBpbnN0YW5jZSA/IGluc3RhbmNlLnBhcmVudCA9PSBudWxsID8gaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dCAmJiBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0LnByb3ZpZGVzIDogaW5zdGFuY2UucGFyZW50LnByb3ZpZGVzIDogdm9pZCAwO1xuICAgIGlmIChwcm92aWRlcyAmJiBrZXkgaW4gcHJvdmlkZXMpIHtcbiAgICAgIHJldHVybiBwcm92aWRlc1trZXldO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlLmNhbGwoaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHkpIDogZGVmYXVsdFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKGBpbmplY3Rpb24gXCIke1N0cmluZyhrZXkpfVwiIG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShgaW5qZWN0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKSBvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMuYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc0luamVjdGlvbkNvbnRleHQoKSB7XG4gIHJldHVybiAhIShjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIHx8IGN1cnJlbnRBcHApO1xufVxuXG5jb25zdCBpbnRlcm5hbE9iamVjdFByb3RvID0ge307XG5jb25zdCBjcmVhdGVJbnRlcm5hbE9iamVjdCA9ICgpID0+IE9iamVjdC5jcmVhdGUoaW50ZXJuYWxPYmplY3RQcm90byk7XG5jb25zdCBpc0ludGVybmFsT2JqZWN0ID0gKG9iaikgPT4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IGludGVybmFsT2JqZWN0UHJvdG87XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSID0gZmFsc2UpIHtcbiAgY29uc3QgcHJvcHMgPSB7fTtcbiAgY29uc3QgYXR0cnMgPSBjcmVhdGVJbnRlcm5hbE9iamVjdCgpO1xuICBpbnN0YW5jZS5wcm9wc0RlZmF1bHRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycyk7XG4gIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkge1xuICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgfVxuICBpZiAoaXNTdGF0ZWZ1bCkge1xuICAgIGluc3RhbmNlLnByb3BzID0gaXNTU1IgPyBwcm9wcyA6IHNoYWxsb3dSZWFjdGl2ZShwcm9wcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpbnN0YW5jZS50eXBlLnByb3BzKSB7XG4gICAgICBpbnN0YW5jZS5wcm9wcyA9IGF0dHJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xuICAgIH1cbiAgfVxuICBpbnN0YW5jZS5hdHRycyA9IGF0dHJzO1xufVxuZnVuY3Rpb24gaXNJbkhtckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgd2hpbGUgKGluc3RhbmNlKSB7XG4gICAgaWYgKGluc3RhbmNlLnR5cGUuX19obXJJZCkgcmV0dXJuIHRydWU7XG4gICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcmF3UHJldlByb3BzLCBvcHRpbWl6ZWQpIHtcbiAgY29uc3Qge1xuICAgIHByb3BzLFxuICAgIGF0dHJzLFxuICAgIHZub2RlOiB7IHBhdGNoRmxhZyB9XG4gIH0gPSBpbnN0YW5jZTtcbiAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xuICBjb25zdCBbb3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gIGxldCBoYXNBdHRyc0NoYW5nZWQgPSBmYWxzZTtcbiAgaWYgKFxuICAgIC8vIGFsd2F5cyBmb3JjZSBmdWxsIGRpZmYgaW4gZGV2XG4gICAgLy8gLSAjMTk0MiBpZiBobXIgaXMgZW5hYmxlZCB3aXRoIHNmYyBjb21wb25lbnRcbiAgICAvLyAtIHZpdGUjODcyIG5vbi1zZmMgY29tcG9uZW50IHVzZWQgYnkgc2ZjIGNvbXBvbmVudFxuICAgICEoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0luSG1yQ29udGV4dChpbnN0YW5jZSkpICYmIChvcHRpbWl6ZWQgfHwgcGF0Y2hGbGFnID4gMCkgJiYgIShwYXRjaEZsYWcgJiAxNilcbiAgKSB7XG4gICAgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBpbnN0YW5jZS52bm9kZS5keW5hbWljUHJvcHM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XG4gICAgICAgIGlmIChpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGhhc093bihhdHRycywga2V5KSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgICAgIHByb3BzW2NhbWVsaXplZEtleV0gPSByZXNvbHZlUHJvcFZhbHVlKFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICByYXdDdXJyZW50UHJvcHMsXG4gICAgICAgICAgICAgIGNhbWVsaXplZEtleSxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSkge1xuICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGtlYmFiS2V5O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgaWYgKCFyYXdQcm9wcyB8fCAvLyBmb3IgY2FtZWxDYXNlXG4gICAgICAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmIC8vIGl0J3MgcG9zc2libGUgdGhlIG9yaWdpbmFsIHByb3BzIHdhcyBwYXNzZWQgaW4gYXMga2ViYWItY2FzZVxuICAgICAgLy8gYW5kIGNvbnZlcnRlZCB0byBjYW1lbENhc2UgKCM5NTUpXG4gICAgICAoKGtlYmFiS2V5ID0gaHlwaGVuYXRlKGtleSkpID09PSBrZXkgfHwgIWhhc093bihyYXdQcm9wcywga2ViYWJLZXkpKSkge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgIGlmIChyYXdQcmV2UHJvcHMgJiYgLy8gZm9yIGNhbWVsQ2FzZVxuICAgICAgICAgIChyYXdQcmV2UHJvcHNba2V5XSAhPT0gdm9pZCAwIHx8IC8vIGZvciBrZWJhYi1jYXNlXG4gICAgICAgICAgcmF3UHJldlByb3BzW2tlYmFiS2V5XSAhPT0gdm9pZCAwKSkge1xuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUoXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIHJhd0N1cnJlbnRQcm9wcyxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXR0cnMgIT09IHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKCFyYXdQcm9wcyB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmIHRydWUpIHtcbiAgICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcbiAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChoYXNBdHRyc0NoYW5nZWQpIHtcbiAgICB0cmlnZ2VyKGluc3RhbmNlLmF0dHJzLCBcInNldFwiLCBcIlwiKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykge1xuICBjb25zdCBbb3B0aW9ucywgbmVlZENhc3RLZXlzXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xuICBsZXQgcmF3Q2FzdFZhbHVlcztcbiAgaWYgKHJhd1Byb3BzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHJhd1Byb3BzKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcbiAgICAgIGxldCBjYW1lbEtleTtcbiAgICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCBjYW1lbEtleSA9IGNhbWVsaXplKGtleSkpKSB7XG4gICAgICAgIGlmICghbmVlZENhc3RLZXlzIHx8ICFuZWVkQ2FzdEtleXMuaW5jbHVkZXMoY2FtZWxLZXkpKSB7XG4gICAgICAgICAgcHJvcHNbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKHJhd0Nhc3RWYWx1ZXMgfHwgKHJhd0Nhc3RWYWx1ZXMgPSB7fSkpW2NhbWVsS2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGF0dHJzKSB8fCB2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xuICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChuZWVkQ2FzdEtleXMpIHtcbiAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgY29uc3QgY2FzdFZhbHVlcyA9IHJhd0Nhc3RWYWx1ZXMgfHwgRU1QVFlfT0JKO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZENhc3RLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBuZWVkQ2FzdEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgcmF3Q3VycmVudFByb3BzLFxuICAgICAgICBrZXksXG4gICAgICAgIGNhc3RWYWx1ZXNba2V5XSxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICFoYXNPd24oY2FzdFZhbHVlcywga2V5KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc0F0dHJzQ2hhbmdlZDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcHJvcHMsIGtleSwgdmFsdWUsIGluc3RhbmNlLCBpc0Fic2VudCkge1xuICBjb25zdCBvcHQgPSBvcHRpb25zW2tleV07XG4gIGlmIChvcHQgIT0gbnVsbCkge1xuICAgIGNvbnN0IGhhc0RlZmF1bHQgPSBoYXNPd24ob3B0LCBcImRlZmF1bHRcIik7XG4gICAgaWYgKGhhc0RlZmF1bHQgJiYgdmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gb3B0LmRlZmF1bHQ7XG4gICAgICBpZiAob3B0LnR5cGUgIT09IEZ1bmN0aW9uICYmICFvcHQuc2tpcEZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHNEZWZhdWx0cyB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGlmIChrZXkgaW4gcHJvcHNEZWZhdWx0cykge1xuICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BzRGVmYXVsdHNba2V5XSA9IGRlZmF1bHRWYWx1ZS5jYWxsKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnN0YW5jZS5jZSkge1xuICAgICAgICBpbnN0YW5jZS5jZS5fc2V0UHJvcChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdFswIC8qIHNob3VsZENhc3QgKi9dKSB7XG4gICAgICBpZiAoaXNBYnNlbnQgJiYgIWhhc0RlZmF1bHQpIHtcbiAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAob3B0WzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dICYmICh2YWx1ZSA9PT0gXCJcIiB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgbWl4aW5Qcm9wc0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wc09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XG4gIGNvbnN0IGNhY2hlID0gX19WVUVfT1BUSU9OU19BUElfXyAmJiBhc01peGluID8gbWl4aW5Qcm9wc0NhY2hlIDogYXBwQ29udGV4dC5wcm9wc0NhY2hlO1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IHJhdyA9IGNvbXAucHJvcHM7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgY29uc3QgbmVlZENhc3RLZXlzID0gW107XG4gIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XG4gIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgY29uc3QgZXh0ZW5kUHJvcHMgPSAocmF3MikgPT4ge1xuICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XG4gICAgICBjb25zdCBbcHJvcHMsIGtleXNdID0gbm9ybWFsaXplUHJvcHNPcHRpb25zKHJhdzIsIGFwcENvbnRleHQsIHRydWUpO1xuICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHByb3BzKTtcbiAgICAgIGlmIChrZXlzKSBuZWVkQ2FzdEtleXMucHVzaCguLi5rZXlzKTtcbiAgICB9O1xuICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcbiAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5leHRlbmRzKSB7XG4gICAgICBleHRlbmRQcm9wcyhjb21wLmV4dGVuZHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5taXhpbnMpIHtcbiAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xuICAgIH1cbiAgfVxuICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xuICAgIGlmIChpc09iamVjdChjb21wKSkge1xuICAgICAgY2FjaGUuc2V0KGNvbXAsIEVNUFRZX0FSUik7XG4gICAgfVxuICAgIHJldHVybiBFTVBUWV9BUlI7XG4gIH1cbiAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNTdHJpbmcocmF3W2ldKSkge1xuICAgICAgICB3YXJuJDEoYHByb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC5gLCByYXdbaV0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKHJhd1tpXSk7XG4gICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xuICAgICAgICBub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID0gRU1QVFlfT0JKO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChyYXcpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNPYmplY3QocmF3KSkge1xuICAgICAgd2FybiQxKGBpbnZhbGlkIHByb3BzIG9wdGlvbnNgLCByYXcpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXcpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcbiAgICAgICAgY29uc3Qgb3B0ID0gcmF3W2tleV07XG4gICAgICAgIGNvbnN0IHByb3AgPSBub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID0gaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSA/IHsgdHlwZTogb3B0IH0gOiBleHRlbmQoe30sIG9wdCk7XG4gICAgICAgIGNvbnN0IHByb3BUeXBlID0gcHJvcC50eXBlO1xuICAgICAgICBsZXQgc2hvdWxkQ2FzdCA9IGZhbHNlO1xuICAgICAgICBsZXQgc2hvdWxkQ2FzdFRydWUgPSB0cnVlO1xuICAgICAgICBpZiAoaXNBcnJheShwcm9wVHlwZSkpIHtcbiAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcHJvcFR5cGUubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gcHJvcFR5cGVbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgdHlwZU5hbWUgPSBpc0Z1bmN0aW9uKHR5cGUpICYmIHR5cGUubmFtZTtcbiAgICAgICAgICAgIGlmICh0eXBlTmFtZSA9PT0gXCJCb29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgc2hvdWxkQ2FzdCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlTmFtZSA9PT0gXCJTdHJpbmdcIikge1xuICAgICAgICAgICAgICBzaG91bGRDYXN0VHJ1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaG91bGRDYXN0ID0gaXNGdW5jdGlvbihwcm9wVHlwZSkgJiYgcHJvcFR5cGUubmFtZSA9PT0gXCJCb29sZWFuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcFswIC8qIHNob3VsZENhc3QgKi9dID0gc2hvdWxkQ2FzdDtcbiAgICAgICAgcHJvcFsxIC8qIHNob3VsZENhc3RUcnVlICovXSA9IHNob3VsZENhc3RUcnVlO1xuICAgICAgICBpZiAoc2hvdWxkQ2FzdCB8fCBoYXNPd24ocHJvcCwgXCJkZWZhdWx0XCIpKSB7XG4gICAgICAgICAgbmVlZENhc3RLZXlzLnB1c2gobm9ybWFsaXplZEtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzID0gW25vcm1hbGl6ZWQsIG5lZWRDYXN0S2V5c107XG4gIGlmIChpc09iamVjdChjb21wKSkge1xuICAgIGNhY2hlLnNldChjb21wLCByZXMpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BOYW1lKGtleSkge1xuICBpZiAoa2V5WzBdICE9PSBcIiRcIiAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoYEludmFsaWQgcHJvcCBuYW1lOiBcIiR7a2V5fVwiIGlzIGEgcmVzZXJ2ZWQgcHJvcGVydHkuYCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0VHlwZShjdG9yKSB7XG4gIGlmIChjdG9yID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9XG4gIGlmICh0eXBlb2YgY3RvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGN0b3IubmFtZSB8fCBcIlwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjdG9yID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc3QgbmFtZSA9IGN0b3IuY29uc3RydWN0b3IgJiYgY3Rvci5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHJldHVybiBuYW1lIHx8IFwiXCI7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzLCBwcm9wcywgaW5zdGFuY2UpIHtcbiAgY29uc3QgcmVzb2x2ZWRWYWx1ZXMgPSB0b1Jhdyhwcm9wcyk7XG4gIGNvbnN0IG9wdGlvbnMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF07XG4gIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICBsZXQgb3B0ID0gb3B0aW9uc1trZXldO1xuICAgIGlmIChvcHQgPT0gbnVsbCkgY29udGludWU7XG4gICAgdmFsaWRhdGVQcm9wKFxuICAgICAga2V5LFxuICAgICAgcmVzb2x2ZWRWYWx1ZXNba2V5XSxcbiAgICAgIG9wdCxcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkocmVzb2x2ZWRWYWx1ZXMpIDogcmVzb2x2ZWRWYWx1ZXMsXG4gICAgICAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmICFoYXNPd24ocmF3UHJvcHMsIGh5cGhlbmF0ZShrZXkpKVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcChuYW1lLCB2YWx1ZSwgcHJvcCwgcHJvcHMsIGlzQWJzZW50KSB7XG4gIGNvbnN0IHsgdHlwZSwgcmVxdWlyZWQsIHZhbGlkYXRvciwgc2tpcENoZWNrIH0gPSBwcm9wO1xuICBpZiAocmVxdWlyZWQgJiYgaXNBYnNlbnQpIHtcbiAgICB3YXJuJDEoJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcmVxdWlyZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGUgIT0gbnVsbCAmJiB0eXBlICE9PSB0cnVlICYmICFza2lwQ2hlY2spIHtcbiAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuICAgIGNvbnN0IHR5cGVzID0gaXNBcnJheSh0eXBlKSA/IHR5cGUgOiBbdHlwZV07XG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoICYmICFpc1ZhbGlkOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgdmFsaWQsIGV4cGVjdGVkVHlwZSB9ID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZXNbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGV4cGVjdGVkVHlwZSB8fCBcIlwiKTtcbiAgICAgIGlzVmFsaWQgPSB2YWxpZDtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB3YXJuJDEoZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmICh2YWxpZGF0b3IgJiYgIXZhbGlkYXRvcih2YWx1ZSwgcHJvcHMpKSB7XG4gICAgd2FybiQxKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyk7XG4gIH1cbn1cbmNvbnN0IGlzU2ltcGxlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBcIlN0cmluZyxOdW1iZXIsQm9vbGVhbixGdW5jdGlvbixTeW1ib2wsQmlnSW50XCJcbik7XG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlKSB7XG4gIGxldCB2YWxpZDtcbiAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJudWxsXCIpIHtcbiAgICB2YWxpZCA9IHZhbHVlID09PSBudWxsO1xuICB9IGVsc2UgaWYgKGlzU2ltcGxlVHlwZShleHBlY3RlZFR5cGUpKSB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJPYmplY3RcIikge1xuICAgIHZhbGlkID0gaXNPYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJBcnJheVwiKSB7XG4gICAgdmFsaWQgPSBpc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBgUHJvcCB0eXBlIFtdIGZvciBwcm9wIFwiJHtuYW1lfVwiIHdvbid0IG1hdGNoIGFueXRoaW5nLiBEaWQgeW91IG1lYW4gdG8gdXNlIHR5cGUgQXJyYXkgaW5zdGVhZD9gO1xuICB9XG4gIGxldCBtZXNzYWdlID0gYEludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCIke25hbWV9XCIuIEV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbihcIiB8IFwiKX1gO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICBjb25zdCByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICBjb25zdCBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcbiAgY29uc3QgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XG4gIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJiBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJiAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYCB3aXRoIHZhbHVlICR7ZXhwZWN0ZWRWYWx1ZX1gO1xuICB9XG4gIG1lc3NhZ2UgKz0gYCwgZ290ICR7cmVjZWl2ZWRUeXBlfSBgO1xuICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IGB3aXRoIHZhbHVlICR7cmVjZWl2ZWRWYWx1ZX0uYDtcbiAgfVxuICByZXR1cm4gbWVzc2FnZTtcbn1cbmZ1bmN0aW9uIHN0eWxlVmFsdWUodmFsdWUsIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09IFwiU3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYFwiJHt2YWx1ZX1cImA7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJOdW1iZXJcIikge1xuICAgIHJldHVybiBgJHtOdW1iZXIodmFsdWUpfWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAke3ZhbHVlfWA7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRXhwbGljYWJsZSh0eXBlKSB7XG4gIGNvbnN0IGV4cGxpY2l0VHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCJdO1xuICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKChlbGVtKSA9PiB0eXBlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW0pO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3Muc29tZSgoZWxlbSkgPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSBcImJvb2xlYW5cIik7XG59XG5cbmNvbnN0IGlzSW50ZXJuYWxLZXkgPSAoa2V5KSA9PiBrZXlbMF0gPT09IFwiX1wiIHx8IGtleSA9PT0gXCIkc3RhYmxlXCI7XG5jb25zdCBub3JtYWxpemVTbG90VmFsdWUgPSAodmFsdWUpID0+IGlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKG5vcm1hbGl6ZVZOb2RlKSA6IFtub3JtYWxpemVWTm9kZSh2YWx1ZSldO1xuY29uc3Qgbm9ybWFsaXplU2xvdCA9IChrZXksIHJhd1Nsb3QsIGN0eCkgPT4ge1xuICBpZiAocmF3U2xvdC5fbikge1xuICAgIHJldHVybiByYXdTbG90O1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB3aXRoQ3R4KCguLi5hcmdzKSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY3VycmVudEluc3RhbmNlICYmICghY3R4IHx8IGN0eC5yb290ID09PSBjdXJyZW50SW5zdGFuY2Uucm9vdCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYFNsb3QgXCIke2tleX1cIiBpbnZva2VkIG91dHNpZGUgb2YgdGhlIHJlbmRlciBmdW5jdGlvbjogdGhpcyB3aWxsIG5vdCB0cmFjayBkZXBlbmRlbmNpZXMgdXNlZCBpbiB0aGUgc2xvdC4gSW52b2tlIHRoZSBzbG90IGZ1bmN0aW9uIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVNsb3RWYWx1ZShyYXdTbG90KC4uLmFyZ3MpKTtcbiAgfSwgY3R4KTtcbiAgbm9ybWFsaXplZC5fYyA9IGZhbHNlO1xuICByZXR1cm4gbm9ybWFsaXplZDtcbn07XG5jb25zdCBub3JtYWxpemVPYmplY3RTbG90cyA9IChyYXdTbG90cywgc2xvdHMsIGluc3RhbmNlKSA9PiB7XG4gIGNvbnN0IGN0eCA9IHJhd1Nsb3RzLl9jdHg7XG4gIGZvciAoY29uc3Qga2V5IGluIHJhd1Nsb3RzKSB7XG4gICAgaWYgKGlzSW50ZXJuYWxLZXkoa2V5KSkgY29udGludWU7XG4gICAgY29uc3QgdmFsdWUgPSByYXdTbG90c1trZXldO1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgc2xvdHNba2V5XSA9IG5vcm1hbGl6ZVNsb3Qoa2V5LCB2YWx1ZSwgY3R4KTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIHNsb3QgXCIke2tleX1cIi4gUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZSh2YWx1ZSk7XG4gICAgICBzbG90c1trZXldID0gKCkgPT4gbm9ybWFsaXplZDtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBub3JtYWxpemVWTm9kZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNLZWVwQWxpdmUoaW5zdGFuY2Uudm5vZGUpICYmIHRydWUpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgTm9uLWZ1bmN0aW9uIHZhbHVlIGVuY291bnRlcmVkIGZvciBkZWZhdWx0IHNsb3QuIFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUoY2hpbGRyZW4pO1xuICBpbnN0YW5jZS5zbG90cy5kZWZhdWx0ID0gKCkgPT4gbm9ybWFsaXplZDtcbn07XG5jb25zdCBhc3NpZ25TbG90cyA9IChzbG90cywgY2hpbGRyZW4sIG9wdGltaXplZCkgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZHJlbikge1xuICAgIGlmIChvcHRpbWl6ZWQgfHwga2V5ICE9PSBcIl9cIikge1xuICAgICAgc2xvdHNba2V5XSA9IGNoaWxkcmVuW2tleV07XG4gICAgfVxuICB9XG59O1xuY29uc3QgaW5pdFNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbiwgb3B0aW1pemVkKSA9PiB7XG4gIGNvbnN0IHNsb3RzID0gaW5zdGFuY2Uuc2xvdHMgPSBjcmVhdGVJbnRlcm5hbE9iamVjdCgpO1xuICBpZiAoaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgMzIpIHtcbiAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcbiAgICBpZiAodHlwZSkge1xuICAgICAgYXNzaWduU2xvdHMoc2xvdHMsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICAgICAgaWYgKG9wdGltaXplZCkge1xuICAgICAgICBkZWYoc2xvdHMsIFwiX1wiLCB0eXBlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIHNsb3RzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XG4gIH1cbn07XG5jb25zdCB1cGRhdGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4sIG9wdGltaXplZCkgPT4ge1xuICBjb25zdCB7IHZub2RlLCBzbG90cyB9ID0gaW5zdGFuY2U7XG4gIGxldCBuZWVkRGVsZXRpb25DaGVjayA9IHRydWU7XG4gIGxldCBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBFTVBUWV9PQko7XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAzMikge1xuICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICAgIGFzc2lnblNsb3RzKHNsb3RzLCBjaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgICAgICAgdHJpZ2dlcihpbnN0YW5jZSwgXCJzZXRcIiwgXCIkc2xvdHNcIik7XG4gICAgICB9IGVsc2UgaWYgKG9wdGltaXplZCAmJiB0eXBlID09PSAxKSB7XG4gICAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NpZ25TbG90cyhzbG90cywgY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gIWNoaWxkcmVuLiRzdGFibGU7XG4gICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xuICAgIH1cbiAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSB7IGRlZmF1bHQ6IDEgfTtcbiAgfVxuICBpZiAobmVlZERlbGV0aW9uQ2hlY2spIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgaWYgKCFpc0ludGVybmFsS2V5KGtleSkgJiYgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgc2xvdHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmxldCBzdXBwb3J0ZWQ7XG5sZXQgcGVyZjtcbmZ1bmN0aW9uIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xuICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xuICAgIHBlcmYubWFyayhgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YCk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgZGV2dG9vbHNQZXJmU3RhcnQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuZE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcbiAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcbiAgICBjb25zdCBzdGFydFRhZyA9IGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gO1xuICAgIGNvbnN0IGVuZFRhZyA9IHN0YXJ0VGFnICsgYDplbmRgO1xuICAgIHBlcmYubWFyayhlbmRUYWcpO1xuICAgIHBlcmYubWVhc3VyZShcbiAgICAgIGA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKX0+ICR7dHlwZX1gLFxuICAgICAgc3RhcnRUYWcsXG4gICAgICBlbmRUYWdcbiAgICApO1xuICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgZGV2dG9vbHNQZXJmRW5kKGluc3RhbmNlLCB0eXBlLCBpc1N1cHBvcnRlZCgpID8gcGVyZi5ub3coKSA6IERhdGUubm93KCkpO1xuICB9XG59XG5mdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgaWYgKHN1cHBvcnRlZCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIHBlcmYgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIH0gZWxzZSB7XG4gICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRlZDtcbn1cblxuZnVuY3Rpb24gaW5pdEZlYXR1cmVGbGFncygpIHtcbiAgY29uc3QgbmVlZFdhcm4gPSBbXTtcbiAgaWYgKHR5cGVvZiBfX1ZVRV9PUFRJT05TX0FQSV9fICE9PSBcImJvb2xlYW5cIikge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfT1BUSU9OU19BUElfX2ApO1xuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9PUFRJT05TX0FQSV9fID0gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX1BST0RfREVWVE9PTFNfX2ApO1xuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9QUk9EX0RFVlRPT0xTX18gPSBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfX2ApO1xuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18gPSBmYWxzZTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5sZW5ndGgpIHtcbiAgICBjb25zdCBtdWx0aSA9IG5lZWRXYXJuLmxlbmd0aCA+IDE7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYEZlYXR1cmUgZmxhZyR7bXVsdGkgPyBgc2AgOiBgYH0gJHtuZWVkV2Fybi5qb2luKFwiLCBcIil9ICR7bXVsdGkgPyBgYXJlYCA6IGBpc2B9IG5vdCBleHBsaWNpdGx5IGRlZmluZWQuIFlvdSBhcmUgcnVubmluZyB0aGUgZXNtLWJ1bmRsZXIgYnVpbGQgb2YgVnVlLCB3aGljaCBleHBlY3RzIHRoZXNlIGNvbXBpbGUtdGltZSBmZWF0dXJlIGZsYWdzIHRvIGJlIGdsb2JhbGx5IGluamVjdGVkIHZpYSB0aGUgYnVuZGxlciBjb25maWcgaW4gb3JkZXIgdG8gZ2V0IGJldHRlciB0cmVlLXNoYWtpbmcgaW4gdGhlIHByb2R1Y3Rpb24gYnVuZGxlLlxuXG5Gb3IgbW9yZSBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9saW5rLnZ1ZWpzLm9yZy9mZWF0dXJlLWZsYWdzLmBcbiAgICApO1xuICB9XG59XG5cbmNvbnN0IHF1ZXVlUG9zdFJlbmRlckVmZmVjdCA9IHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlIDtcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMpO1xufVxuZnVuY3Rpb24gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZucykge1xuICB7XG4gICAgaW5pdEZlYXR1cmVGbGFncygpO1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IGdldEdsb2JhbFRoaXMoKTtcbiAgdGFyZ2V0Ll9fVlVFX18gPSB0cnVlO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBzZXREZXZ0b29sc0hvb2skMSh0YXJnZXQuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXywgdGFyZ2V0KTtcbiAgfVxuICBjb25zdCB7XG4gICAgaW5zZXJ0OiBob3N0SW5zZXJ0LFxuICAgIHJlbW92ZTogaG9zdFJlbW92ZSxcbiAgICBwYXRjaFByb3A6IGhvc3RQYXRjaFByb3AsXG4gICAgY3JlYXRlRWxlbWVudDogaG9zdENyZWF0ZUVsZW1lbnQsXG4gICAgY3JlYXRlVGV4dDogaG9zdENyZWF0ZVRleHQsXG4gICAgY3JlYXRlQ29tbWVudDogaG9zdENyZWF0ZUNvbW1lbnQsXG4gICAgc2V0VGV4dDogaG9zdFNldFRleHQsXG4gICAgc2V0RWxlbWVudFRleHQ6IGhvc3RTZXRFbGVtZW50VGV4dCxcbiAgICBwYXJlbnROb2RlOiBob3N0UGFyZW50Tm9kZSxcbiAgICBuZXh0U2libGluZzogaG9zdE5leHRTaWJsaW5nLFxuICAgIHNldFNjb3BlSWQ6IGhvc3RTZXRTY29wZUlkID0gTk9PUCxcbiAgICBpbnNlcnRTdGF0aWNDb250ZW50OiBob3N0SW5zZXJ0U3RhdGljQ29udGVudFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcGF0Y2ggPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciA9IG51bGwsIHBhcmVudENvbXBvbmVudCA9IG51bGwsIHBhcmVudFN1c3BlbnNlID0gbnVsbCwgbmFtZXNwYWNlID0gdm9pZCAwLCBzbG90U2NvcGVJZHMgPSBudWxsLCBvcHRpbWl6ZWQgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcgPyBmYWxzZSA6ICEhbjIuZHluYW1pY0NoaWxkcmVuKSA9PiB7XG4gICAgaWYgKG4xID09PSBuMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobjEgJiYgIWlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICBhbmNob3IgPSBnZXROZXh0SG9zdE5vZGUobjEpO1xuICAgICAgdW5tb3VudChuMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICBuMSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuMi5wYXRjaEZsYWcgPT09IC0yKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIG4yLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcgfSA9IG4yO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBUZXh0OlxuICAgICAgICBwcm9jZXNzVGV4dChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbW1lbnQ6XG4gICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRpYzpcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgICAgICBtb3VudFN0YXRpY05vZGUobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBuYW1lc3BhY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwYXRjaFN0YXRpY05vZGUobjEsIG4yLCBjb250YWluZXIsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICBwcm9jZXNzRnJhZ21lbnQoXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSkge1xuICAgICAgICAgIHByb2Nlc3NFbGVtZW50KFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgICB0eXBlLnByb2Nlc3MoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICBpbnRlcm5hbHNcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICAgIHR5cGUucHJvY2VzcyhcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIGludGVybmFsc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcIkludmFsaWQgVk5vZGUgdHlwZTpcIiwgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVmICE9IG51bGwgJiYgcGFyZW50Q29tcG9uZW50KSB7XG4gICAgICBzZXRSZWYocmVmLCBuMSAmJiBuMS5yZWYsIHBhcmVudFN1c3BlbnNlLCBuMiB8fCBuMSwgIW4yKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NUZXh0ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaG9zdEluc2VydChcbiAgICAgICAgbjIuZWwgPSBob3N0Q3JlYXRlVGV4dChuMi5jaGlsZHJlbiksXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlbCA9IG4yLmVsID0gbjEuZWw7XG4gICAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XG4gICAgICAgIGhvc3RTZXRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm9jZXNzQ29tbWVudE5vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBob3N0SW5zZXJ0KFxuICAgICAgICBuMi5lbCA9IGhvc3RDcmVhdGVDb21tZW50KG4yLmNoaWxkcmVuIHx8IFwiXCIpLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvclxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50U3RhdGljTm9kZSA9IChuMiwgY29udGFpbmVyLCBhbmNob3IsIG5hbWVzcGFjZSkgPT4ge1xuICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KFxuICAgICAgbjIuY2hpbGRyZW4sXG4gICAgICBjb250YWluZXIsXG4gICAgICBhbmNob3IsXG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBuMi5lbCxcbiAgICAgIG4yLmFuY2hvclxuICAgICk7XG4gIH07XG4gIGNvbnN0IHBhdGNoU3RhdGljTm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgbmFtZXNwYWNlKSA9PiB7XG4gICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xuICAgICAgY29uc3QgYW5jaG9yID0gaG9zdE5leHRTaWJsaW5nKG4xLmFuY2hvcik7XG4gICAgICByZW1vdmVTdGF0aWNOb2RlKG4xKTtcbiAgICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KFxuICAgICAgICBuMi5jaGlsZHJlbixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICAgIG4yLmFuY2hvciA9IG4xLmFuY2hvcjtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9LCBjb250YWluZXIsIG5leHRTaWJsaW5nKSA9PiB7XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xuICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XG4gICAgICBlbCA9IG5leHQ7XG4gICAgfVxuICAgIGhvc3RJbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSkgPT4ge1xuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gYW5jaG9yKSB7XG4gICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcbiAgICAgIGhvc3RSZW1vdmUoZWwpO1xuICAgICAgZWwgPSBuZXh0O1xuICAgIH1cbiAgICBob3N0UmVtb3ZlKGFuY2hvcik7XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NFbGVtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBpZiAobjIudHlwZSA9PT0gXCJzdmdcIikge1xuICAgICAgbmFtZXNwYWNlID0gXCJzdmdcIjtcbiAgICB9IGVsc2UgaWYgKG4yLnR5cGUgPT09IFwibWF0aFwiKSB7XG4gICAgICBuYW1lc3BhY2UgPSBcIm1hdGhtbFwiO1xuICAgIH1cbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgbW91bnRFbGVtZW50KFxuICAgICAgICBuMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoRWxlbWVudChcbiAgICAgICAgbjEsXG4gICAgICAgIG4yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRFbGVtZW50ID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGxldCBlbDtcbiAgICBsZXQgdm5vZGVIb29rO1xuICAgIGNvbnN0IHsgcHJvcHMsIHNoYXBlRmxhZywgdHJhbnNpdGlvbiwgZGlycyB9ID0gdm5vZGU7XG4gICAgZWwgPSB2bm9kZS5lbCA9IGhvc3RDcmVhdGVFbGVtZW50KFxuICAgICAgdm5vZGUudHlwZSxcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIHByb3BzICYmIHByb3BzLmlzLFxuICAgICAgcHJvcHNcbiAgICApO1xuICAgIGlmIChzaGFwZUZsYWcgJiA4KSB7XG4gICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIHZub2RlLmNoaWxkcmVuKTtcbiAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICB2bm9kZS5jaGlsZHJlbixcbiAgICAgICAgZWwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIHJlc29sdmVDaGlsZHJlbk5hbWVzcGFjZSh2bm9kZSwgbmFtZXNwYWNlKSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChkaXJzKSB7XG4gICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiY3JlYXRlZFwiKTtcbiAgICB9XG4gICAgc2V0U2NvcGVJZChlbCwgdm5vZGUsIHZub2RlLnNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KTtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgIGlmIChrZXkgIT09IFwidmFsdWVcIiAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgbnVsbCwgcHJvcHNba2V5XSwgbmFtZXNwYWNlLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIHByb3BzKSB7XG4gICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwidmFsdWVcIiwgbnVsbCwgcHJvcHMudmFsdWUsIG5hbWVzcGFjZSk7XG4gICAgICB9XG4gICAgICBpZiAodm5vZGVIb29rID0gcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSB7XG4gICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRlZihlbCwgXCJfX3Zub2RlXCIsIHZub2RlLCB0cnVlKTtcbiAgICAgIGRlZihlbCwgXCJfX3Z1ZVBhcmVudENvbXBvbmVudFwiLCBwYXJlbnRDb21wb25lbnQsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoZGlycykge1xuICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZU1vdW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyA9IG5lZWRUcmFuc2l0aW9uKHBhcmVudFN1c3BlbnNlLCB0cmFuc2l0aW9uKTtcbiAgICBpZiAobmVlZENhbGxUcmFuc2l0aW9uSG9va3MpIHtcbiAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgIH1cbiAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgaWYgKCh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHwgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgfHwgZGlycykge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyAmJiB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwibW91bnRlZFwiKTtcbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNldFNjb3BlSWQgPSAoZWwsIHZub2RlLCBzY29wZUlkLCBzbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudCkgPT4ge1xuICAgIGlmIChzY29wZUlkKSB7XG4gICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2NvcGVJZCk7XG4gICAgfVxuICAgIGlmIChzbG90U2NvcGVJZHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xvdFNjb3BlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzbG90U2NvcGVJZHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICBsZXQgc3ViVHJlZSA9IHBhcmVudENvbXBvbmVudC5zdWJUcmVlO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc3ViVHJlZS5wYXRjaEZsYWcgPiAwICYmIHN1YlRyZWUucGF0Y2hGbGFnICYgMjA0OCkge1xuICAgICAgICBzdWJUcmVlID0gZmlsdGVyU2luZ2xlUm9vdChzdWJUcmVlLmNoaWxkcmVuKSB8fCBzdWJUcmVlO1xuICAgICAgfVxuICAgICAgaWYgKHZub2RlID09PSBzdWJUcmVlIHx8IGlzU3VzcGVuc2Uoc3ViVHJlZS50eXBlKSAmJiAoc3ViVHJlZS5zc0NvbnRlbnQgPT09IHZub2RlIHx8IHN1YlRyZWUuc3NGYWxsYmFjayA9PT0gdm5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFZOb2RlID0gcGFyZW50Q29tcG9uZW50LnZub2RlO1xuICAgICAgICBzZXRTY29wZUlkKFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIHBhcmVudFZOb2RlLFxuICAgICAgICAgIHBhcmVudFZOb2RlLnNjb3BlSWQsXG4gICAgICAgICAgcGFyZW50Vk5vZGUuc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudC5wYXJlbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBzdGFydCA9IDApID0+IHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGNoaWxkcmVuW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBudWxsLFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaEVsZW1lbnQgPSAobjEsIG4yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgZWwgPSBuMi5lbCA9IG4xLmVsO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZWwuX192bm9kZSA9IG4yO1xuICAgIH1cbiAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgZGlycyB9ID0gbjI7XG4gICAgcGF0Y2hGbGFnIHw9IG4xLnBhdGNoRmxhZyAmIDE2O1xuICAgIGNvbnN0IG9sZFByb3BzID0gbjEucHJvcHMgfHwgRU1QVFlfT0JKO1xuICAgIGNvbnN0IG5ld1Byb3BzID0gbjIucHJvcHMgfHwgRU1QVFlfT0JKO1xuICAgIGxldCB2bm9kZUhvb2s7XG4gICAgcGFyZW50Q29tcG9uZW50ICYmIHRvZ2dsZVJlY3Vyc2UocGFyZW50Q29tcG9uZW50LCBmYWxzZSk7XG4gICAgaWYgKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpIHtcbiAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgbjIsIG4xKTtcbiAgICB9XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlVXBkYXRlXCIpO1xuICAgIH1cbiAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIHRydWUpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgIHBhdGNoRmxhZyA9IDA7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChvbGRQcm9wcy5pbm5lckhUTUwgJiYgbmV3UHJvcHMuaW5uZXJIVE1MID09IG51bGwgfHwgb2xkUHJvcHMudGV4dENvbnRlbnQgJiYgbmV3UHJvcHMudGV4dENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKFxuICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4sXG4gICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgZWwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIHJlc29sdmVDaGlsZHJlbk5hbWVzcGFjZShuMiwgbmFtZXNwYWNlKSxcbiAgICAgICAgc2xvdFNjb3BlSWRzXG4gICAgICApO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW9wdGltaXplZCkge1xuICAgICAgcGF0Y2hDaGlsZHJlbihcbiAgICAgICAgbjEsXG4gICAgICAgIG4yLFxuICAgICAgICBlbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgcmVzb2x2ZUNoaWxkcmVuTmFtZXNwYWNlKG4yLCBuYW1lc3BhY2UpLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xuICAgICAgaWYgKHBhdGNoRmxhZyAmIDE2KSB7XG4gICAgICAgIHBhdGNoUHJvcHMoZWwsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBuYW1lc3BhY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDIpIHtcbiAgICAgICAgICBpZiAob2xkUHJvcHMuY2xhc3MgIT09IG5ld1Byb3BzLmNsYXNzKSB7XG4gICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBcImNsYXNzXCIsIG51bGwsIG5ld1Byb3BzLmNsYXNzLCBuYW1lc3BhY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgNCkge1xuICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwic3R5bGVcIiwgb2xkUHJvcHMuc3R5bGUsIG5ld1Byb3BzLnN0eWxlLCBuYW1lc3BhY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiA4KSB7XG4gICAgICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IG4yLmR5bmFtaWNQcm9wcztcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xuICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYgfHwga2V5ID09PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBwcmV2LCBuZXh0LCBuYW1lc3BhY2UsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMSkge1xuICAgICAgICBpZiAobjEuY2hpbGRyZW4gIT09IG4yLmNoaWxkcmVuKSB7XG4gICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFvcHRpbWl6ZWQgJiYgZHluYW1pY0NoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHBhdGNoUHJvcHMoZWwsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBuYW1lc3BhY2UpO1xuICAgIH1cbiAgICBpZiAoKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVVcGRhdGVkKSB8fCBkaXJzKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xuICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsIFwidXBkYXRlZFwiKTtcbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoQmxvY2tDaGlsZHJlbiA9IChvbGRDaGlsZHJlbiwgbmV3Q2hpbGRyZW4sIGZhbGxiYWNrQ29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcykgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XG4gICAgICBjb25zdCBuZXdWTm9kZSA9IG5ld0NoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgY29udGFpbmVyID0gKFxuICAgICAgICAvLyBvbGRWTm9kZSBtYXkgYmUgYW4gZXJyb3JlZCBhc3luYyBzZXR1cCgpIGNvbXBvbmVudCBpbnNpZGUgU3VzcGVuc2VcbiAgICAgICAgLy8gd2hpY2ggd2lsbCBub3QgaGF2ZSBhIG1vdW50ZWQgZWxlbWVudFxuICAgICAgICBvbGRWTm9kZS5lbCAmJiAvLyAtIEluIHRoZSBjYXNlIG9mIGEgRnJhZ21lbnQsIHdlIG5lZWQgdG8gcHJvdmlkZSB0aGUgYWN0dWFsIHBhcmVudFxuICAgICAgICAvLyBvZiB0aGUgRnJhZ21lbnQgaXRzZWxmIHNvIGl0IGNhbiBtb3ZlIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgKG9sZFZOb2RlLnR5cGUgPT09IEZyYWdtZW50IHx8IC8vIC0gSW4gdGhlIGNhc2Ugb2YgZGlmZmVyZW50IG5vZGVzLCB0aGVyZSBpcyBnb2luZyB0byBiZSBhIHJlcGxhY2VtZW50XG4gICAgICAgIC8vIHdoaWNoIGFsc28gcmVxdWlyZXMgdGhlIGNvcnJlY3QgcGFyZW50IGNvbnRhaW5lclxuICAgICAgICAhaXNTYW1lVk5vZGVUeXBlKG9sZFZOb2RlLCBuZXdWTm9kZSkgfHwgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIGNvbXBvbmVudCwgaXQgY291bGQgY29udGFpbiBhbnl0aGluZy5cbiAgICAgICAgb2xkVk5vZGUuc2hhcGVGbGFnICYgKDYgfCA2NCkpID8gaG9zdFBhcmVudE5vZGUob2xkVk5vZGUuZWwpIDogKFxuICAgICAgICAgIC8vIEluIG90aGVyIGNhc2VzLCB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBub3QgYWN0dWFsbHkgdXNlZCBzbyB3ZVxuICAgICAgICAgIC8vIGp1c3QgcGFzcyB0aGUgYmxvY2sgZWxlbWVudCBoZXJlIHRvIGF2b2lkIGEgRE9NIHBhcmVudE5vZGUgY2FsbC5cbiAgICAgICAgICBmYWxsYmFja0NvbnRhaW5lclxuICAgICAgICApXG4gICAgICApO1xuICAgICAgcGF0Y2goXG4gICAgICAgIG9sZFZOb2RlLFxuICAgICAgICBuZXdWTm9kZSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoUHJvcHMgPSAoZWwsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBuYW1lc3BhY2UpID0+IHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzKSB7XG4gICAgICBpZiAob2xkUHJvcHMgIT09IEVNUFRZX09CSikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRQcm9wcykge1xuICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByb3Aoa2V5KSAmJiAhKGtleSBpbiBuZXdQcm9wcykpIHtcbiAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIG9sZFByb3BzW2tleV0sXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wKGtleSkpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBuZXh0ID0gbmV3UHJvcHNba2V5XTtcbiAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XG4gICAgICAgIGlmIChuZXh0ICE9PSBwcmV2ICYmIGtleSAhPT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBwcmV2LCBuZXh0LCBuYW1lc3BhY2UsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChcInZhbHVlXCIgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJ2YWx1ZVwiLCBvbGRQcm9wcy52YWx1ZSwgbmV3UHJvcHMudmFsdWUsIG5hbWVzcGFjZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm9jZXNzRnJhZ21lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGZyYWdtZW50U3RhcnRBbmNob3IgPSBuMi5lbCA9IG4xID8gbjEuZWwgOiBob3N0Q3JlYXRlVGV4dChcIlwiKTtcbiAgICBjb25zdCBmcmFnbWVudEVuZEFuY2hvciA9IG4yLmFuY2hvciA9IG4xID8gbjEuYW5jaG9yIDogaG9zdENyZWF0ZVRleHQoXCJcIik7XG4gICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IG4yO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIC8vICM1NTIzIGRldiByb290IGZyYWdtZW50IG1heSBpbmhlcml0IGRpcmVjdGl2ZXNcbiAgICAoaXNIbXJVcGRhdGluZyB8fCBwYXRjaEZsYWcgJiAyMDQ4KSkge1xuICAgICAgcGF0Y2hGbGFnID0gMDtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGZyYWdtZW50U2xvdFNjb3BlSWRzKSB7XG4gICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHMgPyBzbG90U2NvcGVJZHMuY29uY2F0KGZyYWdtZW50U2xvdFNjb3BlSWRzKSA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xuICAgIH1cbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaG9zdEluc2VydChmcmFnbWVudFN0YXJ0QW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBob3N0SW5zZXJ0KGZyYWdtZW50RW5kQW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICAvLyAjMTAwMDdcbiAgICAgICAgLy8gc3VjaCBmcmFnbWVudCBsaWtlIGA8PjwvPmAgd2lsbCBiZSBjb21waWxlZCBpbnRvXG4gICAgICAgIC8vIGEgZnJhZ21lbnQgd2hpY2ggZG9lc24ndCBoYXZlIGEgY2hpbGRyZW4uXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSBmYWxsYmFjayB0byBhbiBlbXB0eSBhcnJheVxuICAgICAgICBuMi5jaGlsZHJlbiB8fCBbXSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBmcmFnbWVudEVuZEFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhdGNoRmxhZyA+IDAgJiYgcGF0Y2hGbGFnICYgNjQgJiYgZHluYW1pY0NoaWxkcmVuICYmIC8vICMyNzE1IHRoZSBwcmV2aW91cyBmcmFnbWVudCBjb3VsZCd2ZSBiZWVuIGEgQkFJTGVkIG9uZSBhcyBhIHJlc3VsdFxuICAgICAgLy8gb2YgcmVuZGVyU2xvdCgpIHdpdGggbm8gdmFsaWQgY2hpbGRyZW5cbiAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4oXG4gICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgLy8gIzIwODAgaWYgdGhlIHN0YWJsZSBmcmFnbWVudCBoYXMgYSBrZXksIGl0J3MgYSA8dGVtcGxhdGUgdi1mb3I+IHRoYXQgbWF5XG4gICAgICAgICAgLy8gIGdldCBtb3ZlZCBhcm91bmQuIE1ha2Ugc3VyZSBhbGwgcm9vdCBsZXZlbCB2bm9kZXMgaW5oZXJpdCBlbC5cbiAgICAgICAgICAvLyAjMjEzNCBvciBpZiBpdCdzIGEgY29tcG9uZW50IHJvb3QsIGl0IG1heSBhbHNvIGdldCBtb3ZlZCBhcm91bmRcbiAgICAgICAgICAvLyBhcyB0aGUgY29tcG9uZW50IGlzIGJlaW5nIG1vdmVkLlxuICAgICAgICAgIG4yLmtleSAhPSBudWxsIHx8IHBhcmVudENvbXBvbmVudCAmJiBuMiA9PT0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWVcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAvKiBzaGFsbG93ICovXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0Y2hDaGlsZHJlbihcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgZnJhZ21lbnRFbmRBbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm9jZXNzQ29tcG9uZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBuMi5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGlmIChuMi5zaGFwZUZsYWcgJiA1MTIpIHtcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5hY3RpdmF0ZShcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vdW50Q29tcG9uZW50KFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50Q29tcG9uZW50ID0gKGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSAoaW5pdGlhbFZOb2RlLmNvbXBvbmVudCA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKFxuICAgICAgaW5pdGlhbFZOb2RlLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2VcbiAgICApKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcbiAgICAgIHJlZ2lzdGVySE1SKGluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChpbml0aWFsVk5vZGUpO1xuICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcbiAgICB9XG4gICAgaWYgKGlzS2VlcEFsaXZlKGluaXRpYWxWTm9kZSkpIHtcbiAgICAgIGluc3RhbmNlLmN0eC5yZW5kZXJlciA9IGludGVybmFscztcbiAgICB9XG4gICAge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xuICAgICAgfVxuICAgICAgc2V0dXBDb21wb25lbnQoaW5zdGFuY2UsIGZhbHNlLCBvcHRpbWl6ZWQpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwKSB7XG4gICAgICBwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5yZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QsIG9wdGltaXplZCk7XG4gICAgICBpZiAoIWluaXRpYWxWTm9kZS5lbCkge1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGluc3RhbmNlLnN1YlRyZWUgPSBjcmVhdGVWTm9kZShDb21tZW50KTtcbiAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG51bGwsIHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldHVwUmVuZGVyRWZmZWN0KFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgaW5pdGlhbFZOb2RlLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdXBkYXRlQ29tcG9uZW50ID0gKG4xLCBuMiwgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuMi5jb21wb25lbnQgPSBuMS5jb21wb25lbnQ7XG4gICAgaWYgKHNob3VsZFVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCkpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCAmJiAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChuMik7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuMiwgb3B0aW1pemVkKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLm5leHQgPSBuMjtcbiAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICBpbnN0YW5jZS52bm9kZSA9IG4yO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0dXBSZW5kZXJFZmZlY3QgPSAoaW5zdGFuY2UsIGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGNvbXBvbmVudFVwZGF0ZUZuID0gKCkgPT4ge1xuICAgICAgaWYgKCFpbnN0YW5jZS5pc01vdW50ZWQpIHtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgY29uc3QgeyBlbCwgcHJvcHMgfSA9IGluaXRpYWxWTm9kZTtcbiAgICAgICAgY29uc3QgeyBibSwgbSwgcGFyZW50LCByb290LCB0eXBlIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgY29uc3QgaXNBc3luY1dyYXBwZXJWTm9kZSA9IGlzQXN5bmNXcmFwcGVyKGluaXRpYWxWTm9kZSk7XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIGZhbHNlKTtcbiAgICAgICAgaWYgKGJtKSB7XG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoYm0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBc3luY1dyYXBwZXJWTm9kZSAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xuICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgaW5pdGlhbFZOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcbiAgICAgICAgaWYgKGVsICYmIGh5ZHJhdGVOb2RlKSB7XG4gICAgICAgICAgY29uc3QgaHlkcmF0ZVN1YlRyZWUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGh5ZHJhdGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGh5ZHJhdGVOb2RlKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGh5ZHJhdGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlclZOb2RlKSB7XG4gICAgICAgICAgICB0eXBlLl9fYXN5bmNIeWRyYXRlKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIGh5ZHJhdGVTdWJUcmVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoeWRyYXRlU3ViVHJlZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocm9vdC5jZSkge1xuICAgICAgICAgICAgcm9vdC5jZS5faW5qZWN0Q2hpbGRTdHlsZSh0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdWJUcmVlID0gaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBzdWJUcmVlLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbml0aWFsVk5vZGUuZWwgPSBzdWJUcmVlLmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KG0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSkge1xuICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoXG4gICAgICAgICAgICAoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIHNjb3BlZEluaXRpYWxWTm9kZSksXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxWTm9kZS5zaGFwZUZsYWcgJiAyNTYgfHwgcGFyZW50ICYmIGlzQXN5bmNXcmFwcGVyKHBhcmVudC52bm9kZSkgJiYgcGFyZW50LnZub2RlLnNoYXBlRmxhZyAmIDI1Nikge1xuICAgICAgICAgIGluc3RhbmNlLmEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGluc3RhbmNlLmEsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbml0aWFsVk5vZGUgPSBjb250YWluZXIgPSBhbmNob3IgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHsgbmV4dCwgYnUsIHUsIHBhcmVudCwgdm5vZGUgfSA9IGluc3RhbmNlO1xuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgbm9uSHlkcmF0ZWRBc3luY1Jvb3QgPSBsb2NhdGVOb25IeWRyYXRlZEFzeW5jUm9vdChpbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKG5vbkh5ZHJhdGVkQXN5bmNSb290KSB7XG4gICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XG4gICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbmV4dCwgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vbkh5ZHJhdGVkQXN5bmNSb290LmFzeW5jRGVwLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWluc3RhbmNlLmlzVW5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50VXBkYXRlRm4oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBvcmlnaW5OZXh0ID0gbmV4dDtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobmV4dCB8fCBpbnN0YW5jZS52bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgZmFsc2UpO1xuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIG5leHQuZWwgPSB2bm9kZS5lbDtcbiAgICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG5leHQsIG9wdGltaXplZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IHZub2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0VHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2VHJlZSA9IGluc3RhbmNlLnN1YlRyZWU7XG4gICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSBuZXh0VHJlZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIHByZXZUcmVlLFxuICAgICAgICAgIG5leHRUcmVlLFxuICAgICAgICAgIC8vIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSB0ZWxlcG9ydFxuICAgICAgICAgIGhvc3RQYXJlbnROb2RlKHByZXZUcmVlLmVsKSxcbiAgICAgICAgICAvLyBhbmNob3IgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgZnJhZ21lbnRcbiAgICAgICAgICBnZXROZXh0SG9zdE5vZGUocHJldlRyZWUpLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZVxuICAgICAgICApO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICB9XG4gICAgICAgIG5leHQuZWwgPSBuZXh0VHJlZS5lbDtcbiAgICAgICAgaWYgKG9yaWdpbk5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIG5leHRUcmVlLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodSkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlVXBkYXRlZCkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChcbiAgICAgICAgICAgICgpID0+IGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpLFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpbnN0YW5jZS5zY29wZS5vbigpO1xuICAgIGNvbnN0IGVmZmVjdCA9IGluc3RhbmNlLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChjb21wb25lbnRVcGRhdGVGbik7XG4gICAgaW5zdGFuY2Uuc2NvcGUub2ZmKCk7XG4gICAgY29uc3QgdXBkYXRlID0gaW5zdGFuY2UudXBkYXRlID0gZWZmZWN0LnJ1bi5iaW5kKGVmZmVjdCk7XG4gICAgY29uc3Qgam9iID0gaW5zdGFuY2Uuam9iID0gZWZmZWN0LnJ1bklmRGlydHkuYmluZChlZmZlY3QpO1xuICAgIGpvYi5pID0gaW5zdGFuY2U7XG4gICAgam9iLmlkID0gaW5zdGFuY2UudWlkO1xuICAgIGVmZmVjdC5zY2hlZHVsZXIgPSAoKSA9PiBxdWV1ZUpvYihqb2IpO1xuICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBlZmZlY3Qub25UcmFjayA9IGluc3RhbmNlLnJ0YyA/IChlKSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGMsIGUpIDogdm9pZCAwO1xuICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IGluc3RhbmNlLnJ0ZyA/IChlKSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGcsIGUpIDogdm9pZCAwO1xuICAgIH1cbiAgICB1cGRhdGUoKTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyID0gKGluc3RhbmNlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkgPT4ge1xuICAgIG5leHRWTm9kZS5jb21wb25lbnQgPSBpbnN0YW5jZTtcbiAgICBjb25zdCBwcmV2UHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcztcbiAgICBpbnN0YW5jZS52bm9kZSA9IG5leHRWTm9kZTtcbiAgICBpbnN0YW5jZS5uZXh0ID0gbnVsbDtcbiAgICB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgbmV4dFZOb2RlLnByb3BzLCBwcmV2UHJvcHMsIG9wdGltaXplZCk7XG4gICAgdXBkYXRlU2xvdHMoaW5zdGFuY2UsIG5leHRWTm9kZS5jaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgZmx1c2hQcmVGbHVzaENicyhpbnN0YW5jZSk7XG4gICAgcmVzZXRUcmFja2luZygpO1xuICB9O1xuICBjb25zdCBwYXRjaENoaWxkcmVuID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IGMxID0gbjEgJiYgbjEuY2hpbGRyZW47XG4gICAgY29uc3QgcHJldlNoYXBlRmxhZyA9IG4xID8gbjEuc2hhcGVGbGFnIDogMDtcbiAgICBjb25zdCBjMiA9IG4yLmNoaWxkcmVuO1xuICAgIGNvbnN0IHsgcGF0Y2hGbGFnLCBzaGFwZUZsYWcgfSA9IG4yO1xuICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMTI4KSB7XG4gICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICBjMSxcbiAgICAgICAgICBjMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHBhdGNoRmxhZyAmIDI1Nikge1xuICAgICAgICBwYXRjaFVua2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICBjMSxcbiAgICAgICAgICBjMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiA4KSB7XG4gICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBpZiAoYzIgIT09IGMxKSB7XG4gICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIGMyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNikge1xuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oXG4gICAgICAgICAgICBjMSxcbiAgICAgICAgICAgIGMyLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgOCkge1xuICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgICAgICBjMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hVbmtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGMxID0gYzEgfHwgRU1QVFlfQVJSO1xuICAgIGMyID0gYzIgfHwgRU1QVFlfQVJSO1xuICAgIGNvbnN0IG9sZExlbmd0aCA9IGMxLmxlbmd0aDtcbiAgICBjb25zdCBuZXdMZW5ndGggPSBjMi5sZW5ndGg7XG4gICAgY29uc3QgY29tbW9uTGVuZ3RoID0gTWF0aC5taW4ob2xkTGVuZ3RoLCBuZXdMZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb21tb25MZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICBwYXRjaChcbiAgICAgICAgYzFbaV0sXG4gICAgICAgIG5leHRDaGlsZCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob2xkTGVuZ3RoID4gbmV3TGVuZ3RoKSB7XG4gICAgICB1bm1vdW50Q2hpbGRyZW4oXG4gICAgICAgIGMxLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICB0cnVlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgY29tbW9uTGVuZ3RoXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICBjMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIGNvbW1vbkxlbmd0aFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoS2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGwyID0gYzIubGVuZ3RoO1xuICAgIGxldCBlMSA9IGMxLmxlbmd0aCAtIDE7XG4gICAgbGV0IGUyID0gbDIgLSAxO1xuICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcbiAgICAgIGNvbnN0IG4xID0gYzFbaV07XG4gICAgICBjb25zdCBuMiA9IGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pO1xuICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcbiAgICAgIGNvbnN0IG4xID0gYzFbZTFdO1xuICAgICAgY29uc3QgbjIgPSBjMltlMl0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltlMl0pIDogbm9ybWFsaXplVk5vZGUoYzJbZTJdKTtcbiAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZTEtLTtcbiAgICAgIGUyLS07XG4gICAgfVxuICAgIGlmIChpID4gZTEpIHtcbiAgICAgIGlmIChpIDw9IGUyKSB7XG4gICAgICAgIGNvbnN0IG5leHRQb3MgPSBlMiArIDE7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRQb3MgPCBsMiA/IGMyW25leHRQb3NdLmVsIDogcGFyZW50QW5jaG9yO1xuICAgICAgICB3aGlsZSAoaSA8PSBlMikge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaSA+IGUyKSB7XG4gICAgICB3aGlsZSAoaSA8PSBlMSkge1xuICAgICAgICB1bm1vdW50KGMxW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzMSA9IGk7XG4gICAgICBjb25zdCBzMiA9IGk7XG4gICAgICBjb25zdCBrZXlUb05ld0luZGV4TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGZvciAoaSA9IHMyOyBpIDw9IGUyOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICAgIGlmIChuZXh0Q2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXlUb05ld0luZGV4TWFwLmhhcyhuZXh0Q2hpbGQua2V5KSkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgRHVwbGljYXRlIGtleXMgZm91bmQgZHVyaW5nIHVwZGF0ZTpgLFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShuZXh0Q2hpbGQua2V5KSxcbiAgICAgICAgICAgICAgYE1ha2Ugc3VyZSBrZXlzIGFyZSB1bmlxdWUuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5VG9OZXdJbmRleE1hcC5zZXQobmV4dENoaWxkLmtleSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBqO1xuICAgICAgbGV0IHBhdGNoZWQgPSAwO1xuICAgICAgY29uc3QgdG9CZVBhdGNoZWQgPSBlMiAtIHMyICsgMTtcbiAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgbGV0IG1heE5ld0luZGV4U29GYXIgPSAwO1xuICAgICAgY29uc3QgbmV3SW5kZXhUb09sZEluZGV4TWFwID0gbmV3IEFycmF5KHRvQmVQYXRjaGVkKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0JlUGF0Y2hlZDsgaSsrKSBuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPSAwO1xuICAgICAgZm9yIChpID0gczE7IGkgPD0gZTE7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcbiAgICAgICAgaWYgKHBhdGNoZWQgPj0gdG9CZVBhdGNoZWQpIHtcbiAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0luZGV4O1xuICAgICAgICBpZiAocHJldkNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3SW5kZXggPSBrZXlUb05ld0luZGV4TWFwLmdldChwcmV2Q2hpbGQua2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGogPSBzMjsgaiA8PSBlMjsgaisrKSB7XG4gICAgICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ogLSBzMl0gPT09IDAgJiYgaXNTYW1lVk5vZGVUeXBlKHByZXZDaGlsZCwgYzJbal0pKSB7XG4gICAgICAgICAgICAgIG5ld0luZGV4ID0gajtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdJbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0luZGV4VG9PbGRJbmRleE1hcFtuZXdJbmRleCAtIHMyXSA9IGkgKyAxO1xuICAgICAgICAgIGlmIChuZXdJbmRleCA+PSBtYXhOZXdJbmRleFNvRmFyKSB7XG4gICAgICAgICAgICBtYXhOZXdJbmRleFNvRmFyID0gbmV3SW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBwcmV2Q2hpbGQsXG4gICAgICAgICAgICBjMltuZXdJbmRleF0sXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHBhdGNoZWQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UgPSBtb3ZlZCA/IGdldFNlcXVlbmNlKG5ld0luZGV4VG9PbGRJbmRleE1hcCkgOiBFTVBUWV9BUlI7XG4gICAgICBqID0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UubGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoaSA9IHRvQmVQYXRjaGVkIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gczIgKyBpO1xuICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltuZXh0SW5kZXhdO1xuICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0SW5kZXggKyAxIDwgbDIgPyBjMltuZXh0SW5kZXggKyAxXS5lbCA6IHBhcmVudEFuY2hvcjtcbiAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9PT0gMCkge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG5leHRDaGlsZCxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb3ZlZCkge1xuICAgICAgICAgIGlmIChqIDwgMCB8fCBpICE9PSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZVtqXSkge1xuICAgICAgICAgICAgbW92ZShuZXh0Q2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCAyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbW92ZSA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlLCBwYXJlbnRTdXNwZW5zZSA9IG51bGwpID0+IHtcbiAgICBjb25zdCB7IGVsLCB0eXBlLCB0cmFuc2l0aW9uLCBjaGlsZHJlbiwgc2hhcGVGbGFnIH0gPSB2bm9kZTtcbiAgICBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgbW92ZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgdm5vZGUuc3VzcGVuc2UubW92ZShjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgIHR5cGUubW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGludGVybmFscyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtb3ZlKGNoaWxkcmVuW2ldLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xuICAgICAgfVxuICAgICAgaG9zdEluc2VydCh2bm9kZS5hbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xuICAgICAgbW92ZVN0YXRpY05vZGUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmVlZFRyYW5zaXRpb24yID0gbW92ZVR5cGUgIT09IDIgJiYgc2hhcGVGbGFnICYgMSAmJiB0cmFuc2l0aW9uO1xuICAgIGlmIChuZWVkVHJhbnNpdGlvbjIpIHtcbiAgICAgIGlmIChtb3ZlVHlwZSA9PT0gMCkge1xuICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gdHJhbnNpdGlvbi5lbnRlcihlbCksIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUsIGFmdGVyTGVhdmUgfSA9IHRyYW5zaXRpb247XG4gICAgICAgIGNvbnN0IHJlbW92ZTIgPSAoKSA9PiBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICBsZWF2ZShlbCwgKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlMigpO1xuICAgICAgICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgICAgZGVsYXlMZWF2ZShlbCwgcmVtb3ZlMiwgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgfVxuICB9O1xuICBjb25zdCB1bm1vdW50ID0gKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHJlZixcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgc2hhcGVGbGFnLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgZGlycyxcbiAgICAgIGNhY2hlSW5kZXhcbiAgICB9ID0gdm5vZGU7XG4gICAgaWYgKHBhdGNoRmxhZyA9PT0gLTIpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChjYWNoZUluZGV4ICE9IG51bGwpIHtcbiAgICAgIHBhcmVudENvbXBvbmVudC5yZW5kZXJDYWNoZVtjYWNoZUluZGV4XSA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDI1Nikge1xuICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5kZWFjdGl2YXRlKHZub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkSW52b2tlRGlycyA9IHNoYXBlRmxhZyAmIDEgJiYgZGlycztcbiAgICBjb25zdCBzaG91bGRJbnZva2VWbm9kZUhvb2sgPSAhaXNBc3luY1dyYXBwZXIodm5vZGUpO1xuICAgIGxldCB2bm9kZUhvb2s7XG4gICAgaWYgKHNob3VsZEludm9rZVZub2RlSG9vayAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZVVubW91bnQpKSB7XG4gICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgIHVubW91bnRDb21wb25lbnQodm5vZGUuY29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgIHZub2RlLnN1c3BlbnNlLnVubW91bnQocGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZEludm9rZURpcnMpIHtcbiAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZVVubW91bnRcIik7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgdm5vZGUudHlwZS5yZW1vdmUoXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICBkb1JlbW92ZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChkeW5hbWljQ2hpbGRyZW4gJiYgLy8gIzUxNTRcbiAgICAgIC8vIHdoZW4gdi1vbmNlIGlzIHVzZWQgaW5zaWRlIGEgYmxvY2ssIHNldEJsb2NrVHJhY2tpbmcoLTEpIG1hcmtzIHRoZVxuICAgICAgLy8gcGFyZW50IGJsb2NrIHdpdGggaGFzT25jZTogdHJ1ZVxuICAgICAgLy8gc28gdGhhdCBpdCBkb2Vzbid0IHRha2UgdGhlIGZhc3QgcGF0aCBkdXJpbmcgdW5tb3VudCAtIG90aGVyd2lzZVxuICAgICAgLy8gY29tcG9uZW50cyBuZXN0ZWQgaW4gdi1vbmNlIGFyZSBuZXZlciB1bm1vdW50ZWQuXG4gICAgICAhZHluYW1pY0NoaWxkcmVuLmhhc09uY2UgJiYgLy8gIzExNTM6IGZhc3QgcGF0aCBzaG91bGQgbm90IGJlIHRha2VuIGZvciBub24tc3RhYmxlICh2LWZvcikgZnJhZ21lbnRzXG4gICAgICAodHlwZSAhPT0gRnJhZ21lbnQgfHwgcGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCkpIHtcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKFxuICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBGcmFnbWVudCAmJiBwYXRjaEZsYWcgJiAoMTI4IHwgMjU2KSB8fCAhb3B0aW1pemVkICYmIHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIHVubW91bnRDaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBpZiAoZG9SZW1vdmUpIHtcbiAgICAgICAgcmVtb3ZlKHZub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZEludm9rZVZub2RlSG9vayAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZVVubW91bnRlZCkgfHwgc2hvdWxkSW52b2tlRGlycykge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICBzaG91bGRJbnZva2VEaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJ1bm1vdW50ZWRcIik7XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmUgPSAodm5vZGUpID0+IHtcbiAgICBjb25zdCB7IHR5cGUsIGVsLCBhbmNob3IsIHRyYW5zaXRpb24gfSA9IHZub2RlO1xuICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdm5vZGUucGF0Y2hGbGFnID4gMCAmJiB2bm9kZS5wYXRjaEZsYWcgJiAyMDQ4ICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XG4gICAgICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpIHtcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoY2hpbGQuZWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmUoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVGcmFnbWVudChlbCwgYW5jaG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xuICAgICAgcmVtb3ZlU3RhdGljTm9kZSh2bm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBlcmZvcm1SZW1vdmUgPSAoKSA9PiB7XG4gICAgICBob3N0UmVtb3ZlKGVsKTtcbiAgICAgIGlmICh0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCAmJiB0cmFuc2l0aW9uLmFmdGVyTGVhdmUpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5hZnRlckxlYXZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAmJiB0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCkge1xuICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcbiAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IGxlYXZlKGVsLCBwZXJmb3JtUmVtb3ZlKTtcbiAgICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgIGRlbGF5TGVhdmUodm5vZGUuZWwsIHBlcmZvcm1SZW1vdmUsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVyZm9ybVJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlRnJhZ21lbnQgPSAoY3VyLCBlbmQpID0+IHtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoY3VyICE9PSBlbmQpIHtcbiAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoY3VyKTtcbiAgICAgIGhvc3RSZW1vdmUoY3VyKTtcbiAgICAgIGN1ciA9IG5leHQ7XG4gICAgfVxuICAgIGhvc3RSZW1vdmUoZW5kKTtcbiAgfTtcbiAgY29uc3QgdW5tb3VudENvbXBvbmVudCA9IChpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XG4gICAgICB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKTtcbiAgICB9XG4gICAgY29uc3QgeyBidW0sIHNjb3BlLCBqb2IsIHN1YlRyZWUsIHVtLCBtLCBhIH0gPSBpbnN0YW5jZTtcbiAgICBpbnZhbGlkYXRlTW91bnQobSk7XG4gICAgaW52YWxpZGF0ZU1vdW50KGEpO1xuICAgIGlmIChidW0pIHtcbiAgICAgIGludm9rZUFycmF5Rm5zKGJ1bSk7XG4gICAgfVxuICAgIHNjb3BlLnN0b3AoKTtcbiAgICBpZiAoam9iKSB7XG4gICAgICBqb2IuZmxhZ3MgfD0gODtcbiAgICAgIHVubW91bnQoc3ViVHJlZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgfVxuICAgIGlmICh1bSkge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHVtLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICBpbnN0YW5jZS5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmICFwYXJlbnRTdXNwZW5zZS5pc1VubW91bnRlZCAmJiBpbnN0YW5jZS5hc3luY0RlcCAmJiAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCAmJiBpbnN0YW5jZS5zdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcbiAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMtLTtcbiAgICAgIGlmIChwYXJlbnRTdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgICAgIHBhcmVudFN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdW5tb3VudENoaWxkcmVuID0gKGNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSwgc3RhcnQgPSAwKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVubW91bnQoY2hpbGRyZW5baV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlLCBvcHRpbWl6ZWQpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ2V0TmV4dEhvc3ROb2RlID0gKHZub2RlKSA9PiB7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYpIHtcbiAgICAgIHJldHVybiBnZXROZXh0SG9zdE5vZGUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICByZXR1cm4gdm5vZGUuc3VzcGVuc2UubmV4dCgpO1xuICAgIH1cbiAgICBjb25zdCBlbCA9IGhvc3ROZXh0U2libGluZyh2bm9kZS5hbmNob3IgfHwgdm5vZGUuZWwpO1xuICAgIGNvbnN0IHRlbGVwb3J0RW5kID0gZWwgJiYgZWxbVGVsZXBvcnRFbmRLZXldO1xuICAgIHJldHVybiB0ZWxlcG9ydEVuZCA/IGhvc3ROZXh0U2libGluZyh0ZWxlcG9ydEVuZCkgOiBlbDtcbiAgfTtcbiAgbGV0IGlzRmx1c2hpbmcgPSBmYWxzZTtcbiAgY29uc3QgcmVuZGVyID0gKHZub2RlLCBjb250YWluZXIsIG5hbWVzcGFjZSkgPT4ge1xuICAgIGlmICh2bm9kZSA9PSBudWxsKSB7XG4gICAgICBpZiAoY29udGFpbmVyLl92bm9kZSkge1xuICAgICAgICB1bm1vdW50KGNvbnRhaW5lci5fdm5vZGUsIG51bGwsIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaChcbiAgICAgICAgY29udGFpbmVyLl92bm9kZSB8fCBudWxsLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgICBpZiAoIWlzRmx1c2hpbmcpIHtcbiAgICAgIGlzRmx1c2hpbmcgPSB0cnVlO1xuICAgICAgZmx1c2hQcmVGbHVzaENicygpO1xuICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICAgIGlzRmx1c2hpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGludGVybmFscyA9IHtcbiAgICBwOiBwYXRjaCxcbiAgICB1bTogdW5tb3VudCxcbiAgICBtOiBtb3ZlLFxuICAgIHI6IHJlbW92ZSxcbiAgICBtdDogbW91bnRDb21wb25lbnQsXG4gICAgbWM6IG1vdW50Q2hpbGRyZW4sXG4gICAgcGM6IHBhdGNoQ2hpbGRyZW4sXG4gICAgcGJjOiBwYXRjaEJsb2NrQ2hpbGRyZW4sXG4gICAgbjogZ2V0TmV4dEhvc3ROb2RlLFxuICAgIG86IG9wdGlvbnNcbiAgfTtcbiAgbGV0IGh5ZHJhdGU7XG4gIGxldCBoeWRyYXRlTm9kZTtcbiAgaWYgKGNyZWF0ZUh5ZHJhdGlvbkZucykge1xuICAgIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV0gPSBjcmVhdGVIeWRyYXRpb25GbnMoXG4gICAgICBpbnRlcm5hbHNcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVuZGVyLFxuICAgIGh5ZHJhdGUsXG4gICAgY3JlYXRlQXBwOiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKVxuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUNoaWxkcmVuTmFtZXNwYWNlKHsgdHlwZSwgcHJvcHMgfSwgY3VycmVudE5hbWVzcGFjZSkge1xuICByZXR1cm4gY3VycmVudE5hbWVzcGFjZSA9PT0gXCJzdmdcIiAmJiB0eXBlID09PSBcImZvcmVpZ25PYmplY3RcIiB8fCBjdXJyZW50TmFtZXNwYWNlID09PSBcIm1hdGhtbFwiICYmIHR5cGUgPT09IFwiYW5ub3RhdGlvbi14bWxcIiAmJiBwcm9wcyAmJiBwcm9wcy5lbmNvZGluZyAmJiBwcm9wcy5lbmNvZGluZy5pbmNsdWRlcyhcImh0bWxcIikgPyB2b2lkIDAgOiBjdXJyZW50TmFtZXNwYWNlO1xufVxuZnVuY3Rpb24gdG9nZ2xlUmVjdXJzZSh7IGVmZmVjdCwgam9iIH0sIGFsbG93ZWQpIHtcbiAgaWYgKGFsbG93ZWQpIHtcbiAgICBlZmZlY3QuZmxhZ3MgfD0gMzI7XG4gICAgam9iLmZsYWdzIHw9IDQ7XG4gIH0gZWxzZSB7XG4gICAgZWZmZWN0LmZsYWdzICY9IH4zMjtcbiAgICBqb2IuZmxhZ3MgJj0gfjQ7XG4gIH1cbn1cbmZ1bmN0aW9uIG5lZWRUcmFuc2l0aW9uKHBhcmVudFN1c3BlbnNlLCB0cmFuc2l0aW9uKSB7XG4gIHJldHVybiAoIXBhcmVudFN1c3BlbnNlIHx8IHBhcmVudFN1c3BlbnNlICYmICFwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSAmJiB0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZDtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCBzaGFsbG93ID0gZmFsc2UpIHtcbiAgY29uc3QgY2gxID0gbjEuY2hpbGRyZW47XG4gIGNvbnN0IGNoMiA9IG4yLmNoaWxkcmVuO1xuICBpZiAoaXNBcnJheShjaDEpICYmIGlzQXJyYXkoY2gyKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2gxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjMSA9IGNoMVtpXTtcbiAgICAgIGxldCBjMiA9IGNoMltpXTtcbiAgICAgIGlmIChjMi5zaGFwZUZsYWcgJiAxICYmICFjMi5keW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGMyLnBhdGNoRmxhZyA8PSAwIHx8IGMyLnBhdGNoRmxhZyA9PT0gMzIpIHtcbiAgICAgICAgICBjMiA9IGNoMltpXSA9IGNsb25lSWZNb3VudGVkKGNoMltpXSk7XG4gICAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNoYWxsb3cgJiYgYzIucGF0Y2hGbGFnICE9PSAtMilcbiAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKGMxLCBjMik7XG4gICAgICB9XG4gICAgICBpZiAoYzIudHlwZSA9PT0gVGV4dCkge1xuICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYzIudHlwZSA9PT0gQ29tbWVudCAmJiAhYzIuZWwpIHtcbiAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNlcXVlbmNlKGFycikge1xuICBjb25zdCBwID0gYXJyLnNsaWNlKCk7XG4gIGNvbnN0IHJlc3VsdCA9IFswXTtcbiAgbGV0IGksIGosIHUsIHYsIGM7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGFyckkgPSBhcnJbaV07XG4gICAgaWYgKGFyckkgIT09IDApIHtcbiAgICAgIGogPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGFycltqXSA8IGFyckkpIHtcbiAgICAgICAgcFtpXSA9IGo7XG4gICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHUgPSAwO1xuICAgICAgdiA9IHJlc3VsdC5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKHUgPCB2KSB7XG4gICAgICAgIGMgPSB1ICsgdiA+PiAxO1xuICAgICAgICBpZiAoYXJyW3Jlc3VsdFtjXV0gPCBhcnJJKSB7XG4gICAgICAgICAgdSA9IGMgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHYgPSBjO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXJySSA8IGFycltyZXN1bHRbdV1dKSB7XG4gICAgICAgIGlmICh1ID4gMCkge1xuICAgICAgICAgIHBbaV0gPSByZXN1bHRbdSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFt1XSA9IGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHUgPSByZXN1bHQubGVuZ3RoO1xuICB2ID0gcmVzdWx0W3UgLSAxXTtcbiAgd2hpbGUgKHUtLSA+IDApIHtcbiAgICByZXN1bHRbdV0gPSB2O1xuICAgIHYgPSBwW3ZdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsb2NhdGVOb25IeWRyYXRlZEFzeW5jUm9vdChpbnN0YW5jZSkge1xuICBjb25zdCBzdWJDb21wb25lbnQgPSBpbnN0YW5jZS5zdWJUcmVlLmNvbXBvbmVudDtcbiAgaWYgKHN1YkNvbXBvbmVudCkge1xuICAgIGlmIChzdWJDb21wb25lbnQuYXN5bmNEZXAgJiYgIXN1YkNvbXBvbmVudC5hc3luY1Jlc29sdmVkKSB7XG4gICAgICByZXR1cm4gc3ViQ29tcG9uZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbG9jYXRlTm9uSHlkcmF0ZWRBc3luY1Jvb3Qoc3ViQ29tcG9uZW50KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGludmFsaWRhdGVNb3VudChob29rcykge1xuICBpZiAoaG9va3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKVxuICAgICAgaG9va3NbaV0uZmxhZ3MgfD0gODtcbiAgfVxufVxuXG5jb25zdCBzc3JDb250ZXh0S2V5ID0gU3ltYm9sLmZvcihcInYtc2N4XCIpO1xuY29uc3QgdXNlU1NSQ29udGV4dCA9ICgpID0+IHtcbiAge1xuICAgIGNvbnN0IGN0eCA9IGluamVjdChzc3JDb250ZXh0S2V5KTtcbiAgICBpZiAoIWN0eCkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoXG4gICAgICAgIGBTZXJ2ZXIgcmVuZGVyaW5nIGNvbnRleHQgbm90IHByb3ZpZGVkLiBNYWtlIHN1cmUgdG8gb25seSBjYWxsIHVzZVNTUkNvbnRleHQoKSBjb25kaXRpb25hbGx5IGluIHRoZSBzZXJ2ZXIgYnVpbGQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxufTtcblxuZnVuY3Rpb24gd2F0Y2hFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB3YXRjaFBvc3RFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKFxuICAgIGVmZmVjdCxcbiAgICBudWxsLFxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBleHRlbmQoe30sIG9wdGlvbnMsIHsgZmx1c2g6IFwicG9zdFwiIH0pIDogeyBmbHVzaDogXCJwb3N0XCIgfVxuICApO1xufVxuZnVuY3Rpb24gd2F0Y2hTeW5jRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gZG9XYXRjaChcbiAgICBlZmZlY3QsXG4gICAgbnVsbCxcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gZXh0ZW5kKHt9LCBvcHRpb25zLCB7IGZsdXNoOiBcInN5bmNcIiB9KSA6IHsgZmx1c2g6IFwic3luY1wiIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRnVuY3Rpb24oY2IpKSB7XG4gICAgd2FybiQxKFxuICAgICAgYFxcYHdhdGNoKGZuLCBvcHRpb25zPylcXGAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBVc2UgXFxgd2F0Y2hFZmZlY3QoZm4sIG9wdGlvbnM/KVxcYCBpbnN0ZWFkLiBcXGB3YXRjaFxcYCBub3cgb25seSBzdXBwb3J0cyBcXGB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICApO1xuICB9XG4gIHJldHVybiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZG9XYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zID0gRU1QVFlfT0JKKSB7XG4gIGNvbnN0IHsgaW1tZWRpYXRlLCBkZWVwLCBmbHVzaCwgb25jZSB9ID0gb3B0aW9ucztcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWNiKSB7XG4gICAgaWYgKGltbWVkaWF0ZSAhPT0gdm9pZCAwKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGB3YXRjaCgpIFwiaW1tZWRpYXRlXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGRlZXAgIT09IHZvaWQgMCkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgd2F0Y2goKSBcImRlZXBcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob25jZSAhPT0gdm9pZCAwKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGB3YXRjaCgpIFwib25jZVwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGJhc2VXYXRjaE9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkgYmFzZVdhdGNoT3B0aW9ucy5vbldhcm4gPSB3YXJuJDE7XG4gIGxldCBzc3JDbGVhbnVwO1xuICBpZiAoaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XG4gICAgaWYgKGZsdXNoID09PSBcInN5bmNcIikge1xuICAgICAgY29uc3QgY3R4ID0gdXNlU1NSQ29udGV4dCgpO1xuICAgICAgc3NyQ2xlYW51cCA9IGN0eC5fX3dhdGNoZXJIYW5kbGVzIHx8IChjdHguX193YXRjaGVySGFuZGxlcyA9IFtdKTtcbiAgICB9IGVsc2UgaWYgKCFjYiB8fCBpbW1lZGlhdGUpIHtcbiAgICAgIGJhc2VXYXRjaE9wdGlvbnMub25jZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0b3A6IE5PT1AsXG4gICAgICAgIHJlc3VtZTogTk9PUCxcbiAgICAgICAgcGF1c2U6IE5PT1BcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xuICBiYXNlV2F0Y2hPcHRpb25zLmNhbGwgPSAoZm4sIHR5cGUsIGFyZ3MpID0+IGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncyk7XG4gIGxldCBpc1ByZSA9IGZhbHNlO1xuICBpZiAoZmx1c2ggPT09IFwicG9zdFwiKSB7XG4gICAgYmFzZVdhdGNoT3B0aW9ucy5zY2hlZHVsZXIgPSAoam9iKSA9PiB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3Qoam9iLCBpbnN0YW5jZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChmbHVzaCAhPT0gXCJzeW5jXCIpIHtcbiAgICBpc1ByZSA9IHRydWU7XG4gICAgYmFzZVdhdGNoT3B0aW9ucy5zY2hlZHVsZXIgPSAoam9iLCBpc0ZpcnN0UnVuKSA9PiB7XG4gICAgICBpZiAoaXNGaXJzdFJ1bikge1xuICAgICAgICBqb2IoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSm9iKGpvYik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBiYXNlV2F0Y2hPcHRpb25zLmF1Z21lbnRKb2IgPSAoam9iKSA9PiB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBqb2IuZmxhZ3MgfD0gNDtcbiAgICB9XG4gICAgaWYgKGlzUHJlKSB7XG4gICAgICBqb2IuZmxhZ3MgfD0gMjtcbiAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICBqb2IuaWQgPSBpbnN0YW5jZS51aWQ7XG4gICAgICAgIGpvYi5pID0gaW5zdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCB3YXRjaEhhbmRsZSA9IHdhdGNoJDEoc291cmNlLCBjYiwgYmFzZVdhdGNoT3B0aW9ucyk7XG4gIGlmIChzc3JDbGVhbnVwKSBzc3JDbGVhbnVwLnB1c2god2F0Y2hIYW5kbGUpO1xuICByZXR1cm4gd2F0Y2hIYW5kbGU7XG59XG5mdW5jdGlvbiBpbnN0YW5jZVdhdGNoKHNvdXJjZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgcHVibGljVGhpcyA9IHRoaXMucHJveHk7XG4gIGNvbnN0IGdldHRlciA9IGlzU3RyaW5nKHNvdXJjZSkgPyBzb3VyY2UuaW5jbHVkZXMoXCIuXCIpID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBzb3VyY2UpIDogKCkgPT4gcHVibGljVGhpc1tzb3VyY2VdIDogc291cmNlLmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcyk7XG4gIGxldCBjYjtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgY2IgPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBjYiA9IHZhbHVlLmhhbmRsZXI7XG4gICAgb3B0aW9ucyA9IHZhbHVlO1xuICB9XG4gIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKHRoaXMpO1xuICBjb25zdCByZXMgPSBkb1dhdGNoKGdldHRlciwgY2IuYmluZChwdWJsaWNUaGlzKSwgb3B0aW9ucyk7XG4gIHJlc2V0KCk7XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRoR2V0dGVyKGN0eCwgcGF0aCkge1xuICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBjdXIgPSBjdHg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGggJiYgY3VyOyBpKyspIHtcbiAgICAgIGN1ciA9IGN1cltzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBjdXI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU1vZGVsKHByb3BzLCBuYW1lLCBvcHRpb25zID0gRU1QVFlfT0JKKSB7XG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWkpIHtcbiAgICB3YXJuJDEoYHVzZU1vZGVsKCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xuICAgIHJldHVybiByZWYoKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaS5wcm9wc09wdGlvbnNbMF1bbmFtZV0pIHtcbiAgICB3YXJuJDEoYHVzZU1vZGVsKCkgY2FsbGVkIHdpdGggcHJvcCBcIiR7bmFtZX1cIiB3aGljaCBpcyBub3QgZGVjbGFyZWQuYCk7XG4gICAgcmV0dXJuIHJlZigpO1xuICB9XG4gIGNvbnN0IGNhbWVsaXplZE5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgY29uc3QgaHlwaGVuYXRlZE5hbWUgPSBoeXBoZW5hdGUobmFtZSk7XG4gIGNvbnN0IG1vZGlmaWVycyA9IGdldE1vZGVsTW9kaWZpZXJzKHByb3BzLCBuYW1lKTtcbiAgY29uc3QgcmVzID0gY3VzdG9tUmVmKCh0cmFjaywgdHJpZ2dlcikgPT4ge1xuICAgIGxldCBsb2NhbFZhbHVlO1xuICAgIGxldCBwcmV2U2V0VmFsdWUgPSBFTVBUWV9PQko7XG4gICAgbGV0IHByZXZFbWl0dGVkVmFsdWU7XG4gICAgd2F0Y2hTeW5jRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IHByb3BWYWx1ZSA9IHByb3BzW25hbWVdO1xuICAgICAgaWYgKGhhc0NoYW5nZWQobG9jYWxWYWx1ZSwgcHJvcFZhbHVlKSkge1xuICAgICAgICBsb2NhbFZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICB0cmlnZ2VyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgdHJhY2soKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZ2V0ID8gb3B0aW9ucy5nZXQobG9jYWxWYWx1ZSkgOiBsb2NhbFZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBlbWl0dGVkVmFsdWUgPSBvcHRpb25zLnNldCA/IG9wdGlvbnMuc2V0KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICBpZiAoIWhhc0NoYW5nZWQoZW1pdHRlZFZhbHVlLCBsb2NhbFZhbHVlKSAmJiAhKHByZXZTZXRWYWx1ZSAhPT0gRU1QVFlfT0JKICYmIGhhc0NoYW5nZWQodmFsdWUsIHByZXZTZXRWYWx1ZSkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhd1Byb3BzID0gaS52bm9kZS5wcm9wcztcbiAgICAgICAgaWYgKCEocmF3UHJvcHMgJiYgLy8gY2hlY2sgaWYgcGFyZW50IGhhcyBwYXNzZWQgdi1tb2RlbFxuICAgICAgICAobmFtZSBpbiByYXdQcm9wcyB8fCBjYW1lbGl6ZWROYW1lIGluIHJhd1Byb3BzIHx8IGh5cGhlbmF0ZWROYW1lIGluIHJhd1Byb3BzKSAmJiAoYG9uVXBkYXRlOiR7bmFtZX1gIGluIHJhd1Byb3BzIHx8IGBvblVwZGF0ZToke2NhbWVsaXplZE5hbWV9YCBpbiByYXdQcm9wcyB8fCBgb25VcGRhdGU6JHtoeXBoZW5hdGVkTmFtZX1gIGluIHJhd1Byb3BzKSkpIHtcbiAgICAgICAgICBsb2NhbFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdHJpZ2dlcigpO1xuICAgICAgICB9XG4gICAgICAgIGkuZW1pdChgdXBkYXRlOiR7bmFtZX1gLCBlbWl0dGVkVmFsdWUpO1xuICAgICAgICBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgZW1pdHRlZFZhbHVlKSAmJiBoYXNDaGFuZ2VkKHZhbHVlLCBwcmV2U2V0VmFsdWUpICYmICFoYXNDaGFuZ2VkKGVtaXR0ZWRWYWx1ZSwgcHJldkVtaXR0ZWRWYWx1ZSkpIHtcbiAgICAgICAgICB0cmlnZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldlNldFZhbHVlID0gdmFsdWU7XG4gICAgICAgIHByZXZFbWl0dGVkVmFsdWUgPSBlbWl0dGVkVmFsdWU7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJlc1tTeW1ib2wuaXRlcmF0b3JdID0gKCkgPT4ge1xuICAgIGxldCBpMiA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGlmIChpMiA8IDIpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaTIrKyA/IG1vZGlmaWVycyB8fCBFTVBUWV9PQkogOiByZXMsIGRvbmU6IGZhbHNlIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHJlcztcbn1cbmNvbnN0IGdldE1vZGVsTW9kaWZpZXJzID0gKHByb3BzLCBtb2RlbE5hbWUpID0+IHtcbiAgcmV0dXJuIG1vZGVsTmFtZSA9PT0gXCJtb2RlbFZhbHVlXCIgfHwgbW9kZWxOYW1lID09PSBcIm1vZGVsLXZhbHVlXCIgPyBwcm9wcy5tb2RlbE1vZGlmaWVycyA6IHByb3BzW2Ake21vZGVsTmFtZX1Nb2RpZmllcnNgXSB8fCBwcm9wc1tgJHtjYW1lbGl6ZShtb2RlbE5hbWUpfU1vZGlmaWVyc2BdIHx8IHByb3BzW2Ake2h5cGhlbmF0ZShtb2RlbE5hbWUpfU1vZGlmaWVyc2BdO1xufTtcblxuZnVuY3Rpb24gZW1pdChpbnN0YW5jZSwgZXZlbnQsIC4uLnJhd0FyZ3MpIHtcbiAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkKSByZXR1cm47XG4gIGNvbnN0IHByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVtaXRzT3B0aW9ucyxcbiAgICAgIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc11cbiAgICB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKGVtaXRzT3B0aW9ucykge1xuICAgICAgaWYgKCEoZXZlbnQgaW4gZW1pdHNPcHRpb25zKSAmJiB0cnVlKSB7XG4gICAgICAgIGlmICghcHJvcHNPcHRpb25zIHx8ICEodG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSkgaW4gcHJvcHNPcHRpb25zKSkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBDb21wb25lbnQgZW1pdHRlZCBldmVudCBcIiR7ZXZlbnR9XCIgYnV0IGl0IGlzIG5laXRoZXIgZGVjbGFyZWQgaW4gdGhlIGVtaXRzIG9wdGlvbiBub3IgYXMgYW4gXCIke3RvSGFuZGxlcktleShjYW1lbGl6ZShldmVudCkpfVwiIHByb3AuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGVtaXRzT3B0aW9uc1tldmVudF07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbGlkYXRvcikpIHtcbiAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdG9yKC4uLnJhd0FyZ3MpO1xuICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgSW52YWxpZCBldmVudCBhcmd1bWVudHM6IGV2ZW50IHZhbGlkYXRpb24gZmFpbGVkIGZvciBldmVudCBcIiR7ZXZlbnR9XCIuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGFyZ3MgPSByYXdBcmdzO1xuICBjb25zdCBpc01vZGVsTGlzdGVuZXIgPSBldmVudC5zdGFydHNXaXRoKFwidXBkYXRlOlwiKTtcbiAgY29uc3QgbW9kaWZpZXJzID0gaXNNb2RlbExpc3RlbmVyICYmIGdldE1vZGVsTW9kaWZpZXJzKHByb3BzLCBldmVudC5zbGljZSg3KSk7XG4gIGlmIChtb2RpZmllcnMpIHtcbiAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcCgoYSkgPT4gaXNTdHJpbmcoYSkgPyBhLnRyaW0oKSA6IGEpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKGxvb3NlVG9OdW1iZXIpO1xuICAgIH1cbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc0NvbXBvbmVudEVtaXQoaW5zdGFuY2UsIGV2ZW50LCBhcmdzKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHByb3BzW3RvSGFuZGxlcktleShsb3dlckNhc2VFdmVudCldKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBFdmVudCBcIiR7bG93ZXJDYXNlRXZlbnR9XCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgJHtmb3JtYXRDb21wb25lbnROYW1lKFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIGluc3RhbmNlLnR5cGVcbiAgICAgICAgKX0gYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFwiJHtldmVudH1cIi4gTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2Ugdi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHtoeXBoZW5hdGUoXG4gICAgICAgICAgZXZlbnRcbiAgICAgICAgKX1cIiBpbnN0ZWFkIG9mIFwiJHtldmVudH1cIi5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBsZXQgaGFuZGxlck5hbWU7XG4gIGxldCBoYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoZXZlbnQpXSB8fCAvLyBhbHNvIHRyeSBjYW1lbENhc2UgZXZlbnQgaGFuZGxlciAoIzIyNDkpXG4gIHByb3BzW2hhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSldO1xuICBpZiAoIWhhbmRsZXIgJiYgaXNNb2RlbExpc3RlbmVyKSB7XG4gICAgaGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGh5cGhlbmF0ZShldmVudCkpXTtcbiAgfVxuICBpZiAoaGFuZGxlcikge1xuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgaGFuZGxlcixcbiAgICAgIGluc3RhbmNlLFxuICAgICAgNixcbiAgICAgIGFyZ3NcbiAgICApO1xuICB9XG4gIGNvbnN0IG9uY2VIYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgKyBgT25jZWBdO1xuICBpZiAob25jZUhhbmRsZXIpIHtcbiAgICBpZiAoIWluc3RhbmNlLmVtaXR0ZWQpIHtcbiAgICAgIGluc3RhbmNlLmVtaXR0ZWQgPSB7fTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdID0gdHJ1ZTtcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIG9uY2VIYW5kbGVyLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA2LFxuICAgICAgYXJnc1xuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcbiAgY29uc3QgY2FjaGUgPSBhcHBDb250ZXh0LmVtaXRzQ2FjaGU7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcbiAgaWYgKGNhY2hlZCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBjb25zdCByYXcgPSBjb21wLmVtaXRzO1xuICBsZXQgbm9ybWFsaXplZCA9IHt9O1xuICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xuICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgIGNvbnN0IGV4dGVuZEVtaXRzID0gKHJhdzIpID0+IHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGcm9tRXh0ZW5kID0gbm9ybWFsaXplRW1pdHNPcHRpb25zKHJhdzIsIGFwcENvbnRleHQsIHRydWUpO1xuICAgICAgaWYgKG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKSB7XG4gICAgICAgIGhhc0V4dGVuZHMgPSB0cnVlO1xuICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgbm9ybWFsaXplZEZyb21FeHRlbmQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xuICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XG4gICAgfVxuICAgIGlmIChjb21wLmV4dGVuZHMpIHtcbiAgICAgIGV4dGVuZEVtaXRzKGNvbXAuZXh0ZW5kcyk7XG4gICAgfVxuICAgIGlmIChjb21wLm1peGlucykge1xuICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XG4gICAgfVxuICB9XG4gIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XG4gICAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgICBjYWNoZS5zZXQoY29tcCwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICByYXcuZm9yRWFjaCgoa2V5KSA9PiBub3JtYWxpemVkW2tleV0gPSBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICBleHRlbmQobm9ybWFsaXplZCwgcmF3KTtcbiAgfVxuICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICBjYWNoZS5zZXQoY29tcCwgbm9ybWFsaXplZCk7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5mdW5jdGlvbiBpc0VtaXRMaXN0ZW5lcihvcHRpb25zLCBrZXkpIHtcbiAgaWYgKCFvcHRpb25zIHx8ICFpc09uKGtleSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAga2V5ID0ga2V5LnNsaWNlKDIpLnJlcGxhY2UoL09uY2UkLywgXCJcIik7XG4gIHJldHVybiBoYXNPd24ob3B0aW9ucywga2V5WzBdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSkpIHx8IGhhc093bihvcHRpb25zLCBoeXBoZW5hdGUoa2V5KSkgfHwgaGFzT3duKG9wdGlvbnMsIGtleSk7XG59XG5cbmxldCBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XG5mdW5jdGlvbiBtYXJrQXR0cnNBY2Nlc3NlZCgpIHtcbiAgYWNjZXNzZWRBdHRycyA9IHRydWU7XG59XG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSB7XG4gIGNvbnN0IHtcbiAgICB0eXBlOiBDb21wb25lbnQsXG4gICAgdm5vZGUsXG4gICAgcHJveHksXG4gICAgd2l0aFByb3h5LFxuICAgIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10sXG4gICAgc2xvdHMsXG4gICAgYXR0cnMsXG4gICAgZW1pdCxcbiAgICByZW5kZXIsXG4gICAgcmVuZGVyQ2FjaGUsXG4gICAgcHJvcHMsXG4gICAgZGF0YSxcbiAgICBzZXR1cFN0YXRlLFxuICAgIGN0eCxcbiAgICBpbmhlcml0QXR0cnNcbiAgfSA9IGluc3RhbmNlO1xuICBjb25zdCBwcmV2ID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKTtcbiAgbGV0IHJlc3VsdDtcbiAgbGV0IGZhbGx0aHJvdWdoQXR0cnM7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDQpIHtcbiAgICAgIGNvbnN0IHByb3h5VG9Vc2UgPSB3aXRoUHJveHkgfHwgcHJveHk7XG4gICAgICBjb25zdCB0aGlzUHJveHkgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwID8gbmV3IFByb3h5KHByb3h5VG9Vc2UsIHtcbiAgICAgICAgZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBQcm9wZXJ0eSAnJHtTdHJpbmcoXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKX0nIHdhcyBhY2Nlc3NlZCB2aWEgJ3RoaXMnLiBBdm9pZCB1c2luZyAndGhpcycgaW4gdGVtcGxhdGVzLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xuICAgICAgICB9XG4gICAgICB9KSA6IHByb3h5VG9Vc2U7XG4gICAgICByZXN1bHQgPSBub3JtYWxpemVWTm9kZShcbiAgICAgICAgcmVuZGVyLmNhbGwoXG4gICAgICAgICAgdGhpc1Byb3h5LFxuICAgICAgICAgIHByb3h5VG9Vc2UsXG4gICAgICAgICAgcmVuZGVyQ2FjaGUsXG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShwcm9wcykgOiBwcm9wcyxcbiAgICAgICAgICBzZXR1cFN0YXRlLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgY3R4XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBmYWxsdGhyb3VnaEF0dHJzID0gYXR0cnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlbmRlcjIgPSBDb21wb25lbnQ7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBhdHRycyA9PT0gcHJvcHMpIHtcbiAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKFxuICAgICAgICByZW5kZXIyLmxlbmd0aCA+IDEgPyByZW5kZXIyKFxuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkocHJvcHMpIDogcHJvcHMsXG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHtcbiAgICAgICAgICAgIGdldCBhdHRycygpIHtcbiAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3dSZWFkb25seShhdHRycyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2xvdHMsXG4gICAgICAgICAgICBlbWl0XG4gICAgICAgICAgfSA6IHsgYXR0cnMsIHNsb3RzLCBlbWl0IH1cbiAgICAgICAgKSA6IHJlbmRlcjIoXG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShwcm9wcykgOiBwcm9wcyxcbiAgICAgICAgICBudWxsXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBmYWxsdGhyb3VnaEF0dHJzID0gQ29tcG9uZW50LnByb3BzID8gYXR0cnMgOiBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2goYXR0cnMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgYmxvY2tTdGFjay5sZW5ndGggPSAwO1xuICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDEpO1xuICAgIHJlc3VsdCA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICB9XG4gIGxldCByb290ID0gcmVzdWx0O1xuICBsZXQgc2V0Um9vdCA9IHZvaWQgMDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcmVzdWx0LnBhdGNoRmxhZyA+IDAgJiYgcmVzdWx0LnBhdGNoRmxhZyAmIDIwNDgpIHtcbiAgICBbcm9vdCwgc2V0Um9vdF0gPSBnZXRDaGlsZFJvb3QocmVzdWx0KTtcbiAgfVxuICBpZiAoZmFsbHRocm91Z2hBdHRycyAmJiBpbmhlcml0QXR0cnMgIT09IGZhbHNlKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZhbGx0aHJvdWdoQXR0cnMpO1xuICAgIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSByb290O1xuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgaWYgKHNoYXBlRmxhZyAmICgxIHwgNikpIHtcbiAgICAgICAgaWYgKHByb3BzT3B0aW9ucyAmJiBrZXlzLnNvbWUoaXNNb2RlbExpc3RlbmVyKSkge1xuICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBmaWx0ZXJNb2RlbExpc3RlbmVycyhcbiAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMsXG4gICAgICAgICAgICBwcm9wc09wdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QgPSBjbG9uZVZOb2RlKHJvb3QsIGZhbGx0aHJvdWdoQXR0cnMsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhYWNjZXNzZWRBdHRycyAmJiByb290LnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgY29uc3QgYWxsQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycyk7XG4gICAgICAgIGNvbnN0IGV2ZW50QXR0cnMgPSBbXTtcbiAgICAgICAgY29uc3QgZXh0cmFBdHRycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFsbEF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGFsbEF0dHJzW2ldO1xuICAgICAgICAgIGlmIChpc09uKGtleSkpIHtcbiAgICAgICAgICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkpIHtcbiAgICAgICAgICAgICAgZXZlbnRBdHRycy5wdXNoKGtleVsyXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXh0cmFBdHRycy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHRyYUF0dHJzLmxlbmd0aCkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBFeHRyYW5lb3VzIG5vbi1wcm9wcyBhdHRyaWJ1dGVzICgke2V4dHJhQXR0cnMuam9pbihcIiwgXCIpfSkgd2VyZSBwYXNzZWQgdG8gY29tcG9uZW50IGJ1dCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBpbmhlcml0ZWQgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IHJvb3Qgbm9kZXMuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50QXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEV4dHJhbmVvdXMgbm9uLWVtaXRzIGV2ZW50IGxpc3RlbmVycyAoJHtldmVudEF0dHJzLmpvaW4oXCIsIFwiKX0pIHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLiBJZiB0aGUgbGlzdGVuZXIgaXMgaW50ZW5kZWQgdG8gYmUgYSBjb21wb25lbnQgY3VzdG9tIGV2ZW50IGxpc3RlbmVyIG9ubHksIGRlY2xhcmUgaXQgdXNpbmcgdGhlIFwiZW1pdHNcIiBvcHRpb24uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZub2RlLmRpcnMpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgUnVudGltZSBkaXJlY3RpdmUgdXNlZCBvbiBjb21wb25lbnQgd2l0aCBub24tZWxlbWVudCByb290IG5vZGUuIFRoZSBkaXJlY3RpdmVzIHdpbGwgbm90IGZ1bmN0aW9uIGFzIGludGVuZGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJvb3QgPSBjbG9uZVZOb2RlKHJvb3QsIG51bGwsIGZhbHNlLCB0cnVlKTtcbiAgICByb290LmRpcnMgPSByb290LmRpcnMgPyByb290LmRpcnMuY29uY2F0KHZub2RlLmRpcnMpIDogdm5vZGUuZGlycztcbiAgfVxuICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBDb21wb25lbnQgaW5zaWRlIDxUcmFuc2l0aW9uPiByZW5kZXJzIG5vbi1lbGVtZW50IHJvb3Qgbm9kZSB0aGF0IGNhbm5vdCBiZSBhbmltYXRlZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByb290LnRyYW5zaXRpb24gPSB2bm9kZS50cmFuc2l0aW9uO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldFJvb3QpIHtcbiAgICBzZXRSb290KHJvb3QpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHJvb3Q7XG4gIH1cbiAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXYpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZ2V0Q2hpbGRSb290ID0gKHZub2RlKSA9PiB7XG4gIGNvbnN0IHJhd0NoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gIGNvbnN0IGR5bmFtaWNDaGlsZHJlbiA9IHZub2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgY29uc3QgY2hpbGRSb290ID0gZmlsdGVyU2luZ2xlUm9vdChyYXdDaGlsZHJlbiwgZmFsc2UpO1xuICBpZiAoIWNoaWxkUm9vdCkge1xuICAgIHJldHVybiBbdm5vZGUsIHZvaWQgMF07XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGlsZFJvb3QucGF0Y2hGbGFnID4gMCAmJiBjaGlsZFJvb3QucGF0Y2hGbGFnICYgMjA0OCkge1xuICAgIHJldHVybiBnZXRDaGlsZFJvb3QoY2hpbGRSb290KTtcbiAgfVxuICBjb25zdCBpbmRleCA9IHJhd0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KTtcbiAgY29uc3QgZHluYW1pY0luZGV4ID0gZHluYW1pY0NoaWxkcmVuID8gZHluYW1pY0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KSA6IC0xO1xuICBjb25zdCBzZXRSb290ID0gKHVwZGF0ZWRSb290KSA9PiB7XG4gICAgcmF3Q2hpbGRyZW5baW5kZXhdID0gdXBkYXRlZFJvb3Q7XG4gICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgaWYgKGR5bmFtaWNJbmRleCA+IC0xKSB7XG4gICAgICAgIGR5bmFtaWNDaGlsZHJlbltkeW5hbWljSW5kZXhdID0gdXBkYXRlZFJvb3Q7XG4gICAgICB9IGVsc2UgaWYgKHVwZGF0ZWRSb290LnBhdGNoRmxhZyA+IDApIHtcbiAgICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gWy4uLmR5bmFtaWNDaGlsZHJlbiwgdXBkYXRlZFJvb3RdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFtub3JtYWxpemVWTm9kZShjaGlsZFJvb3QpLCBzZXRSb290XTtcbn07XG5mdW5jdGlvbiBmaWx0ZXJTaW5nbGVSb290KGNoaWxkcmVuLCByZWN1cnNlID0gdHJ1ZSkge1xuICBsZXQgc2luZ2xlUm9vdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVk5vZGUoY2hpbGQpKSB7XG4gICAgICBpZiAoY2hpbGQudHlwZSAhPT0gQ29tbWVudCB8fCBjaGlsZC5jaGlsZHJlbiA9PT0gXCJ2LWlmXCIpIHtcbiAgICAgICAgaWYgKHNpbmdsZVJvb3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2luZ2xlUm9vdCA9IGNoaWxkO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHJlY3Vyc2UgJiYgc2luZ2xlUm9vdC5wYXRjaEZsYWcgPiAwICYmIHNpbmdsZVJvb3QucGF0Y2hGbGFnICYgMjA0OCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlclNpbmdsZVJvb3Qoc2luZ2xlUm9vdC5jaGlsZHJlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNpbmdsZVJvb3Q7XG59XG5jb25zdCBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2ggPSAoYXR0cnMpID0+IHtcbiAgbGV0IHJlcztcbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICBpZiAoa2V5ID09PSBcImNsYXNzXCIgfHwga2V5ID09PSBcInN0eWxlXCIgfHwgaXNPbihrZXkpKSB7XG4gICAgICAocmVzIHx8IChyZXMgPSB7fSkpW2tleV0gPSBhdHRyc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGZpbHRlck1vZGVsTGlzdGVuZXJzID0gKGF0dHJzLCBwcm9wcykgPT4ge1xuICBjb25zdCByZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpIHx8ICEoa2V5LnNsaWNlKDkpIGluIHByb3BzKSkge1xuICAgICAgcmVzW2tleV0gPSBhdHRyc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGlzRWxlbWVudFJvb3QgPSAodm5vZGUpID0+IHtcbiAgcmV0dXJuIHZub2RlLnNoYXBlRmxhZyAmICg2IHwgMSkgfHwgdm5vZGUudHlwZSA9PT0gQ29tbWVudDtcbn07XG5mdW5jdGlvbiBzaG91bGRVcGRhdGVDb21wb25lbnQocHJldlZOb2RlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkge1xuICBjb25zdCB7IHByb3BzOiBwcmV2UHJvcHMsIGNoaWxkcmVuOiBwcmV2Q2hpbGRyZW4sIGNvbXBvbmVudCB9ID0gcHJldlZOb2RlO1xuICBjb25zdCB7IHByb3BzOiBuZXh0UHJvcHMsIGNoaWxkcmVuOiBuZXh0Q2hpbGRyZW4sIHBhdGNoRmxhZyB9ID0gbmV4dFZOb2RlO1xuICBjb25zdCBlbWl0cyA9IGNvbXBvbmVudC5lbWl0c09wdGlvbnM7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG5leHRWTm9kZS5kaXJzIHx8IG5leHRWTm9kZS50cmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9wdGltaXplZCAmJiBwYXRjaEZsYWcgPj0gMCkge1xuICAgIGlmIChwYXRjaEZsYWcgJiAxMDI0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHBhdGNoRmxhZyAmIDE2KSB7XG4gICAgICBpZiAoIXByZXZQcm9wcykge1xuICAgICAgICByZXR1cm4gISFuZXh0UHJvcHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XG4gICAgfSBlbHNlIGlmIChwYXRjaEZsYWcgJiA4KSB7XG4gICAgICBjb25zdCBkeW5hbWljUHJvcHMgPSBuZXh0Vk5vZGUuZHluYW1pY1Byb3BzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZHluYW1pY1Byb3BzW2ldO1xuICAgICAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmICFpc0VtaXRMaXN0ZW5lcihlbWl0cywga2V5KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSB7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbiB8fCAhbmV4dENoaWxkcmVuLiRzdGFibGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2UHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXByZXZQcm9wcykge1xuICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xuICAgIH1cbiAgICBpZiAoIW5leHRQcm9wcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzT3B0aW9ucykge1xuICBjb25zdCBuZXh0S2V5cyA9IE9iamVjdC5rZXlzKG5leHRQcm9wcyk7XG4gIGlmIChuZXh0S2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKHByZXZQcm9wcykubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0S2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IG5leHRLZXlzW2ldO1xuICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiYgIWlzRW1pdExpc3RlbmVyKGVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUhPQ0hvc3RFbCh7IHZub2RlLCBwYXJlbnQgfSwgZWwpIHtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGNvbnN0IHJvb3QgPSBwYXJlbnQuc3ViVHJlZTtcbiAgICBpZiAocm9vdC5zdXNwZW5zZSAmJiByb290LnN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9PT0gdm5vZGUpIHtcbiAgICAgIHJvb3QuZWwgPSB2bm9kZS5lbDtcbiAgICB9XG4gICAgaWYgKHJvb3QgPT09IHZub2RlKSB7XG4gICAgICAodm5vZGUgPSBwYXJlbnQudm5vZGUpLmVsID0gZWw7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaXNTdXNwZW5zZSA9ICh0eXBlKSA9PiB0eXBlLl9faXNTdXNwZW5zZTtcbmxldCBzdXNwZW5zZUlkID0gMDtcbmNvbnN0IFN1c3BlbnNlSW1wbCA9IHtcbiAgbmFtZTogXCJTdXNwZW5zZVwiLFxuICAvLyBJbiBvcmRlciB0byBtYWtlIFN1c3BlbnNlIHRyZWUtc2hha2FibGUsIHdlIG5lZWQgdG8gYXZvaWQgaW1wb3J0aW5nIGl0XG4gIC8vIGRpcmVjdGx5IGluIHRoZSByZW5kZXJlci4gVGhlIHJlbmRlcmVyIGNoZWNrcyBmb3IgdGhlIF9faXNTdXNwZW5zZSBmbGFnXG4gIC8vIG9uIGEgdm5vZGUncyB0eXBlIGFuZCBjYWxscyB0aGUgYHByb2Nlc3NgIG1ldGhvZCwgcGFzc2luZyBpbiByZW5kZXJlclxuICAvLyBpbnRlcm5hbHMuXG4gIF9faXNTdXNwZW5zZTogdHJ1ZSxcbiAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykge1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBtb3VudFN1c3BlbnNlKFxuICAgICAgICBuMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIHJlbmRlcmVySW50ZXJuYWxzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UuZGVwcyA+IDAgJiYgIW4xLnN1c3BlbnNlLmlzSW5GYWxsYmFjaykge1xuICAgICAgICBuMi5zdXNwZW5zZSA9IG4xLnN1c3BlbnNlO1xuICAgICAgICBuMi5zdXNwZW5zZS52bm9kZSA9IG4yO1xuICAgICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwYXRjaFN1c3BlbnNlKFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIHJlbmRlcmVySW50ZXJuYWxzXG4gICAgICApO1xuICAgIH1cbiAgfSxcbiAgaHlkcmF0ZTogaHlkcmF0ZVN1c3BlbnNlLFxuICBub3JtYWxpemU6IG5vcm1hbGl6ZVN1c3BlbnNlQ2hpbGRyZW5cbn07XG5jb25zdCBTdXNwZW5zZSA9IFN1c3BlbnNlSW1wbCA7XG5mdW5jdGlvbiB0cmlnZ2VyRXZlbnQodm5vZGUsIG5hbWUpIHtcbiAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzW25hbWVdO1xuICBpZiAoaXNGdW5jdGlvbihldmVudExpc3RlbmVyKSkge1xuICAgIGV2ZW50TGlzdGVuZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gIGNvbnN0IHtcbiAgICBwOiBwYXRjaCxcbiAgICBvOiB7IGNyZWF0ZUVsZW1lbnQgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGNvbnN0IGhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgIHZub2RlLFxuICAgIHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBjb250YWluZXIsXG4gICAgaGlkZGVuQ29udGFpbmVyLFxuICAgIGFuY2hvcixcbiAgICBuYW1lc3BhY2UsXG4gICAgc2xvdFNjb3BlSWRzLFxuICAgIG9wdGltaXplZCxcbiAgICByZW5kZXJlckludGVybmFsc1xuICApO1xuICBwYXRjaChcbiAgICBudWxsLFxuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQsXG4gICAgaGlkZGVuQ29udGFpbmVyLFxuICAgIG51bGwsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIHN1c3BlbnNlLFxuICAgIG5hbWVzcGFjZSxcbiAgICBzbG90U2NvcGVJZHNcbiAgKTtcbiAgaWYgKHN1c3BlbnNlLmRlcHMgPiAwKSB7XG4gICAgdHJpZ2dlckV2ZW50KHZub2RlLCBcIm9uUGVuZGluZ1wiKTtcbiAgICB0cmlnZ2VyRXZlbnQodm5vZGUsIFwib25GYWxsYmFja1wiKTtcbiAgICBwYXRjaChcbiAgICAgIG51bGwsXG4gICAgICB2bm9kZS5zc0ZhbGxiYWNrLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgYW5jaG9yLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgbnVsbCxcbiAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBzbG90U2NvcGVJZHNcbiAgICApO1xuICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgdm5vZGUuc3NGYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgc3VzcGVuc2UucmVzb2x2ZShmYWxzZSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoU3VzcGVuc2UobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IHA6IHBhdGNoLCB1bTogdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSkge1xuICBjb25zdCBzdXNwZW5zZSA9IG4yLnN1c3BlbnNlID0gbjEuc3VzcGVuc2U7XG4gIHN1c3BlbnNlLnZub2RlID0gbjI7XG4gIG4yLmVsID0gbjEuZWw7XG4gIGNvbnN0IG5ld0JyYW5jaCA9IG4yLnNzQ29udGVudDtcbiAgY29uc3QgbmV3RmFsbGJhY2sgPSBuMi5zc0ZhbGxiYWNrO1xuICBjb25zdCB7IGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgaXNJbkZhbGxiYWNrLCBpc0h5ZHJhdGluZyB9ID0gc3VzcGVuc2U7XG4gIGlmIChwZW5kaW5nQnJhbmNoKSB7XG4gICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcbiAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgcGVuZGluZ0JyYW5jaCkpIHtcbiAgICAgIHBhdGNoKFxuICAgICAgICBwZW5kaW5nQnJhbmNoLFxuICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIGlmIChpc0luRmFsbGJhY2spIHtcbiAgICAgICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICAgICAgbmV3RmFsbGJhY2ssXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VzcGVuc2UucGVuZGluZ0lkID0gc3VzcGVuc2VJZCsrO1xuICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IHBlbmRpbmdCcmFuY2g7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bm1vdW50KHBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UpO1xuICAgICAgfVxuICAgICAgc3VzcGVuc2UuZGVwcyA9IDA7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLmxlbmd0aCA9IDA7XG4gICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgaWYgKGlzSW5GYWxsYmFjaykge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICAgIG5ld0ZhbGxiYWNrLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xuICAgICAgcGF0Y2goXG4gICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3QnJhbmNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlckV2ZW50KG4yLCBcIm9uUGVuZGluZ1wiKTtcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XG4gICAgICBpZiAobmV3QnJhbmNoLnNoYXBlRmxhZyAmIDUxMikge1xuICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQgPSBuZXdCcmFuY2guY29tcG9uZW50LnN1c3BlbnNlSWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQgPSBzdXNwZW5zZUlkKys7XG4gICAgICB9XG4gICAgICBwYXRjaChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgdGltZW91dCwgcGVuZGluZ0lkIH0gPSBzdXNwZW5zZTtcbiAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0lkID09PSBwZW5kaW5nSWQpIHtcbiAgICAgICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudFN1c3BlbnNlLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaGlkZGVuQ29udGFpbmVyLCBhbmNob3IsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBpc0h5ZHJhdGluZyA9IGZhbHNlKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUgJiYgIWhhc1dhcm5lZCkge1xuICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyBcImluZm9cIiA6IFwibG9nXCJdKFxuICAgICAgYDxTdXNwZW5zZT4gaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUgYW5kIGl0cyBBUEkgd2lsbCBsaWtlbHkgY2hhbmdlLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwOiBwYXRjaCxcbiAgICBtOiBtb3ZlLFxuICAgIHVtOiB1bm1vdW50LFxuICAgIG46IG5leHQsXG4gICAgbzogeyBwYXJlbnROb2RlLCByZW1vdmUgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGxldCBwYXJlbnRTdXNwZW5zZUlkO1xuICBjb25zdCBpc1N1c3BlbnNpYmxlID0gaXNWTm9kZVN1c3BlbnNpYmxlKHZub2RlKTtcbiAgaWYgKGlzU3VzcGVuc2libGUpIHtcbiAgICBpZiAocGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgcGFyZW50U3VzcGVuc2VJZCA9IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdJZDtcbiAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMrKztcbiAgICB9XG4gIH1cbiAgY29uc3QgdGltZW91dCA9IHZub2RlLnByb3BzID8gdG9OdW1iZXIodm5vZGUucHJvcHMudGltZW91dCkgOiB2b2lkIDA7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgYXNzZXJ0TnVtYmVyKHRpbWVvdXQsIGBTdXNwZW5zZSB0aW1lb3V0YCk7XG4gIH1cbiAgY29uc3QgaW5pdGlhbEFuY2hvciA9IGFuY2hvcjtcbiAgY29uc3Qgc3VzcGVuc2UgPSB7XG4gICAgdm5vZGUsXG4gICAgcGFyZW50OiBwYXJlbnRTdXNwZW5zZSxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgbmFtZXNwYWNlLFxuICAgIGNvbnRhaW5lcixcbiAgICBoaWRkZW5Db250YWluZXIsXG4gICAgZGVwczogMCxcbiAgICBwZW5kaW5nSWQ6IHN1c3BlbnNlSWQrKyxcbiAgICB0aW1lb3V0OiB0eXBlb2YgdGltZW91dCA9PT0gXCJudW1iZXJcIiA/IHRpbWVvdXQgOiAtMSxcbiAgICBhY3RpdmVCcmFuY2g6IG51bGwsXG4gICAgcGVuZGluZ0JyYW5jaDogbnVsbCxcbiAgICBpc0luRmFsbGJhY2s6ICFpc0h5ZHJhdGluZyxcbiAgICBpc0h5ZHJhdGluZyxcbiAgICBpc1VubW91bnRlZDogZmFsc2UsXG4gICAgZWZmZWN0czogW10sXG4gICAgcmVzb2x2ZShyZXN1bWUgPSBmYWxzZSwgc3luYyA9IGZhbHNlKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBpZiAoIXJlc3VtZSAmJiAhc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIHdpdGhvdXQgYSBwZW5kaW5nIGJyYW5jaC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VzcGVuc2UuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHVubW91bnRlZCBzdXNwZW5zZSBib3VuZGFyeS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICB2bm9kZTogdm5vZGUyLFxuICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgIHBlbmRpbmdCcmFuY2gsXG4gICAgICAgIHBlbmRpbmdJZCxcbiAgICAgICAgZWZmZWN0cyxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50OiBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcjJcbiAgICAgIH0gPSBzdXNwZW5zZTtcbiAgICAgIGxldCBkZWxheUVudGVyID0gZmFsc2U7XG4gICAgICBpZiAoc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXJlc3VtZSkge1xuICAgICAgICBkZWxheUVudGVyID0gYWN0aXZlQnJhbmNoICYmIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbiAmJiBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24ubW9kZSA9PT0gXCJvdXQtaW5cIjtcbiAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcbiAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdJZCA9PT0gc3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgICAgIG1vdmUoXG4gICAgICAgICAgICAgICAgcGVuZGluZ0JyYW5jaCxcbiAgICAgICAgICAgICAgICBjb250YWluZXIyLFxuICAgICAgICAgICAgICAgIGFuY2hvciA9PT0gaW5pdGlhbEFuY2hvciA/IG5leHQoYWN0aXZlQnJhbmNoKSA6IGFuY2hvcixcbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZWZmZWN0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aXZlQnJhbmNoKSB7XG4gICAgICAgICAgaWYgKHBhcmVudE5vZGUoYWN0aXZlQnJhbmNoLmVsKSAhPT0gc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVubW91bnQoYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQyLCBzdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWxheUVudGVyKSB7XG4gICAgICAgICAgbW92ZShwZW5kaW5nQnJhbmNoLCBjb250YWluZXIyLCBhbmNob3IsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHBlbmRpbmdCcmFuY2gpO1xuICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG51bGw7XG4gICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSBmYWxzZTtcbiAgICAgIGxldCBwYXJlbnQgPSBzdXNwZW5zZS5wYXJlbnQ7XG4gICAgICBsZXQgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gZmFsc2U7XG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICAgIHBhcmVudC5lZmZlY3RzLnB1c2goLi4uZWZmZWN0cyk7XG4gICAgICAgICAgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNVbnJlc29sdmVkQW5jZXN0b3IgJiYgIWRlbGF5RW50ZXIpIHtcbiAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihlZmZlY3RzKTtcbiAgICAgIH1cbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMgPSBbXTtcbiAgICAgIGlmIChpc1N1c3BlbnNpYmxlKSB7XG4gICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmIHBhcmVudFN1c3BlbnNlSWQgPT09IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdJZCkge1xuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMtLTtcbiAgICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCAmJiAhc3luYykge1xuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJpZ2dlckV2ZW50KHZub2RlMiwgXCJvblJlc29sdmVcIik7XG4gICAgfSxcbiAgICBmYWxsYmFjayhmYWxsYmFja1ZOb2RlKSB7XG4gICAgICBpZiAoIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB2bm9kZTogdm5vZGUyLCBhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudDogcGFyZW50Q29tcG9uZW50MiwgY29udGFpbmVyOiBjb250YWluZXIyLCBuYW1lc3BhY2U6IG5hbWVzcGFjZTIgfSA9IHN1c3BlbnNlO1xuICAgICAgdHJpZ2dlckV2ZW50KHZub2RlMiwgXCJvbkZhbGxiYWNrXCIpO1xuICAgICAgY29uc3QgYW5jaG9yMiA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgIGNvbnN0IG1vdW50RmFsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIGlmICghc3VzcGVuc2UuaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgZmFsbGJhY2tWTm9kZSxcbiAgICAgICAgICBjb250YWluZXIyLFxuICAgICAgICAgIGFuY2hvcjIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50MixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgbmFtZXNwYWNlMixcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgZmFsbGJhY2tWTm9kZSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGVsYXlFbnRlciA9IGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbiAmJiBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24ubW9kZSA9PT0gXCJvdXQtaW5cIjtcbiAgICAgIGlmIChkZWxheUVudGVyKSB7XG4gICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSBtb3VudEZhbGxiYWNrO1xuICAgICAgfVxuICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgIHVubW91bnQoXG4gICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50MixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gbm8gc3VzcGVuc2Ugc28gdW5tb3VudCBob29rcyBmaXJlIG5vd1xuICAgICAgICB0cnVlXG4gICAgICAgIC8vIHNob3VsZFJlbW92ZVxuICAgICAgKTtcbiAgICAgIGlmICghZGVsYXlFbnRlcikge1xuICAgICAgICBtb3VudEZhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3ZlKGNvbnRhaW5lcjIsIGFuY2hvcjIsIHR5cGUpIHtcbiAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJiBtb3ZlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgY29udGFpbmVyMiwgYW5jaG9yMiwgdHlwZSk7XG4gICAgICBzdXNwZW5zZS5jb250YWluZXIgPSBjb250YWluZXIyO1xuICAgIH0sXG4gICAgbmV4dCgpIHtcbiAgICAgIHJldHVybiBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiYgbmV4dChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0LCBvcHRpbWl6ZWQyKSB7XG4gICAgICBjb25zdCBpc0luUGVuZGluZ1N1c3BlbnNlID0gISFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoO1xuICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UpIHtcbiAgICAgICAgc3VzcGVuc2UuZGVwcysrO1xuICAgICAgfVxuICAgICAgY29uc3QgaHlkcmF0ZWRFbCA9IGluc3RhbmNlLnZub2RlLmVsO1xuICAgICAgaW5zdGFuY2UuYXN5bmNEZXAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAwKTtcbiAgICAgIH0pLnRoZW4oKGFzeW5jU2V0dXBSZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkIHx8IHN1c3BlbnNlLmlzVW5tb3VudGVkIHx8IHN1c3BlbnNlLnBlbmRpbmdJZCAhPT0gaW5zdGFuY2Uuc3VzcGVuc2VJZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5hc3luY1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyB2bm9kZTogdm5vZGUyIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUyKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgYXN5bmNTZXR1cFJlc3VsdCwgZmFsc2UpO1xuICAgICAgICBpZiAoaHlkcmF0ZWRFbCkge1xuICAgICAgICAgIHZub2RlMi5lbCA9IGh5ZHJhdGVkRWw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAhaHlkcmF0ZWRFbCAmJiBpbnN0YW5jZS5zdWJUcmVlLmVsO1xuICAgICAgICBzZXR1cFJlbmRlckVmZmVjdChcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICB2bm9kZTIsXG4gICAgICAgICAgLy8gY29tcG9uZW50IG1heSBoYXZlIGJlZW4gbW92ZWQgYmVmb3JlIHJlc29sdmUuXG4gICAgICAgICAgLy8gaWYgdGhpcyBpcyBub3QgYSBoeWRyYXRpb24sIGluc3RhbmNlLnN1YlRyZWUgd2lsbCBiZSB0aGUgY29tbWVudFxuICAgICAgICAgIC8vIHBsYWNlaG9sZGVyLlxuICAgICAgICAgIHBhcmVudE5vZGUoaHlkcmF0ZWRFbCB8fCBpbnN0YW5jZS5zdWJUcmVlLmVsKSxcbiAgICAgICAgICAvLyBhbmNob3Igd2lsbCBub3QgYmUgdXNlZCBpZiB0aGlzIGlzIGh5ZHJhdGlvbiwgc28gb25seSBuZWVkIHRvXG4gICAgICAgICAgLy8gY29uc2lkZXIgdGhlIGNvbW1lbnQgcGxhY2Vob2xkZXIgY2FzZS5cbiAgICAgICAgICBoeWRyYXRlZEVsID8gbnVsbCA6IG5leHQoaW5zdGFuY2Uuc3ViVHJlZSksXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIG9wdGltaXplZDJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgcmVtb3ZlKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIHZub2RlMi5lbCk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSAmJiAtLXN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdW5tb3VudChwYXJlbnRTdXNwZW5zZTIsIGRvUmVtb3ZlKSB7XG4gICAgICBzdXNwZW5zZS5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgICBpZiAoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKSB7XG4gICAgICAgIHVubW91bnQoXG4gICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZTIsXG4gICAgICAgICAgZG9SZW1vdmVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgIHVubW91bnQoXG4gICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UyLFxuICAgICAgICAgIGRvUmVtb3ZlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gc3VzcGVuc2U7XG59XG5mdW5jdGlvbiBoeWRyYXRlU3VzcGVuc2Uobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSkge1xuICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICB2bm9kZSxcbiAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgbm9kZS5wYXJlbnROb2RlLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgIG51bGwsXG4gICAgbmFtZXNwYWNlLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWQsXG4gICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgdHJ1ZVxuICApO1xuICBjb25zdCByZXN1bHQgPSBoeWRyYXRlTm9kZShcbiAgICBub2RlLFxuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIHN1c3BlbnNlLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWRcbiAgKTtcbiAgaWYgKHN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICBzdXNwZW5zZS5yZXNvbHZlKGZhbHNlLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlbih2bm9kZSkge1xuICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xuICBjb25zdCBpc1Nsb3RDaGlsZHJlbiA9IHNoYXBlRmxhZyAmIDMyO1xuICB2bm9kZS5zc0NvbnRlbnQgPSBub3JtYWxpemVTdXNwZW5zZVNsb3QoXG4gICAgaXNTbG90Q2hpbGRyZW4gPyBjaGlsZHJlbi5kZWZhdWx0IDogY2hpbGRyZW5cbiAgKTtcbiAgdm5vZGUuc3NGYWxsYmFjayA9IGlzU2xvdENoaWxkcmVuID8gbm9ybWFsaXplU3VzcGVuc2VTbG90KGNoaWxkcmVuLmZhbGxiYWNrKSA6IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VTbG90KHMpIHtcbiAgbGV0IGJsb2NrO1xuICBpZiAoaXNGdW5jdGlvbihzKSkge1xuICAgIGNvbnN0IHRyYWNrQmxvY2sgPSBpc0Jsb2NrVHJlZUVuYWJsZWQgJiYgcy5fYztcbiAgICBpZiAodHJhY2tCbG9jaykge1xuICAgICAgcy5fZCA9IGZhbHNlO1xuICAgICAgb3BlbkJsb2NrKCk7XG4gICAgfVxuICAgIHMgPSBzKCk7XG4gICAgaWYgKHRyYWNrQmxvY2spIHtcbiAgICAgIHMuX2QgPSB0cnVlO1xuICAgICAgYmxvY2sgPSBjdXJyZW50QmxvY2s7XG4gICAgICBjbG9zZUJsb2NrKCk7XG4gICAgfVxuICB9XG4gIGlmIChpc0FycmF5KHMpKSB7XG4gICAgY29uc3Qgc2luZ2xlQ2hpbGQgPSBmaWx0ZXJTaW5nbGVSb290KHMpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFzaW5nbGVDaGlsZCAmJiBzLmZpbHRlcigoY2hpbGQpID0+IGNoaWxkICE9PSBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UKS5sZW5ndGggPiAwKSB7XG4gICAgICB3YXJuJDEoYDxTdXNwZW5zZT4gc2xvdHMgZXhwZWN0IGEgc2luZ2xlIHJvb3Qgbm9kZS5gKTtcbiAgICB9XG4gICAgcyA9IHNpbmdsZUNoaWxkO1xuICB9XG4gIHMgPSBub3JtYWxpemVWTm9kZShzKTtcbiAgaWYgKGJsb2NrICYmICFzLmR5bmFtaWNDaGlsZHJlbikge1xuICAgIHMuZHluYW1pY0NoaWxkcmVuID0gYmxvY2suZmlsdGVyKChjKSA9PiBjICE9PSBzKTtcbiAgfVxuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKGZuLCBzdXNwZW5zZSkge1xuICBpZiAoc3VzcGVuc2UgJiYgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgIGlmIChpc0FycmF5KGZuKSkge1xuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKC4uLmZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKGZuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcXVldWVQb3N0Rmx1c2hDYihmbik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgYnJhbmNoKSB7XG4gIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IGJyYW5jaDtcbiAgY29uc3QgeyB2bm9kZSwgcGFyZW50Q29tcG9uZW50IH0gPSBzdXNwZW5zZTtcbiAgbGV0IGVsID0gYnJhbmNoLmVsO1xuICB3aGlsZSAoIWVsICYmIGJyYW5jaC5jb21wb25lbnQpIHtcbiAgICBicmFuY2ggPSBicmFuY2guY29tcG9uZW50LnN1YlRyZWU7XG4gICAgZWwgPSBicmFuY2guZWw7XG4gIH1cbiAgdm5vZGUuZWwgPSBlbDtcbiAgaWYgKHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcbiAgICBwYXJlbnRDb21wb25lbnQudm5vZGUuZWwgPSBlbDtcbiAgICB1cGRhdGVIT0NIb3N0RWwocGFyZW50Q29tcG9uZW50LCBlbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVk5vZGVTdXNwZW5zaWJsZSh2bm9kZSkge1xuICBjb25zdCBzdXNwZW5zaWJsZSA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnN1c3BlbnNpYmxlO1xuICByZXR1cm4gc3VzcGVuc2libGUgIT0gbnVsbCAmJiBzdXNwZW5zaWJsZSAhPT0gZmFsc2U7XG59XG5cbmNvbnN0IEZyYWdtZW50ID0gU3ltYm9sLmZvcihcInYtZmd0XCIpO1xuY29uc3QgVGV4dCA9IFN5bWJvbC5mb3IoXCJ2LXR4dFwiKTtcbmNvbnN0IENvbW1lbnQgPSBTeW1ib2wuZm9yKFwidi1jbXRcIik7XG5jb25zdCBTdGF0aWMgPSBTeW1ib2wuZm9yKFwidi1zdGNcIik7XG5jb25zdCBibG9ja1N0YWNrID0gW107XG5sZXQgY3VycmVudEJsb2NrID0gbnVsbDtcbmZ1bmN0aW9uIG9wZW5CbG9jayhkaXNhYmxlVHJhY2tpbmcgPSBmYWxzZSkge1xuICBibG9ja1N0YWNrLnB1c2goY3VycmVudEJsb2NrID0gZGlzYWJsZVRyYWNraW5nID8gbnVsbCA6IFtdKTtcbn1cbmZ1bmN0aW9uIGNsb3NlQmxvY2soKSB7XG4gIGJsb2NrU3RhY2sucG9wKCk7XG4gIGN1cnJlbnRCbG9jayA9IGJsb2NrU3RhY2tbYmxvY2tTdGFjay5sZW5ndGggLSAxXSB8fCBudWxsO1xufVxubGV0IGlzQmxvY2tUcmVlRW5hYmxlZCA9IDE7XG5mdW5jdGlvbiBzZXRCbG9ja1RyYWNraW5nKHZhbHVlKSB7XG4gIGlzQmxvY2tUcmVlRW5hYmxlZCArPSB2YWx1ZTtcbiAgaWYgKHZhbHVlIDwgMCAmJiBjdXJyZW50QmxvY2spIHtcbiAgICBjdXJyZW50QmxvY2suaGFzT25jZSA9IHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldHVwQmxvY2sodm5vZGUpIHtcbiAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gaXNCbG9ja1RyZWVFbmFibGVkID4gMCA/IGN1cnJlbnRCbG9jayB8fCBFTVBUWV9BUlIgOiBudWxsO1xuICBjbG9zZUJsb2NrKCk7XG4gIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIGN1cnJlbnRCbG9jaykge1xuICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50QmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgc2hhcGVGbGFnKSB7XG4gIHJldHVybiBzZXR1cEJsb2NrKFxuICAgIGNyZWF0ZUJhc2VWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgZHluYW1pY1Byb3BzLFxuICAgICAgc2hhcGVGbGFnLFxuICAgICAgdHJ1ZVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMpIHtcbiAgcmV0dXJuIHNldHVwQmxvY2soXG4gICAgY3JlYXRlVk5vZGUoXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHBhdGNoRmxhZyxcbiAgICAgIGR5bmFtaWNQcm9wcyxcbiAgICAgIHRydWVcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBpc1ZOb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IHZhbHVlLl9fdl9pc1ZOb2RlID09PSB0cnVlIDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG4yLnNoYXBlRmxhZyAmIDYgJiYgbjEuY29tcG9uZW50KSB7XG4gICAgY29uc3QgZGlydHlJbnN0YW5jZXMgPSBobXJEaXJ0eUNvbXBvbmVudHMuZ2V0KG4yLnR5cGUpO1xuICAgIGlmIChkaXJ0eUluc3RhbmNlcyAmJiBkaXJ0eUluc3RhbmNlcy5oYXMobjEuY29tcG9uZW50KSkge1xuICAgICAgbjEuc2hhcGVGbGFnICY9IH4yNTY7XG4gICAgICBuMi5zaGFwZUZsYWcgJj0gfjUxMjtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG4xLnR5cGUgPT09IG4yLnR5cGUgJiYgbjEua2V5ID09PSBuMi5rZXk7XG59XG5sZXQgdm5vZGVBcmdzVHJhbnNmb3JtZXI7XG5mdW5jdGlvbiB0cmFuc2Zvcm1WTm9kZUFyZ3ModHJhbnNmb3JtZXIpIHtcbiAgdm5vZGVBcmdzVHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcjtcbn1cbmNvbnN0IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gPSAoLi4uYXJncykgPT4ge1xuICByZXR1cm4gX2NyZWF0ZVZOb2RlKFxuICAgIC4uLnZub2RlQXJnc1RyYW5zZm9ybWVyID8gdm5vZGVBcmdzVHJhbnNmb3JtZXIoYXJncywgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSA6IGFyZ3NcbiAgKTtcbn07XG5jb25zdCBub3JtYWxpemVLZXkgPSAoeyBrZXkgfSkgPT4ga2V5ICE9IG51bGwgPyBrZXkgOiBudWxsO1xuY29uc3Qgbm9ybWFsaXplUmVmID0gKHtcbiAgcmVmLFxuICByZWZfa2V5LFxuICByZWZfZm9yXG59KSA9PiB7XG4gIGlmICh0eXBlb2YgcmVmID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVmID0gXCJcIiArIHJlZjtcbiAgfVxuICByZXR1cm4gcmVmICE9IG51bGwgPyBpc1N0cmluZyhyZWYpIHx8IGlzUmVmKHJlZikgfHwgaXNGdW5jdGlvbihyZWYpID8geyBpOiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIHI6IHJlZiwgazogcmVmX2tleSwgZjogISFyZWZfZm9yIH0gOiByZWYgOiBudWxsO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgc2hhcGVGbGFnID0gdHlwZSA9PT0gRnJhZ21lbnQgPyAwIDogMSwgaXNCbG9ja05vZGUgPSBmYWxzZSwgbmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24gPSBmYWxzZSkge1xuICBjb25zdCB2bm9kZSA9IHtcbiAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcbiAgICBfX3Zfc2tpcDogdHJ1ZSxcbiAgICB0eXBlLFxuICAgIHByb3BzLFxuICAgIGtleTogcHJvcHMgJiYgbm9ybWFsaXplS2V5KHByb3BzKSxcbiAgICByZWY6IHByb3BzICYmIG5vcm1hbGl6ZVJlZihwcm9wcyksXG4gICAgc2NvcGVJZDogY3VycmVudFNjb3BlSWQsXG4gICAgc2xvdFNjb3BlSWRzOiBudWxsLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICBzdXNwZW5zZTogbnVsbCxcbiAgICBzc0NvbnRlbnQ6IG51bGwsXG4gICAgc3NGYWxsYmFjazogbnVsbCxcbiAgICBkaXJzOiBudWxsLFxuICAgIHRyYW5zaXRpb246IG51bGwsXG4gICAgZWw6IG51bGwsXG4gICAgYW5jaG9yOiBudWxsLFxuICAgIHRhcmdldDogbnVsbCxcbiAgICB0YXJnZXRTdGFydDogbnVsbCxcbiAgICB0YXJnZXRBbmNob3I6IG51bGwsXG4gICAgc3RhdGljQ291bnQ6IDAsXG4gICAgc2hhcGVGbGFnLFxuICAgIHBhdGNoRmxhZyxcbiAgICBkeW5hbWljUHJvcHMsXG4gICAgZHluYW1pY0NoaWxkcmVuOiBudWxsLFxuICAgIGFwcENvbnRleHQ6IG51bGwsXG4gICAgY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2VcbiAgfTtcbiAgaWYgKG5lZWRGdWxsQ2hpbGRyZW5Ob3JtYWxpemF0aW9uKSB7XG4gICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKTtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICB0eXBlLm5vcm1hbGl6ZSh2bm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgdm5vZGUuc2hhcGVGbGFnIHw9IGlzU3RyaW5nKGNoaWxkcmVuKSA/IDggOiAxNjtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB2bm9kZS5rZXkgIT09IHZub2RlLmtleSkge1xuICAgIHdhcm4kMShgVk5vZGUgY3JlYXRlZCB3aXRoIGludmFsaWQga2V5IChOYU4pLiBWTm9kZSB0eXBlOmAsIHZub2RlLnR5cGUpO1xuICB9XG4gIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIC8vIGF2b2lkIGEgYmxvY2sgbm9kZSBmcm9tIHRyYWNraW5nIGl0c2VsZlxuICAhaXNCbG9ja05vZGUgJiYgLy8gaGFzIGN1cnJlbnQgcGFyZW50IGJsb2NrXG4gIGN1cnJlbnRCbG9jayAmJiAvLyBwcmVzZW5jZSBvZiBhIHBhdGNoIGZsYWcgaW5kaWNhdGVzIHRoaXMgbm9kZSBuZWVkcyBwYXRjaGluZyBvbiB1cGRhdGVzLlxuICAvLyBjb21wb25lbnQgbm9kZXMgYWxzbyBzaG91bGQgYWx3YXlzIGJlIHBhdGNoZWQsIGJlY2F1c2UgZXZlbiBpZiB0aGVcbiAgLy8gY29tcG9uZW50IGRvZXNuJ3QgbmVlZCB0byB1cGRhdGUsIGl0IG5lZWRzIHRvIHBlcnNpc3QgdGhlIGluc3RhbmNlIG9uIHRvXG4gIC8vIHRoZSBuZXh0IHZub2RlIHNvIHRoYXQgaXQgY2FuIGJlIHByb3Blcmx5IHVubW91bnRlZCBsYXRlci5cbiAgKHZub2RlLnBhdGNoRmxhZyA+IDAgfHwgc2hhcGVGbGFnICYgNikgJiYgLy8gdGhlIEVWRU5UUyBmbGFnIGlzIG9ubHkgZm9yIGh5ZHJhdGlvbiBhbmQgaWYgaXQgaXMgdGhlIG9ubHkgZmxhZywgdGhlXG4gIC8vIHZub2RlIHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBkeW5hbWljIGR1ZSB0byBoYW5kbGVyIGNhY2hpbmcuXG4gIHZub2RlLnBhdGNoRmxhZyAhPT0gMzIpIHtcbiAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XG4gIH1cbiAgcmV0dXJuIHZub2RlO1xufVxuY29uc3QgY3JlYXRlVk5vZGUgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA6IF9jcmVhdGVWTm9kZTtcbmZ1bmN0aW9uIF9jcmVhdGVWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgaXNCbG9ja05vZGUgPSBmYWxzZSkge1xuICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICF0eXBlKSB7XG4gICAgICB3YXJuJDEoYEludmFsaWQgdm5vZGUgdHlwZSB3aGVuIGNyZWF0aW5nIHZub2RlOiAke3R5cGV9LmApO1xuICAgIH1cbiAgICB0eXBlID0gQ29tbWVudDtcbiAgfVxuICBpZiAoaXNWTm9kZSh0eXBlKSkge1xuICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUoXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICB0cnVlXG4gICAgICAvKiBtZXJnZVJlZjogdHJ1ZSAqL1xuICAgICk7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBub3JtYWxpemVDaGlsZHJlbihjbG9uZWQsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgIWlzQmxvY2tOb2RlICYmIGN1cnJlbnRCbG9jaykge1xuICAgICAgaWYgKGNsb25lZC5zaGFwZUZsYWcgJiA2KSB7XG4gICAgICAgIGN1cnJlbnRCbG9ja1tjdXJyZW50QmxvY2suaW5kZXhPZih0eXBlKV0gPSBjbG9uZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50QmxvY2sucHVzaChjbG9uZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjbG9uZWQucGF0Y2hGbGFnID0gLTI7XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBpZiAoaXNDbGFzc0NvbXBvbmVudCh0eXBlKSkge1xuICAgIHR5cGUgPSB0eXBlLl9fdmNjT3B0cztcbiAgfVxuICBpZiAocHJvcHMpIHtcbiAgICBwcm9wcyA9IGd1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcyk7XG4gICAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gICAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcbiAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3Qoc3R5bGUpKSB7XG4gICAgICBpZiAoaXNQcm94eShzdHlsZSkgJiYgIWlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICAgIHN0eWxlID0gZXh0ZW5kKHt9LCBzdHlsZSk7XG4gICAgICB9XG4gICAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2hhcGVGbGFnID0gaXNTdHJpbmcodHlwZSkgPyAxIDogaXNTdXNwZW5zZSh0eXBlKSA/IDEyOCA6IGlzVGVsZXBvcnQodHlwZSkgPyA2NCA6IGlzT2JqZWN0KHR5cGUpID8gNCA6IGlzRnVuY3Rpb24odHlwZSkgPyAyIDogMDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2hhcGVGbGFnICYgNCAmJiBpc1Byb3h5KHR5cGUpKSB7XG4gICAgdHlwZSA9IHRvUmF3KHR5cGUpO1xuICAgIHdhcm4kMShcbiAgICAgIGBWdWUgcmVjZWl2ZWQgYSBDb21wb25lbnQgdGhhdCB3YXMgbWFkZSBhIHJlYWN0aXZlIG9iamVjdC4gVGhpcyBjYW4gbGVhZCB0byB1bm5lY2Vzc2FyeSBwZXJmb3JtYW5jZSBvdmVyaGVhZCBhbmQgc2hvdWxkIGJlIGF2b2lkZWQgYnkgbWFya2luZyB0aGUgY29tcG9uZW50IHdpdGggXFxgbWFya1Jhd1xcYCBvciB1c2luZyBcXGBzaGFsbG93UmVmXFxgIGluc3RlYWQgb2YgXFxgcmVmXFxgLmAsXG4gICAgICBgXG5Db21wb25lbnQgdGhhdCB3YXMgbWFkZSByZWFjdGl2ZTogYCxcbiAgICAgIHR5cGVcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGVCYXNlVk5vZGUoXG4gICAgdHlwZSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBwYXRjaEZsYWcsXG4gICAgZHluYW1pY1Byb3BzLFxuICAgIHNoYXBlRmxhZyxcbiAgICBpc0Jsb2NrTm9kZSxcbiAgICB0cnVlXG4gICk7XG59XG5mdW5jdGlvbiBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpIHtcbiAgaWYgKCFwcm9wcykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBpc1Byb3h5KHByb3BzKSB8fCBpc0ludGVybmFsT2JqZWN0KHByb3BzKSA/IGV4dGVuZCh7fSwgcHJvcHMpIDogcHJvcHM7XG59XG5mdW5jdGlvbiBjbG9uZVZOb2RlKHZub2RlLCBleHRyYVByb3BzLCBtZXJnZVJlZiA9IGZhbHNlLCBjbG9uZVRyYW5zaXRpb24gPSBmYWxzZSkge1xuICBjb25zdCB7IHByb3BzLCByZWYsIHBhdGNoRmxhZywgY2hpbGRyZW4sIHRyYW5zaXRpb24gfSA9IHZub2RlO1xuICBjb25zdCBtZXJnZWRQcm9wcyA9IGV4dHJhUHJvcHMgPyBtZXJnZVByb3BzKHByb3BzIHx8IHt9LCBleHRyYVByb3BzKSA6IHByb3BzO1xuICBjb25zdCBjbG9uZWQgPSB7XG4gICAgX192X2lzVk5vZGU6IHRydWUsXG4gICAgX192X3NraXA6IHRydWUsXG4gICAgdHlwZTogdm5vZGUudHlwZSxcbiAgICBwcm9wczogbWVyZ2VkUHJvcHMsXG4gICAga2V5OiBtZXJnZWRQcm9wcyAmJiBub3JtYWxpemVLZXkobWVyZ2VkUHJvcHMpLFxuICAgIHJlZjogZXh0cmFQcm9wcyAmJiBleHRyYVByb3BzLnJlZiA/IChcbiAgICAgIC8vICMyMDc4IGluIHRoZSBjYXNlIG9mIDxjb21wb25lbnQgOmlzPVwidm5vZGVcIiByZWY9XCJleHRyYVwiLz5cbiAgICAgIC8vIGlmIHRoZSB2bm9kZSBpdHNlbGYgYWxyZWFkeSBoYXMgYSByZWYsIGNsb25lVk5vZGUgd2lsbCBuZWVkIHRvIG1lcmdlXG4gICAgICAvLyB0aGUgcmVmcyBzbyB0aGUgc2luZ2xlIHZub2RlIGNhbiBiZSBzZXQgb24gbXVsdGlwbGUgcmVmc1xuICAgICAgbWVyZ2VSZWYgJiYgcmVmID8gaXNBcnJheShyZWYpID8gcmVmLmNvbmNhdChub3JtYWxpemVSZWYoZXh0cmFQcm9wcykpIDogW3JlZiwgbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXSA6IG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKVxuICAgICkgOiByZWYsXG4gICAgc2NvcGVJZDogdm5vZGUuc2NvcGVJZCxcbiAgICBzbG90U2NvcGVJZHM6IHZub2RlLnNsb3RTY29wZUlkcyxcbiAgICBjaGlsZHJlbjogISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBwYXRjaEZsYWcgPT09IC0xICYmIGlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKSA6IGNoaWxkcmVuLFxuICAgIHRhcmdldDogdm5vZGUudGFyZ2V0LFxuICAgIHRhcmdldFN0YXJ0OiB2bm9kZS50YXJnZXRTdGFydCxcbiAgICB0YXJnZXRBbmNob3I6IHZub2RlLnRhcmdldEFuY2hvcixcbiAgICBzdGF0aWNDb3VudDogdm5vZGUuc3RhdGljQ291bnQsXG4gICAgc2hhcGVGbGFnOiB2bm9kZS5zaGFwZUZsYWcsXG4gICAgLy8gaWYgdGhlIHZub2RlIGlzIGNsb25lZCB3aXRoIGV4dHJhIHByb3BzLCB3ZSBjYW4gbm8gbG9uZ2VyIGFzc3VtZSBpdHNcbiAgICAvLyBleGlzdGluZyBwYXRjaCBmbGFnIHRvIGJlIHJlbGlhYmxlIGFuZCBuZWVkIHRvIGFkZCB0aGUgRlVMTF9QUk9QUyBmbGFnLlxuICAgIC8vIG5vdGU6IHByZXNlcnZlIGZsYWcgZm9yIGZyYWdtZW50cyBzaW5jZSB0aGV5IHVzZSB0aGUgZmxhZyBmb3IgY2hpbGRyZW5cbiAgICAvLyBmYXN0IHBhdGhzIG9ubHkuXG4gICAgcGF0Y2hGbGFnOiBleHRyYVByb3BzICYmIHZub2RlLnR5cGUgIT09IEZyYWdtZW50ID8gcGF0Y2hGbGFnID09PSAtMSA/IDE2IDogcGF0Y2hGbGFnIHwgMTYgOiBwYXRjaEZsYWcsXG4gICAgZHluYW1pY1Byb3BzOiB2bm9kZS5keW5hbWljUHJvcHMsXG4gICAgZHluYW1pY0NoaWxkcmVuOiB2bm9kZS5keW5hbWljQ2hpbGRyZW4sXG4gICAgYXBwQ29udGV4dDogdm5vZGUuYXBwQ29udGV4dCxcbiAgICBkaXJzOiB2bm9kZS5kaXJzLFxuICAgIHRyYW5zaXRpb24sXG4gICAgLy8gVGhlc2Ugc2hvdWxkIHRlY2huaWNhbGx5IG9ubHkgYmUgbm9uLW51bGwgb24gbW91bnRlZCBWTm9kZXMuIEhvd2V2ZXIsXG4gICAgLy8gdGhleSAqc2hvdWxkKiBiZSBjb3BpZWQgZm9yIGtlcHQtYWxpdmUgdm5vZGVzLiBTbyB3ZSBqdXN0IGFsd2F5cyBjb3B5XG4gICAgLy8gdGhlbSBzaW5jZSB0aGVtIGJlaW5nIG5vbi1udWxsIGR1cmluZyBhIG1vdW50IGRvZXNuJ3QgYWZmZWN0IHRoZSBsb2dpYyBhc1xuICAgIC8vIHRoZXkgd2lsbCBzaW1wbHkgYmUgb3ZlcndyaXR0ZW4uXG4gICAgY29tcG9uZW50OiB2bm9kZS5jb21wb25lbnQsXG4gICAgc3VzcGVuc2U6IHZub2RlLnN1c3BlbnNlLFxuICAgIHNzQ29udGVudDogdm5vZGUuc3NDb250ZW50ICYmIGNsb25lVk5vZGUodm5vZGUuc3NDb250ZW50KSxcbiAgICBzc0ZhbGxiYWNrOiB2bm9kZS5zc0ZhbGxiYWNrICYmIGNsb25lVk5vZGUodm5vZGUuc3NGYWxsYmFjayksXG4gICAgZWw6IHZub2RlLmVsLFxuICAgIGFuY2hvcjogdm5vZGUuYW5jaG9yLFxuICAgIGN0eDogdm5vZGUuY3R4LFxuICAgIGNlOiB2bm9kZS5jZVxuICB9O1xuICBpZiAodHJhbnNpdGlvbiAmJiBjbG9uZVRyYW5zaXRpb24pIHtcbiAgICBzZXRUcmFuc2l0aW9uSG9va3MoXG4gICAgICBjbG9uZWQsXG4gICAgICB0cmFuc2l0aW9uLmNsb25lKGNsb25lZClcbiAgICApO1xuICB9XG4gIHJldHVybiBjbG9uZWQ7XG59XG5mdW5jdGlvbiBkZWVwQ2xvbmVWTm9kZSh2bm9kZSkge1xuICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgaWYgKGlzQXJyYXkodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgY2xvbmVkLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKTtcbiAgfVxuICByZXR1cm4gY2xvbmVkO1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlKHRleHQgPSBcIiBcIiwgZmxhZyA9IDApIHtcbiAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIHRleHQsIGZsYWcpO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGljVk5vZGUoY29udGVudCwgbnVtYmVyT2ZOb2Rlcykge1xuICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKFN0YXRpYywgbnVsbCwgY29udGVudCk7XG4gIHZub2RlLnN0YXRpY0NvdW50ID0gbnVtYmVyT2ZOb2RlcztcbiAgcmV0dXJuIHZub2RlO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudFZOb2RlKHRleHQgPSBcIlwiLCBhc0Jsb2NrID0gZmFsc2UpIHtcbiAgcmV0dXJuIGFzQmxvY2sgPyAob3BlbkJsb2NrKCksIGNyZWF0ZUJsb2NrKENvbW1lbnQsIG51bGwsIHRleHQpKSA6IGNyZWF0ZVZOb2RlKENvbW1lbnQsIG51bGwsIHRleHQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVk5vZGUoY2hpbGQpIHtcbiAgaWYgKGNoaWxkID09IG51bGwgfHwgdHlwZW9mIGNoaWxkID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShDb21tZW50KTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KGNoaWxkKSkge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShcbiAgICAgIEZyYWdtZW50LFxuICAgICAgbnVsbCxcbiAgICAgIC8vICMzNjY2LCBhdm9pZCByZWZlcmVuY2UgcG9sbHV0aW9uIHdoZW4gcmV1c2luZyB2bm9kZVxuICAgICAgY2hpbGQuc2xpY2UoKVxuICAgICk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNoaWxkID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGNsb25lSWZNb3VudGVkKGNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgU3RyaW5nKGNoaWxkKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsb25lSWZNb3VudGVkKGNoaWxkKSB7XG4gIHJldHVybiBjaGlsZC5lbCA9PT0gbnVsbCAmJiBjaGlsZC5wYXRjaEZsYWcgIT09IC0xIHx8IGNoaWxkLm1lbW8gPyBjaGlsZCA6IGNsb25lVk5vZGUoY2hpbGQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKSB7XG4gIGxldCB0eXBlID0gMDtcbiAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHZub2RlO1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfSBlbHNlIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIHR5cGUgPSAxNjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoc2hhcGVGbGFnICYgKDEgfCA2NCkpIHtcbiAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZHJlbi5kZWZhdWx0O1xuICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgc2xvdC5fYyAmJiAoc2xvdC5fZCA9IGZhbHNlKTtcbiAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIHNsb3QoKSk7XG4gICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IDMyO1xuICAgICAgY29uc3Qgc2xvdEZsYWcgPSBjaGlsZHJlbi5fO1xuICAgICAgaWYgKCFzbG90RmxhZyAmJiAhaXNJbnRlcm5hbE9iamVjdChjaGlsZHJlbikpIHtcbiAgICAgICAgY2hpbGRyZW4uX2N0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgICAgIH0gZWxzZSBpZiAoc2xvdEZsYWcgPT09IDMgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XG4gICAgICAgIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2Uuc2xvdHMuXyA9PT0gMSkge1xuICAgICAgICAgIGNoaWxkcmVuLl8gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoaWxkcmVuLl8gPSAyO1xuICAgICAgICAgIHZub2RlLnBhdGNoRmxhZyB8PSAxMDI0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oY2hpbGRyZW4pKSB7XG4gICAgY2hpbGRyZW4gPSB7IGRlZmF1bHQ6IGNoaWxkcmVuLCBfY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfTtcbiAgICB0eXBlID0gMzI7XG4gIH0gZWxzZSB7XG4gICAgY2hpbGRyZW4gPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgdHlwZSA9IDE2O1xuICAgICAgY2hpbGRyZW4gPSBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSA4O1xuICAgIH1cbiAgfVxuICB2bm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB2bm9kZS5zaGFwZUZsYWcgfD0gdHlwZTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJvcHMoLi4uYXJncykge1xuICBjb25zdCByZXQgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9NZXJnZSA9IGFyZ3NbaV07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdG9NZXJnZSkge1xuICAgICAgaWYgKGtleSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgICAgIGlmIChyZXQuY2xhc3MgIT09IHRvTWVyZ2UuY2xhc3MpIHtcbiAgICAgICAgICByZXQuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhbcmV0LmNsYXNzLCB0b01lcmdlLmNsYXNzXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgcmV0LnN0eWxlID0gbm9ybWFsaXplU3R5bGUoW3JldC5zdHlsZSwgdG9NZXJnZS5zdHlsZV0pO1xuICAgICAgfSBlbHNlIGlmIChpc09uKGtleSkpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSByZXRba2V5XTtcbiAgICAgICAgY29uc3QgaW5jb21pbmcgPSB0b01lcmdlW2tleV07XG4gICAgICAgIGlmIChpbmNvbWluZyAmJiBleGlzdGluZyAhPT0gaW5jb21pbmcgJiYgIShpc0FycmF5KGV4aXN0aW5nKSAmJiBleGlzdGluZy5pbmNsdWRlcyhpbmNvbWluZykpKSB7XG4gICAgICAgICAgcmV0W2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgaW5jb21pbmcpIDogaW5jb21pbmc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ICE9PSBcIlwiKSB7XG4gICAgICAgIHJldFtrZXldID0gdG9NZXJnZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gaW52b2tlVk5vZGVIb29rKGhvb2ssIGluc3RhbmNlLCB2bm9kZSwgcHJldlZOb2RlID0gbnVsbCkge1xuICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgNywgW1xuICAgIHZub2RlLFxuICAgIHByZXZWTm9kZVxuICBdKTtcbn1cblxuY29uc3QgZW1wdHlBcHBDb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xubGV0IHVpZCA9IDA7XG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSh2bm9kZSwgcGFyZW50LCBzdXNwZW5zZSkge1xuICBjb25zdCB0eXBlID0gdm5vZGUudHlwZTtcbiAgY29uc3QgYXBwQ29udGV4dCA9IChwYXJlbnQgPyBwYXJlbnQuYXBwQ29udGV4dCA6IHZub2RlLmFwcENvbnRleHQpIHx8IGVtcHR5QXBwQ29udGV4dDtcbiAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgdWlkOiB1aWQrKyxcbiAgICB2bm9kZSxcbiAgICB0eXBlLFxuICAgIHBhcmVudCxcbiAgICBhcHBDb250ZXh0LFxuICAgIHJvb3Q6IG51bGwsXG4gICAgLy8gdG8gYmUgaW1tZWRpYXRlbHkgc2V0XG4gICAgbmV4dDogbnVsbCxcbiAgICBzdWJUcmVlOiBudWxsLFxuICAgIC8vIHdpbGwgYmUgc2V0IHN5bmNocm9ub3VzbHkgcmlnaHQgYWZ0ZXIgY3JlYXRpb25cbiAgICBlZmZlY3Q6IG51bGwsXG4gICAgdXBkYXRlOiBudWxsLFxuICAgIC8vIHdpbGwgYmUgc2V0IHN5bmNocm9ub3VzbHkgcmlnaHQgYWZ0ZXIgY3JlYXRpb25cbiAgICBqb2I6IG51bGwsXG4gICAgc2NvcGU6IG5ldyBFZmZlY3RTY29wZShcbiAgICAgIHRydWVcbiAgICAgIC8qIGRldGFjaGVkICovXG4gICAgKSxcbiAgICByZW5kZXI6IG51bGwsXG4gICAgcHJveHk6IG51bGwsXG4gICAgZXhwb3NlZDogbnVsbCxcbiAgICBleHBvc2VQcm94eTogbnVsbCxcbiAgICB3aXRoUHJveHk6IG51bGwsXG4gICAgcHJvdmlkZXM6IHBhcmVudCA/IHBhcmVudC5wcm92aWRlcyA6IE9iamVjdC5jcmVhdGUoYXBwQ29udGV4dC5wcm92aWRlcyksXG4gICAgaWRzOiBwYXJlbnQgPyBwYXJlbnQuaWRzIDogW1wiXCIsIDAsIDBdLFxuICAgIGFjY2Vzc0NhY2hlOiBudWxsLFxuICAgIHJlbmRlckNhY2hlOiBbXSxcbiAgICAvLyBsb2NhbCByZXNvbHZlZCBhc3NldHNcbiAgICBjb21wb25lbnRzOiBudWxsLFxuICAgIGRpcmVjdGl2ZXM6IG51bGwsXG4gICAgLy8gcmVzb2x2ZWQgcHJvcHMgYW5kIGVtaXRzIG9wdGlvbnNcbiAgICBwcm9wc09wdGlvbnM6IG5vcm1hbGl6ZVByb3BzT3B0aW9ucyh0eXBlLCBhcHBDb250ZXh0KSxcbiAgICBlbWl0c09wdGlvbnM6IG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyh0eXBlLCBhcHBDb250ZXh0KSxcbiAgICAvLyBlbWl0XG4gICAgZW1pdDogbnVsbCxcbiAgICAvLyB0byBiZSBzZXQgaW1tZWRpYXRlbHlcbiAgICBlbWl0dGVkOiBudWxsLFxuICAgIC8vIHByb3BzIGRlZmF1bHQgdmFsdWVcbiAgICBwcm9wc0RlZmF1bHRzOiBFTVBUWV9PQkosXG4gICAgLy8gaW5oZXJpdEF0dHJzXG4gICAgaW5oZXJpdEF0dHJzOiB0eXBlLmluaGVyaXRBdHRycyxcbiAgICAvLyBzdGF0ZVxuICAgIGN0eDogRU1QVFlfT0JKLFxuICAgIGRhdGE6IEVNUFRZX09CSixcbiAgICBwcm9wczogRU1QVFlfT0JKLFxuICAgIGF0dHJzOiBFTVBUWV9PQkosXG4gICAgc2xvdHM6IEVNUFRZX09CSixcbiAgICByZWZzOiBFTVBUWV9PQkosXG4gICAgc2V0dXBTdGF0ZTogRU1QVFlfT0JKLFxuICAgIHNldHVwQ29udGV4dDogbnVsbCxcbiAgICAvLyBzdXNwZW5zZSByZWxhdGVkXG4gICAgc3VzcGVuc2UsXG4gICAgc3VzcGVuc2VJZDogc3VzcGVuc2UgPyBzdXNwZW5zZS5wZW5kaW5nSWQgOiAwLFxuICAgIGFzeW5jRGVwOiBudWxsLFxuICAgIGFzeW5jUmVzb2x2ZWQ6IGZhbHNlLFxuICAgIC8vIGxpZmVjeWNsZSBob29rc1xuICAgIC8vIG5vdCB1c2luZyBlbnVtcyBoZXJlIGJlY2F1c2UgaXQgcmVzdWx0cyBpbiBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICBpc1VubW91bnRlZDogZmFsc2UsXG4gICAgaXNEZWFjdGl2YXRlZDogZmFsc2UsXG4gICAgYmM6IG51bGwsXG4gICAgYzogbnVsbCxcbiAgICBibTogbnVsbCxcbiAgICBtOiBudWxsLFxuICAgIGJ1OiBudWxsLFxuICAgIHU6IG51bGwsXG4gICAgdW06IG51bGwsXG4gICAgYnVtOiBudWxsLFxuICAgIGRhOiBudWxsLFxuICAgIGE6IG51bGwsXG4gICAgcnRnOiBudWxsLFxuICAgIHJ0YzogbnVsbCxcbiAgICBlYzogbnVsbCxcbiAgICBzcDogbnVsbFxuICB9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGluc3RhbmNlLmN0eCA9IGNyZWF0ZURldlJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlLmN0eCA9IHsgXzogaW5zdGFuY2UgfTtcbiAgfVxuICBpbnN0YW5jZS5yb290ID0gcGFyZW50ID8gcGFyZW50LnJvb3QgOiBpbnN0YW5jZTtcbiAgaW5zdGFuY2UuZW1pdCA9IGVtaXQuYmluZChudWxsLCBpbnN0YW5jZSk7XG4gIGlmICh2bm9kZS5jZSkge1xuICAgIHZub2RlLmNlKGluc3RhbmNlKTtcbiAgfVxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5sZXQgY3VycmVudEluc3RhbmNlID0gbnVsbDtcbmNvbnN0IGdldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG5sZXQgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2U7XG5sZXQgc2V0SW5TU1JTZXR1cFN0YXRlO1xue1xuICBjb25zdCBnID0gZ2V0R2xvYmFsVGhpcygpO1xuICBjb25zdCByZWdpc3Rlckdsb2JhbFNldHRlciA9IChrZXksIHNldHRlcikgPT4ge1xuICAgIGxldCBzZXR0ZXJzO1xuICAgIGlmICghKHNldHRlcnMgPSBnW2tleV0pKSBzZXR0ZXJzID0gZ1trZXldID0gW107XG4gICAgc2V0dGVycy5wdXNoKHNldHRlcik7XG4gICAgcmV0dXJuICh2KSA9PiB7XG4gICAgICBpZiAoc2V0dGVycy5sZW5ndGggPiAxKSBzZXR0ZXJzLmZvckVhY2goKHNldCkgPT4gc2V0KHYpKTtcbiAgICAgIGVsc2Ugc2V0dGVyc1swXSh2KTtcbiAgICB9O1xuICB9O1xuICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZSA9IHJlZ2lzdGVyR2xvYmFsU2V0dGVyKFxuICAgIGBfX1ZVRV9JTlNUQU5DRV9TRVRURVJTX19gLFxuICAgICh2KSA9PiBjdXJyZW50SW5zdGFuY2UgPSB2XG4gICk7XG4gIHNldEluU1NSU2V0dXBTdGF0ZSA9IHJlZ2lzdGVyR2xvYmFsU2V0dGVyKFxuICAgIGBfX1ZVRV9TU1JfU0VUVEVSU19fYCxcbiAgICAodikgPT4gaXNJblNTUkNvbXBvbmVudFNldHVwID0gdlxuICApO1xufVxuY29uc3Qgc2V0Q3VycmVudEluc3RhbmNlID0gKGluc3RhbmNlKSA9PiB7XG4gIGNvbnN0IHByZXYgPSBjdXJyZW50SW5zdGFuY2U7XG4gIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgaW5zdGFuY2Uuc2NvcGUub24oKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpbnN0YW5jZS5zY29wZS5vZmYoKTtcbiAgICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZShwcmV2KTtcbiAgfTtcbn07XG5jb25zdCB1bnNldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IHtcbiAgY3VycmVudEluc3RhbmNlICYmIGN1cnJlbnRJbnN0YW5jZS5zY29wZS5vZmYoKTtcbiAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UobnVsbCk7XG59O1xuY29uc3QgaXNCdWlsdEluVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXCJzbG90LGNvbXBvbmVudFwiKTtcbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCB7IGlzTmF0aXZlVGFnIH0pIHtcbiAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBpc05hdGl2ZVRhZyhuYW1lKSkge1xuICAgIHdhcm4kMShcbiAgICAgIFwiRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCBpZDogXCIgKyBuYW1lXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgNDtcbn1cbmxldCBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBmYWxzZTtcbmZ1bmN0aW9uIHNldHVwQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUiA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSkge1xuICBpc1NTUiAmJiBzZXRJblNTUlNldHVwU3RhdGUoaXNTU1IpO1xuICBjb25zdCB7IHByb3BzLCBjaGlsZHJlbiB9ID0gaW5zdGFuY2Uudm5vZGU7XG4gIGNvbnN0IGlzU3RhdGVmdWwgPSBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKTtcbiAgaW5pdFByb3BzKGluc3RhbmNlLCBwcm9wcywgaXNTdGF0ZWZ1bCwgaXNTU1IpO1xuICBpbml0U2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICBjb25zdCBzZXR1cFJlc3VsdCA9IGlzU3RhdGVmdWwgPyBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUikgOiB2b2lkIDA7XG4gIGlzU1NSICYmIHNldEluU1NSU2V0dXBTdGF0ZShmYWxzZSk7XG4gIHJldHVybiBzZXR1cFJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpZiAoQ29tcG9uZW50Lm5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShDb21wb25lbnQubmFtZSwgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcpO1xuICAgIH1cbiAgICBpZiAoQ29tcG9uZW50LmNvbXBvbmVudHMpIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmNvbXBvbmVudHMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZXNbaV0sIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC5kaXJlY3RpdmVzKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5kaXJlY3RpdmVzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC5jb21waWxlck9wdGlvbnMgJiYgaXNSdW50aW1lT25seSgpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBcImNvbXBpbGVyT3B0aW9uc1wiIGlzIG9ubHkgc3VwcG9ydGVkIHdoZW4gdXNpbmcgYSBidWlsZCBvZiBWdWUgdGhhdCBpbmNsdWRlcyB0aGUgcnVudGltZSBjb21waWxlci4gU2luY2UgeW91IGFyZSB1c2luZyBhIHJ1bnRpbWUtb25seSBidWlsZCwgdGhlIG9wdGlvbnMgc2hvdWxkIGJlIHBhc3NlZCB2aWEgeW91ciBidWlsZCB0b29sIGNvbmZpZyBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGluc3RhbmNlLmFjY2Vzc0NhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGluc3RhbmNlLnByb3h5ID0gbmV3IFByb3h5KGluc3RhbmNlLmN0eCwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gIH1cbiAgY29uc3QgeyBzZXR1cCB9ID0gQ29tcG9uZW50O1xuICBpZiAoc2V0dXApIHtcbiAgICBjb25zdCBzZXR1cENvbnRleHQgPSBpbnN0YW5jZS5zZXR1cENvbnRleHQgPSBzZXR1cC5sZW5ndGggPiAxID8gY3JlYXRlU2V0dXBDb250ZXh0KGluc3RhbmNlKSA6IG51bGw7XG4gICAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICBjb25zdCBzZXR1cFJlc3VsdCA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcbiAgICAgIHNldHVwLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICAwLFxuICAgICAgW1xuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnByb3BzKSA6IGluc3RhbmNlLnByb3BzLFxuICAgICAgICBzZXR1cENvbnRleHRcbiAgICAgIF1cbiAgICApO1xuICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICByZXNldCgpO1xuICAgIGlmIChpc1Byb21pc2Uoc2V0dXBSZXN1bHQpKSB7XG4gICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyKGluc3RhbmNlKSkgbWFya0FzeW5jQm91bmRhcnkoaW5zdGFuY2UpO1xuICAgICAgc2V0dXBSZXN1bHQudGhlbih1bnNldEN1cnJlbnRJbnN0YW5jZSwgdW5zZXRDdXJyZW50SW5zdGFuY2UpO1xuICAgICAgaWYgKGlzU1NSKSB7XG4gICAgICAgIHJldHVybiBzZXR1cFJlc3VsdC50aGVuKChyZXNvbHZlZFJlc3VsdCkgPT4ge1xuICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCByZXNvbHZlZFJlc3VsdCwgaXNTU1IpO1xuICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGluc3RhbmNlLCAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5hc3luY0RlcCA9IHNldHVwUmVzdWx0O1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaW5zdGFuY2Uuc3VzcGVuc2UpIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gKF9hID0gQ29tcG9uZW50Lm5hbWUpICE9IG51bGwgPyBfYSA6IFwiQW5vbnltb3VzXCI7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYENvbXBvbmVudCA8JHtuYW1lfT46IHNldHVwIGZ1bmN0aW9uIHJldHVybmVkIGEgcHJvbWlzZSwgYnV0IG5vIDxTdXNwZW5zZT4gYm91bmRhcnkgd2FzIGZvdW5kIGluIHRoZSBwYXJlbnQgY29tcG9uZW50IHRyZWUuIEEgY29tcG9uZW50IHdpdGggYXN5bmMgc2V0dXAoKSBtdXN0IGJlIG5lc3RlZCBpbiBhIDxTdXNwZW5zZT4gaW4gb3JkZXIgdG8gYmUgcmVuZGVyZWQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpIHtcbiAgaWYgKGlzRnVuY3Rpb24oc2V0dXBSZXN1bHQpKSB7XG4gICAgaWYgKGluc3RhbmNlLnR5cGUuX19zc3JJbmxpbmVSZW5kZXIpIHtcbiAgICAgIGluc3RhbmNlLnNzclJlbmRlciA9IHNldHVwUmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5yZW5kZXIgPSBzZXR1cFJlc3VsdDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qoc2V0dXBSZXN1bHQpKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNWTm9kZShzZXR1cFJlc3VsdCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYHNldHVwKCkgc2hvdWxkIG5vdCByZXR1cm4gVk5vZGVzIGRpcmVjdGx5IC0gcmV0dXJuIGEgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBpbnN0YW5jZS5kZXZ0b29sc1Jhd1NldHVwU3RhdGUgPSBzZXR1cFJlc3VsdDtcbiAgICB9XG4gICAgaW5zdGFuY2Uuc2V0dXBTdGF0ZSA9IHByb3h5UmVmcyhzZXR1cFJlc3VsdCk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldHVwUmVzdWx0ICE9PSB2b2lkIDApIHtcbiAgICB3YXJuJDEoXG4gICAgICBgc2V0dXAoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC4gUmVjZWl2ZWQ6ICR7c2V0dXBSZXN1bHQgPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBzZXR1cFJlc3VsdH1gXG4gICAgKTtcbiAgfVxuICBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IpO1xufVxubGV0IGNvbXBpbGU7XG5sZXQgaW5zdGFsbFdpdGhQcm94eTtcbmZ1bmN0aW9uIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyKF9jb21waWxlKSB7XG4gIGNvbXBpbGUgPSBfY29tcGlsZTtcbiAgaW5zdGFsbFdpdGhQcm94eSA9IChpKSA9PiB7XG4gICAgaWYgKGkucmVuZGVyLl9yYykge1xuICAgICAgaS53aXRoUHJveHkgPSBuZXcgUHJveHkoaS5jdHgsIFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyk7XG4gICAgfVxuICB9O1xufVxuY29uc3QgaXNSdW50aW1lT25seSA9ICgpID0+ICFjb21waWxlO1xuZnVuY3Rpb24gZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSLCBza2lwT3B0aW9ucykge1xuICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICBpZiAoIWluc3RhbmNlLnJlbmRlcikge1xuICAgIGlmICghaXNTU1IgJiYgY29tcGlsZSAmJiAhQ29tcG9uZW50LnJlbmRlcikge1xuICAgICAgY29uc3QgdGVtcGxhdGUgPSBDb21wb25lbnQudGVtcGxhdGUgfHwgcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpLnRlbXBsYXRlO1xuICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaXNDdXN0b21FbGVtZW50LCBjb21waWxlck9wdGlvbnMgfSA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnO1xuICAgICAgICBjb25zdCB7IGRlbGltaXRlcnMsIGNvbXBpbGVyT3B0aW9uczogY29tcG9uZW50Q29tcGlsZXJPcHRpb25zIH0gPSBDb21wb25lbnQ7XG4gICAgICAgIGNvbnN0IGZpbmFsQ29tcGlsZXJPcHRpb25zID0gZXh0ZW5kKFxuICAgICAgICAgIGV4dGVuZChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaXNDdXN0b21FbGVtZW50LFxuICAgICAgICAgICAgICBkZWxpbWl0ZXJzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcGlsZXJPcHRpb25zXG4gICAgICAgICAgKSxcbiAgICAgICAgICBjb21wb25lbnRDb21waWxlck9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgICAgQ29tcG9uZW50LnJlbmRlciA9IGNvbXBpbGUodGVtcGxhdGUsIGZpbmFsQ29tcGlsZXJPcHRpb25zKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLnJlbmRlciA9IENvbXBvbmVudC5yZW5kZXIgfHwgTk9PUDtcbiAgICBpZiAoaW5zdGFsbFdpdGhQcm94eSkge1xuICAgICAgaW5zdGFsbFdpdGhQcm94eShpbnN0YW5jZSk7XG4gICAgfVxuICB9XG4gIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmIHRydWUpIHtcbiAgICBjb25zdCByZXNldCA9IHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgcGF1c2VUcmFja2luZygpO1xuICAgIHRyeSB7XG4gICAgICBhcHBseU9wdGlvbnMoaW5zdGFuY2UpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICByZXNldCgpO1xuICAgIH1cbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhQ29tcG9uZW50LnJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1AgJiYgIWlzU1NSKSB7XG4gICAgaWYgKCFjb21waWxlICYmIENvbXBvbmVudC50ZW1wbGF0ZSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgQ29tcG9uZW50IHByb3ZpZGVkIHRlbXBsYXRlIG9wdGlvbiBidXQgcnVudGltZSBjb21waWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgVnVlLmAgKyAoYCBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi5gIClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4kMShgQ29tcG9uZW50IGlzIG1pc3NpbmcgdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uOiBgLCBDb21wb25lbnQpO1xuICAgIH1cbiAgfVxufVxuY29uc3QgYXR0cnNQcm94eUhhbmRsZXJzID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHtcbiAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIsIFwiXCIpO1xuICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgfSxcbiAgc2V0KCkge1xuICAgIHdhcm4kMShgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHkoKSB7XG4gICAgd2FybiQxKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59IDoge1xuICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIsIFwiXCIpO1xuICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFNsb3RzUHJveHkoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIG5ldyBQcm94eShpbnN0YW5jZS5zbG90cywge1xuICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIsIFwiJHNsb3RzXCIpO1xuICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3QgZXhwb3NlID0gKGV4cG9zZWQpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICAgICAgd2FybiQxKGBleHBvc2UoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZSBwZXIgc2V0dXAoKS5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChleHBvc2VkICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGV4cG9zZWRUeXBlID0gdHlwZW9mIGV4cG9zZWQ7XG4gICAgICAgIGlmIChleHBvc2VkVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGV4cG9zZWQpKSB7XG4gICAgICAgICAgICBleHBvc2VkVHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUmVmKGV4cG9zZWQpKSB7XG4gICAgICAgICAgICBleHBvc2VkVHlwZSA9IFwicmVmXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvc2VkVHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBleHBvc2UoKSBzaG91bGQgYmUgcGFzc2VkIGEgcGxhaW4gb2JqZWN0LCByZWNlaXZlZCAke2V4cG9zZWRUeXBlfS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW5jZS5leHBvc2VkID0gZXhwb3NlZCB8fCB7fTtcbiAgfTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBsZXQgYXR0cnNQcm94eTtcbiAgICBsZXQgc2xvdHNQcm94eTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBnZXQgYXR0cnMoKSB7XG4gICAgICAgIHJldHVybiBhdHRyc1Byb3h5IHx8IChhdHRyc1Byb3h5ID0gbmV3IFByb3h5KGluc3RhbmNlLmF0dHJzLCBhdHRyc1Byb3h5SGFuZGxlcnMpKTtcbiAgICAgIH0sXG4gICAgICBnZXQgc2xvdHMoKSB7XG4gICAgICAgIHJldHVybiBzbG90c1Byb3h5IHx8IChzbG90c1Byb3h5ID0gZ2V0U2xvdHNQcm94eShpbnN0YW5jZSkpO1xuICAgICAgfSxcbiAgICAgIGdldCBlbWl0KCkge1xuICAgICAgICByZXR1cm4gKGV2ZW50LCAuLi5hcmdzKSA9PiBpbnN0YW5jZS5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBleHBvc2VcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgYXR0cnM6IG5ldyBQcm94eShpbnN0YW5jZS5hdHRycywgYXR0cnNQcm94eUhhbmRsZXJzKSxcbiAgICAgIHNsb3RzOiBpbnN0YW5jZS5zbG90cyxcbiAgICAgIGVtaXQ6IGluc3RhbmNlLmVtaXQsXG4gICAgICBleHBvc2VcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkge1xuICBpZiAoaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgIHJldHVybiBpbnN0YW5jZS5leHBvc2VQcm94eSB8fCAoaW5zdGFuY2UuZXhwb3NlUHJveHkgPSBuZXcgUHJveHkocHJveHlSZWZzKG1hcmtSYXcoaW5zdGFuY2UuZXhwb3NlZCkpLCB7XG4gICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXApIHtcbiAgICAgICAgICByZXR1cm4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhcyh0YXJnZXQsIGtleSkge1xuICAgICAgICByZXR1cm4ga2V5IGluIHRhcmdldCB8fCBrZXkgaW4gcHVibGljUHJvcGVydGllc01hcDtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLnByb3h5O1xuICB9XG59XG5jb25zdCBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuY29uc3QgY2xhc3NpZnkgPSAoc3RyKSA9PiBzdHIucmVwbGFjZShjbGFzc2lmeVJFLCAoYykgPT4gYy50b1VwcGVyQ2FzZSgpKS5yZXBsYWNlKC9bLV9dL2csIFwiXCIpO1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQsIGluY2x1ZGVJbmZlcnJlZCA9IHRydWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oQ29tcG9uZW50KSA/IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSA6IENvbXBvbmVudC5uYW1lIHx8IGluY2x1ZGVJbmZlcnJlZCAmJiBDb21wb25lbnQuX19uYW1lO1xufVxuZnVuY3Rpb24gZm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgQ29tcG9uZW50LCBpc1Jvb3QgPSBmYWxzZSkge1xuICBsZXQgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KTtcbiAgaWYgKCFuYW1lICYmIENvbXBvbmVudC5fX2ZpbGUpIHtcbiAgICBjb25zdCBtYXRjaCA9IENvbXBvbmVudC5fX2ZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwuXFx3KyQvKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIG5hbWUgPSBtYXRjaFsxXTtcbiAgICB9XG4gIH1cbiAgaWYgKCFuYW1lICYmIGluc3RhbmNlICYmIGluc3RhbmNlLnBhcmVudCkge1xuICAgIGNvbnN0IGluZmVyRnJvbVJlZ2lzdHJ5ID0gKHJlZ2lzdHJ5KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiByZWdpc3RyeSkge1xuICAgICAgICBpZiAocmVnaXN0cnlba2V5XSA9PT0gQ29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgbmFtZSA9IGluZmVyRnJvbVJlZ2lzdHJ5KFxuICAgICAgaW5zdGFuY2UuY29tcG9uZW50cyB8fCBpbnN0YW5jZS5wYXJlbnQudHlwZS5jb21wb25lbnRzXG4gICAgKSB8fCBpbmZlckZyb21SZWdpc3RyeShpbnN0YW5jZS5hcHBDb250ZXh0LmNvbXBvbmVudHMpO1xuICB9XG4gIHJldHVybiBuYW1lID8gY2xhc3NpZnkobmFtZSkgOiBpc1Jvb3QgPyBgQXBwYCA6IGBBbm9ueW1vdXNgO1xufVxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudCh2YWx1ZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgJiYgXCJfX3ZjY09wdHNcIiBpbiB2YWx1ZTtcbn1cblxuY29uc3QgY29tcHV0ZWQgPSAoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMpID0+IHtcbiAgY29uc3QgYyA9IGNvbXB1dGVkJDEoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMsIGlzSW5TU1JDb21wb25lbnRTZXR1cCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGlmIChpICYmIGkuYXBwQ29udGV4dC5jb25maWcud2FyblJlY3Vyc2l2ZUNvbXB1dGVkKSB7XG4gICAgICBjLl93YXJuUmVjdXJzaXZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGM7XG59O1xuXG5mdW5jdGlvbiB1c2VUZW1wbGF0ZVJlZihrZXkpIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBjb25zdCByID0gc2hhbGxvd1JlZihudWxsKTtcbiAgaWYgKGkpIHtcbiAgICBjb25zdCByZWZzID0gaS5yZWZzID09PSBFTVBUWV9PQkogPyBpLnJlZnMgPSB7fSA6IGkucmVmcztcbiAgICBsZXQgZGVzYztcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAoZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVmcywga2V5KSkgJiYgIWRlc2MuY29uZmlndXJhYmxlKSB7XG4gICAgICB3YXJuJDEoYHVzZVRlbXBsYXRlUmVmKCcke2tleX0nKSBhbHJlYWR5IGV4aXN0cy5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlZnMsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHIudmFsdWUsXG4gICAgICAgIHNldDogKHZhbCkgPT4gci52YWx1ZSA9IHZhbFxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgdXNlVGVtcGxhdGVSZWYoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHJlYWRvbmx5KHIpIDogcjtcbn1cblxuZnVuY3Rpb24gaCh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKSB7XG4gIGNvbnN0IGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICBpZiAobCA9PT0gMikge1xuICAgIGlmIChpc09iamVjdChwcm9wc09yQ2hpbGRyZW4pICYmICFpc0FycmF5KHByb3BzT3JDaGlsZHJlbikpIHtcbiAgICAgIGlmIChpc1ZOb2RlKHByb3BzT3JDaGlsZHJlbikpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIFtwcm9wc09yQ2hpbGRyZW5dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgcHJvcHNPckNoaWxkcmVuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGwgPiAzKSB7XG4gICAgICBjaGlsZHJlbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgfSBlbHNlIGlmIChsID09PSAzICYmIGlzVk5vZGUoY2hpbGRyZW4pKSB7XG4gICAgICBjaGlsZHJlbiA9IFtjaGlsZHJlbl07XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q3VzdG9tRm9ybWF0dGVyKCkge1xuICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB2dWVTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6IzNiYTc3NlwiIH07XG4gIGNvbnN0IG51bWJlclN0eWxlID0geyBzdHlsZTogXCJjb2xvcjojMTY3N2ZmXCIgfTtcbiAgY29uc3Qgc3RyaW5nU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiNmNTIyMmRcIiB9O1xuICBjb25zdCBrZXl3b3JkU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiNlYjJmOTZcIiB9O1xuICBjb25zdCBmb3JtYXR0ZXIgPSB7XG4gICAgX192dWVfY3VzdG9tX2Zvcm1hdHRlcjogdHJ1ZSxcbiAgICBoZWFkZXIob2JqKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAob2JqLl9faXNWdWUpIHtcbiAgICAgICAgcmV0dXJuIFtcImRpdlwiLCB2dWVTdHlsZSwgYFZ1ZUluc3RhbmNlYF07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVmKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIFtcInNwYW5cIiwgdnVlU3R5bGUsIGdlblJlZkZsYWcob2JqKV0sXG4gICAgICAgICAgXCI8XCIsXG4gICAgICAgICAgLy8gYXZvaWQgZGVidWdnZXIgYWNjZXNzaW5nIHZhbHVlIGFmZmVjdGluZyBiZWhhdmlvclxuICAgICAgICAgIGZvcm1hdFZhbHVlKFwiX3ZhbHVlXCIgaW4gb2JqID8gb2JqLl92YWx1ZSA6IG9iaiksXG4gICAgICAgICAgYD5gXG4gICAgICAgIF07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUob2JqKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyBcIlNoYWxsb3dSZWFjdGl2ZVwiIDogXCJSZWFjdGl2ZVwiXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxuICAgICAgICAgIGA+JHtpc1JlYWRvbmx5KG9iaikgPyBgIChyZWFkb25seSlgIDogYGB9YFxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWRvbmx5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIFtcInNwYW5cIiwgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gXCJTaGFsbG93UmVhZG9ubHlcIiA6IFwiUmVhZG9ubHlcIl0sXG4gICAgICAgICAgXCI8XCIsXG4gICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcbiAgICAgICAgICBcIj5cIlxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBoYXNCb2R5KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19pc1Z1ZTtcbiAgICB9LFxuICAgIGJvZHkob2JqKSB7XG4gICAgICBpZiAob2JqICYmIG9iai5fX2lzVnVlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5mb3JtYXRJbnN0YW5jZShvYmouJClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGZvcm1hdEluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgY29uc3QgYmxvY2tzID0gW107XG4gICAgaWYgKGluc3RhbmNlLnR5cGUucHJvcHMgJiYgaW5zdGFuY2UucHJvcHMpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJwcm9wc1wiLCB0b1JhdyhpbnN0YW5jZS5wcm9wcykpKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLnNldHVwU3RhdGUgIT09IEVNUFRZX09CSikge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcInNldHVwXCIsIGluc3RhbmNlLnNldHVwU3RhdGUpKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLmRhdGEgIT09IEVNUFRZX09CSikge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcImRhdGFcIiwgdG9SYXcoaW5zdGFuY2UuZGF0YSkpKTtcbiAgICB9XG4gICAgY29uc3QgY29tcHV0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgXCJjb21wdXRlZFwiKTtcbiAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJjb21wdXRlZFwiLCBjb21wdXRlZCkpO1xuICAgIH1cbiAgICBjb25zdCBpbmplY3RlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCBcImluamVjdFwiKTtcbiAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJpbmplY3RlZFwiLCBpbmplY3RlZCkpO1xuICAgIH1cbiAgICBibG9ja3MucHVzaChbXG4gICAgICBcImRpdlwiLFxuICAgICAge30sXG4gICAgICBbXG4gICAgICAgIFwic3BhblwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IGtleXdvcmRTdHlsZS5zdHlsZSArIFwiO29wYWNpdHk6MC42NlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJCAoaW50ZXJuYWwpOiBcIlxuICAgICAgXSxcbiAgICAgIFtcIm9iamVjdFwiLCB7IG9iamVjdDogaW5zdGFuY2UgfV1cbiAgICBdKTtcbiAgICByZXR1cm4gYmxvY2tzO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlQmxvY2sodHlwZSwgdGFyZ2V0KSB7XG4gICAgdGFyZ2V0ID0gZXh0ZW5kKHt9LCB0YXJnZXQpO1xuICAgIGlmICghT2JqZWN0LmtleXModGFyZ2V0KS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHt9XTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7IHN0eWxlOiBcImxpbmUtaGVpZ2h0OjEuMjVlbTttYXJnaW4tYm90dG9tOjAuNmVtXCIgfSxcbiAgICAgIFtcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0eWxlOiBcImNvbG9yOiM0NzY1ODJcIlxuICAgICAgICB9LFxuICAgICAgICB0eXBlXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IFwicGFkZGluZy1sZWZ0OjEuMjVlbVwiXG4gICAgICAgIH0sXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKHRhcmdldCkubWFwKChrZXkpID0+IHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgW1wic3BhblwiLCBrZXl3b3JkU3R5bGUsIGtleSArIFwiOiBcIl0sXG4gICAgICAgICAgICBmb3JtYXRWYWx1ZSh0YXJnZXRba2V5XSwgZmFsc2UpXG4gICAgICAgICAgXTtcbiAgICAgICAgfSlcbiAgICAgIF1cbiAgICBdO1xuICB9XG4gIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHYsIGFzUmF3ID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwgbnVtYmVyU3R5bGUsIHZdO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHN0cmluZ1N0eWxlLCBKU09OLnN0cmluZ2lmeSh2KV07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIGtleXdvcmRTdHlsZSwgdl07XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2KSkge1xuICAgICAgcmV0dXJuIFtcIm9iamVjdFwiLCB7IG9iamVjdDogYXNSYXcgPyB0b1Jhdyh2KSA6IHYgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHN0cmluZ1N0eWxlLCBTdHJpbmcodildO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBleHRyYWN0S2V5cyhpbnN0YW5jZSwgdHlwZSkge1xuICAgIGNvbnN0IENvbXAgPSBpbnN0YW5jZS50eXBlO1xuICAgIGlmIChpc0Z1bmN0aW9uKENvbXApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhY3RlZCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLmN0eCkge1xuICAgICAgaWYgKGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkpIHtcbiAgICAgICAgZXh0cmFjdGVkW2tleV0gPSBpbnN0YW5jZS5jdHhba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4dHJhY3RlZDtcbiAgfVxuICBmdW5jdGlvbiBpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpIHtcbiAgICBjb25zdCBvcHRzID0gQ29tcFt0eXBlXTtcbiAgICBpZiAoaXNBcnJheShvcHRzKSAmJiBvcHRzLmluY2x1ZGVzKGtleSkgfHwgaXNPYmplY3Qob3B0cykgJiYga2V5IGluIG9wdHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQ29tcC5leHRlbmRzICYmIGlzS2V5T2ZUeXBlKENvbXAuZXh0ZW5kcywga2V5LCB0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChDb21wLm1peGlucyAmJiBDb21wLm1peGlucy5zb21lKChtKSA9PiBpc0tleU9mVHlwZShtLCBrZXksIHR5cGUpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdlblJlZkZsYWcodikge1xuICAgIGlmIChpc1NoYWxsb3codikpIHtcbiAgICAgIHJldHVybiBgU2hhbGxvd1JlZmA7XG4gICAgfVxuICAgIGlmICh2LmVmZmVjdCkge1xuICAgICAgcmV0dXJuIGBDb21wdXRlZFJlZmA7XG4gICAgfVxuICAgIHJldHVybiBgUmVmYDtcbiAgfVxuICBpZiAod2luZG93LmRldnRvb2xzRm9ybWF0dGVycykge1xuICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMucHVzaChmb3JtYXR0ZXIpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMgPSBbZm9ybWF0dGVyXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3aXRoTWVtbyhtZW1vLCByZW5kZXIsIGNhY2hlLCBpbmRleCkge1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZVtpbmRleF07XG4gIGlmIChjYWNoZWQgJiYgaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBjb25zdCByZXQgPSByZW5kZXIoKTtcbiAgcmV0Lm1lbW8gPSBtZW1vLnNsaWNlKCk7XG4gIHJldC5jYWNoZUluZGV4ID0gaW5kZXg7XG4gIHJldHVybiBjYWNoZVtpbmRleF0gPSByZXQ7XG59XG5mdW5jdGlvbiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykge1xuICBjb25zdCBwcmV2ID0gY2FjaGVkLm1lbW87XG4gIGlmIChwcmV2Lmxlbmd0aCAhPSBtZW1vLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXYubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGFzQ2hhbmdlZChwcmV2W2ldLCBtZW1vW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcbiAgICBjdXJyZW50QmxvY2sucHVzaChjYWNoZWQpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5jb25zdCB2ZXJzaW9uID0gXCIzLjUuMC1iZXRhLjNcIjtcbmNvbnN0IHdhcm4gPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gd2FybiQxIDogTk9PUDtcbmNvbnN0IEVycm9yVHlwZVN0cmluZ3MgPSBFcnJvclR5cGVTdHJpbmdzJDEgO1xuY29uc3QgZGV2dG9vbHMgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IHRydWUgPyBkZXZ0b29scyQxIDogdm9pZCAwO1xuY29uc3Qgc2V0RGV2dG9vbHNIb29rID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCB0cnVlID8gc2V0RGV2dG9vbHNIb29rJDEgOiBOT09QO1xuY29uc3QgX3NzclV0aWxzID0ge1xuICBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSxcbiAgc2V0dXBDb21wb25lbnQsXG4gIHJlbmRlckNvbXBvbmVudFJvb3QsXG4gIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSxcbiAgaXNWTm9kZTogaXNWTm9kZSxcbiAgbm9ybWFsaXplVk5vZGUsXG4gIGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlLFxuICBlbnN1cmVWYWxpZFZOb2RlXG59O1xuY29uc3Qgc3NyVXRpbHMgPSBfc3NyVXRpbHMgO1xuY29uc3QgcmVzb2x2ZUZpbHRlciA9IG51bGw7XG5jb25zdCBjb21wYXRVdGlscyA9IG51bGw7XG5jb25zdCBEZXByZWNhdGlvblR5cGVzID0gbnVsbDtcblxuZXhwb3J0IHsgQmFzZVRyYW5zaXRpb24sIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCBDb21tZW50LCBEZXByZWNhdGlvblR5cGVzLCBFcnJvckNvZGVzLCBFcnJvclR5cGVTdHJpbmdzLCBGcmFnbWVudCwgS2VlcEFsaXZlLCBTdGF0aWMsIFN1c3BlbnNlLCBUZWxlcG9ydCwgVGV4dCwgYXNzZXJ0TnVtYmVyLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgY2FsbFdpdGhFcnJvckhhbmRsaW5nLCBjbG9uZVZOb2RlLCBjb21wYXRVdGlscywgY29tcHV0ZWQsIGNyZWF0ZUJsb2NrLCBjcmVhdGVDb21tZW50Vk5vZGUsIGNyZWF0ZUVsZW1lbnRCbG9jaywgY3JlYXRlQmFzZVZOb2RlIGFzIGNyZWF0ZUVsZW1lbnRWTm9kZSwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIsIGNyZWF0ZVByb3BzUmVzdFByb3h5LCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlU2xvdHMsIGNyZWF0ZVN0YXRpY1ZOb2RlLCBjcmVhdGVUZXh0Vk5vZGUsIGNyZWF0ZVZOb2RlLCBkZWZpbmVBc3luY0NvbXBvbmVudCwgZGVmaW5lQ29tcG9uZW50LCBkZWZpbmVFbWl0cywgZGVmaW5lRXhwb3NlLCBkZWZpbmVNb2RlbCwgZGVmaW5lT3B0aW9ucywgZGVmaW5lUHJvcHMsIGRlZmluZVNsb3RzLCBkZXZ0b29scywgZ2V0Q3VycmVudEluc3RhbmNlLCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIGd1YXJkUmVhY3RpdmVQcm9wcywgaCwgaGFuZGxlRXJyb3IsIGhhc0luamVjdGlvbkNvbnRleHQsIGh5ZHJhdGVPbklkbGUsIGh5ZHJhdGVPbkludGVyYWN0aW9uLCBoeWRyYXRlT25NZWRpYVF1ZXJ5LCBoeWRyYXRlT25WaXNpYmxlLCBpbml0Q3VzdG9tRm9ybWF0dGVyLCBpbmplY3QsIGlzTWVtb1NhbWUsIGlzUnVudGltZU9ubHksIGlzVk5vZGUsIG1lcmdlRGVmYXVsdHMsIG1lcmdlTW9kZWxzLCBtZXJnZVByb3BzLCBuZXh0VGljaywgb25BY3RpdmF0ZWQsIG9uQmVmb3JlTW91bnQsIG9uQmVmb3JlVW5tb3VudCwgb25CZWZvcmVVcGRhdGUsIG9uRGVhY3RpdmF0ZWQsIG9uRXJyb3JDYXB0dXJlZCwgb25Nb3VudGVkLCBvblJlbmRlclRyYWNrZWQsIG9uUmVuZGVyVHJpZ2dlcmVkLCBvblNlcnZlclByZWZldGNoLCBvblVubW91bnRlZCwgb25VcGRhdGVkLCBvcGVuQmxvY2ssIHBvcFNjb3BlSWQsIHByb3ZpZGUsIHB1c2hTY29wZUlkLCBxdWV1ZVBvc3RGbHVzaENiLCByZWdpc3RlclJ1bnRpbWVDb21waWxlciwgcmVuZGVyTGlzdCwgcmVuZGVyU2xvdCwgcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSwgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQsIHJlc29sdmVGaWx0ZXIsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIHNldEJsb2NrVHJhY2tpbmcsIHNldERldnRvb2xzSG9vaywgc2V0VHJhbnNpdGlvbkhvb2tzLCBzc3JDb250ZXh0S2V5LCBzc3JVdGlscywgdG9IYW5kbGVycywgdHJhbnNmb3JtVk5vZGVBcmdzLCB1c2VBdHRycywgdXNlSWQsIHVzZU1vZGVsLCB1c2VTU1JDb250ZXh0LCB1c2VTbG90cywgdXNlVGVtcGxhdGVSZWYsIHVzZVRyYW5zaXRpb25TdGF0ZSwgdmVyc2lvbiwgd2Fybiwgd2F0Y2gsIHdhdGNoRWZmZWN0LCB3YXRjaFBvc3RFZmZlY3QsIHdhdGNoU3luY0VmZmVjdCwgd2l0aEFzeW5jQ29udGV4dCwgd2l0aEN0eCwgd2l0aERlZmF1bHRzLCB3aXRoRGlyZWN0aXZlcywgd2l0aE1lbW8sIHdpdGhTY29wZUlkIH07XG4iLCIvKipcbiogQHZ1ZS9zaGFyZWQgdjMuNS4wLWJldGEuM1xuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWFrZU1hcChzdHIsIGV4cGVjdHNMb3dlckNhc2UpIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldChzdHIuc3BsaXQoXCIsXCIpKTtcbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2UgPyAodmFsKSA9PiBzZXQuaGFzKHZhbC50b0xvd2VyQ2FzZSgpKSA6ICh2YWwpID0+IHNldC5oYXModmFsKTtcbn1cblxuY29uc3QgRU1QVFlfT0JKID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IE9iamVjdC5mcmVlemUoe30pIDoge307XG5jb25zdCBFTVBUWV9BUlIgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcbmNvbnN0IE5PT1AgPSAoKSA9PiB7XG59O1xuY29uc3QgTk8gPSAoKSA9PiBmYWxzZTtcbmNvbnN0IGlzT24gPSAoa2V5KSA9PiBrZXkuY2hhckNvZGVBdCgwKSA9PT0gMTExICYmIGtleS5jaGFyQ29kZUF0KDEpID09PSAxMTAgJiYgLy8gdXBwZXJjYXNlIGxldHRlclxuKGtleS5jaGFyQ29kZUF0KDIpID4gMTIyIHx8IGtleS5jaGFyQ29kZUF0KDIpIDwgOTcpO1xuY29uc3QgaXNNb2RlbExpc3RlbmVyID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoXCJvblVwZGF0ZTpcIik7XG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcbiAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcbiAgaWYgKGkgPiAtMSkge1xuICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gIH1cbn07XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgTWFwXVwiO1xuY29uc3QgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFNldF1cIjtcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbmNvbnN0IGlzUmVnRXhwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiO1xuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN5bWJvbFwiO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIjtcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIChpc09iamVjdCh2YWwpIHx8IGlzRnVuY3Rpb24odmFsKSkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xufTtcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufTtcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiYga2V5ICE9PSBcIk5hTlwiICYmIGtleVswXSAhPT0gXCItXCIgJiYgXCJcIiArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XG5jb25zdCBpc1Jlc2VydmVkUHJvcCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICAvLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXG4gIFwiLGtleSxyZWYscmVmX2ZvcixyZWZfa2V5LG9uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCxvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLG9uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWRcIlxuKTtcbmNvbnN0IGlzQnVpbHRJbkRpcmVjdGl2ZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBcImJpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0LG1lbW9cIlxuKTtcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChzdHIpID0+IHtcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgfTtcbn07XG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIik7XG4gIH1cbik7XG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgXCItJDFcIikudG9Mb3dlckNhc2UoKVxuKTtcbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn0pO1xuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4ge1xuICAgIGNvbnN0IHMgPSBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGA7XG4gICAgcmV0dXJuIHM7XG4gIH1cbik7XG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpO1xuY29uc3QgaW52b2tlQXJyYXlGbnMgPSAoZm5zLCAuLi5hcmcpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBmbnNbaV0oLi4uYXJnKTtcbiAgfVxufTtcbmNvbnN0IGRlZiA9IChvYmosIGtleSwgdmFsdWUsIHdyaXRhYmxlID0gZmFsc2UpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlLFxuICAgIHZhbHVlXG4gIH0pO1xufTtcbmNvbnN0IGxvb3NlVG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBpc1N0cmluZyh2YWwpID8gTnVtYmVyKHZhbCkgOiBOYU47XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xubGV0IF9nbG9iYWxUaGlzO1xuY29uc3QgZ2V0R2xvYmFsVGhpcyA9ICgpID0+IHtcbiAgcmV0dXJuIF9nbG9iYWxUaGlzIHx8IChfZ2xvYmFsVGhpcyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pO1xufTtcbmNvbnN0IGlkZW50UkUgPSAvXltfJGEtekEtWlxceEEwLVxcdUZGRkZdW18kYS16QS1aMC05XFx4QTAtXFx1RkZGRl0qJC87XG5mdW5jdGlvbiBnZW5Qcm9wc0FjY2Vzc0V4cChuYW1lKSB7XG4gIHJldHVybiBpZGVudFJFLnRlc3QobmFtZSkgPyBgX19wcm9wcy4ke25hbWV9YCA6IGBfX3Byb3BzWyR7SlNPTi5zdHJpbmdpZnkobmFtZSl9XWA7XG59XG5cbmNvbnN0IFBhdGNoRmxhZ3MgPSB7XG4gIFwiVEVYVFwiOiAxLFxuICBcIjFcIjogXCJURVhUXCIsXG4gIFwiQ0xBU1NcIjogMixcbiAgXCIyXCI6IFwiQ0xBU1NcIixcbiAgXCJTVFlMRVwiOiA0LFxuICBcIjRcIjogXCJTVFlMRVwiLFxuICBcIlBST1BTXCI6IDgsXG4gIFwiOFwiOiBcIlBST1BTXCIsXG4gIFwiRlVMTF9QUk9QU1wiOiAxNixcbiAgXCIxNlwiOiBcIkZVTExfUFJPUFNcIixcbiAgXCJORUVEX0hZRFJBVElPTlwiOiAzMixcbiAgXCIzMlwiOiBcIk5FRURfSFlEUkFUSU9OXCIsXG4gIFwiU1RBQkxFX0ZSQUdNRU5UXCI6IDY0LFxuICBcIjY0XCI6IFwiU1RBQkxFX0ZSQUdNRU5UXCIsXG4gIFwiS0VZRURfRlJBR01FTlRcIjogMTI4LFxuICBcIjEyOFwiOiBcIktFWUVEX0ZSQUdNRU5UXCIsXG4gIFwiVU5LRVlFRF9GUkFHTUVOVFwiOiAyNTYsXG4gIFwiMjU2XCI6IFwiVU5LRVlFRF9GUkFHTUVOVFwiLFxuICBcIk5FRURfUEFUQ0hcIjogNTEyLFxuICBcIjUxMlwiOiBcIk5FRURfUEFUQ0hcIixcbiAgXCJEWU5BTUlDX1NMT1RTXCI6IDEwMjQsXG4gIFwiMTAyNFwiOiBcIkRZTkFNSUNfU0xPVFNcIixcbiAgXCJERVZfUk9PVF9GUkFHTUVOVFwiOiAyMDQ4LFxuICBcIjIwNDhcIjogXCJERVZfUk9PVF9GUkFHTUVOVFwiLFxuICBcIkNBQ0hFRFwiOiAtMSxcbiAgXCItMVwiOiBcIkNBQ0hFRFwiLFxuICBcIkJBSUxcIjogLTIsXG4gIFwiLTJcIjogXCJCQUlMXCJcbn07XG5jb25zdCBQYXRjaEZsYWdOYW1lcyA9IHtcbiAgWzFdOiBgVEVYVGAsXG4gIFsyXTogYENMQVNTYCxcbiAgWzRdOiBgU1RZTEVgLFxuICBbOF06IGBQUk9QU2AsXG4gIFsxNl06IGBGVUxMX1BST1BTYCxcbiAgWzMyXTogYE5FRURfSFlEUkFUSU9OYCxcbiAgWzY0XTogYFNUQUJMRV9GUkFHTUVOVGAsXG4gIFsxMjhdOiBgS0VZRURfRlJBR01FTlRgLFxuICBbMjU2XTogYFVOS0VZRURfRlJBR01FTlRgLFxuICBbNTEyXTogYE5FRURfUEFUQ0hgLFxuICBbMTAyNF06IGBEWU5BTUlDX1NMT1RTYCxcbiAgWzIwNDhdOiBgREVWX1JPT1RfRlJBR01FTlRgLFxuICBbLTFdOiBgSE9JU1RFRGAsXG4gIFstMl06IGBCQUlMYFxufTtcblxuY29uc3QgU2hhcGVGbGFncyA9IHtcbiAgXCJFTEVNRU5UXCI6IDEsXG4gIFwiMVwiOiBcIkVMRU1FTlRcIixcbiAgXCJGVU5DVElPTkFMX0NPTVBPTkVOVFwiOiAyLFxuICBcIjJcIjogXCJGVU5DVElPTkFMX0NPTVBPTkVOVFwiLFxuICBcIlNUQVRFRlVMX0NPTVBPTkVOVFwiOiA0LFxuICBcIjRcIjogXCJTVEFURUZVTF9DT01QT05FTlRcIixcbiAgXCJURVhUX0NISUxEUkVOXCI6IDgsXG4gIFwiOFwiOiBcIlRFWFRfQ0hJTERSRU5cIixcbiAgXCJBUlJBWV9DSElMRFJFTlwiOiAxNixcbiAgXCIxNlwiOiBcIkFSUkFZX0NISUxEUkVOXCIsXG4gIFwiU0xPVFNfQ0hJTERSRU5cIjogMzIsXG4gIFwiMzJcIjogXCJTTE9UU19DSElMRFJFTlwiLFxuICBcIlRFTEVQT1JUXCI6IDY0LFxuICBcIjY0XCI6IFwiVEVMRVBPUlRcIixcbiAgXCJTVVNQRU5TRVwiOiAxMjgsXG4gIFwiMTI4XCI6IFwiU1VTUEVOU0VcIixcbiAgXCJDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkVcIjogMjU2LFxuICBcIjI1NlwiOiBcIkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRVwiLFxuICBcIkNPTVBPTkVOVF9LRVBUX0FMSVZFXCI6IDUxMixcbiAgXCI1MTJcIjogXCJDT01QT05FTlRfS0VQVF9BTElWRVwiLFxuICBcIkNPTVBPTkVOVFwiOiA2LFxuICBcIjZcIjogXCJDT01QT05FTlRcIlxufTtcblxuY29uc3QgU2xvdEZsYWdzID0ge1xuICBcIlNUQUJMRVwiOiAxLFxuICBcIjFcIjogXCJTVEFCTEVcIixcbiAgXCJEWU5BTUlDXCI6IDIsXG4gIFwiMlwiOiBcIkRZTkFNSUNcIixcbiAgXCJGT1JXQVJERURcIjogMyxcbiAgXCIzXCI6IFwiRk9SV0FSREVEXCJcbn07XG5jb25zdCBzbG90RmxhZ3NUZXh0ID0ge1xuICBbMV06IFwiU1RBQkxFXCIsXG4gIFsyXTogXCJEWU5BTUlDXCIsXG4gIFszXTogXCJGT1JXQVJERURcIlxufTtcblxuY29uc3QgR0xPQkFMU19BTExPV0VEID0gXCJJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLHBhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LE1hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQsY29uc29sZSxFcnJvcixTeW1ib2xcIjtcbmNvbnN0IGlzR2xvYmFsbHlBbGxvd2VkID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoR0xPQkFMU19BTExPV0VEKTtcbmNvbnN0IGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCA9IGlzR2xvYmFsbHlBbGxvd2VkO1xuXG5jb25zdCByYW5nZSA9IDI7XG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZShzb3VyY2UsIHN0YXJ0ID0gMCwgZW5kID0gc291cmNlLmxlbmd0aCkge1xuICBzdGFydCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHN0YXJ0LCBzb3VyY2UubGVuZ3RoKSk7XG4gIGVuZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGVuZCwgc291cmNlLmxlbmd0aCkpO1xuICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBcIlwiO1xuICBsZXQgbGluZXMgPSBzb3VyY2Uuc3BsaXQoLyhcXHI/XFxuKS8pO1xuICBjb25zdCBuZXdsaW5lU2VxdWVuY2VzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDEpO1xuICBsaW5lcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAwKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAobmV3bGluZVNlcXVlbmNlc1tpXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2ldLmxlbmd0aCB8fCAwKTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbGluZSA9IGogKyAxO1xuICAgICAgICByZXMucHVzaChcbiAgICAgICAgICBgJHtsaW5lfSR7XCIgXCIucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5ld0xpbmVTZXFMZW5ndGggPSBuZXdsaW5lU2VxdWVuY2VzW2pdICYmIG5ld2xpbmVTZXF1ZW5jZXNbal0ubGVuZ3RoIHx8IDA7XG4gICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSAobGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGgpKTtcbiAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIiBcIi5yZXBlYXQocGFkKSArIFwiXlwiLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpLCAxKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGlzU3RyaW5nKGl0ZW0pID8gcGFyc2VTdHJpbmdTdHlsZShpdGVtKSA6IG5vcm1hbGl6ZVN0eWxlKGl0ZW0pO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsaXplZCkge1xuICAgICAgICAgIHJlc1trZXldID0gbm9ybWFsaXplZFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuY29uc3QgbGlzdERlbGltaXRlclJFID0gLzsoPyFbXihdKlxcKSkvZztcbmNvbnN0IHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOihbXl0rKS87XG5jb25zdCBzdHlsZUNvbW1lbnRSRSA9IC9cXC9cXCpbXl0qP1xcKlxcLy9nO1xuZnVuY3Rpb24gcGFyc2VTdHJpbmdTdHlsZShjc3NUZXh0KSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBjc3NUZXh0LnJlcGxhY2Uoc3R5bGVDb21tZW50UkUsIFwiXCIpLnNwbGl0KGxpc3REZWxpbWl0ZXJSRSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBjb25zdCB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyUkUpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJldFt0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZShzdHlsZXMpIHtcbiAgbGV0IHJldCA9IFwiXCI7XG4gIGlmICghc3R5bGVzIHx8IGlzU3RyaW5nKHN0eWxlcykpIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xuICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBrZXkuc3RhcnRzV2l0aChgLS1gKSA/IGtleSA6IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgcmV0ICs9IGAke25vcm1hbGl6ZWRLZXl9OiR7dmFsdWV9O2A7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzcyh2YWx1ZSkge1xuICBsZXQgcmVzID0gXCJcIjtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJlcyA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcbiAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgXCIgXCI7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW25hbWVdKSB7XG4gICAgICAgIHJlcyArPSBuYW1lICsgXCIgXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXMudHJpbSgpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMocHJvcHMpIHtcbiAgaWYgKCFwcm9wcykgcmV0dXJuIG51bGw7XG4gIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xuICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xuICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xuICB9XG4gIGlmIChzdHlsZSkge1xuICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICB9XG4gIHJldHVybiBwcm9wcztcbn1cblxuY29uc3QgSFRNTF9UQUdTID0gXCJodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSxhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsaDEsaDIsaDMsaDQsaDUsaDYsbmF2LHNlY3Rpb24sZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdFwiO1xuY29uc3QgU1ZHX1RBR1MgPSBcInN2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSxkZWZzLGRlc2MsZGlzY2FyZCxlbGxpcHNlLGZlQmxlbmQsZmVDb2xvck1hdHJpeCxmZUNvbXBvbmVudFRyYW5zZmVyLGZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsZmVEaXN0YW50TGlnaHQsZmVEcm9wU2hhZG93LGZlRmxvb2QsZmVGdW5jQSxmZUZ1bmNCLGZlRnVuY0csZmVGdW5jUixmZUdhdXNzaWFuQmx1cixmZUltYWdlLGZlTWVyZ2UsZmVNZXJnZU5vZGUsZmVNb3JwaG9sb2d5LGZlT2Zmc2V0LGZlUG9pbnRMaWdodCxmZVNwZWN1bGFyTGlnaHRpbmcsZmVTcG90TGlnaHQsZmVUaWxlLGZlVHVyYnVsZW5jZSxmaWx0ZXIsZm9yZWlnbk9iamVjdCxnLGhhdGNoLGhhdGNocGF0aCxpbWFnZSxsaW5lLGxpbmVhckdyYWRpZW50LG1hcmtlcixtYXNrLG1lc2gsbWVzaGdyYWRpZW50LG1lc2hwYXRjaCxtZXNocm93LG1ldGFkYXRhLG1wYXRoLHBhdGgscGF0dGVybixwb2x5Z29uLHBvbHlsaW5lLHJhZGlhbEdyYWRpZW50LHJlY3Qsc2V0LHNvbGlkY29sb3Isc3RvcCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dFBhdGgsdGl0bGUsdHNwYW4sdW5rbm93bix1c2Usdmlld1wiO1xuY29uc3QgTUFUSF9UQUdTID0gXCJhbm5vdGF0aW9uLGFubm90YXRpb24teG1sLG1hY3Rpb24sbWFsaWduZ3JvdXAsbWFsaWdubWFyayxtYXRoLG1lbmNsb3NlLG1lcnJvcixtZmVuY2VkLG1mcmFjLG1mcmFjdGlvbixtZ2x5cGgsbWksbWxhYmVsZWR0cixtbG9uZ2RpdixtbXVsdGlzY3JpcHRzLG1uLG1vLG1vdmVyLG1wYWRkZWQsbXBoYW50b20sbXByZXNjcmlwdHMsbXJvb3QsbXJvdyxtcyxtc2NhcnJpZXMsbXNjYXJyeSxtc2dyb3VwLG1zbGluZSxtc3BhY2UsbXNxcnQsbXNyb3csbXN0YWNrLG1zdHlsZSxtc3ViLG1zdWJzdXAsbXN1cCxtdGFibGUsbXRkLG10ZXh0LG10cixtdW5kZXIsbXVuZGVyb3Zlcixub25lLHNlbWFudGljc1wiO1xuY29uc3QgVk9JRF9UQUdTID0gXCJhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGhyLGltZyxpbnB1dCxsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdiclwiO1xuY29uc3QgaXNIVE1MVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoSFRNTF9UQUdTKTtcbmNvbnN0IGlzU1ZHVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoU1ZHX1RBR1MpO1xuY29uc3QgaXNNYXRoTUxUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChNQVRIX1RBR1MpO1xuY29uc3QgaXNWb2lkVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoVk9JRF9UQUdTKTtcblxuY29uc3Qgc3BlY2lhbEJvb2xlYW5BdHRycyA9IGBpdGVtc2NvcGUsYWxsb3dmdWxsc2NyZWVuLGZvcm1ub3ZhbGlkYXRlLGlzbWFwLG5vbW9kdWxlLG5vdmFsaWRhdGUscmVhZG9ubHlgO1xuY29uc3QgaXNTcGVjaWFsQm9vbGVhbkF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzKTtcbmNvbnN0IGlzQm9vbGVhbkF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgc3BlY2lhbEJvb2xlYW5BdHRycyArIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGluZXJ0LGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGBcbik7XG5mdW5jdGlvbiBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgfHwgdmFsdWUgPT09IFwiXCI7XG59XG5jb25zdCB1bnNhZmVBdHRyQ2hhclJFID0gL1s+Lz1cIidcXHUwMDA5XFx1MDAwYVxcdTAwMGNcXHUwMDIwXS87XG5jb25zdCBhdHRyVmFsaWRhdGlvbkNhY2hlID0ge307XG5mdW5jdGlvbiBpc1NTUlNhZmVBdHRyTmFtZShuYW1lKSB7XG4gIGlmIChhdHRyVmFsaWRhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV07XG4gIH1cbiAgY29uc3QgaXNVbnNhZmUgPSB1bnNhZmVBdHRyQ2hhclJFLnRlc3QobmFtZSk7XG4gIGlmIChpc1Vuc2FmZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYHVuc2FmZSBhdHRyaWJ1dGUgbmFtZTogJHtuYW1lfWApO1xuICB9XG4gIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdID0gIWlzVW5zYWZlO1xufVxuY29uc3QgcHJvcHNUb0F0dHJNYXAgPSB7XG4gIGFjY2VwdENoYXJzZXQ6IFwiYWNjZXB0LWNoYXJzZXRcIixcbiAgY2xhc3NOYW1lOiBcImNsYXNzXCIsXG4gIGh0bWxGb3I6IFwiZm9yXCIsXG4gIGh0dHBFcXVpdjogXCJodHRwLWVxdWl2XCJcbn07XG5jb25zdCBpc0tub3duSHRtbEF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYGFjY2VwdCxhY2NlcHQtY2hhcnNldCxhY2Nlc3NrZXksYWN0aW9uLGFsaWduLGFsbG93LGFsdCxhc3luYyxhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsYXV0b2ZvY3VzLGF1dG9wbGF5LGJhY2tncm91bmQsYmdjb2xvcixib3JkZXIsYnVmZmVyZWQsY2FwdHVyZSxjaGFsbGVuZ2UsY2hhcnNldCxjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxjb2RlYmFzZSxjb2xvcixjb2xzLGNvbHNwYW4sY29udGVudCxjb250ZW50ZWRpdGFibGUsY29udGV4dG1lbnUsY29udHJvbHMsY29vcmRzLGNyb3Nzb3JpZ2luLGNzcCxkYXRhLGRhdGV0aW1lLGRlY29kaW5nLGRlZmF1bHQsZGVmZXIsZGlyLGRpcm5hbWUsZGlzYWJsZWQsZG93bmxvYWQsZHJhZ2dhYmxlLGRyb3B6b25lLGVuY3R5cGUsZW50ZXJrZXloaW50LGZvcixmb3JtLGZvcm1hY3Rpb24sZm9ybWVuY3R5cGUsZm9ybW1ldGhvZCxmb3Jtbm92YWxpZGF0ZSxmb3JtdGFyZ2V0LGhlYWRlcnMsaGVpZ2h0LGhpZGRlbixoaWdoLGhyZWYsaHJlZmxhbmcsaHR0cC1lcXVpdixpY29uLGlkLGltcG9ydGFuY2UsaW5lcnQsaW50ZWdyaXR5LGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvYWRpbmcsbGlzdCxsb29wLGxvdyxtYW5pZmVzdCxtYXgsbWF4bGVuZ3RoLG1pbmxlbmd0aCxtZWRpYSxtaW4sbXVsdGlwbGUsbXV0ZWQsbmFtZSxub3ZhbGlkYXRlLG9wZW4sb3B0aW11bSxwYXR0ZXJuLHBpbmcscGxhY2Vob2xkZXIscG9zdGVyLHByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxyZWZlcnJlcnBvbGljeSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsc2NvcGUsc2NvcGVkLHNlbGVjdGVkLHNoYXBlLHNpemUsc2l6ZXMsc2xvdCxzcGFuLHNwZWxsY2hlY2ssc3JjLHNyY2RvYyxzcmNsYW5nLHNyY3NldCxzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCx2YWx1ZSx3aWR0aCx3cmFwYFxuKTtcbmNvbnN0IGlzS25vd25TdmdBdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIGB4bWxucyxhY2NlbnQtaGVpZ2h0LGFjY3VtdWxhdGUsYWRkaXRpdmUsYWxpZ25tZW50LWJhc2VsaW5lLGFscGhhYmV0aWMsYW1wbGl0dWRlLGFyYWJpYy1mb3JtLGFzY2VudCxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVR5cGUsYXppbXV0aCxiYXNlRnJlcXVlbmN5LGJhc2VsaW5lLXNoaWZ0LGJhc2VQcm9maWxlLGJib3gsYmVnaW4sYmlhcyxieSxjYWxjTW9kZSxjYXAtaGVpZ2h0LGNsYXNzLGNsaXAsY2xpcFBhdGhVbml0cyxjbGlwLXBhdGgsY2xpcC1ydWxlLGNvbG9yLGNvbG9yLWludGVycG9sYXRpb24sY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzLGNvbG9yLXByb2ZpbGUsY29sb3ItcmVuZGVyaW5nLGNvbnRlbnRTY3JpcHRUeXBlLGNvbnRlbnRTdHlsZVR5cGUsY3Jvc3NvcmlnaW4sY3Vyc29yLGN4LGN5LGQsZGVjZWxlcmF0ZSxkZXNjZW50LGRpZmZ1c2VDb25zdGFudCxkaXJlY3Rpb24sZGlzcGxheSxkaXZpc29yLGRvbWluYW50LWJhc2VsaW5lLGR1cixkeCxkeSxlZGdlTW9kZSxlbGV2YXRpb24sZW5hYmxlLWJhY2tncm91bmQsZW5kLGV4cG9uZW50LGZpbGwsZmlsbC1vcGFjaXR5LGZpbGwtcnVsZSxmaWx0ZXIsZmlsdGVyUmVzLGZpbHRlclVuaXRzLGZsb29kLWNvbG9yLGZsb29kLW9wYWNpdHksZm9udC1mYW1pbHksZm9udC1zaXplLGZvbnQtc2l6ZS1hZGp1c3QsZm9udC1zdHJldGNoLGZvbnQtc3R5bGUsZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZvcm1hdCxmcm9tLGZyLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCxnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCxnbHlwaFJlZixncmFkaWVudFRyYW5zZm9ybSxncmFkaWVudFVuaXRzLGhhbmdpbmcsaGVpZ2h0LGhyZWYsaHJlZmxhbmcsaG9yaXotYWR2LXgsaG9yaXotb3JpZ2luLXgsaWQsaWRlb2dyYXBoaWMsaW1hZ2UtcmVuZGVyaW5nLGluLGluMixpbnRlcmNlcHQsayxrMSxrMixrMyxrNCxrZXJuZWxNYXRyaXgsa2VybmVsVW5pdExlbmd0aCxrZXJuaW5nLGtleVBvaW50cyxrZXlTcGxpbmVzLGtleVRpbWVzLGxhbmcsbGVuZ3RoQWRqdXN0LGxldHRlci1zcGFjaW5nLGxpZ2h0aW5nLWNvbG9yLGxpbWl0aW5nQ29uZUFuZ2xlLGxvY2FsLG1hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLG1hc2ssbWFza0NvbnRlbnRVbml0cyxtYXNrVW5pdHMsbWF0aGVtYXRpY2FsLG1heCxtZWRpYSxtZXRob2QsbWluLG1vZGUsbmFtZSxudW1PY3RhdmVzLG9mZnNldCxvcGFjaXR5LG9wZXJhdG9yLG9yZGVyLG9yaWVudCxvcmllbnRhdGlvbixvcmlnaW4sb3ZlcmZsb3csb3ZlcmxpbmUtcG9zaXRpb24sb3ZlcmxpbmUtdGhpY2tuZXNzLHBhbm9zZS0xLHBhaW50LW9yZGVyLHBhdGgscGF0aExlbmd0aCxwYXR0ZXJuQ29udGVudFVuaXRzLHBhdHRlcm5UcmFuc2Zvcm0scGF0dGVyblVuaXRzLHBpbmcscG9pbnRlci1ldmVudHMscG9pbnRzLHBvaW50c0F0WCxwb2ludHNBdFkscG9pbnRzQXRaLHByZXNlcnZlQWxwaGEscHJlc2VydmVBc3BlY3RSYXRpbyxwcmltaXRpdmVVbml0cyxyLHJhZGl1cyxyZWZlcnJlclBvbGljeSxyZWZYLHJlZlkscmVsLHJlbmRlcmluZy1pbnRlbnQscmVwZWF0Q291bnQscmVwZWF0RHVyLHJlcXVpcmVkRXh0ZW5zaW9ucyxyZXF1aXJlZEZlYXR1cmVzLHJlc3RhcnQscmVzdWx0LHJvdGF0ZSxyeCxyeSxzY2FsZSxzZWVkLHNoYXBlLXJlbmRlcmluZyxzbG9wZSxzcGFjaW5nLHNwZWN1bGFyQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxzcGVlZCxzcHJlYWRNZXRob2Qsc3RhcnRPZmZzZXQsc3RkRGV2aWF0aW9uLHN0ZW1oLHN0ZW12LHN0aXRjaFRpbGVzLHN0b3AtY29sb3Isc3RvcC1vcGFjaXR5LHN0cmlrZXRocm91Z2gtcG9zaXRpb24sc3RyaWtldGhyb3VnaC10aGlja25lc3Msc3RyaW5nLHN0cm9rZSxzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSxzdHJva2Utd2lkdGgsc3R5bGUsc3VyZmFjZVNjYWxlLHN5c3RlbUxhbmd1YWdlLHRhYmluZGV4LHRhYmxlVmFsdWVzLHRhcmdldCx0YXJnZXRYLHRhcmdldFksdGV4dC1hbmNob3IsdGV4dC1kZWNvcmF0aW9uLHRleHQtcmVuZGVyaW5nLHRleHRMZW5ndGgsdG8sdHJhbnNmb3JtLHRyYW5zZm9ybS1vcmlnaW4sdHlwZSx1MSx1Mix1bmRlcmxpbmUtcG9zaXRpb24sdW5kZXJsaW5lLXRoaWNrbmVzcyx1bmljb2RlLHVuaWNvZGUtYmlkaSx1bmljb2RlLXJhbmdlLHVuaXRzLXBlci1lbSx2LWFscGhhYmV0aWMsdi1oYW5naW5nLHYtaWRlb2dyYXBoaWMsdi1tYXRoZW1hdGljYWwsdmFsdWVzLHZlY3Rvci1lZmZlY3QsdmVyc2lvbix2ZXJ0LWFkdi15LHZlcnQtb3JpZ2luLXgsdmVydC1vcmlnaW4teSx2aWV3Qm94LHZpZXdUYXJnZXQsdmlzaWJpbGl0eSx3aWR0aCx3aWR0aHMsd29yZC1zcGFjaW5nLHdyaXRpbmctbW9kZSx4LHgtaGVpZ2h0LHgxLHgyLHhDaGFubmVsU2VsZWN0b3IseGxpbms6YWN0dWF0ZSx4bGluazphcmNyb2xlLHhsaW5rOmhyZWYseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLHhsaW5rOnR5cGUseG1sbnM6eGxpbmsseG1sOmJhc2UseG1sOmxhbmcseG1sOnNwYWNlLHkseTEseTIseUNoYW5uZWxTZWxlY3Rvcix6LHpvb21BbmRQYW5gXG4pO1xuZnVuY3Rpb24gaXNSZW5kZXJhYmxlQXR0clZhbHVlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCI7XG59XG5cbmNvbnN0IGVzY2FwZVJFID0gL1tcIicmPD5dLztcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gIGNvbnN0IHN0ciA9IFwiXCIgKyBzdHJpbmc7XG4gIGNvbnN0IG1hdGNoID0gZXNjYXBlUkUuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBsZXQgaHRtbCA9IFwiXCI7XG4gIGxldCBlc2NhcGVkO1xuICBsZXQgaW5kZXg7XG4gIGxldCBsYXN0SW5kZXggPSAwO1xuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICBlc2NhcGVkID0gXCImcXVvdDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM4OlxuICAgICAgICBlc2NhcGVkID0gXCImYW1wO1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIGVzY2FwZWQgPSBcIiYjMzk7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmx0O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZndDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGVkO1xuICB9XG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG59XG5jb25zdCBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XG4gIHJldHVybiBzcmMucmVwbGFjZShjb21tZW50U3RyaXBSRSwgXCJcIik7XG59XG5cbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGVxdWFsICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgZXF1YWwgPSBsb29zZUVxdWFsKGFbaV0sIGJbaV0pO1xuICB9XG4gIHJldHVybiBlcXVhbDtcbn1cbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xuICBsZXQgYlZhbGlkVHlwZSA9IGlzRGF0ZShiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCkgOiBmYWxzZTtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNTeW1ib2woYSk7XG4gIGJWYWxpZFR5cGUgPSBpc1N5bWJvbChiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xuICBiVmFsaWRUeXBlID0gaXNBcnJheShiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikgOiBmYWxzZTtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XG4gIGJWYWxpZFR5cGUgPSBpc09iamVjdChiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIGlmICghYVZhbGlkVHlwZSB8fCAhYlZhbGlkVHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYSkubGVuZ3RoO1xuICAgIGNvbnN0IGJLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhiKS5sZW5ndGg7XG4gICAgaWYgKGFLZXlzQ291bnQgIT09IGJLZXlzQ291bnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgY29uc3QgYUhhc0tleSA9IGEuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGNvbnN0IGJIYXNLZXkgPSBiLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBpZiAoYUhhc0tleSAmJiAhYkhhc0tleSB8fCAhYUhhc0tleSAmJiBiSGFzS2V5IHx8ICFsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbn1cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xuICByZXR1cm4gYXJyLmZpbmRJbmRleCgoaXRlbSkgPT4gbG9vc2VFcXVhbChpdGVtLCB2YWwpKTtcbn1cblxuY29uc3QgaXNSZWYgPSAodmFsKSA9PiB7XG4gIHJldHVybiAhISh2YWwgJiYgdmFsW1wiX192X2lzUmVmXCJdID09PSB0cnVlKTtcbn07XG5jb25zdCB0b0Rpc3BsYXlTdHJpbmcgPSAodmFsKSA9PiB7XG4gIHJldHVybiBpc1N0cmluZyh2YWwpID8gdmFsIDogdmFsID09IG51bGwgPyBcIlwiIDogaXNBcnJheSh2YWwpIHx8IGlzT2JqZWN0KHZhbCkgJiYgKHZhbC50b1N0cmluZyA9PT0gb2JqZWN0VG9TdHJpbmcgfHwgIWlzRnVuY3Rpb24odmFsLnRvU3RyaW5nKSkgPyBpc1JlZih2YWwpID8gdG9EaXNwbGF5U3RyaW5nKHZhbC52YWx1ZSkgOiBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKSA6IFN0cmluZyh2YWwpO1xufTtcbmNvbnN0IHJlcGxhY2VyID0gKF9rZXksIHZhbCkgPT4ge1xuICBpZiAoaXNSZWYodmFsKSkge1xuICAgIHJldHVybiByZXBsYWNlcihfa2V5LCB2YWwudmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoXG4gICAgICAgIChlbnRyaWVzLCBba2V5LCB2YWwyXSwgaSkgPT4ge1xuICAgICAgICAgIGVudHJpZXNbc3RyaW5naWZ5U3ltYm9sKGtleSwgaSkgKyBcIiA9PlwiXSA9IHZhbDI7XG4gICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHt9XG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgU2V0KCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLnZhbHVlcygpXS5tYXAoKHYpID0+IHN0cmluZ2lmeVN5bWJvbCh2KSlcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzU3ltYm9sKHZhbCkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5U3ltYm9sKHZhbCk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSAmJiAhaXNBcnJheSh2YWwpICYmICFpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5jb25zdCBzdHJpbmdpZnlTeW1ib2wgPSAodiwgaSA9IFwiXCIpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKFxuICAgIC8vIFN5bWJvbC5kZXNjcmlwdGlvbiBpbiBlczIwMTkrIHNvIHdlIG5lZWQgdG8gY2FzdCBoZXJlIHRvIHBhc3NcbiAgICAvLyB0aGUgbGliOiBlczIwMTYgY2hlY2tcbiAgICBpc1N5bWJvbCh2KSA/IGBTeW1ib2woJHsoX2EgPSB2LmRlc2NyaXB0aW9uKSAhPSBudWxsID8gX2EgOiBpfSlgIDogdlxuICApO1xufTtcblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgUGF0Y2hGbGFncywgU2hhcGVGbGFncywgU2xvdEZsYWdzLCBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgZGVmLCBlc2NhcGVIdG1sLCBlc2NhcGVIdG1sQ29tbWVudCwgZXh0ZW5kLCBnZW5Qcm9wc0FjY2Vzc0V4cCwgZ2VuZXJhdGVDb2RlRnJhbWUsIGdldEdsb2JhbFRoaXMsIGhhc0NoYW5nZWQsIGhhc093biwgaHlwaGVuYXRlLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGludm9rZUFycmF5Rm5zLCBpc0FycmF5LCBpc0Jvb2xlYW5BdHRyLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGlzRGF0ZSwgaXNGdW5jdGlvbiwgaXNHbG9iYWxseUFsbG93ZWQsIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25IdG1sQXR0ciwgaXNLbm93blN2Z0F0dHIsIGlzTWFwLCBpc01hdGhNTFRhZywgaXNNb2RlbExpc3RlbmVyLCBpc09iamVjdCwgaXNPbiwgaXNQbGFpbk9iamVjdCwgaXNQcm9taXNlLCBpc1JlZ0V4cCwgaXNSZW5kZXJhYmxlQXR0clZhbHVlLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIGxvb3NlVG9OdW1iZXIsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIG9iamVjdFRvU3RyaW5nLCBwYXJzZVN0cmluZ1N0eWxlLCBwcm9wc1RvQXR0ck1hcCwgcmVtb3ZlLCBzbG90RmxhZ3NUZXh0LCBzdHJpbmdpZnlTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCB0b1Jhd1R5cGUsIHRvVHlwZVN0cmluZyB9O1xuIiwiLyoqXG4qIEB2dWUvcnVudGltZS1kb20gdjMuNS4wLWJldGEuM1xuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuaW1wb3J0IHsgd2FybiwgaCwgQmFzZVRyYW5zaXRpb24sIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCBhc3NlcnROdW1iZXIsIGdldEN1cnJlbnRJbnN0YW5jZSwgb25CZWZvcmVNb3VudCwgd2F0Y2hQb3N0RWZmZWN0LCBvbk1vdW50ZWQsIG9uVW5tb3VudGVkLCBGcmFnbWVudCwgU3RhdGljLCBjYW1lbGl6ZSwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGRlZmluZUNvbXBvbmVudCwgbmV4dFRpY2ssIHVucmVmLCBjcmVhdGVWTm9kZSwgdXNlVHJhbnNpdGlvblN0YXRlLCBvblVwZGF0ZWQsIHRvUmF3LCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIHNldFRyYW5zaXRpb25Ib29rcywgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgaXNSdW50aW1lT25seSwgY3JlYXRlUmVuZGVyZXIsIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuaW1wb3J0IHsgZXh0ZW5kLCBpc09iamVjdCwgdG9OdW1iZXIsIGlzQXJyYXksIGlzU3RyaW5nLCBoeXBoZW5hdGUsIGNhcGl0YWxpemUsIGluY2x1ZGVCb29sZWFuQXR0ciwgaXNTeW1ib2wsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpc0Z1bmN0aW9uLCBOT09QLCBpc09uLCBpc01vZGVsTGlzdGVuZXIsIGlzUGxhaW5PYmplY3QsIGhhc093biwgY2FtZWxpemUgYXMgY2FtZWxpemUkMSwgRU1QVFlfT0JKLCBsb29zZVRvTnVtYmVyLCBsb29zZUluZGV4T2YsIGlzU2V0LCBsb29zZUVxdWFsLCBpbnZva2VBcnJheUZucywgaXNIVE1MVGFnLCBpc1NWR1RhZywgaXNNYXRoTUxUYWcgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmxldCBwb2xpY3kgPSB2b2lkIDA7XG5jb25zdCB0dCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnRydXN0ZWRUeXBlcztcbmlmICh0dCkge1xuICB0cnkge1xuICAgIHBvbGljeSA9IC8qIEBfX1BVUkVfXyAqLyB0dC5jcmVhdGVQb2xpY3koXCJ2dWVcIiwge1xuICAgICAgY3JlYXRlSFRNTDogKHZhbCkgPT4gdmFsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYEVycm9yIGNyZWF0aW5nIHRydXN0ZWQgdHlwZXMgcG9saWN5OiAke2V9YCk7XG4gIH1cbn1cbmNvbnN0IHVuc2FmZVRvVHJ1c3RlZEhUTUwgPSBwb2xpY3kgPyAodmFsKSA9PiBwb2xpY3kuY3JlYXRlSFRNTCh2YWwpIDogKHZhbCkgPT4gdmFsO1xuY29uc3Qgc3ZnTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5jb25zdCBtYXRobWxOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiO1xuY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiBudWxsO1xuY29uc3QgdGVtcGxhdGVDb250YWluZXIgPSBkb2MgJiYgLyogQF9fUFVSRV9fICovIGRvYy5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG5jb25zdCBub2RlT3BzID0ge1xuICBpbnNlcnQ6IChjaGlsZCwgcGFyZW50LCBhbmNob3IpID0+IHtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBhbmNob3IgfHwgbnVsbCk7XG4gIH0sXG4gIHJlbW92ZTogKGNoaWxkKSA9PiB7XG4gICAgY29uc3QgcGFyZW50ID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfSxcbiAgY3JlYXRlRWxlbWVudDogKHRhZywgbmFtZXNwYWNlLCBpcywgcHJvcHMpID0+IHtcbiAgICBjb25zdCBlbCA9IG5hbWVzcGFjZSA9PT0gXCJzdmdcIiA/IGRvYy5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIHRhZykgOiBuYW1lc3BhY2UgPT09IFwibWF0aG1sXCIgPyBkb2MuY3JlYXRlRWxlbWVudE5TKG1hdGhtbE5TLCB0YWcpIDogaXMgPyBkb2MuY3JlYXRlRWxlbWVudCh0YWcsIHsgaXMgfSkgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmICh0YWcgPT09IFwic2VsZWN0XCIgJiYgcHJvcHMgJiYgcHJvcHMubXVsdGlwbGUgIT0gbnVsbCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIiwgcHJvcHMubXVsdGlwbGUpO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH0sXG4gIGNyZWF0ZVRleHQ6ICh0ZXh0KSA9PiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCksXG4gIGNyZWF0ZUNvbW1lbnQ6ICh0ZXh0KSA9PiBkb2MuY3JlYXRlQ29tbWVudCh0ZXh0KSxcbiAgc2V0VGV4dDogKG5vZGUsIHRleHQpID0+IHtcbiAgICBub2RlLm5vZGVWYWx1ZSA9IHRleHQ7XG4gIH0sXG4gIHNldEVsZW1lbnRUZXh0OiAoZWwsIHRleHQpID0+IHtcbiAgICBlbC50ZXh0Q29udGVudCA9IHRleHQ7XG4gIH0sXG4gIHBhcmVudE5vZGU6IChub2RlKSA9PiBub2RlLnBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiAobm9kZSkgPT4gbm9kZS5uZXh0U2libGluZyxcbiAgcXVlcnlTZWxlY3RvcjogKHNlbGVjdG9yKSA9PiBkb2MucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXG4gIHNldFNjb3BlSWQoZWwsIGlkKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGlkLCBcIlwiKTtcbiAgfSxcbiAgLy8gX19VTlNBRkVfX1xuICAvLyBSZWFzb246IGlubmVySFRNTC5cbiAgLy8gU3RhdGljIGNvbnRlbnQgaGVyZSBjYW4gb25seSBjb21lIGZyb20gY29tcGlsZWQgdGVtcGxhdGVzLlxuICAvLyBBcyBsb25nIGFzIHRoZSB1c2VyIG9ubHkgdXNlcyB0cnVzdGVkIHRlbXBsYXRlcywgdGhpcyBpcyBzYWZlLlxuICBpbnNlcnRTdGF0aWNDb250ZW50KGNvbnRlbnQsIHBhcmVudCwgYW5jaG9yLCBuYW1lc3BhY2UsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBiZWZvcmUgPSBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZDtcbiAgICBpZiAoc3RhcnQgJiYgKHN0YXJ0ID09PSBlbmQgfHwgc3RhcnQubmV4dFNpYmxpbmcpKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHN0YXJ0LmNsb25lTm9kZSh0cnVlKSwgYW5jaG9yKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQgfHwgIShzdGFydCA9IHN0YXJ0Lm5leHRTaWJsaW5nKSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXBsYXRlQ29udGFpbmVyLmlubmVySFRNTCA9IHVuc2FmZVRvVHJ1c3RlZEhUTUwoXG4gICAgICAgIG5hbWVzcGFjZSA9PT0gXCJzdmdcIiA/IGA8c3ZnPiR7Y29udGVudH08L3N2Zz5gIDogbmFtZXNwYWNlID09PSBcIm1hdGhtbFwiID8gYDxtYXRoPiR7Y29udGVudH08L21hdGg+YCA6IGNvbnRlbnRcbiAgICAgICk7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlQ29udGFpbmVyLmNvbnRlbnQ7XG4gICAgICBpZiAobmFtZXNwYWNlID09PSBcInN2Z1wiIHx8IG5hbWVzcGFjZSA9PT0gXCJtYXRobWxcIikge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gdGVtcGxhdGUuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKHdyYXBwZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRlbXBsYXRlLmFwcGVuZENoaWxkKHdyYXBwZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGUucmVtb3ZlQ2hpbGQod3JhcHBlcik7XG4gICAgICB9XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRlbXBsYXRlLCBhbmNob3IpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgLy8gZmlyc3RcbiAgICAgIGJlZm9yZSA/IGJlZm9yZS5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkLFxuICAgICAgLy8gbGFzdFxuICAgICAgYW5jaG9yID8gYW5jaG9yLnByZXZpb3VzU2libGluZyA6IHBhcmVudC5sYXN0Q2hpbGRcbiAgICBdO1xuICB9XG59O1xuXG5jb25zdCBUUkFOU0lUSU9OID0gXCJ0cmFuc2l0aW9uXCI7XG5jb25zdCBBTklNQVRJT04gPSBcImFuaW1hdGlvblwiO1xuY29uc3QgdnRjS2V5ID0gU3ltYm9sKFwiX3Z0Y1wiKTtcbmNvbnN0IFRyYW5zaXRpb24gPSAocHJvcHMsIHsgc2xvdHMgfSkgPT4gaChCYXNlVHJhbnNpdGlvbiwgcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhwcm9wcyksIHNsb3RzKTtcblRyYW5zaXRpb24uZGlzcGxheU5hbWUgPSBcIlRyYW5zaXRpb25cIjtcbmNvbnN0IERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBjc3M6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IHRydWVcbiAgfSxcbiAgZHVyYXRpb246IFtTdHJpbmcsIE51bWJlciwgT2JqZWN0XSxcbiAgZW50ZXJGcm9tQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyRnJvbUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVGcm9tQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZ1xufTtcbmNvbnN0IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSBUcmFuc2l0aW9uLnByb3BzID0gLyogQF9fUFVSRV9fICovIGV4dGVuZChcbiAge30sXG4gIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLFxuICBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzXG4pO1xuY29uc3QgY2FsbEhvb2sgPSAoaG9vaywgYXJncyA9IFtdKSA9PiB7XG4gIGlmIChpc0FycmF5KGhvb2spKSB7XG4gICAgaG9vay5mb3JFYWNoKChoMikgPT4gaDIoLi4uYXJncykpO1xuICB9IGVsc2UgaWYgKGhvb2spIHtcbiAgICBob29rKC4uLmFyZ3MpO1xuICB9XG59O1xuY29uc3QgaGFzRXhwbGljaXRDYWxsYmFjayA9IChob29rKSA9PiB7XG4gIHJldHVybiBob29rID8gaXNBcnJheShob29rKSA/IGhvb2suc29tZSgoaDIpID0+IGgyLmxlbmd0aCA+IDEpIDogaG9vay5sZW5ndGggPiAxIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcykge1xuICBjb25zdCBiYXNlUHJvcHMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcmF3UHJvcHMpIHtcbiAgICBpZiAoIShrZXkgaW4gRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpIHtcbiAgICAgIGJhc2VQcm9wc1trZXldID0gcmF3UHJvcHNba2V5XTtcbiAgICB9XG4gIH1cbiAgaWYgKHJhd1Byb3BzLmNzcyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gYmFzZVByb3BzO1xuICB9XG4gIGNvbnN0IHtcbiAgICBuYW1lID0gXCJ2XCIsXG4gICAgdHlwZSxcbiAgICBkdXJhdGlvbixcbiAgICBlbnRlckZyb21DbGFzcyA9IGAke25hbWV9LWVudGVyLWZyb21gLFxuICAgIGVudGVyQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1hY3RpdmVgLFxuICAgIGVudGVyVG9DbGFzcyA9IGAke25hbWV9LWVudGVyLXRvYCxcbiAgICBhcHBlYXJGcm9tQ2xhc3MgPSBlbnRlckZyb21DbGFzcyxcbiAgICBhcHBlYXJBY3RpdmVDbGFzcyA9IGVudGVyQWN0aXZlQ2xhc3MsXG4gICAgYXBwZWFyVG9DbGFzcyA9IGVudGVyVG9DbGFzcyxcbiAgICBsZWF2ZUZyb21DbGFzcyA9IGAke25hbWV9LWxlYXZlLWZyb21gLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1hY3RpdmVgLFxuICAgIGxlYXZlVG9DbGFzcyA9IGAke25hbWV9LWxlYXZlLXRvYFxuICB9ID0gcmF3UHJvcHM7XG4gIGNvbnN0IGR1cmF0aW9ucyA9IG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgY29uc3QgZW50ZXJEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMF07XG4gIGNvbnN0IGxlYXZlRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzFdO1xuICBjb25zdCB7XG4gICAgb25CZWZvcmVFbnRlcixcbiAgICBvbkVudGVyLFxuICAgIG9uRW50ZXJDYW5jZWxsZWQsXG4gICAgb25MZWF2ZSxcbiAgICBvbkxlYXZlQ2FuY2VsbGVkLFxuICAgIG9uQmVmb3JlQXBwZWFyID0gb25CZWZvcmVFbnRlcixcbiAgICBvbkFwcGVhciA9IG9uRW50ZXIsXG4gICAgb25BcHBlYXJDYW5jZWxsZWQgPSBvbkVudGVyQ2FuY2VsbGVkXG4gIH0gPSBiYXNlUHJvcHM7XG4gIGNvbnN0IGZpbmlzaEVudGVyID0gKGVsLCBpc0FwcGVhciwgZG9uZSkgPT4ge1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzKTtcbiAgICBkb25lICYmIGRvbmUoKTtcbiAgfTtcbiAgY29uc3QgZmluaXNoTGVhdmUgPSAoZWwsIGRvbmUpID0+IHtcbiAgICBlbC5faXNMZWF2aW5nID0gZmFsc2U7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgZG9uZSAmJiBkb25lKCk7XG4gIH07XG4gIGNvbnN0IG1ha2VFbnRlckhvb2sgPSAoaXNBcHBlYXIpID0+IHtcbiAgICByZXR1cm4gKGVsLCBkb25lKSA9PiB7XG4gICAgICBjb25zdCBob29rID0gaXNBcHBlYXIgPyBvbkFwcGVhciA6IG9uRW50ZXI7XG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoRW50ZXIoZWwsIGlzQXBwZWFyLCBkb25lKTtcbiAgICAgIGNhbGxIb29rKGhvb2ssIFtlbCwgcmVzb2x2ZV0pO1xuICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckZyb21DbGFzcyA6IGVudGVyRnJvbUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xuICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2soaG9vaykpIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGVudGVyRHVyYXRpb24sIHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXh0ZW5kKGJhc2VQcm9wcywge1xuICAgIG9uQmVmb3JlRW50ZXIoZWwpIHtcbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlRW50ZXIsIFtlbF0pO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckZyb21DbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyQWN0aXZlQ2xhc3MpO1xuICAgIH0sXG4gICAgb25CZWZvcmVBcHBlYXIoZWwpIHtcbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlQXBwZWFyLCBbZWxdKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyRnJvbUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyQWN0aXZlQ2xhc3MpO1xuICAgIH0sXG4gICAgb25FbnRlcjogbWFrZUVudGVySG9vayhmYWxzZSksXG4gICAgb25BcHBlYXI6IG1ha2VFbnRlckhvb2sodHJ1ZSksXG4gICAgb25MZWF2ZShlbCwgZG9uZSkge1xuICAgICAgZWwuX2lzTGVhdmluZyA9IHRydWU7XG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoTGVhdmUoZWwsIGRvbmUpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgZm9yY2VSZWZsb3coKTtcbiAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgIGlmICghZWwuX2lzTGVhdmluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2sob25MZWF2ZSkpIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGxlYXZlRHVyYXRpb24sIHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNhbGxIb29rKG9uTGVhdmUsIFtlbCwgcmVzb2x2ZV0pO1xuICAgIH0sXG4gICAgb25FbnRlckNhbmNlbGxlZChlbCkge1xuICAgICAgZmluaXNoRW50ZXIoZWwsIGZhbHNlKTtcbiAgICAgIGNhbGxIb29rKG9uRW50ZXJDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH0sXG4gICAgb25BcHBlYXJDYW5jZWxsZWQoZWwpIHtcbiAgICAgIGZpbmlzaEVudGVyKGVsLCB0cnVlKTtcbiAgICAgIGNhbGxIb29rKG9uQXBwZWFyQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICB9LFxuICAgIG9uTGVhdmVDYW5jZWxsZWQoZWwpIHtcbiAgICAgIGZpbmlzaExlYXZlKGVsKTtcbiAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbikge1xuICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGR1cmF0aW9uKSkge1xuICAgIHJldHVybiBbTnVtYmVyT2YoZHVyYXRpb24uZW50ZXIpLCBOdW1iZXJPZihkdXJhdGlvbi5sZWF2ZSldO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG4gPSBOdW1iZXJPZihkdXJhdGlvbik7XG4gICAgcmV0dXJuIFtuLCBuXTtcbiAgfVxufVxuZnVuY3Rpb24gTnVtYmVyT2YodmFsKSB7XG4gIGNvbnN0IHJlcyA9IHRvTnVtYmVyKHZhbCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgYXNzZXJ0TnVtYmVyKHJlcywgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb25cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XG4gIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgZWwuY2xhc3NMaXN0LmFkZChjKSk7XG4gIChlbFt2dGNLZXldIHx8IChlbFt2dGNLZXldID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkpLmFkZChjbHMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgY29uc3QgX3Z0YyA9IGVsW3Z0Y0tleV07XG4gIGlmIChfdnRjKSB7XG4gICAgX3Z0Yy5kZWxldGUoY2xzKTtcbiAgICBpZiAoIV92dGMuc2l6ZSkge1xuICAgICAgZWxbdnRjS2V5XSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG5leHRGcmFtZShjYikge1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XG4gIH0pO1xufVxubGV0IGVuZElkID0gMDtcbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgZXhwZWN0ZWRUeXBlLCBleHBsaWNpdFRpbWVvdXQsIHJlc29sdmUpIHtcbiAgY29uc3QgaWQgPSBlbC5fZW5kSWQgPSArK2VuZElkO1xuICBjb25zdCByZXNvbHZlSWZOb3RTdGFsZSA9ICgpID0+IHtcbiAgICBpZiAoaWQgPT09IGVsLl9lbmRJZCkge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH1cbiAgfTtcbiAgaWYgKGV4cGxpY2l0VGltZW91dCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmVJZk5vdFN0YWxlLCBleHBsaWNpdFRpbWVvdXQpO1xuICB9XG4gIGNvbnN0IHsgdHlwZSwgdGltZW91dCwgcHJvcENvdW50IH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgaWYgKCF0eXBlKSB7XG4gICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgfVxuICBjb25zdCBlbmRFdmVudCA9IHR5cGUgKyBcImVuZFwiO1xuICBsZXQgZW5kZWQgPSAwO1xuICBjb25zdCBlbmQgPSAoKSA9PiB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xuICAgIHJlc29sdmVJZk5vdFN0YWxlKCk7XG4gIH07XG4gIGNvbnN0IG9uRW5kID0gKGUpID0+IHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsICYmICsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICBjb25zdCBnZXRTdHlsZVByb3BlcnRpZXMgPSAoa2V5KSA9PiAoc3R5bGVzW2tleV0gfHwgXCJcIikuc3BsaXQoXCIsIFwiKTtcbiAgY29uc3QgdHJhbnNpdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfURlbGF5YCk7XG4gIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1EdXJhdGlvbmApO1xuICBjb25zdCB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIGNvbnN0IGFuaW1hdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtBTklNQVRJT059RGVsYXlgKTtcbiAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke0FOSU1BVElPTn1EdXJhdGlvbmApO1xuICBjb25zdCBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG4gIGxldCB0eXBlID0gbnVsbDtcbiAgbGV0IHRpbWVvdXQgPSAwO1xuICBsZXQgcHJvcENvdW50ID0gMDtcbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMCA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dCA/IFRSQU5TSVRJT04gOiBBTklNQVRJT04gOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGUgPyB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGggOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoIDogMDtcbiAgfVxuICBjb25zdCBoYXNUcmFuc2Zvcm0gPSB0eXBlID09PSBUUkFOU0lUSU9OICYmIC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS8udGVzdChcbiAgICBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1Qcm9wZXJ0eWApLnRvU3RyaW5nKClcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIHRpbWVvdXQsXG4gICAgcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VGltZW91dChkZWxheXMsIGR1cmF0aW9ucykge1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KC4uLmR1cmF0aW9ucy5tYXAoKGQsIGkpID0+IHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSkpKTtcbn1cbmZ1bmN0aW9uIHRvTXMocykge1xuICBpZiAocyA9PT0gXCJhdXRvXCIpIHJldHVybiAwO1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoXCIsXCIsIFwiLlwiKSkgKiAxZTM7XG59XG5mdW5jdGlvbiBmb3JjZVJlZmxvdygpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBwYXRjaENsYXNzKGVsLCB2YWx1ZSwgaXNTVkcpIHtcbiAgY29uc3QgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbFt2dGNLZXldO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICB2YWx1ZSA9ICh2YWx1ZSA/IFt2YWx1ZSwgLi4udHJhbnNpdGlvbkNsYXNzZXNdIDogWy4uLnRyYW5zaXRpb25DbGFzc2VzXSkuam9pbihcIiBcIik7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgfSBlbHNlIGlmIChpc1NWRykge1xuICAgIGVsLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5jbGFzc05hbWUgPSB2YWx1ZTtcbiAgfVxufVxuXG5jb25zdCB2U2hvd09yaWdpbmFsRGlzcGxheSA9IFN5bWJvbChcIl92b2RcIik7XG5jb25zdCB2U2hvd0hpZGRlbiA9IFN5bWJvbChcIl92c2hcIik7XG5jb25zdCB2U2hvdyA9IHtcbiAgYmVmb3JlTW91bnQoZWwsIHsgdmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcbiAgICBlbFt2U2hvd09yaWdpbmFsRGlzcGxheV0gPSBlbC5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XG4gICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgbW91bnRlZChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XG4gICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICB9XG4gIH0sXG4gIHVwZGF0ZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKSByZXR1cm47XG4gICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgc2V0RGlzcGxheShlbCwgdHJ1ZSk7XG4gICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNpdGlvbi5sZWF2ZShlbCwgKCkgPT4ge1xuICAgICAgICAgIHNldERpc3BsYXkoZWwsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZVVubW91bnQoZWwsIHsgdmFsdWUgfSkge1xuICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgfVxufTtcbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gIHZTaG93Lm5hbWUgPSBcInNob3dcIjtcbn1cbmZ1bmN0aW9uIHNldERpc3BsYXkoZWwsIHZhbHVlKSB7XG4gIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsW3ZTaG93T3JpZ2luYWxEaXNwbGF5XSA6IFwibm9uZVwiO1xuICBlbFt2U2hvd0hpZGRlbl0gPSAhdmFsdWU7XG59XG5mdW5jdGlvbiBpbml0VlNob3dGb3JTU1IoKSB7XG4gIHZTaG93LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSkgPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiB7IHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0gfTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IENTU19WQVJfVEVYVCA9IFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJDU1NfVkFSX1RFWFRcIiA6IFwiXCIpO1xuZnVuY3Rpb24gdXNlQ3NzVmFycyhnZXR0ZXIpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCFpbnN0YW5jZSkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgdXNlQ3NzVmFycyBpcyBjYWxsZWQgd2l0aG91dCBjdXJyZW50IGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UuYCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVwZGF0ZVRlbGVwb3J0cyA9IGluc3RhbmNlLnV0ID0gKHZhcnMgPSBnZXR0ZXIoaW5zdGFuY2UucHJveHkpKSA9PiB7XG4gICAgQXJyYXkuZnJvbShcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXYtb3duZXI9XCIke2luc3RhbmNlLnVpZH1cIl1gKVxuICAgICkuZm9yRWFjaCgobm9kZSkgPT4gc2V0VmFyc09uTm9kZShub2RlLCB2YXJzKSk7XG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5zdGFuY2UuZ2V0Q3NzVmFycyA9ICgpID0+IGdldHRlcihpbnN0YW5jZS5wcm94eSk7XG4gIH1cbiAgY29uc3Qgc2V0VmFycyA9ICgpID0+IHtcbiAgICBjb25zdCB2YXJzID0gZ2V0dGVyKGluc3RhbmNlLnByb3h5KTtcbiAgICBpZiAoaW5zdGFuY2UuY2UpIHtcbiAgICAgIHNldFZhcnNPbk5vZGUoaW5zdGFuY2UuY2UsIHZhcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRWYXJzT25WTm9kZShpbnN0YW5jZS5zdWJUcmVlLCB2YXJzKTtcbiAgICB9XG4gICAgdXBkYXRlVGVsZXBvcnRzKHZhcnMpO1xuICB9O1xuICBvbkJlZm9yZU1vdW50KCgpID0+IHtcbiAgICB3YXRjaFBvc3RFZmZlY3Qoc2V0VmFycyk7XG4gIH0pO1xuICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgIGNvbnN0IG9iID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoc2V0VmFycyk7XG4gICAgb2Iub2JzZXJ2ZShpbnN0YW5jZS5zdWJUcmVlLmVsLnBhcmVudE5vZGUsIHsgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgIG9uVW5tb3VudGVkKCgpID0+IG9iLmRpc2Nvbm5lY3QoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0VmFyc09uVk5vZGUodm5vZGUsIHZhcnMpIHtcbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2U7XG4gICAgdm5vZGUgPSBzdXNwZW5zZS5hY3RpdmVCcmFuY2g7XG4gICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgIXN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goKCkgPT4ge1xuICAgICAgICBzZXRWYXJzT25WTm9kZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIHZhcnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHdoaWxlICh2bm9kZS5jb21wb25lbnQpIHtcbiAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudC5zdWJUcmVlO1xuICB9XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxICYmIHZub2RlLmVsKSB7XG4gICAgc2V0VmFyc09uTm9kZSh2bm9kZS5lbCwgdmFycyk7XG4gIH0gZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjKSA9PiBzZXRWYXJzT25WTm9kZShjLCB2YXJzKSk7XG4gIH0gZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gU3RhdGljKSB7XG4gICAgbGV0IHsgZWwsIGFuY2hvciB9ID0gdm5vZGU7XG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKTtcbiAgICAgIGlmIChlbCA9PT0gYW5jaG9yKSBicmVhaztcbiAgICAgIGVsID0gZWwubmV4dFNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKSB7XG4gIGlmIChlbC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gICAgbGV0IGNzc1RleHQgPSBcIlwiO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhcnMpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KGAtLSR7a2V5fWAsIHZhcnNba2V5XSk7XG4gICAgICBjc3NUZXh0ICs9IGAtLSR7a2V5fTogJHt2YXJzW2tleV19O2A7XG4gICAgfVxuICAgIHN0eWxlW0NTU19WQVJfVEVYVF0gPSBjc3NUZXh0O1xuICB9XG59XG5cbmNvbnN0IGRpc3BsYXlSRSA9IC8oXnw7KVxccypkaXNwbGF5XFxzKjovO1xuZnVuY3Rpb24gcGF0Y2hTdHlsZShlbCwgcHJldiwgbmV4dCkge1xuICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuICBjb25zdCBpc0Nzc1N0cmluZyA9IGlzU3RyaW5nKG5leHQpO1xuICBsZXQgaGFzQ29udHJvbGxlZERpc3BsYXkgPSBmYWxzZTtcbiAgaWYgKG5leHQgJiYgIWlzQ3NzU3RyaW5nKSB7XG4gICAgaWYgKHByZXYpIHtcbiAgICAgIGlmICghaXNTdHJpbmcocHJldikpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xuICAgICAgICAgIGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IHByZXZTdHlsZSBvZiBwcmV2LnNwbGl0KFwiO1wiKSkge1xuICAgICAgICAgIGNvbnN0IGtleSA9IHByZXZTdHlsZS5zbGljZSgwLCBwcmV2U3R5bGUuaW5kZXhPZihcIjpcIikpLnRyaW0oKTtcbiAgICAgICAgICBpZiAobmV4dFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksIFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXh0KSB7XG4gICAgICBpZiAoa2V5ID09PSBcImRpc3BsYXlcIikge1xuICAgICAgICBoYXNDb250cm9sbGVkRGlzcGxheSA9IHRydWU7XG4gICAgICB9XG4gICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBuZXh0W2tleV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNDc3NTdHJpbmcpIHtcbiAgICAgIGlmIChwcmV2ICE9PSBuZXh0KSB7XG4gICAgICAgIGNvbnN0IGNzc1ZhclRleHQgPSBzdHlsZVtDU1NfVkFSX1RFWFRdO1xuICAgICAgICBpZiAoY3NzVmFyVGV4dCkge1xuICAgICAgICAgIG5leHQgKz0gXCI7XCIgKyBjc3NWYXJUZXh0O1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlLmNzc1RleHQgPSBuZXh0O1xuICAgICAgICBoYXNDb250cm9sbGVkRGlzcGxheSA9IGRpc3BsYXlSRS50ZXN0KG5leHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldikge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgfVxuICB9XG4gIGlmICh2U2hvd09yaWdpbmFsRGlzcGxheSBpbiBlbCkge1xuICAgIGVsW3ZTaG93T3JpZ2luYWxEaXNwbGF5XSA9IGhhc0NvbnRyb2xsZWREaXNwbGF5ID8gc3R5bGUuZGlzcGxheSA6IFwiXCI7XG4gICAgaWYgKGVsW3ZTaG93SGlkZGVuXSkge1xuICAgICAgc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH1cbiAgfVxufVxuY29uc3Qgc2VtaWNvbG9uUkUgPSAvW15cXFxcXTtcXHMqJC87XG5jb25zdCBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xuZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHZhbCkge1xuICBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgdmFsLmZvckVhY2goKHYpID0+IHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2KSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB2YWwgPSBcIlwiO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBpZiAoc2VtaWNvbG9uUkUudGVzdCh2YWwpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYFVuZXhwZWN0ZWQgc2VtaWNvbG9uIGF0IHRoZSBlbmQgb2YgJyR7bmFtZX0nIHN0eWxlIHZhbHVlOiAnJHt2YWx9J2BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcIi0tXCIpKSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmVmaXhlZCA9IGF1dG9QcmVmaXgoc3R5bGUsIG5hbWUpO1xuICAgICAgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICBoeXBoZW5hdGUocHJlZml4ZWQpLFxuICAgICAgICAgIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCBcIlwiKSxcbiAgICAgICAgICBcImltcG9ydGFudFwiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZVtwcmVmaXhlZF0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jb25zdCBwcmVmaXhlcyA9IFtcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCJdO1xuY29uc3QgcHJlZml4Q2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGF1dG9QcmVmaXgoc3R5bGUsIHJhd05hbWUpIHtcbiAgY29uc3QgY2FjaGVkID0gcHJlZml4Q2FjaGVbcmF3TmFtZV07XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGxldCBuYW1lID0gY2FtZWxpemUocmF3TmFtZSk7XG4gIGlmIChuYW1lICE9PSBcImZpbHRlclwiICYmIG5hbWUgaW4gc3R5bGUpIHtcbiAgICByZXR1cm4gcHJlZml4Q2FjaGVbcmF3TmFtZV0gPSBuYW1lO1xuICB9XG4gIG5hbWUgPSBjYXBpdGFsaXplKG5hbWUpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIG5hbWU7XG4gICAgaWYgKHByZWZpeGVkIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4Q2FjaGVbcmF3TmFtZV0gPSBwcmVmaXhlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJhd05hbWU7XG59XG5cbmNvbnN0IHhsaW5rTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIjtcbmZ1bmN0aW9uIHBhdGNoQXR0cihlbCwga2V5LCB2YWx1ZSwgaXNTVkcsIGluc3RhbmNlLCBpc0Jvb2xlYW4gPSBpc1NwZWNpYWxCb29sZWFuQXR0cihrZXkpKSB7XG4gIGlmIChpc1NWRyAmJiBrZXkuc3RhcnRzV2l0aChcInhsaW5rOlwiKSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXkuc2xpY2UoNiwga2V5Lmxlbmd0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgaXNCb29sZWFuICYmICFpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFxuICAgICAgICBrZXksXG4gICAgICAgIGlzQm9vbGVhbiA/IFwiXCIgOiBpc1N5bWJvbCh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogdmFsdWVcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhdGNoRE9NUHJvcChlbCwga2V5LCB2YWx1ZSwgcGFyZW50Q29tcG9uZW50KSB7XG4gIGlmIChrZXkgPT09IFwiaW5uZXJIVE1MXCIgfHwga2V5ID09PSBcInRleHRDb250ZW50XCIpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuO1xuICAgIGVsW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFnID0gZWwudGFnTmFtZTtcbiAgaWYgKGtleSA9PT0gXCJ2YWx1ZVwiICYmIHRhZyAhPT0gXCJQUk9HUkVTU1wiICYmIC8vIGN1c3RvbSBlbGVtZW50cyBtYXkgdXNlIF92YWx1ZSBpbnRlcm5hbGx5XG4gICF0YWcuaW5jbHVkZXMoXCItXCIpKSB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YWcgPT09IFwiT1BUSU9OXCIgPyBlbC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSB8fCBcIlwiIDogZWwudmFsdWU7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IFN0cmluZyh2YWx1ZSk7XG4gICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSB8fCAhKFwiX3ZhbHVlXCIgaW4gZWwpKSB7XG4gICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfVxuICAgIGVsLl92YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbmVlZFJlbW92ZSA9IGZhbHNlO1xuICBpZiAodmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcbiAgICBpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHZhbHVlID0gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgbmVlZFJlbW92ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgICBuZWVkUmVtb3ZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBlbFtrZXldID0gdmFsdWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhbmVlZFJlbW92ZSkge1xuICAgICAgd2FybihcbiAgICAgICAgYEZhaWxlZCBzZXR0aW5nIHByb3AgXCIke2tleX1cIiBvbiA8JHt0YWcudG9Mb3dlckNhc2UoKX0+OiB2YWx1ZSAke3ZhbHVlfSBpcyBpbnZhbGlkLmAsXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIG5lZWRSZW1vdmUgJiYgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5jb25zdCB2ZWlLZXkgPSBTeW1ib2woXCJfdmVpXCIpO1xuZnVuY3Rpb24gcGF0Y2hFdmVudChlbCwgcmF3TmFtZSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGluc3RhbmNlID0gbnVsbCkge1xuICBjb25zdCBpbnZva2VycyA9IGVsW3ZlaUtleV0gfHwgKGVsW3ZlaUtleV0gPSB7fSk7XG4gIGNvbnN0IGV4aXN0aW5nSW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdO1xuICBpZiAobmV4dFZhbHVlICYmIGV4aXN0aW5nSW52b2tlcikge1xuICAgIGV4aXN0aW5nSW52b2tlci52YWx1ZSA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzYW5pdGl6ZUV2ZW50VmFsdWUobmV4dFZhbHVlLCByYXdOYW1lKSA6IG5leHRWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbbmFtZSwgb3B0aW9uc10gPSBwYXJzZU5hbWUocmF3TmFtZSk7XG4gICAgaWYgKG5leHRWYWx1ZSkge1xuICAgICAgY29uc3QgaW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdID0gY3JlYXRlSW52b2tlcihcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNhbml0aXplRXZlbnRWYWx1ZShuZXh0VmFsdWUsIHJhd05hbWUpIDogbmV4dFZhbHVlLFxuICAgICAgICBpbnN0YW5jZVxuICAgICAgKTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGludm9rZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdJbnZva2VyKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBleGlzdGluZ0ludm9rZXIsIG9wdGlvbnMpO1xuICAgICAgaW52b2tlcnNbcmF3TmFtZV0gPSB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5jb25zdCBvcHRpb25zTW9kaWZpZXJSRSA9IC8oPzpPbmNlfFBhc3NpdmV8Q2FwdHVyZSkkLztcbmZ1bmN0aW9uIHBhcnNlTmFtZShuYW1lKSB7XG4gIGxldCBvcHRpb25zO1xuICBpZiAob3B0aW9uc01vZGlmaWVyUkUudGVzdChuYW1lKSkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgICBsZXQgbTtcbiAgICB3aGlsZSAobSA9IG5hbWUubWF0Y2gob3B0aW9uc01vZGlmaWVyUkUpKSB7XG4gICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCAtIG1bMF0ubGVuZ3RoKTtcbiAgICAgIG9wdGlvbnNbbVswXS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGNvbnN0IGV2ZW50ID0gbmFtZVsyXSA9PT0gXCI6XCIgPyBuYW1lLnNsaWNlKDMpIDogaHlwaGVuYXRlKG5hbWUuc2xpY2UoMikpO1xuICByZXR1cm4gW2V2ZW50LCBvcHRpb25zXTtcbn1cbmxldCBjYWNoZWROb3cgPSAwO1xuY29uc3QgcCA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcbmNvbnN0IGdldE5vdyA9ICgpID0+IGNhY2hlZE5vdyB8fCAocC50aGVuKCgpID0+IGNhY2hlZE5vdyA9IDApLCBjYWNoZWROb3cgPSBEYXRlLm5vdygpKTtcbmZ1bmN0aW9uIGNyZWF0ZUludm9rZXIoaW5pdGlhbFZhbHVlLCBpbnN0YW5jZSkge1xuICBjb25zdCBpbnZva2VyID0gKGUpID0+IHtcbiAgICBpZiAoIWUuX3Z0cykge1xuICAgICAgZS5fdnRzID0gRGF0ZS5ub3coKTtcbiAgICB9IGVsc2UgaWYgKGUuX3Z0cyA8PSBpbnZva2VyLmF0dGFjaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgcGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgaW52b2tlci52YWx1ZSksXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDUsXG4gICAgICBbZV1cbiAgICApO1xuICB9O1xuICBpbnZva2VyLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBpbnZva2VyLmF0dGFjaGVkID0gZ2V0Tm93KCk7XG4gIHJldHVybiBpbnZva2VyO1xufVxuZnVuY3Rpb24gc2FuaXRpemVFdmVudFZhbHVlKHZhbHVlLCBwcm9wTmFtZSkge1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgd2FybihcbiAgICBgV3JvbmcgdHlwZSBwYXNzZWQgYXMgZXZlbnQgaGFuZGxlciB0byAke3Byb3BOYW1lfSAtIGRpZCB5b3UgZm9yZ2V0IEAgb3IgOiBpbiBmcm9udCBvZiB5b3VyIHByb3A/XG5FeHBlY3RlZCBmdW5jdGlvbiBvciBhcnJheSBvZiBmdW5jdGlvbnMsIHJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgdmFsdWV9LmBcbiAgKTtcbiAgcmV0dXJuIE5PT1A7XG59XG5mdW5jdGlvbiBwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCB2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBvcmlnaW5hbFN0b3AgPSBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjtcbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9ICgpID0+IHtcbiAgICAgIG9yaWdpbmFsU3RvcC5jYWxsKGUpO1xuICAgICAgZS5fc3RvcHBlZCA9IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gdmFsdWUubWFwKFxuICAgICAgKGZuKSA9PiAoZTIpID0+ICFlMi5fc3RvcHBlZCAmJiBmbiAmJiBmbihlMilcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5jb25zdCBpc05hdGl2ZU9uID0gKGtleSkgPT4ga2V5LmNoYXJDb2RlQXQoMCkgPT09IDExMSAmJiBrZXkuY2hhckNvZGVBdCgxKSA9PT0gMTEwICYmIC8vIGxvd2VyY2FzZSBsZXR0ZXJcbmtleS5jaGFyQ29kZUF0KDIpID4gOTYgJiYga2V5LmNoYXJDb2RlQXQoMikgPCAxMjM7XG5jb25zdCBwYXRjaFByb3AgPSAoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIG5hbWVzcGFjZSwgcGFyZW50Q29tcG9uZW50KSA9PiB7XG4gIGNvbnN0IGlzU1ZHID0gbmFtZXNwYWNlID09PSBcInN2Z1wiO1xuICBpZiAoa2V5ID09PSBcImNsYXNzXCIpIHtcbiAgICBwYXRjaENsYXNzKGVsLCBuZXh0VmFsdWUsIGlzU1ZHKTtcbiAgfSBlbHNlIGlmIChrZXkgPT09IFwic3R5bGVcIikge1xuICAgIHBhdGNoU3R5bGUoZWwsIHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc09uKGtleSkpIHtcbiAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XG4gICAgICBwYXRjaEV2ZW50KGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBwYXJlbnRDb21wb25lbnQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChrZXlbMF0gPT09IFwiLlwiID8gKGtleSA9IGtleS5zbGljZSgxKSwgdHJ1ZSkgOiBrZXlbMF0gPT09IFwiXlwiID8gKGtleSA9IGtleS5zbGljZSgxKSwgZmFsc2UpIDogc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpKSB7XG4gICAgcGF0Y2hET01Qcm9wKGVsLCBrZXksIG5leHRWYWx1ZSk7XG4gICAgaWYgKCFlbC50YWdOYW1lLmluY2x1ZGVzKFwiLVwiKSAmJiAoa2V5ID09PSBcInZhbHVlXCIgfHwga2V5ID09PSBcImNoZWNrZWRcIiB8fCBrZXkgPT09IFwic2VsZWN0ZWRcIikpIHtcbiAgICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHLCBwYXJlbnRDb21wb25lbnQsIGtleSAhPT0gXCJ2YWx1ZVwiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGtleSA9PT0gXCJ0cnVlLXZhbHVlXCIpIHtcbiAgICAgIGVsLl90cnVlVmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiZmFsc2UtdmFsdWVcIikge1xuICAgICAgZWwuX2ZhbHNlVmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgfVxuICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNob3VsZFNldEFzUHJvcChlbCwga2V5LCB2YWx1ZSwgaXNTVkcpIHtcbiAgaWYgKGlzU1ZHKSB7XG4gICAgaWYgKGtleSA9PT0gXCJpbm5lckhUTUxcIiB8fCBrZXkgPT09IFwidGV4dENvbnRlbnRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChrZXkgaW4gZWwgJiYgaXNOYXRpdmVPbihrZXkpICYmIGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwic3BlbGxjaGVja1wiIHx8IGtleSA9PT0gXCJkcmFnZ2FibGVcIiB8fCBrZXkgPT09IFwidHJhbnNsYXRlXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJmb3JtXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJsaXN0XCIgJiYgZWwudGFnTmFtZSA9PT0gXCJJTlBVVFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwidHlwZVwiICYmIGVsLnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcIndpZHRoXCIgfHwga2V5ID09PSBcImhlaWdodFwiKSB7XG4gICAgY29uc3QgdGFnID0gZWwudGFnTmFtZTtcbiAgICBpZiAodGFnID09PSBcIklNR1wiIHx8IHRhZyA9PT0gXCJWSURFT1wiIHx8IHRhZyA9PT0gXCJDQU5WQVNcIiB8fCB0YWcgPT09IFwiU09VUkNFXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzTmF0aXZlT24oa2V5KSAmJiBpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSBpbiBlbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChlbC5faXNWdWVDRSAmJiAoL1tBLVpdLy50ZXN0KGtleSkgfHwgIWlzU3RyaW5nKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IFJFTU9WQUwgPSB7fTtcbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQob3B0aW9ucywgZXh0cmFPcHRpb25zLCBfY3JlYXRlQXBwKSB7XG4gIGNvbnN0IENvbXAgPSBkZWZpbmVDb21wb25lbnQob3B0aW9ucywgZXh0cmFPcHRpb25zKTtcbiAgaWYgKGlzUGxhaW5PYmplY3QoQ29tcCkpIGV4dGVuZChDb21wLCBleHRyYU9wdGlvbnMpO1xuICBjbGFzcyBWdWVDdXN0b21FbGVtZW50IGV4dGVuZHMgVnVlRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoaW5pdGlhbFByb3BzKSB7XG4gICAgICBzdXBlcihDb21wLCBpbml0aWFsUHJvcHMsIF9jcmVhdGVBcHApO1xuICAgIH1cbiAgfVxuICBWdWVDdXN0b21FbGVtZW50LmRlZiA9IENvbXA7XG4gIHJldHVybiBWdWVDdXN0b21FbGVtZW50O1xufVxuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG5jb25zdCBkZWZpbmVTU1JDdXN0b21FbGVtZW50ID0gLyogQF9fTk9fU0lERV9FRkZFQ1RTX18gKi8gKG9wdGlvbnMsIGV4dHJhT3B0aW9ucykgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGRlZmluZUN1c3RvbUVsZW1lbnQob3B0aW9ucywgZXh0cmFPcHRpb25zLCBjcmVhdGVTU1JBcHApO1xufTtcbmNvbnN0IEJhc2VDbGFzcyA9IHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IEhUTUxFbGVtZW50IDogY2xhc3Mge1xufTtcbmNsYXNzIFZ1ZUVsZW1lbnQgZXh0ZW5kcyBCYXNlQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfZGVmLCBfcHJvcHMgPSB7fSwgX2NyZWF0ZUFwcCA9IGNyZWF0ZUFwcCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fZGVmID0gX2RlZjtcbiAgICB0aGlzLl9wcm9wcyA9IF9wcm9wcztcbiAgICB0aGlzLl9jcmVhdGVBcHAgPSBfY3JlYXRlQXBwO1xuICAgIHRoaXMuX2lzVnVlQ0UgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9hcHAgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX25vbmNlID0gdGhpcy5fZGVmLm5vbmNlO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Jlc29sdmVkID0gZmFsc2U7XG4gICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBudWxsO1xuICAgIHRoaXMuX3N0eWxlQ2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICB0aGlzLl9vYiA9IG51bGw7XG4gICAgaWYgKHRoaXMuc2hhZG93Um9vdCAmJiBfY3JlYXRlQXBwICE9PSBjcmVhdGVBcHApIHtcbiAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzLnNoYWRvd1Jvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBDdXN0b20gZWxlbWVudCBoYXMgcHJlLXJlbmRlcmVkIGRlY2xhcmF0aXZlIHNoYWRvdyByb290IGJ1dCBpcyBub3QgZGVmaW5lZCBhcyBoeWRyYXRhYmxlLiBVc2UgXFxgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudFxcYC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoX2RlZi5zaGFkb3dSb290ICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6IFwib3BlblwiIH0pO1xuICAgICAgICB0aGlzLl9yb290ID0gdGhpcy5zaGFkb3dSb290O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5fZGVmLl9fYXN5bmNMb2FkZXIpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVQcm9wcyh0aGlzLl9kZWYpO1xuICAgIH1cbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgdGhpcy5fcGFyc2VTbG90cygpO1xuICAgIH1cbiAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQgJiYgKHBhcmVudC5wYXJlbnROb2RlIHx8IHBhcmVudC5ob3N0KSkge1xuICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIFZ1ZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkKSB7XG4gICAgICAgIHRoaXMuX3NldFBhcmVudCgpO1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nUmVzb2x2ZSkge1xuICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZXNvbHZlID0gcGFyZW50Ll9wZW5kaW5nUmVzb2x2ZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZXNvbHZlID0gdm9pZCAwO1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZURlZigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmVEZWYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfc2V0UGFyZW50KHBhcmVudCA9IHRoaXMuX3BhcmVudCkge1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHRoaXMuX2luc3RhbmNlLnBhcmVudCA9IHBhcmVudC5faW5zdGFuY2U7XG4gICAgICB0aGlzLl9pbnN0YW5jZS5wcm92aWRlcyA9IHBhcmVudC5faW5zdGFuY2UucHJvdmlkZXM7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9vYikge1xuICAgICAgICAgIHRoaXMuX29iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB0aGlzLl9vYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXBwICYmIHRoaXMuX2FwcC51bm1vdW50KCk7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlLmNlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl9hcHAgPSB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHJlc29sdmUgaW5uZXIgY29tcG9uZW50IGRlZmluaXRpb24gKGhhbmRsZSBwb3NzaWJsZSBhc3luYyBjb21wb25lbnQpXG4gICAqL1xuICBfcmVzb2x2ZURlZigpIHtcbiAgICBpZiAodGhpcy5fcGVuZGluZ1Jlc29sdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3NldEF0dHIodGhpcy5hdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICAgIH1cbiAgICB0aGlzLl9vYiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fc2V0QXR0cihtLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX29iLm9ic2VydmUodGhpcywgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuICAgIGNvbnN0IHJlc29sdmUgPSAoZGVmLCBpc0FzeW5jID0gZmFsc2UpID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3BlbmRpbmdSZXNvbHZlID0gdm9pZCAwO1xuICAgICAgY29uc3QgeyBwcm9wcywgc3R5bGVzIH0gPSBkZWY7XG4gICAgICBsZXQgbnVtYmVyUHJvcHM7XG4gICAgICBpZiAocHJvcHMgJiYgIWlzQXJyYXkocHJvcHMpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgY29uc3Qgb3B0ID0gcHJvcHNba2V5XTtcbiAgICAgICAgICBpZiAob3B0ID09PSBOdW1iZXIgfHwgb3B0ICYmIG9wdC50eXBlID09PSBOdW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gdGhpcy5fcHJvcHMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IHRvTnVtYmVyKHRoaXMuX3Byb3BzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKG51bWJlclByb3BzIHx8IChudW1iZXJQcm9wcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKSlbY2FtZWxpemUkMShrZXkpXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9udW1iZXJQcm9wcyA9IG51bWJlclByb3BzO1xuICAgICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVByb3BzKGRlZik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKHN0eWxlcyk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc3R5bGVzKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJDdXN0b20gZWxlbWVudCBzdHlsZSBpbmplY3Rpb24gaXMgbm90IHN1cHBvcnRlZCB3aGVuIHVzaW5nIHNoYWRvd1Jvb3Q6IGZhbHNlXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21vdW50KGRlZik7XG4gICAgfTtcbiAgICBjb25zdCBhc3luY0RlZiA9IHRoaXMuX2RlZi5fX2FzeW5jTG9hZGVyO1xuICAgIGlmIChhc3luY0RlZikge1xuICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSBhc3luY0RlZigpLnRoZW4oXG4gICAgICAgIChkZWYpID0+IHJlc29sdmUodGhpcy5fZGVmID0gZGVmLCB0cnVlKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZSh0aGlzLl9kZWYpO1xuICAgIH1cbiAgfVxuICBfbW91bnQoZGVmKSB7XG4gICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykgJiYgIWRlZi5uYW1lKSB7XG4gICAgICBkZWYubmFtZSA9IFwiVnVlRWxlbWVudFwiO1xuICAgIH1cbiAgICB0aGlzLl9hcHAgPSB0aGlzLl9jcmVhdGVBcHAoZGVmKTtcbiAgICBpZiAoZGVmLmNvbmZpZ3VyZUFwcCkge1xuICAgICAgZGVmLmNvbmZpZ3VyZUFwcCh0aGlzLl9hcHApO1xuICAgIH1cbiAgICB0aGlzLl9hcHAuX2NlVk5vZGUgPSB0aGlzLl9jcmVhdGVWTm9kZSgpO1xuICAgIHRoaXMuX2FwcC5tb3VudCh0aGlzLl9yb290KTtcbiAgICBjb25zdCBleHBvc2VkID0gdGhpcy5faW5zdGFuY2UgJiYgdGhpcy5faW5zdGFuY2UuZXhwb3NlZDtcbiAgICBpZiAoIWV4cG9zZWQpIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBleHBvc2VkKSB7XG4gICAgICBpZiAoIWhhc093bih0aGlzLCBrZXkpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICAvLyB1bndyYXAgcmVmIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBwdWJsaWMgaW5zdGFuY2UgYmVoYXZpb3JcbiAgICAgICAgICBnZXQ6ICgpID0+IHVucmVmKGV4cG9zZWRba2V5XSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgd2FybihgRXhwb3NlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGFscmVhZHkgZXhpc3RzIG9uIGN1c3RvbSBlbGVtZW50LmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfcmVzb2x2ZVByb3BzKGRlZikge1xuICAgIGNvbnN0IHsgcHJvcHMgfSA9IGRlZjtcbiAgICBjb25zdCBkZWNsYXJlZFByb3BLZXlzID0gaXNBcnJheShwcm9wcykgPyBwcm9wcyA6IE9iamVjdC5rZXlzKHByb3BzIHx8IHt9KTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzKSkge1xuICAgICAgaWYgKGtleVswXSAhPT0gXCJfXCIgJiYgZGVjbGFyZWRQcm9wS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHRoaXMuX3NldFByb3Aoa2V5LCB0aGlzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBkZWNsYXJlZFByb3BLZXlzLm1hcChjYW1lbGl6ZSQxKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb3Aoa2V5KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbCkge1xuICAgICAgICAgIHRoaXMuX3NldFByb3Aoa2V5LCB2YWwsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX3NldEF0dHIoa2V5KSB7XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKFwiZGF0YS12LVwiKSkgcmV0dXJuO1xuICAgIGNvbnN0IGhhcyA9IHRoaXMuaGFzQXR0cmlidXRlKGtleSk7XG4gICAgbGV0IHZhbHVlID0gaGFzID8gdGhpcy5nZXRBdHRyaWJ1dGUoa2V5KSA6IFJFTU9WQUw7XG4gICAgY29uc3QgY2FtZWxLZXkgPSBjYW1lbGl6ZSQxKGtleSk7XG4gICAgaWYgKGhhcyAmJiB0aGlzLl9udW1iZXJQcm9wcyAmJiB0aGlzLl9udW1iZXJQcm9wc1tjYW1lbEtleV0pIHtcbiAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRQcm9wKGNhbWVsS2V5LCB2YWx1ZSwgZmFsc2UsIHRydWUpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9nZXRQcm9wKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9wcm9wc1trZXldO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXRQcm9wKGtleSwgdmFsLCBzaG91bGRSZWZsZWN0ID0gdHJ1ZSwgc2hvdWxkVXBkYXRlID0gZmFsc2UpIHtcbiAgICBpZiAodmFsICE9PSB0aGlzLl9wcm9wc1trZXldKSB7XG4gICAgICBpZiAodmFsID09PSBSRU1PVkFMKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9wcm9wc1trZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRVcGRhdGUgJiYgdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVmbGVjdCkge1xuICAgICAgICBpZiAodmFsID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSksIFwiXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpLCB2YWwgKyBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmICghdmFsKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF91cGRhdGUoKSB7XG4gICAgcmVuZGVyKHRoaXMuX2NyZWF0ZVZOb2RlKCksIHRoaXMuX3Jvb3QpO1xuICB9XG4gIF9jcmVhdGVWTm9kZSgpIHtcbiAgICBjb25zdCBiYXNlUHJvcHMgPSB7fTtcbiAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgYmFzZVByb3BzLm9uVm5vZGVNb3VudGVkID0gYmFzZVByb3BzLm9uVm5vZGVVcGRhdGVkID0gdGhpcy5fcmVuZGVyU2xvdHMuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZSh0aGlzLl9kZWYsIGV4dGVuZChiYXNlUHJvcHMsIHRoaXMuX3Byb3BzKSk7XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgdm5vZGUuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgaW5zdGFuY2UuY2UgPSB0aGlzO1xuICAgICAgICBpbnN0YW5jZS5pc0NFID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jZVJlbG9hZCA9IChuZXdTdHlsZXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdHlsZXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmZvckVhY2goKHMpID0+IHRoaXMuX3Jvb3QucmVtb3ZlQ2hpbGQocykpO1xuICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKG5ld1N0eWxlcyk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoID0gKGV2ZW50LCBhcmdzKSA9PiB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50KFxuICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgaXNQbGFpbk9iamVjdChhcmdzWzBdKSA/IGV4dGVuZCh7IGRldGFpbDogYXJncyB9LCBhcmdzWzBdKSA6IHsgZGV0YWlsOiBhcmdzIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICBpbnN0YW5jZS5lbWl0ID0gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgZGlzcGF0Y2goZXZlbnQsIGFyZ3MpO1xuICAgICAgICAgIGlmIChoeXBoZW5hdGUoZXZlbnQpICE9PSBldmVudCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goaHlwaGVuYXRlKGV2ZW50KSwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZXRQYXJlbnQoKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbiAgfVxuICBfYXBwbHlTdHlsZXMoc3R5bGVzLCBvd25lcikge1xuICAgIGlmICghc3R5bGVzKSByZXR1cm47XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICBpZiAob3duZXIgPT09IHRoaXMuX2RlZiB8fCB0aGlzLl9zdHlsZUNoaWxkcmVuLmhhcyhvd25lcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3R5bGVDaGlsZHJlbi5hZGQob3duZXIpO1xuICAgIH1cbiAgICBjb25zdCBub25jZSA9IHRoaXMuX25vbmNlO1xuICAgIGZvciAobGV0IGkgPSBzdHlsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBpZiAobm9uY2UpIHMuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICAgICAgcy50ZXh0Q29udGVudCA9IHN0eWxlc1tpXTtcbiAgICAgIHRoaXMuc2hhZG93Um9vdC5wcmVwZW5kKHMpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgICAgaWYgKG93bmVyLl9faG1ySWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2hpbGRTdHlsZXMpIHRoaXMuX2NoaWxkU3R5bGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGxldCBlbnRyeSA9IHRoaXMuX2NoaWxkU3R5bGVzLmdldChvd25lci5fX2htcklkKTtcbiAgICAgICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY2hpbGRTdHlsZXMuc2V0KG93bmVyLl9faG1ySWQsIGVudHJ5ID0gW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW50cnkucHVzaChzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKHRoaXMuX3N0eWxlcyB8fCAodGhpcy5fc3R5bGVzID0gW10pKS5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPbmx5IGNhbGxlZCB3aGVuIHNoYWRkb3dSb290IGlzIGZhbHNlXG4gICAqL1xuICBfcGFyc2VTbG90cygpIHtcbiAgICBjb25zdCBzbG90cyA9IHRoaXMuX3Nsb3RzID0ge307XG4gICAgbGV0IG47XG4gICAgd2hpbGUgKG4gPSB0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGNvbnN0IHNsb3ROYW1lID0gbi5ub2RlVHlwZSA9PT0gMSAmJiBuLmdldEF0dHJpYnV0ZShcInNsb3RcIikgfHwgXCJkZWZhdWx0XCI7XG4gICAgICAoc2xvdHNbc2xvdE5hbWVdIHx8IChzbG90c1tzbG90TmFtZV0gPSBbXSkpLnB1c2gobik7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKG4pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogT25seSBjYWxsZWQgd2hlbiBzaGFkZG93Um9vdCBpcyBmYWxzZVxuICAgKi9cbiAgX3JlbmRlclNsb3RzKCkge1xuICAgIGNvbnN0IG91dGxldHMgPSB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzbG90XCIpO1xuICAgIGNvbnN0IHNjb3BlSWQgPSB0aGlzLl9pbnN0YW5jZS50eXBlLl9fc2NvcGVJZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dGxldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG8gPSBvdXRsZXRzW2ldO1xuICAgICAgY29uc3Qgc2xvdE5hbWUgPSBvLmdldEF0dHJpYnV0ZShcIm5hbWVcIikgfHwgXCJkZWZhdWx0XCI7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5fc2xvdHNbc2xvdE5hbWVdO1xuICAgICAgY29uc3QgcGFyZW50ID0gby5wYXJlbnROb2RlO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBuIG9mIGNvbnRlbnQpIHtcbiAgICAgICAgICBpZiAoc2NvcGVJZCAmJiBuLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHNjb3BlSWQgKyBcIi1zXCI7XG4gICAgICAgICAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKG4sIDEpO1xuICAgICAgICAgICAgbi5zZXRBdHRyaWJ1dGUoaWQsIFwiXCIpO1xuICAgICAgICAgICAgbGV0IGNoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkID0gd2Fsa2VyLm5leHROb2RlKCkpIHtcbiAgICAgICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKGlkLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShuLCBvKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKG8uZmlyc3RDaGlsZCkgcGFyZW50Lmluc2VydEJlZm9yZShvLmZpcnN0Q2hpbGQsIG8pO1xuICAgICAgfVxuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG8pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfaW5qZWN0Q2hpbGRTdHlsZShjb21wKSB7XG4gICAgdGhpcy5fYXBwbHlTdHlsZXMoY29tcC5zdHlsZXMsIGNvbXApO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9yZW1vdmVDaGlsZFN0eWxlKGNvbXApIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdGhpcy5fc3R5bGVDaGlsZHJlbi5kZWxldGUoY29tcCk7XG4gICAgICBpZiAodGhpcy5fY2hpbGRTdHlsZXMgJiYgY29tcC5fX2htcklkKSB7XG4gICAgICAgIGNvbnN0IG9sZFN0eWxlcyA9IHRoaXMuX2NoaWxkU3R5bGVzLmdldChjb21wLl9faG1ySWQpO1xuICAgICAgICBpZiAob2xkU3R5bGVzKSB7XG4gICAgICAgICAgb2xkU3R5bGVzLmZvckVhY2goKHMpID0+IHRoaXMuX3Jvb3QucmVtb3ZlQ2hpbGQocykpO1xuICAgICAgICAgIG9sZFN0eWxlcy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1c2VIb3N0KGNhbGxlcikge1xuICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBjb25zdCBlbCA9IGluc3RhbmNlICYmIGluc3RhbmNlLmNlO1xuICBpZiAoZWwpIHtcbiAgICByZXR1cm4gZWw7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGAke2NhbGxlciB8fCBcInVzZUhvc3RcIn0gY2FsbGVkIHdpdGhvdXQgYW4gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgJHtjYWxsZXIgfHwgXCJ1c2VIb3N0XCJ9IGNhbiBvbmx5IGJlIHVzZWQgaW4gY29tcG9uZW50cyBkZWZpbmVkIHZpYSBkZWZpbmVDdXN0b21FbGVtZW50LmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdXNlU2hhZG93Um9vdCgpIHtcbiAgY29uc3QgZWwgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gdXNlSG9zdChcInVzZVNoYWRvd1Jvb3RcIikgOiB1c2VIb3N0KCk7XG4gIHJldHVybiBlbCAmJiBlbC5zaGFkb3dSb290O1xufVxuXG5mdW5jdGlvbiB1c2VDc3NNb2R1bGUobmFtZSA9IFwiJHN0eWxlXCIpIHtcbiAge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGB1c2VDc3NNb2R1bGUgbXVzdCBiZSBjYWxsZWQgaW5zaWRlIHNldHVwKClgKTtcbiAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgfVxuICAgIGNvbnN0IG1vZHVsZXMgPSBpbnN0YW5jZS50eXBlLl9fY3NzTW9kdWxlcztcbiAgICBpZiAoIW1vZHVsZXMpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGVzIGluamVjdGVkLmApO1xuICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICB9XG4gICAgY29uc3QgbW9kID0gbW9kdWxlc1tuYW1lXTtcbiAgICBpZiAoIW1vZCkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZSBuYW1lZCBcIiR7bmFtZX1cIi5gKTtcbiAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgfVxuICAgIHJldHVybiBtb2Q7XG4gIH1cbn1cblxuY29uc3QgcG9zaXRpb25NYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG5ld1Bvc2l0aW9uTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBtb3ZlQ2JLZXkgPSBTeW1ib2woXCJfbW92ZUNiXCIpO1xuY29uc3QgZW50ZXJDYktleSA9IFN5bWJvbChcIl9lbnRlckNiXCIpO1xuY29uc3QgVHJhbnNpdGlvbkdyb3VwSW1wbCA9IHtcbiAgbmFtZTogXCJUcmFuc2l0aW9uR3JvdXBcIixcbiAgcHJvcHM6IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoe30sIFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIHtcbiAgICB0YWc6IFN0cmluZyxcbiAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xuICB9KSxcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcbiAgICBsZXQgcHJldkNoaWxkcmVuO1xuICAgIGxldCBjaGlsZHJlbjtcbiAgICBvblVwZGF0ZWQoKCkgPT4ge1xuICAgICAgaWYgKCFwcmV2Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vdmVDbGFzcyA9IHByb3BzLm1vdmVDbGFzcyB8fCBgJHtwcm9wcy5uYW1lIHx8IFwidlwifS1tb3ZlYDtcbiAgICAgIGlmICghaGFzQ1NTVHJhbnNmb3JtKFxuICAgICAgICBwcmV2Q2hpbGRyZW5bMF0uZWwsXG4gICAgICAgIGluc3RhbmNlLnZub2RlLmVsLFxuICAgICAgICBtb3ZlQ2xhc3NcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgICAgY29uc3QgbW92ZWRDaGlsZHJlbiA9IHByZXZDaGlsZHJlbi5maWx0ZXIoYXBwbHlUcmFuc2xhdGlvbik7XG4gICAgICBmb3JjZVJlZmxvdygpO1xuICAgICAgbW92ZWRDaGlsZHJlbi5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gYy5lbDtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBzdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBcIlwiO1xuICAgICAgICBjb25zdCBjYiA9IGVsW21vdmVDYktleV0gPSAoZSkgPT4ge1xuICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBjYik7XG4gICAgICAgICAgICBlbFttb3ZlQ2JLZXldID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICAgIGNvbnN0IGNzc1RyYW5zaXRpb25Qcm9wcyA9IHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpO1xuICAgICAgbGV0IHRhZyA9IHJhd1Byb3BzLnRhZyB8fCBGcmFnbWVudDtcbiAgICAgIHByZXZDaGlsZHJlbiA9IFtdO1xuICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgIGlmIChjaGlsZC5lbCAmJiBjaGlsZC5lbCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgICAgY3NzVHJhbnNpdGlvblByb3BzLFxuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoXG4gICAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgICBjaGlsZC5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCA/IGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihzbG90cy5kZWZhdWx0KCkpIDogW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhjaGlsZCwgY3NzVHJhbnNpdGlvblByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihgPFRyYW5zaXRpb25Hcm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZC5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHRhZywgbnVsbCwgY2hpbGRyZW4pO1xuICAgIH07XG4gIH1cbn07XG5jb25zdCByZW1vdmVNb2RlID0gKHByb3BzKSA9PiBkZWxldGUgcHJvcHMubW9kZTtcbi8qIEBfX1BVUkVfXyAqLyByZW1vdmVNb2RlKFRyYW5zaXRpb25Hcm91cEltcGwucHJvcHMpO1xuY29uc3QgVHJhbnNpdGlvbkdyb3VwID0gVHJhbnNpdGlvbkdyb3VwSW1wbDtcbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzKGMpIHtcbiAgY29uc3QgZWwgPSBjLmVsO1xuICBpZiAoZWxbbW92ZUNiS2V5XSkge1xuICAgIGVsW21vdmVDYktleV0oKTtcbiAgfVxuICBpZiAoZWxbZW50ZXJDYktleV0pIHtcbiAgICBlbFtlbnRlckNiS2V5XSgpO1xuICB9XG59XG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbihjKSB7XG4gIG5ld1Bvc2l0aW9uTWFwLnNldChjLCBjLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbn1cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24oYykge1xuICBjb25zdCBvbGRQb3MgPSBwb3NpdGlvbk1hcC5nZXQoYyk7XG4gIGNvbnN0IG5ld1BvcyA9IG5ld1Bvc2l0aW9uTWFwLmdldChjKTtcbiAgY29uc3QgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICBjb25zdCBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjb25zdCBzID0gYy5lbC5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMud2Via2l0VHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2R4fXB4LCR7ZHl9cHgpYDtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9IFwiMHNcIjtcbiAgICByZXR1cm4gYztcbiAgfVxufVxuZnVuY3Rpb24gaGFzQ1NTVHJhbnNmb3JtKGVsLCByb290LCBtb3ZlQ2xhc3MpIHtcbiAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgY29uc3QgX3Z0YyA9IGVsW3Z0Y0tleV07XG4gIGlmIChfdnRjKSB7XG4gICAgX3Z0Yy5mb3JFYWNoKChjbHMpID0+IHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LnJlbW92ZShjKSk7XG4gICAgfSk7XG4gIH1cbiAgbW92ZUNsYXNzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QuYWRkKGMpKTtcbiAgY2xvbmUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICBjb25zdCBjb250YWluZXIgPSByb290Lm5vZGVUeXBlID09PSAxID8gcm9vdCA6IHJvb3QucGFyZW50Tm9kZTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgY29uc3QgeyBoYXNUcmFuc2Zvcm0gfSA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgcmV0dXJuIGhhc1RyYW5zZm9ybTtcbn1cblxuY29uc3QgZ2V0TW9kZWxBc3NpZ25lciA9ICh2bm9kZSkgPT4ge1xuICBjb25zdCBmbiA9IHZub2RlLnByb3BzW1wib25VcGRhdGU6bW9kZWxWYWx1ZVwiXSB8fCBmYWxzZTtcbiAgcmV0dXJuIGlzQXJyYXkoZm4pID8gKHZhbHVlKSA9PiBpbnZva2VBcnJheUZucyhmbiwgdmFsdWUpIDogZm47XG59O1xuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0KGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQoZSkge1xuICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgaWYgKHRhcmdldC5jb21wb3NpbmcpIHtcbiAgICB0YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiaW5wdXRcIikpO1xuICB9XG59XG5jb25zdCBhc3NpZ25LZXkgPSBTeW1ib2woXCJfYXNzaWduXCIpO1xuY29uc3Qgdk1vZGVsVGV4dCA9IHtcbiAgY3JlYXRlZChlbCwgeyBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgY29uc3QgY2FzdFRvTnVtYmVyID0gbnVtYmVyIHx8IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGUgPT09IFwibnVtYmVyXCI7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbGF6eSA/IFwiY2hhbmdlXCIgOiBcImlucHV0XCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS50YXJnZXQuY29tcG9zaW5nKSByZXR1cm47XG4gICAgICBsZXQgZG9tVmFsdWUgPSBlbC52YWx1ZTtcbiAgICAgIGlmICh0cmltKSB7XG4gICAgICAgIGRvbVZhbHVlID0gZG9tVmFsdWUudHJpbSgpO1xuICAgICAgfVxuICAgICAgaWYgKGNhc3RUb051bWJlcikge1xuICAgICAgICBkb21WYWx1ZSA9IGxvb3NlVG9OdW1iZXIoZG9tVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxbYXNzaWduS2V5XShkb21WYWx1ZSk7XG4gICAgfSk7XG4gICAgaWYgKHRyaW0pIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgZWwudmFsdWUgPSBlbC52YWx1ZS50cmltKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFsYXp5KSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNvbXBvc2l0aW9uc3RhcnRcIiwgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY29tcG9zaXRpb25lbmRcIiwgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICB9XG4gIH0sXG4gIC8vIHNldCB2YWx1ZSBvbiBtb3VudGVkIHNvIGl0J3MgYWZ0ZXIgbWluL21heCBmb3IgdHlwZT1cInJhbmdlXCJcbiAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgZWwudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG9sZFZhbHVlLCBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgaWYgKGVsLmNvbXBvc2luZykgcmV0dXJuO1xuICAgIGNvbnN0IGVsVmFsdWUgPSAobnVtYmVyIHx8IGVsLnR5cGUgPT09IFwibnVtYmVyXCIpICYmICEvXjBcXGQvLnRlc3QoZWwudmFsdWUpID8gbG9vc2VUb051bWJlcihlbC52YWx1ZSkgOiBlbC52YWx1ZTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWU7XG4gICAgaWYgKGVsVmFsdWUgPT09IG5ld1ZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbCAmJiBlbC50eXBlICE9PSBcInJhbmdlXCIpIHtcbiAgICAgIGlmIChsYXp5ICYmIHZhbHVlID09PSBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHJpbSAmJiBlbC52YWx1ZS50cmltKCkgPT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgfVxufTtcbmNvbnN0IHZNb2RlbENoZWNrYm94ID0ge1xuICAvLyAjNDA5NiBhcnJheSBjaGVja2JveGVzIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcbiAgZGVlcDogdHJ1ZSxcbiAgY3JlYXRlZChlbCwgXywgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbW9kZWxWYWx1ZSA9IGVsLl9tb2RlbFZhbHVlO1xuICAgICAgY29uc3QgZWxlbWVudFZhbHVlID0gZ2V0VmFsdWUoZWwpO1xuICAgICAgY29uc3QgY2hlY2tlZCA9IGVsLmNoZWNrZWQ7XG4gICAgICBjb25zdCBhc3NpZ24gPSBlbFthc3NpZ25LZXldO1xuICAgICAgaWYgKGlzQXJyYXkobW9kZWxWYWx1ZSkpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBsb29zZUluZGV4T2YobW9kZWxWYWx1ZSwgZWxlbWVudFZhbHVlKTtcbiAgICAgICAgY29uc3QgZm91bmQgPSBpbmRleCAhPT0gLTE7XG4gICAgICAgIGlmIChjaGVja2VkICYmICFmb3VuZCkge1xuICAgICAgICAgIGFzc2lnbihtb2RlbFZhbHVlLmNvbmNhdChlbGVtZW50VmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmICghY2hlY2tlZCAmJiBmb3VuZCkge1xuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gWy4uLm1vZGVsVmFsdWVdO1xuICAgICAgICAgIGZpbHRlcmVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgYXNzaWduKGZpbHRlcmVkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1NldChtb2RlbFZhbHVlKSkge1xuICAgICAgICBjb25zdCBjbG9uZWQgPSBuZXcgU2V0KG1vZGVsVmFsdWUpO1xuICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgIGNsb25lZC5hZGQoZWxlbWVudFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9uZWQuZGVsZXRlKGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduKGNsb25lZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NpZ24oZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICAvLyBzZXQgaW5pdGlhbCBjaGVja2VkIG9uIG1vdW50IHRvIHdhaXQgZm9yIHRydWUtdmFsdWUvZmFsc2UtdmFsdWVcbiAgbW91bnRlZDogc2V0Q2hlY2tlZCxcbiAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBzZXRDaGVja2VkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBzZXRDaGVja2VkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICBlbC5fbW9kZWxWYWx1ZSA9IHZhbHVlO1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBlbC5jaGVja2VkID0gbG9vc2VJbmRleE9mKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSkgPiAtMTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICBlbC5jaGVja2VkID0gdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgZ2V0Q2hlY2tib3hWYWx1ZShlbCwgdHJ1ZSkpO1xuICB9XG59XG5jb25zdCB2TW9kZWxSYWRpbyA9IHtcbiAgY3JlYXRlZChlbCwgeyB2YWx1ZSB9LCB2bm9kZSkge1xuICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGVsW2Fzc2lnbktleV0oZ2V0VmFsdWUoZWwpKTtcbiAgICB9KTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IHZNb2RlbFNlbGVjdCA9IHtcbiAgLy8gPHNlbGVjdCBtdWx0aXBsZT4gdmFsdWUgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxuICBkZWVwOiB0cnVlLFxuICBjcmVhdGVkKGVsLCB7IHZhbHVlLCBtb2RpZmllcnM6IHsgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICBjb25zdCBpc1NldE1vZGVsID0gaXNTZXQodmFsdWUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGVsLm9wdGlvbnMsIChvKSA9PiBvLnNlbGVjdGVkKS5tYXAoXG4gICAgICAgIChvKSA9PiBudW1iZXIgPyBsb29zZVRvTnVtYmVyKGdldFZhbHVlKG8pKSA6IGdldFZhbHVlKG8pXG4gICAgICApO1xuICAgICAgZWxbYXNzaWduS2V5XShcbiAgICAgICAgZWwubXVsdGlwbGUgPyBpc1NldE1vZGVsID8gbmV3IFNldChzZWxlY3RlZFZhbCkgOiBzZWxlY3RlZFZhbCA6IHNlbGVjdGVkVmFsWzBdXG4gICAgICApO1xuICAgICAgZWwuX2Fzc2lnbmluZyA9IHRydWU7XG4gICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGVsLl9hc3NpZ25pbmcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgfSxcbiAgLy8gc2V0IHZhbHVlIGluIG1vdW50ZWQgJiB1cGRhdGVkIGJlY2F1c2UgPHNlbGVjdD4gcmVsaWVzIG9uIGl0cyBjaGlsZHJlblxuICAvLyA8b3B0aW9uPnMuXG4gIG1vdW50ZWQoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBudW1iZXIgfSB9KSB7XG4gICAgc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCBfYmluZGluZywgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZWQoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBudW1iZXIgfSB9KSB7XG4gICAgaWYgKCFlbC5fYXNzaWduaW5nKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSwgbnVtYmVyKSB7XG4gIGNvbnN0IGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgY29uc3QgaXNBcnJheVZhbHVlID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc011bHRpcGxlICYmICFpc0FycmF5VmFsdWUgJiYgIWlzU2V0KHZhbHVlKSkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgIGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw+IGV4cGVjdHMgYW4gQXJyYXkgb3IgU2V0IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpfS5gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBnZXRWYWx1ZShvcHRpb24pO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBpZiAoaXNBcnJheVZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvblR5cGUgPSB0eXBlb2Ygb3B0aW9uVmFsdWU7XG4gICAgICAgIGlmIChvcHRpb25UeXBlID09PSBcInN0cmluZ1wiIHx8IG9wdGlvblR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5zb21lKCh2KSA9PiBTdHJpbmcodikgPT09IFN0cmluZyhvcHRpb25WYWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgb3B0aW9uVmFsdWUpID4gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmhhcyhvcHRpb25WYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUgJiYgZWwuc2VsZWN0ZWRJbmRleCAhPT0gLTEpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlKGVsKSB7XG4gIHJldHVybiBcIl92YWx1ZVwiIGluIGVsID8gZWwuX3ZhbHVlIDogZWwudmFsdWU7XG59XG5mdW5jdGlvbiBnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSB7XG4gIGNvbnN0IGtleSA9IGNoZWNrZWQgPyBcIl90cnVlVmFsdWVcIiA6IFwiX2ZhbHNlVmFsdWVcIjtcbiAgcmV0dXJuIGtleSBpbiBlbCA/IGVsW2tleV0gOiBjaGVja2VkO1xufVxuY29uc3Qgdk1vZGVsRHluYW1pYyA9IHtcbiAgY3JlYXRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgXCJjcmVhdGVkXCIpO1xuICB9LFxuICBtb3VudGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCBcIm1vdW50ZWRcIik7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIFwiYmVmb3JlVXBkYXRlXCIpO1xuICB9LFxuICB1cGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgXCJ1cGRhdGVkXCIpO1xuICB9XG59O1xuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNNb2RlbCh0YWdOYW1lLCB0eXBlKSB7XG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJTRUxFQ1RcIjpcbiAgICAgIHJldHVybiB2TW9kZWxTZWxlY3Q7XG4gICAgY2FzZSBcIlRFWFRBUkVBXCI6XG4gICAgICByZXR1cm4gdk1vZGVsVGV4dDtcbiAgICBkZWZhdWx0OlxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgICAgIHJldHVybiB2TW9kZWxDaGVja2JveDtcbiAgICAgICAgY2FzZSBcInJhZGlvXCI6XG4gICAgICAgICAgcmV0dXJuIHZNb2RlbFJhZGlvO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2TW9kZWxUZXh0O1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBob29rKSB7XG4gIGNvbnN0IG1vZGVsVG9Vc2UgPSByZXNvbHZlRHluYW1pY01vZGVsKFxuICAgIGVsLnRhZ05hbWUsXG4gICAgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZVxuICApO1xuICBjb25zdCBmbiA9IG1vZGVsVG9Vc2VbaG9va107XG4gIGZuICYmIGZuKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKTtcbn1cbmZ1bmN0aW9uIGluaXRWTW9kZWxGb3JTU1IoKSB7XG4gIHZNb2RlbFRleHQuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiAoeyB2YWx1ZSB9KTtcbiAgdk1vZGVsUmFkaW8uZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xuICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUVxdWFsKHZub2RlLnByb3BzLnZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICB9XG4gIH07XG4gIHZNb2RlbENoZWNrYm94LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSwgdm5vZGUpID0+IHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgaWYgKHZub2RlLnByb3BzICYmIHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICB9XG4gIH07XG4gIHZNb2RlbER5bmFtaWMuZ2V0U1NSUHJvcHMgPSAoYmluZGluZywgdm5vZGUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZub2RlLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbW9kZWxUb1VzZSA9IHJlc29sdmVEeW5hbWljTW9kZWwoXG4gICAgICAvLyByZXNvbHZlRHluYW1pY01vZGVsIGV4cGVjdHMgYW4gdXBwZXJjYXNlIHRhZyBuYW1lLCBidXQgdm5vZGUudHlwZSBpcyBsb3dlcmNhc2VcbiAgICAgIHZub2RlLnR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgIHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGVcbiAgICApO1xuICAgIGlmIChtb2RlbFRvVXNlLmdldFNTUlByb3BzKSB7XG4gICAgICByZXR1cm4gbW9kZWxUb1VzZS5nZXRTU1JQcm9wcyhiaW5kaW5nLCB2bm9kZSk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBzeXN0ZW1Nb2RpZmllcnMgPSBbXCJjdHJsXCIsIFwic2hpZnRcIiwgXCJhbHRcIiwgXCJtZXRhXCJdO1xuY29uc3QgbW9kaWZpZXJHdWFyZHMgPSB7XG4gIHN0b3A6IChlKSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpLFxuICBwcmV2ZW50OiAoZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLFxuICBzZWxmOiAoZSkgPT4gZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCxcbiAgY3RybDogKGUpID0+ICFlLmN0cmxLZXksXG4gIHNoaWZ0OiAoZSkgPT4gIWUuc2hpZnRLZXksXG4gIGFsdDogKGUpID0+ICFlLmFsdEtleSxcbiAgbWV0YTogKGUpID0+ICFlLm1ldGFLZXksXG4gIGxlZnQ6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDAsXG4gIG1pZGRsZTogKGUpID0+IFwiYnV0dG9uXCIgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMSxcbiAgcmlnaHQ6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDIsXG4gIGV4YWN0OiAoZSwgbW9kaWZpZXJzKSA9PiBzeXN0ZW1Nb2RpZmllcnMuc29tZSgobSkgPT4gZVtgJHttfUtleWBdICYmICFtb2RpZmllcnMuaW5jbHVkZXMobSkpXG59O1xuY29uc3Qgd2l0aE1vZGlmaWVycyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gZm4uX3dpdGhNb2RzIHx8IChmbi5fd2l0aE1vZHMgPSB7fSk7XG4gIGNvbnN0IGNhY2hlS2V5ID0gbW9kaWZpZXJzLmpvaW4oXCIuXCIpO1xuICByZXR1cm4gY2FjaGVbY2FjaGVLZXldIHx8IChjYWNoZVtjYWNoZUtleV0gPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZ3VhcmQgPSBtb2RpZmllckd1YXJkc1ttb2RpZmllcnNbaV1dO1xuICAgICAgaWYgKGd1YXJkICYmIGd1YXJkKGV2ZW50LCBtb2RpZmllcnMpKSByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBmbihldmVudCwgLi4uYXJncyk7XG4gIH0pO1xufTtcbmNvbnN0IGtleU5hbWVzID0ge1xuICBlc2M6IFwiZXNjYXBlXCIsXG4gIHNwYWNlOiBcIiBcIixcbiAgdXA6IFwiYXJyb3ctdXBcIixcbiAgbGVmdDogXCJhcnJvdy1sZWZ0XCIsXG4gIHJpZ2h0OiBcImFycm93LXJpZ2h0XCIsXG4gIGRvd246IFwiYXJyb3ctZG93blwiLFxuICBkZWxldGU6IFwiYmFja3NwYWNlXCJcbn07XG5jb25zdCB3aXRoS2V5cyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gZm4uX3dpdGhLZXlzIHx8IChmbi5fd2l0aEtleXMgPSB7fSk7XG4gIGNvbnN0IGNhY2hlS2V5ID0gbW9kaWZpZXJzLmpvaW4oXCIuXCIpO1xuICByZXR1cm4gY2FjaGVbY2FjaGVLZXldIHx8IChjYWNoZVtjYWNoZUtleV0gPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoIShcImtleVwiIGluIGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBldmVudEtleSA9IGh5cGhlbmF0ZShldmVudC5rZXkpO1xuICAgIGlmIChtb2RpZmllcnMuc29tZShcbiAgICAgIChrKSA9PiBrID09PSBldmVudEtleSB8fCBrZXlOYW1lc1trXSA9PT0gZXZlbnRLZXlcbiAgICApKSB7XG4gICAgICByZXR1cm4gZm4oZXZlbnQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5jb25zdCByZW5kZXJlck9wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKHsgcGF0Y2hQcm9wIH0sIG5vZGVPcHMpO1xubGV0IHJlbmRlcmVyO1xubGV0IGVuYWJsZWRIeWRyYXRpb24gPSBmYWxzZTtcbmZ1bmN0aW9uIGVuc3VyZVJlbmRlcmVyKCkge1xuICByZXR1cm4gcmVuZGVyZXIgfHwgKHJlbmRlcmVyID0gY3JlYXRlUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKSk7XG59XG5mdW5jdGlvbiBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpIHtcbiAgcmVuZGVyZXIgPSBlbmFibGVkSHlkcmF0aW9uID8gcmVuZGVyZXIgOiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpO1xuICBlbmFibGVkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgcmV0dXJuIHJlbmRlcmVyO1xufVxuY29uc3QgcmVuZGVyID0gKC4uLmFyZ3MpID0+IHtcbiAgZW5zdXJlUmVuZGVyZXIoKS5yZW5kZXIoLi4uYXJncyk7XG59O1xuY29uc3QgaHlkcmF0ZSA9ICguLi5hcmdzKSA9PiB7XG4gIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuaHlkcmF0ZSguLi5hcmdzKTtcbn07XG5jb25zdCBjcmVhdGVBcHAgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBhcHAgPSBlbnN1cmVSZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xuICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XG4gIH1cbiAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xuICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcbiAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGFwcC5fY29tcG9uZW50O1xuICAgIGlmICghaXNGdW5jdGlvbihjb21wb25lbnQpICYmICFjb21wb25lbnQucmVuZGVyICYmICFjb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgIGNvbXBvbmVudC50ZW1wbGF0ZSA9IGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgfVxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIGNvbnRhaW5lci50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IHByb3h5ID0gbW91bnQoY29udGFpbmVyLCBmYWxzZSwgcmVzb2x2ZVJvb3ROYW1lc3BhY2UoY29udGFpbmVyKSk7XG4gICAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoXCJ2LWNsb2FrXCIpO1xuICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtdi1hcHBcIiwgXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbiAgcmV0dXJuIGFwcDtcbn07XG5jb25zdCBjcmVhdGVTU1JBcHAgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBhcHAgPSBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xuICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XG4gIH1cbiAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xuICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gbW91bnQoY29udGFpbmVyLCB0cnVlLCByZXNvbHZlUm9vdE5hbWVzcGFjZShjb250YWluZXIpKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBhcHA7XG59O1xuZnVuY3Rpb24gcmVzb2x2ZVJvb3ROYW1lc3BhY2UoY29udGFpbmVyKSB7XG4gIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgcmV0dXJuIFwic3ZnXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBNYXRoTUxFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgY29udGFpbmVyIGluc3RhbmNlb2YgTWF0aE1MRWxlbWVudCkge1xuICAgIHJldHVybiBcIm1hdGhtbFwiO1xuICB9XG59XG5mdW5jdGlvbiBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsIFwiaXNOYXRpdmVUYWdcIiwge1xuICAgIHZhbHVlOiAodGFnKSA9PiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWR1RhZyh0YWcpIHx8IGlzTWF0aE1MVGFnKHRhZyksXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKSB7XG4gIGlmIChpc1J1bnRpbWVPbmx5KCkpIHtcbiAgICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBhcHAuY29uZmlnLmlzQ3VzdG9tRWxlbWVudDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgXCJpc0N1c3RvbUVsZW1lbnRcIiwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gaXNDdXN0b21FbGVtZW50O1xuICAgICAgfSxcbiAgICAgIHNldCgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgVGhlIFxcYGlzQ3VzdG9tRWxlbWVudFxcYCBjb25maWcgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSBcXGBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50XFxgIGluc3RlYWQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGNvbXBpbGVyT3B0aW9ucyA9IGFwcC5jb25maWcuY29tcGlsZXJPcHRpb25zO1xuICAgIGNvbnN0IG1zZyA9IGBUaGUgXFxgY29tcGlsZXJPcHRpb25zXFxgIGNvbmZpZyBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZS5qcyB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyIChha2EgXCJmdWxsIGJ1aWxkXCIpLiBTaW5jZSB5b3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQsIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBtdXN0IGJlIHBhc3NlZCB0byBcXGBAdnVlL2NvbXBpbGVyLWRvbVxcYCBpbiB0aGUgYnVpbGQgc2V0dXAgaW5zdGVhZC5cbi0gRm9yIHZ1ZS1sb2FkZXI6IHBhc3MgaXQgdmlhIHZ1ZS1sb2FkZXIncyBcXGBjb21waWxlck9wdGlvbnNcXGAgbG9hZGVyIG9wdGlvbi5cbi0gRm9yIHZ1ZS1jbGk6IHNlZSBodHRwczovL2NsaS52dWVqcy5vcmcvZ3VpZGUvd2VicGFjay5odG1sI21vZGlmeWluZy1vcHRpb25zLW9mLWEtbG9hZGVyXG4tIEZvciB2aXRlOiBwYXNzIGl0IHZpYSBAdml0ZWpzL3BsdWdpbi12dWUgb3B0aW9ucy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS1wbHVnaW4tdnVlL3RyZWUvbWFpbi9wYWNrYWdlcy9wbHVnaW4tdnVlI2V4YW1wbGUtZm9yLXBhc3Npbmctb3B0aW9ucy10by12dWVjb21waWxlci1zZmNgO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCBcImNvbXBpbGVyT3B0aW9uc1wiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVyT3B0aW9ucztcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoaXNTdHJpbmcoY29udGFpbmVyKSkge1xuICAgIGNvbnN0IHJlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhcmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRmFpbGVkIHRvIG1vdW50IGFwcDogbW91bnQgdGFyZ2V0IHNlbGVjdG9yIFwiJHtjb250YWluZXJ9XCIgcmV0dXJuZWQgbnVsbC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdpbmRvdy5TaGFkb3dSb290ICYmIGNvbnRhaW5lciBpbnN0YW5jZW9mIHdpbmRvdy5TaGFkb3dSb290ICYmIGNvbnRhaW5lci5tb2RlID09PSBcImNsb3NlZFwiKSB7XG4gICAgd2FybihcbiAgICAgIGBtb3VudGluZyBvbiBhIFNoYWRvd1Jvb3Qgd2l0aCBcXGB7bW9kZTogXCJjbG9zZWRcIn1cXGAgbWF5IGxlYWQgdG8gdW5wcmVkaWN0YWJsZSBidWdzYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cbmxldCBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IGZhbHNlO1xuY29uc3QgaW5pdERpcmVjdGl2ZXNGb3JTU1IgPSAoKSA9PiB7XG4gIGlmICghc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQpIHtcbiAgICBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IHRydWU7XG4gICAgaW5pdFZNb2RlbEZvclNTUigpO1xuICAgIGluaXRWU2hvd0ZvclNTUigpO1xuICB9XG59IDtcblxuZXhwb3J0IHsgVHJhbnNpdGlvbiwgVHJhbnNpdGlvbkdyb3VwLCBWdWVFbGVtZW50LCBjcmVhdGVBcHAsIGNyZWF0ZVNTUkFwcCwgZGVmaW5lQ3VzdG9tRWxlbWVudCwgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCwgaHlkcmF0ZSwgaW5pdERpcmVjdGl2ZXNGb3JTU1IsIHJlbmRlciwgdXNlQ3NzTW9kdWxlLCB1c2VDc3NWYXJzLCB1c2VIb3N0LCB1c2VTaGFkb3dSb290LCB2TW9kZWxDaGVja2JveCwgdk1vZGVsRHluYW1pYywgdk1vZGVsUmFkaW8sIHZNb2RlbFNlbGVjdCwgdk1vZGVsVGV4dCwgdlNob3csIHdpdGhLZXlzLCB3aXRoTW9kaWZpZXJzIH07XG4iLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM2M/eG1sJTIwdmVyc2lvbj0nMS4wJyUyMGVuY29kaW5nPSd1dGYtOCc/JTNlJTNjIS0tJTIwVXBsb2FkZWQlMjB0bzolMjBTVkclMjBSZXBvLCUyMHd3dy5zdmdyZXBvLmNvbSwlMjBHZW5lcmF0b3I6JTIwU1ZHJTIwUmVwbyUyME1peGVyJTIwVG9vbHMlMjAtLSUzZSUzY3N2ZyUyMHdpZHRoPSc4MDBweCclMjBoZWlnaHQ9JzgwMHB4JyUyMHZpZXdCb3g9JzAlMjAwJTIwMjQlMjAyNCclMjBmaWxsPSdub25lJyUyMHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyclM2UlM2NnJTIwaWQ9J01lbnUlMjAvJTIwQ2xvc2VfTEcnJTNlJTNjcGF0aCUyMGlkPSdWZWN0b3InJTIwZD0nTTIxJTIwMjFMMTIlMjAxMk0xMiUyMDEyTDMlMjAzTTEyJTIwMTJMMjEuMDAwMSUyMDNNMTIlMjAxMkwzJTIwMjEuMDAwMSclMjBzdHJva2U9JyUyMzAwMDAwMCclMjBzdHJva2Utd2lkdGg9JzInJTIwc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJyUyMHN0cm9rZS1saW5lam9pbj0ncm91bmQnLyUzZSUzYy9nJTNlJTNjL3N2ZyUzZVwiIiwiZXhwb3J0IGRlZmF1bHQgXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNjP3htbCUyMHZlcnNpb249JzEuMCclMjBlbmNvZGluZz0ndXRmLTgnPyUzZSUzYyEtLSUyMFVwbG9hZGVkJTIwdG86JTIwU1ZHJTIwUmVwbywlMjB3d3cuc3ZncmVwby5jb20sJTIwR2VuZXJhdG9yOiUyMFNWRyUyMFJlcG8lMjBNaXhlciUyMFRvb2xzJTIwLS0lM2UlM2NzdmclMjB3aWR0aD0nODAwcHgnJTIwaGVpZ2h0PSc4MDBweCclMjB2aWV3Qm94PScwJTIwMCUyMDI0JTIwMjQnJTIwZmlsbD0nJTIzMDAzMjc0JyUyMHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyclM2UlM2NnJTIwaWQ9J0Fycm93JTIwLyUyMENhcmV0X0NpcmNsZV9VcCclM2UlM2NwYXRoJTIwaWQ9J1ZlY3RvciclMjBkPSdNOSUyMDEzTDEyJTIwMTBMMTUlMjAxM00yMSUyMDEyQzIxJTIwNy4wMjk0NCUyMDE2Ljk3MDYlMjAzJTIwMTIlMjAzQzcuMDI5NDQlMjAzJTIwMyUyMDcuMDI5NDQlMjAzJTIwMTJDMyUyMDE2Ljk3MDYlMjA3LjAyOTQ0JTIwMjElMjAxMiUyMDIxQzE2Ljk3MDYlMjAyMSUyMDIxJTIwMTYuOTcwNiUyMDIxJTIwMTJaJyUyMHN0cm9rZT0nJTIzRkZGRkZGJyUyMHN0cm9rZS13aWR0aD0nMiclMjBzdHJva2UtbGluZWNhcD0ncm91bmQnJTIwc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCcvJTNlJTNjL2clM2UlM2Mvc3ZnJTNlXCIiLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM2M/eG1sJTIwdmVyc2lvbj0nMS4wJyUyMGVuY29kaW5nPSd1dGYtOCc/JTNlJTNjIS0tJTIwVXBsb2FkZWQlMjB0bzolMjBTVkclMjBSZXBvLCUyMHd3dy5zdmdyZXBvLmNvbSwlMjBHZW5lcmF0b3I6JTIwU1ZHJTIwUmVwbyUyME1peGVyJTIwVG9vbHMlMjAtLSUzZSUzY3N2ZyUyMHdpZHRoPSc4MDBweCclMjBoZWlnaHQ9JzgwMHB4JyUyMHZpZXdCb3g9JzAlMjAwJTIwMjQlMjAyNCclMjBmaWxsPSdub25lJyUyMHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyclM2UlM2NnJTIwaWQ9J0VkaXQlMjAvJTIwTGlzdF9Vbm9yZGVyZWQnJTNlJTNjcGF0aCUyMGlkPSdWZWN0b3InJTIwZD0nTTklMjAxN0gxOU05JTIwMTJIMTlNOSUyMDdIMTlNNS4wMDE5NSUyMDE3VjE3LjAwMkw1JTIwMTcuMDAyVjE3SDUuMDAxOTVaTTUuMDAxOTUlMjAxMlYxMi4wMDJMNSUyMDEyLjAwMlYxMkg1LjAwMTk1Wk01LjAwMTk1JTIwN1Y3LjAwMkw1JTIwNy4wMDE5NVY3SDUuMDAxOTVaJyUyMHN0cm9rZT0nJTIzMDAwMDAwJyUyMHN0cm9rZS13aWR0aD0nMiclMjBzdHJva2UtbGluZWNhcD0ncm91bmQnJTIwc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCcvJTNlJTNjL2clM2UlM2Mvc3ZnJTNlXCIiLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM2M/eG1sJTIwdmVyc2lvbj0nMS4wJyUyMGVuY29kaW5nPSd1dGYtOCc/JTNlJTNjIS0tJTIwVXBsb2FkZWQlMjB0bzolMjBTVkclMjBSZXBvLCUyMHd3dy5zdmdyZXBvLmNvbSwlMjBHZW5lcmF0b3I6JTIwU1ZHJTIwUmVwbyUyME1peGVyJTIwVG9vbHMlMjAtLSUzZSUzY3N2ZyUyMHdpZHRoPSc4MDBweCclMjBoZWlnaHQ9JzgwMHB4JyUyMHZpZXdCb3g9JzAlMjAwJTIwMjQlMjAyNCclMjBmaWxsPSdub25lJyUyMHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyclM2UlM2NnJTIwaWQ9J05hdmlnYXRpb24lMjAvJTIwSG91c2VfMDMnJTNlJTNjcGF0aCUyMGlkPSdWZWN0b3InJTIwZD0nTTIlMjAyMC4wMDAxSDRNNCUyMDIwLjAwMDFIMTBNNCUyMDIwLjAwMDFWMTEuNDUyMkM0JTIwMTAuOTE3OSUyMDQlMjAxMC42NTA2JTIwNC4wNjQ5NyUyMDEwLjQwMTlDNC4xMjI1NSUyMDEwLjE4MTYlMjA0LjIxNzc5JTIwOS45NzMwNyUyMDQuMzQ1NyUyMDkuNzg0NjRDNC40OTAwNCUyMDkuNTcyMDElMjA0LjY5MDY0JTIwOS4zOTU2OSUyMDUuMDkyNzclMjA5LjA0MzgzTDkuODk0MzYlMjA0Ljg0MjQ0QzEwLjYzOTglMjA0LjE5MDE0JTIwMTEuMDEyNiUyMDMuODYzOTclMjAxMS40MzI0JTIwMy43Mzk4MkMxMS44MDI2JTIwMy42MzAzNSUyMDEyLjE5NzIlMjAzLjYzMDM1JTIwMTIuNTY3NCUyMDMuNzM5ODJDMTIuOTg3NSUyMDMuODY0MDYlMjAxMy4zNjA4JTIwNC4xOTA1NCUyMDE0LjEwNzQlMjA0Ljg0MzgzTDE4LjkwNzQlMjA5LjA0MzgzQzE5LjMwOTUlMjA5LjM5NTY4JTIwMTkuNTEwMiUyMDkuNTcyMDIlMjAxOS42NTQ2JTIwOS43ODQ2NEMxOS43ODI1JTIwOS45NzMwNyUyMDE5Ljg3NyUyMDEwLjE4MTYlMjAxOS45MzQ2JTIwMTAuNDAxOUMxOS45OTk1JTIwMTAuNjUwNiUyMDIwJTIwMTAuOTE3OSUyMDIwJTIwMTEuNDUyMlYyMC4wMDAxTTEwJTIwMjAuMDAwMUgxNE0xMCUyMDIwLjAwMDFWMTYuMDAwMUMxMCUyMDE0Ljg5NTUlMjAxMC44OTU0JTIwMTQuMDAwMSUyMDEyJTIwMTQuMDAwMUMxMy4xMDQ2JTIwMTQuMDAwMSUyMDE0JTIwMTQuODk1NSUyMDE0JTIwMTYuMDAwMVYyMC4wMDAxTTE0JTIwMjAuMDAwMUgyME0yMCUyMDIwLjAwMDFIMjInJTIwc3Ryb2tlPSclMjMwMDAwMDAnJTIwc3Ryb2tlLXdpZHRoPScyJyUyMHN0cm9rZS1saW5lY2FwPSdyb3VuZCclMjBzdHJva2UtbGluZWpvaW49J3JvdW5kJy8lM2UlM2MvZyUzZSUzYy9zdmclM2VcIiIsImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9zdmcreG1sLCUzYz94bWwlMjB2ZXJzaW9uPScxLjAnJTIwZW5jb2Rpbmc9J3V0Zi04Jz8lM2UlM2MhLS0lMjBVcGxvYWRlZCUyMHRvOiUyMFNWRyUyMFJlcG8sJTIwd3d3LnN2Z3JlcG8uY29tLCUyMEdlbmVyYXRvcjolMjBTVkclMjBSZXBvJTIwTWl4ZXIlMjBUb29scyUyMC0tJTNlJTNjc3ZnJTIwd2lkdGg9JzgwMHB4JyUyMGhlaWdodD0nODAwcHgnJTIwdmlld0JveD0nMCUyMDAlMjAyNCUyMDI0JyUyMGZpbGw9J25vbmUnJTIweG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyUzZSUzY2clMjBpZD0nV2FybmluZyUyMC8lMjBDaXJjbGVfSGVscCclM2UlM2NwYXRoJTIwaWQ9J1ZlY3RvciclMjBkPSdNOS4xNDY0OCUyMDkuMDczNjFDOS4zMTcyOCUyMDguNTQ3MzIlMjA5LjYzMDE1JTIwOC4wNzg5NiUyMDEwLjA1MDglMjA3LjcxOTQ4QzEwLjQ3MTQlMjA3LjM2MDAxJTIwMTAuOTgzOCUyMDcuMTIzNzglMjAxMS41MzAzJTIwNy4wMzcwOEMxMi4wNzY4JTIwNi45NTAzOCUyMDEyLjYzNjIlMjA3LjAxNjQlMjAxMy4xNDc1JTIwNy4yMjgwM0MxMy42NTg3JTIwNy40Mzk2NiUyMDE0LjEwMTQlMjA3Ljc4ODc1JTIwMTQuNDI2OCUyMDguMjM2MzNDMTQuNzUyMSUyMDguNjgzOTElMjAxNC45NDY5JTIwOS4yMTI1NiUyMDE0Ljk5MDQlMjA5Ljc2NDE2QzE1LjAzMzklMjAxMC4zMTU4JTIwMTQuOTIzOCUyMDEwLjg2ODglMjAxNC42NzI3JTIwMTEuMzYxOEMxNC40MjE1JTIwMTEuODU0OCUyMDE0LjAzOTQlMjAxMi4yNjg1JTIwMTMuNTY3NiUyMDEyLjU1NzZDMTMuMDk1OCUyMDEyLjg0NjclMjAxMi41NTMzJTIwMTIuOTk5OCUyMDEyJTIwMTIuOTk5OFYxNC4wMDAyTTEyJTIwMjFDNy4wMjk0NCUyMDIxJTIwMyUyMDE2Ljk3MDYlMjAzJTIwMTJDMyUyMDcuMDI5NDQlMjA3LjAyOTQ0JTIwMyUyMDEyJTIwM0MxNi45NzA2JTIwMyUyMDIxJTIwNy4wMjk0NCUyMDIxJTIwMTJDMjElMjAxNi45NzA2JTIwMTYuOTcwNiUyMDIxJTIwMTIlMjAyMVpNMTIuMDQ5OCUyMDE3VjE3LjFMMTEuOTUwMiUyMDE3LjEwMDJWMTdIMTIuMDQ5OFonJTIwc3Ryb2tlPSclMjMwMDAwMDAnJTIwc3Ryb2tlLXdpZHRoPScyJyUyMHN0cm9rZS1saW5lY2FwPSdyb3VuZCclMjBzdHJva2UtbGluZWpvaW49J3JvdW5kJy8lM2UlM2MvZyUzZSUzYy9zdmclM2VcIiIsImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9zdmcreG1sLCUzYz94bWwlMjB2ZXJzaW9uPScxLjAnJTIwZW5jb2Rpbmc9J3V0Zi04Jz8lM2UlM2MhLS0lMjBVcGxvYWRlZCUyMHRvOiUyMFNWRyUyMFJlcG8sJTIwd3d3LnN2Z3JlcG8uY29tLCUyMEdlbmVyYXRvcjolMjBTVkclMjBSZXBvJTIwTWl4ZXIlMjBUb29scyUyMC0tJTNlJTNjc3ZnJTIwZmlsbD0nJTIzRkZGRkZGJyUyMGNvbG9yPSdGRkZGRkYnJTIwd2lkdGg9JzgwMHB4JyUyMGhlaWdodD0nODAwcHgnJTIwdmlld0JveD0nMCUyMDAlMjAzMiUyMDMyJyUyMHZlcnNpb249JzEuMSclMjB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnJTNlJTNjcGF0aCUyMGQ9J00yNCUyMDBoLTExYy0xLjEwNCUyMDAtMiUyMDAuODk1LTIlMjAyaDExdjhoOHYxNmgtN3YyaDdjMS4xMDUlMjAwJTIwMi0wLjg5NSUyMDItMnYtMTh6TTI0JTIwOHYtNS4xNzJsNS4xNzElMjA1LjE3MmgtNS4xNzF6TTIlMjA0Yy0xLjEwNSUyMDAtMiUyMDAuODk2LTIlMjAydjI0YzAlMjAxLjEwNSUyMDAuODk1JTIwMiUyMDIlMjAyaDE3YzEuMTA1JTIwMCUyMDItMC44OTUlMjAyLTJ2LTE4bC04LTguMDAxaC0xMXpNMTklMjAzMGgtMTd2LTI0aDl2OGg4djE2ek0xMyUyMDEydi01LjE3Mmw1LjE3MSUyMDUuMTcyaC01LjE3MXonJTNlJTNjL3BhdGglM2UlM2Mvc3ZnJTNlXCIiLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM2M/eG1sJTIwdmVyc2lvbj0nMS4wJyUyMGVuY29kaW5nPSd1dGYtOCc/JTNlJTNjIS0tJTIwVXBsb2FkZWQlMjB0bzolMjBTVkclMjBSZXBvLCUyMHd3dy5zdmdyZXBvLmNvbSwlMjBHZW5lcmF0b3I6JTIwU1ZHJTIwUmVwbyUyME1peGVyJTIwVG9vbHMlMjAtLSUzZSUzY3N2ZyUyMHdpZHRoPSc4MDBweCclMjBoZWlnaHQ9JzgwMHB4JyUyMHZpZXdCb3g9JzAlMjAwJTIwMjQlMjAyNCclMjBmaWxsPSdub25lJyUyMHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyclM2UlM2NnJTIwaWQ9J0Fycm93JTIwLyUyMEFycm93X1JlbG9hZF8wMiclM2UlM2NwYXRoJTIwaWQ9J1ZlY3RvciclMjBkPSdNMTQlMjAxNkgxOVYyMU0xMCUyMDhINVYzTTE5LjQxNzYlMjA5LjAwMzRDMTguODU2OSUyMDcuNjE1NjYlMjAxNy45MTgxJTIwNi40MTMwNCUyMDE2LjcwOCUyMDUuNTMyMjNDMTUuNDk3OSUyMDQuNjUxNDElMjAxNC4wNjUyJTIwNC4xMjc1MiUyMDEyLjU3MjMlMjA0LjAyMDUxQzExLjA3OTQlMjAzLjkxMzUlMjA5LjU4NjA2JTIwNC4yMjc0JTIwOC4yNjI3JTIwNC45MjY2MUM2LjkzOTMzJTIwNS42MjU4MiUyMDUuODM4ODIlMjA2LjY4MjU0JTIwNS4wODU5NCUyMDcuOTc2MTJNNC41ODIwMyUyMDE0Ljk5NzFDNS4xNDI3MiUyMDE2LjM4NDglMjA2LjA4MTQ2JTIwMTcuNTg3NCUyMDcuMjkxNTclMjAxOC40NjgyQzguNTAxNjklMjAxOS4zNDkxJTIwOS45MzU4OCUyMDE5Ljg3MjMlMjAxMS40Mjg4JTIwMTkuOTc5M0MxMi45MjE3JTIwMjAuMDg2MyUyMDE0LjQxMzglMjAxOS43NzI1JTIwMTUuNzM3MSUyMDE5LjA3MzJDMTcuMDYwNSUyMDE4LjM3NCUyMDE4LjE2MDMlMjAxNy4zMTc1JTIwMTguOTEzMSUyMDE2LjAyMzknJTIwc3Ryb2tlPSclMjNGRkZGRkYnJTIwc3Ryb2tlLXdpZHRoPScyJyUyMHN0cm9rZS1saW5lY2FwPSdyb3VuZCclMjBzdHJva2UtbGluZWpvaW49J3JvdW5kJy8lM2UlM2MvZyUzZSUzYy9zdmclM2VcIiIsImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9zdmcreG1sLCUzYz94bWwlMjB2ZXJzaW9uPScxLjAnJTIwZW5jb2Rpbmc9J3V0Zi04Jz8lM2UlM2MhLS0lMjBVcGxvYWRlZCUyMHRvOiUyMFNWRyUyMFJlcG8sJTIwd3d3LnN2Z3JlcG8uY29tLCUyMEdlbmVyYXRvcjolMjBTVkclMjBSZXBvJTIwTWl4ZXIlMjBUb29scyUyMC0tJTNlJTNjc3ZnJTIwd2lkdGg9JzgwMHB4JyUyMGhlaWdodD0nODAwcHgnJTIwdmlld0JveD0nMCUyMDAlMjAyNCUyMDI0JyUyMGZpbGw9J25vbmUnJTIweG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyUzZSUzY2clMjBpZD0nQ29tbXVuaWNhdGlvbiUyMC8lMjBTaGFyZV9pT1NfRXhwb3J0JyUzZSUzY3BhdGglMjBpZD0nVmVjdG9yJyUyMGQ9J005JTIwNkwxMiUyMDNNMTIlMjAzTDE1JTIwNk0xMiUyMDNWMTNNNy4wMDAyMyUyMDEwQzYuMDY4MzUlMjAxMCUyMDUuNjAyNDElMjAxMCUyMDUuMjM0ODYlMjAxMC4xNTIyQzQuNzQ0ODElMjAxMC4zNTUyJTIwNC4zNTUyMyUyMDEwLjc0NDglMjA0LjE1MjI0JTIwMTEuMjM0OUM0JTIwMTEuNjAyNCUyMDQlMjAxMi4wNjgxJTIwNCUyMDEzVjE3LjhDNCUyMDE4LjkyMDElMjA0JTIwMTkuNDc5OCUyMDQuMjE3OTklMjAxOS45MDc2QzQuNDA5NzMlMjAyMC4yODM5JTIwNC43MTU0NyUyMDIwLjU5MDUlMjA1LjA5MTglMjAyMC43ODIyQzUuNTE5MiUyMDIxJTIwNi4wNzg5OSUyMDIxJTIwNy4xOTY5MSUyMDIxSDE2LjgwMzZDMTcuOTIxNSUyMDIxJTIwMTguNDgwNSUyMDIxJTIwMTguOTA3OSUyMDIwLjc4MjJDMTkuMjg0MiUyMDIwLjU5MDUlMjAxOS41OTA1JTIwMjAuMjgzOSUyMDE5Ljc4MjIlMjAxOS45MDc2QzIwJTIwMTkuNDgwMiUyMDIwJTIwMTguOTIxJTIwMjAlMjAxNy44MDMxVjEzQzIwJTIwMTIuMDY4MSUyMDE5Ljk5OTklMjAxMS42MDI0JTIwMTkuODQ3NyUyMDExLjIzNDlDMTkuNjQ0NyUyMDEwLjc0NDglMjAxOS4yNTU0JTIwMTAuMzU1MiUyMDE4Ljc2NTQlMjAxMC4xNTIyQzE4LjM5NzglMjAxMCUyMDE3LjkzMTklMjAxMCUyMDE3JTIwMTAnJTIwc3Ryb2tlPSclMjNGRkZGRkYnJTIwc3Ryb2tlLXdpZHRoPScyJyUyMHN0cm9rZS1saW5lY2FwPSdyb3VuZCclMjBzdHJva2UtbGluZWpvaW49J3JvdW5kJy8lM2UlM2MvZyUzZSUzYy9zdmclM2VcIiIsImV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzQuNTYuMCc7IC8vIHgtcmVsZWFzZS1wbGVhc2UtdmVyc2lvblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5tanMubWFwIiwiZXhwb3J0IGxldCBhdXRvID0gZmFsc2U7XG5leHBvcnQgbGV0IGtpbmQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGZldGNoID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBSZXNwb25zZSA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgSGVhZGVycyA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgRm9ybURhdGEgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IEJsb2IgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IEZpbGUgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IFJlYWRhYmxlU3RyZWFtID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucyA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgZ2V0RGVmYXVsdEFnZW50ID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBmaWxlRnJvbVBhdGggPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGlzRnNSZWFkU3RyZWFtID0gdW5kZWZpbmVkO1xuZXhwb3J0IGZ1bmN0aW9uIHNldFNoaW1zKHNoaW1zLCBvcHRpb25zID0geyBhdXRvOiBmYWxzZSB9KSB7XG4gICAgaWYgKGF1dG8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB5b3UgbXVzdCBcXGBpbXBvcnQgJ29wZW5haS9zaGltcy8ke3NoaW1zLmtpbmR9J1xcYCBiZWZvcmUgaW1wb3J0aW5nIGFueXRoaW5nIGVsc2UgZnJvbSBvcGVuYWlgKTtcbiAgICB9XG4gICAgaWYgKGtpbmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW4ndCBcXGBpbXBvcnQgJ29wZW5haS9zaGltcy8ke3NoaW1zLmtpbmR9J1xcYCBhZnRlciBcXGBpbXBvcnQgJ29wZW5haS9zaGltcy8ke2tpbmR9J1xcYGApO1xuICAgIH1cbiAgICBhdXRvID0gb3B0aW9ucy5hdXRvO1xuICAgIGtpbmQgPSBzaGltcy5raW5kO1xuICAgIGZldGNoID0gc2hpbXMuZmV0Y2g7XG4gICAgUmVxdWVzdCA9IHNoaW1zLlJlcXVlc3Q7XG4gICAgUmVzcG9uc2UgPSBzaGltcy5SZXNwb25zZTtcbiAgICBIZWFkZXJzID0gc2hpbXMuSGVhZGVycztcbiAgICBGb3JtRGF0YSA9IHNoaW1zLkZvcm1EYXRhO1xuICAgIEJsb2IgPSBzaGltcy5CbG9iO1xuICAgIEZpbGUgPSBzaGltcy5GaWxlO1xuICAgIFJlYWRhYmxlU3RyZWFtID0gc2hpbXMuUmVhZGFibGVTdHJlYW07XG4gICAgZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMgPSBzaGltcy5nZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucztcbiAgICBnZXREZWZhdWx0QWdlbnQgPSBzaGltcy5nZXREZWZhdWx0QWdlbnQ7XG4gICAgZmlsZUZyb21QYXRoID0gc2hpbXMuZmlsZUZyb21QYXRoO1xuICAgIGlzRnNSZWFkU3RyZWFtID0gc2hpbXMuaXNGc1JlYWRTdHJlYW07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWdpc3RyeS5tanMubWFwIiwiLyoqXG4gKiBEaXNjbGFpbWVyOiBtb2R1bGVzIGluIF9zaGltcyBhcmVuJ3QgaW50ZW5kZWQgdG8gYmUgaW1wb3J0ZWQgYnkgU0RLIHVzZXJzLlxuICovXG5leHBvcnQgY2xhc3MgTXVsdGlwYXJ0Qm9keSB7XG4gICAgY29uc3RydWN0b3IoYm9keSkge1xuICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIH1cbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiAnTXVsdGlwYXJ0Qm9keSc7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TXVsdGlwYXJ0Qm9keS5tanMubWFwIiwiaW1wb3J0IHsgTXVsdGlwYXJ0Qm9keSB9IGZyb20gXCIuL011bHRpcGFydEJvZHkubWpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UnVudGltZSh7IG1hbnVhbGx5SW1wb3J0ZWQgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVjb21tZW5kYXRpb24gPSBtYW51YWxseUltcG9ydGVkID9cbiAgICAgICAgYFlvdSBtYXkgbmVlZCB0byB1c2UgcG9seWZpbGxzYFxuICAgICAgICA6IGBBZGQgb25lIG9mIHRoZXNlIGltcG9ydHMgYmVmb3JlIHlvdXIgZmlyc3QgXFxgaW1wb3J0IOKApiBmcm9tICdvcGVuYWknXFxgOlxuLSBcXGBpbXBvcnQgJ29wZW5haS9zaGltcy9ub2RlJ1xcYCAoaWYgeW91J3JlIHJ1bm5pbmcgb24gTm9kZSlcbi0gXFxgaW1wb3J0ICdvcGVuYWkvc2hpbXMvd2ViJ1xcYCAob3RoZXJ3aXNlKVxuYDtcbiAgICBsZXQgX2ZldGNoLCBfUmVxdWVzdCwgX1Jlc3BvbnNlLCBfSGVhZGVycztcbiAgICB0cnkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIF9mZXRjaCA9IGZldGNoO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIF9SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBfUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBfSGVhZGVycyA9IEhlYWRlcnM7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRoaXMgZW52aXJvbm1lbnQgaXMgbWlzc2luZyB0aGUgZm9sbG93aW5nIFdlYiBGZXRjaCBBUEkgdHlwZTogJHtlcnJvci5tZXNzYWdlfS4gJHtyZWNvbW1lbmRhdGlvbn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogJ3dlYicsXG4gICAgICAgIGZldGNoOiBfZmV0Y2gsXG4gICAgICAgIFJlcXVlc3Q6IF9SZXF1ZXN0LFxuICAgICAgICBSZXNwb25zZTogX1Jlc3BvbnNlLFxuICAgICAgICBIZWFkZXJzOiBfSGVhZGVycyxcbiAgICAgICAgRm9ybURhdGE6IFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBGb3JtRGF0YSA6IChjbGFzcyBGb3JtRGF0YSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZpbGUgdXBsb2FkcyBhcmVuJ3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQgeWV0IGFzICdGb3JtRGF0YScgaXMgdW5kZWZpbmVkLiAke3JlY29tbWVuZGF0aW9ufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgQmxvYjogdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnID8gQmxvYiA6IChjbGFzcyBCbG9iIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZmlsZSB1cGxvYWRzIGFyZW4ndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCB5ZXQgYXMgJ0Jsb2InIGlzIHVuZGVmaW5lZC4gJHtyZWNvbW1lbmRhdGlvbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIEZpbGU6IFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyA/IEZpbGUgOiAoY2xhc3MgRmlsZSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZpbGUgdXBsb2FkcyBhcmVuJ3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQgeWV0IGFzICdGaWxlJyBpcyB1bmRlZmluZWQuICR7cmVjb21tZW5kYXRpb259YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBSZWFkYWJsZVN0cmVhbTogXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdHlwZW9mIFJlYWRhYmxlU3RyZWFtICE9PSAndW5kZWZpbmVkJyA/IFJlYWRhYmxlU3RyZWFtIDogKGNsYXNzIFJlYWRhYmxlU3RyZWFtIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3RyZWFtaW5nIGlzbid0IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50IHlldCBhcyAnUmVhZGFibGVTdHJlYW0nIGlzIHVuZGVmaW5lZC4gJHtyZWNvbW1lbmRhdGlvbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zOiBhc3luYyAoXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZm9ybSwgb3B0cykgPT4gKHtcbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICBib2R5OiBuZXcgTXVsdGlwYXJ0Qm9keShmb3JtKSxcbiAgICAgICAgfSksXG4gICAgICAgIGdldERlZmF1bHRBZ2VudDogKHVybCkgPT4gdW5kZWZpbmVkLFxuICAgICAgICBmaWxlRnJvbVBhdGg6ICgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGBmaWxlRnJvbVBhdGhgIGZ1bmN0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGluIE5vZGUuIFNlZSB0aGUgUkVBRE1FIGZvciBtb3JlIGRldGFpbHM6IGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlI2ZpbGUtdXBsb2FkcycpO1xuICAgICAgICB9LFxuICAgICAgICBpc0ZzUmVhZFN0cmVhbTogKHZhbHVlKSA9PiBmYWxzZSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViLXJ1bnRpbWUubWpzLm1hcCIsIi8qKlxuICogRGlzY2xhaW1lcjogbW9kdWxlcyBpbiBfc2hpbXMgYXJlbid0IGludGVuZGVkIHRvIGJlIGltcG9ydGVkIGJ5IFNESyB1c2Vycy5cbiAqL1xuaW1wb3J0ICogYXMgc2hpbXMgZnJvbSAnLi9yZWdpc3RyeS5tanMnO1xuaW1wb3J0ICogYXMgYXV0byBmcm9tICdvcGVuYWkvX3NoaW1zL2F1dG8vcnVudGltZSc7XG5pZiAoIXNoaW1zLmtpbmQpIHNoaW1zLnNldFNoaW1zKGF1dG8uZ2V0UnVudGltZSgpLCB7IGF1dG86IHRydWUgfSk7XG5leHBvcnQgKiBmcm9tICcuL3JlZ2lzdHJ5Lm1qcyc7XG4iLCJpbXBvcnQgeyBSZWFkYWJsZVN0cmVhbSB9IGZyb20gXCIuL19zaGltcy9pbmRleC5tanNcIjtcbmltcG9ydCB7IE9wZW5BSUVycm9yIH0gZnJvbSBcIi4vZXJyb3IubWpzXCI7XG5pbXBvcnQgeyBBUElFcnJvciB9IGZyb20gJ29wZW5haS9lcnJvcic7XG5leHBvcnQgY2xhc3MgU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVyYXRvciwgY29udHJvbGxlcikge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRlcmF0b3I7XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU1NFUmVzcG9uc2UocmVzcG9uc2UsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgbGV0IGNvbnN1bWVkID0gZmFsc2U7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBpdGVyYXRvcigpIHtcbiAgICAgICAgICAgIGlmIChjb25zdW1lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGl0ZXJhdGUgb3ZlciBhIGNvbnN1bWVkIHN0cmVhbSwgdXNlIGAudGVlKClgIHRvIHNwbGl0IHRoZSBzdHJlYW0uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdW1lZCA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHNzZSBvZiBfaXRlclNTRU1lc3NhZ2VzKHJlc3BvbnNlLCBjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3NlLmRhdGEuc3RhcnRzV2l0aCgnW0RPTkVdJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNzZS5ldmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHNzZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IHBhcnNlIG1lc3NhZ2UgaW50byBKU09OOmAsIHNzZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGcm9tIGNodW5rOmAsIHNzZS5yYXcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKHVuZGVmaW5lZCwgZGF0YS5lcnJvciwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShzc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBwYXJzZSBtZXNzYWdlIGludG8gSlNPTjpgLCBzc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRnJvbSBjaHVuazpgLCBzc2UucmF3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogSXMgdGhpcyB3aGVyZSB0aGUgZXJyb3Igc2hvdWxkIGJlIHRocm93bj9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzc2UuZXZlbnQgPT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBUElFcnJvcih1bmRlZmluZWQsIGRhdGEuZXJyb3IsIGRhdGEubWVzc2FnZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHsgZXZlbnQ6IHNzZS5ldmVudCwgZGF0YTogZGF0YSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBjYWxscyBgc3RyZWFtLmNvbnRyb2xsZXIuYWJvcnQoKWAsIHdlIHNob3VsZCBleGl0IHdpdGhvdXQgdGhyb3dpbmcuXG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm5hbWUgPT09ICdBYm9ydEVycm9yJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBgYnJlYWtgcywgYWJvcnQgdGhlIG9uZ29pbmcgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShpdGVyYXRvciwgY29udHJvbGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFN0cmVhbSBmcm9tIGEgbmV3bGluZS1zZXBhcmF0ZWQgUmVhZGFibGVTdHJlYW1cbiAgICAgKiB3aGVyZSBlYWNoIGl0ZW0gaXMgYSBKU09OIHZhbHVlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgbGV0IGNvbnN1bWVkID0gZmFsc2U7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBpdGVyTGluZXMoKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lRGVjb2RlciA9IG5ldyBMaW5lRGVjb2RlcigpO1xuICAgICAgICAgICAgY29uc3QgaXRlciA9IHJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYWJsZShyZWFkYWJsZVN0cmVhbSk7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGl0ZXIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZGVjb2RlKGNodW5rKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBsaW5lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5mbHVzaCgpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiogaXRlcmF0b3IoKSB7XG4gICAgICAgICAgICBpZiAoY29uc3VtZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpdGVyYXRlIG92ZXIgYSBjb25zdW1lZCBzdHJlYW0sIHVzZSBgLnRlZSgpYCB0byBzcGxpdCB0aGUgc3RyZWFtLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3VtZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBsaW5lIG9mIGl0ZXJMaW5lcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lKVxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgSlNPTi5wYXJzZShsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGNhbGxzIGBzdHJlYW0uY29udHJvbGxlci5hYm9ydCgpYCwgd2Ugc2hvdWxkIGV4aXQgd2l0aG91dCB0aHJvd2luZy5cbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubmFtZSA9PT0gJ0Fib3J0RXJyb3InKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGBicmVha2BzLCBhYm9ydCB0aGUgb25nb2luZyByZXF1ZXN0LlxuICAgICAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKGl0ZXJhdG9yLCBjb250cm9sbGVyKTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BsaXRzIHRoZSBzdHJlYW0gaW50byB0d28gc3RyZWFtcyB3aGljaCBjYW4gYmVcbiAgICAgKiBpbmRlcGVuZGVudGx5IHJlYWQgZnJvbSBhdCBkaWZmZXJlbnQgc3BlZWRzLlxuICAgICAqL1xuICAgIHRlZSgpIHtcbiAgICAgICAgY29uc3QgbGVmdCA9IFtdO1xuICAgICAgICBjb25zdCByaWdodCA9IFtdO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgY29uc3QgdGVlSXRlcmF0b3IgPSAocXVldWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBTdHJlYW0oKCkgPT4gdGVlSXRlcmF0b3IobGVmdCksIHRoaXMuY29udHJvbGxlciksXG4gICAgICAgICAgICBuZXcgU3RyZWFtKCgpID0+IHRlZUl0ZXJhdG9yKHJpZ2h0KSwgdGhpcy5jb250cm9sbGVyKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBzdHJlYW0gdG8gYSBuZXdsaW5lLXNlcGFyYXRlZCBSZWFkYWJsZVN0cmVhbSBvZlxuICAgICAqIEpTT04gc3RyaW5naWZpZWQgdmFsdWVzIGluIHRoZSBzdHJlYW1cbiAgICAgKiB3aGljaCBjYW4gYmUgdHVybmVkIGJhY2sgaW50byBhIFN0cmVhbSB3aXRoIGBTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKClgLlxuICAgICAqL1xuICAgIHRvUmVhZGFibGVTdHJlYW0oKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgaXRlcjtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICAgICAgICAgIGl0ZXIgPSBzZWxmW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jIHB1bGwoY3RybCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGl0ZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHJsLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmVucXVldWUoYnl0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGl0ZXIucmV0dXJuPy4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogX2l0ZXJTU0VNZXNzYWdlcyhyZXNwb25zZSwgY29udHJvbGxlcikge1xuICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgQXR0ZW1wdGVkIHRvIGl0ZXJhdGUgb3ZlciBhIHJlc3BvbnNlIHdpdGggbm8gYm9keWApO1xuICAgIH1cbiAgICBjb25zdCBzc2VEZWNvZGVyID0gbmV3IFNTRURlY29kZXIoKTtcbiAgICBjb25zdCBsaW5lRGVjb2RlciA9IG5ldyBMaW5lRGVjb2RlcigpO1xuICAgIGNvbnN0IGl0ZXIgPSByZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmFibGUocmVzcG9uc2UuYm9keSk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBzc2VDaHVuayBvZiBpdGVyU1NFQ2h1bmtzKGl0ZXIpKSB7XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5kZWNvZGUoc3NlQ2h1bmspKSB7XG4gICAgICAgICAgICBjb25zdCBzc2UgPSBzc2VEZWNvZGVyLmRlY29kZShsaW5lKTtcbiAgICAgICAgICAgIGlmIChzc2UpXG4gICAgICAgICAgICAgICAgeWllbGQgc3NlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5mbHVzaCgpKSB7XG4gICAgICAgIGNvbnN0IHNzZSA9IHNzZURlY29kZXIuZGVjb2RlKGxpbmUpO1xuICAgICAgICBpZiAoc3NlKVxuICAgICAgICAgICAgeWllbGQgc3NlO1xuICAgIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gYXN5bmMgaXRlcmFibGUgaXRlcmF0b3IsIGl0ZXJhdGVzIG92ZXIgaXQgYW5kIHlpZWxkcyBmdWxsXG4gKiBTU0UgY2h1bmtzLCBpLmUuIHlpZWxkcyB3aGVuIGEgZG91YmxlIG5ldy1saW5lIGlzIGVuY291bnRlcmVkLlxuICovXG5hc3luYyBmdW5jdGlvbiogaXRlclNTRUNodW5rcyhpdGVyYXRvcikge1xuICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgIGlmIChjaHVuayA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiaW5hcnlDaHVuayA9IGNodW5rIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgVWludDhBcnJheShjaHVuaylcbiAgICAgICAgICAgIDogdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShjaHVuaylcbiAgICAgICAgICAgICAgICA6IGNodW5rO1xuICAgICAgICBsZXQgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgYmluYXJ5Q2h1bmsubGVuZ3RoKTtcbiAgICAgICAgbmV3RGF0YS5zZXQoZGF0YSk7XG4gICAgICAgIG5ld0RhdGEuc2V0KGJpbmFyeUNodW5rLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgIGRhdGEgPSBuZXdEYXRhO1xuICAgICAgICBsZXQgcGF0dGVybkluZGV4O1xuICAgICAgICB3aGlsZSAoKHBhdHRlcm5JbmRleCA9IGZpbmREb3VibGVOZXdsaW5lSW5kZXgoZGF0YSkpICE9PSAtMSkge1xuICAgICAgICAgICAgeWllbGQgZGF0YS5zbGljZSgwLCBwYXR0ZXJuSW5kZXgpO1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UocGF0dGVybkluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHlpZWxkIGRhdGE7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZERvdWJsZU5ld2xpbmVJbmRleChidWZmZXIpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHNlYXJjaGVzIHRoZSBidWZmZXIgZm9yIHRoZSBlbmQgcGF0dGVybnMgKFxcclxcciwgXFxuXFxuLCBcXHJcXG5cXHJcXG4pXG4gICAgLy8gYW5kIHJldHVybnMgdGhlIGluZGV4IHJpZ2h0IGFmdGVyIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFueSBwYXR0ZXJuLFxuICAgIC8vIG9yIC0xIGlmIG5vbmUgb2YgdGhlIHBhdHRlcm5zIGFyZSBmb3VuZC5cbiAgICBjb25zdCBuZXdsaW5lID0gMHgwYTsgLy8gXFxuXG4gICAgY29uc3QgY2FycmlhZ2UgPSAweDBkOyAvLyBcXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gbmV3bGluZSAmJiBidWZmZXJbaSArIDFdID09PSBuZXdsaW5lKSB7XG4gICAgICAgICAgICAvLyBcXG5cXG5cbiAgICAgICAgICAgIHJldHVybiBpICsgMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyW2ldID09PSBjYXJyaWFnZSAmJiBidWZmZXJbaSArIDFdID09PSBjYXJyaWFnZSkge1xuICAgICAgICAgICAgLy8gXFxyXFxyXG4gICAgICAgICAgICByZXR1cm4gaSArIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gY2FycmlhZ2UgJiZcbiAgICAgICAgICAgIGJ1ZmZlcltpICsgMV0gPT09IG5ld2xpbmUgJiZcbiAgICAgICAgICAgIGkgKyAzIDwgYnVmZmVyLmxlbmd0aCAmJlxuICAgICAgICAgICAgYnVmZmVyW2kgKyAyXSA9PT0gY2FycmlhZ2UgJiZcbiAgICAgICAgICAgIGJ1ZmZlcltpICsgM10gPT09IG5ld2xpbmUpIHtcbiAgICAgICAgICAgIC8vIFxcclxcblxcclxcblxuICAgICAgICAgICAgcmV0dXJuIGkgKyA0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmNsYXNzIFNTRURlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmV2ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgfVxuICAgIGRlY29kZShsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmVuZHNXaXRoKCdcXHInKSkge1xuICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyaW5nKDAsIGxpbmUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBsaW5lIGFuZCB3ZSBkaWRuJ3QgcHJldmlvdXNseSBlbmNvdW50ZXIgYW55IG1lc3NhZ2VzXG4gICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnQgJiYgIXRoaXMuZGF0YS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCBzc2UgPSB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgICAgIHJhdzogdGhpcy5jaHVua3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5ldmVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgICAgICByZXR1cm4gc3NlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobGluZSk7XG4gICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJzonKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFtmaWVsZG5hbWUsIF8sIHZhbHVlXSA9IHBhcnRpdGlvbihsaW5lLCAnOicpO1xuICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnICcpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRuYW1lID09PSAnZXZlbnQnKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGRuYW1lID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vKipcbiAqIEEgcmUtaW1wbGVtZW50YXRpb24gb2YgaHR0cHgncyBgTGluZURlY29kZXJgIGluIFB5dGhvbiB0aGF0IGhhbmRsZXMgaW5jcmVtZW50YWxseVxuICogcmVhZGluZyBsaW5lcyBmcm9tIHRleHQuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2VuY29kZS9odHRweC9ibG9iLzkyMDMzM2VhOTgxMThlOWNmNjE3ZjI0NjkwNWQ3YjIwMjUxMDk0MWMvaHR0cHgvX2RlY29kZXJzLnB5I0wyNThcbiAqL1xuY2xhc3MgTGluZURlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnRyYWlsaW5nQ1IgPSBmYWxzZTtcbiAgICB9XG4gICAgZGVjb2RlKGNodW5rKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gdGhpcy5kZWNvZGVUZXh0KGNodW5rKTtcbiAgICAgICAgaWYgKHRoaXMudHJhaWxpbmdDUikge1xuICAgICAgICAgICAgdGV4dCA9ICdcXHInICsgdGV4dDtcbiAgICAgICAgICAgIHRoaXMudHJhaWxpbmdDUiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0LmVuZHNXaXRoKCdcXHInKSkge1xuICAgICAgICAgICAgdGhpcy50cmFpbGluZ0NSID0gdHJ1ZTtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFpbGluZ05ld2xpbmUgPSBMaW5lRGVjb2Rlci5ORVdMSU5FX0NIQVJTLmhhcyh0ZXh0W3RleHQubGVuZ3RoIC0gMV0gfHwgJycpO1xuICAgICAgICBsZXQgbGluZXMgPSB0ZXh0LnNwbGl0KExpbmVEZWNvZGVyLk5FV0xJTkVfUkVHRVhQKTtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSB0cmFpbGluZyBuZXcgbGluZSB0aGVuIHRoZSBsYXN0IGVudHJ5IHdpbGwgYmUgYW4gZW1wdHlcbiAgICAgICAgLy8gc3RyaW5nIHdoaWNoIHdlIGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgaWYgKHRyYWlsaW5nTmV3bGluZSkge1xuICAgICAgICAgICAgbGluZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSAmJiAhdHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGxpbmVzWzBdKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGluZXMgPSBbdGhpcy5idWZmZXIuam9pbignJykgKyBsaW5lc1swXSwgLi4ubGluZXMuc2xpY2UoMSldO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRyYWlsaW5nTmV3bGluZSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBbbGluZXMucG9wKCkgfHwgJyddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG4gICAgZGVjb2RlVGV4dChieXRlcykge1xuICAgICAgICBpZiAoYnl0ZXMgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICAgIC8vIE5vZGU6XG4gICAgICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ5dGVzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBVbmV4cGVjdGVkOiByZWNlaXZlZCBub24tVWludDhBcnJheSAoJHtieXRlcy5jb25zdHJ1Y3Rvci5uYW1lfSkgc3RyZWFtIGNodW5rIGluIGFuIGVudmlyb25tZW50IHdpdGggYSBnbG9iYWwgXCJCdWZmZXJcIiBkZWZpbmVkLCB3aGljaCB0aGlzIGxpYnJhcnkgYXNzdW1lcyB0byBiZSBOb2RlLiBQbGVhc2UgcmVwb3J0IHRoaXMgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnJvd3NlclxuICAgICAgICBpZiAodHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBieXRlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0RGVjb2RlciA/PyAodGhpcy50ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0RGVjb2Rlci5kZWNvZGUoYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBVbmV4cGVjdGVkOiByZWNlaXZlZCBub24tVWludDhBcnJheS9BcnJheUJ1ZmZlciAoJHtieXRlcy5jb25zdHJ1Y3Rvci5uYW1lfSkgaW4gYSB3ZWIgcGxhdGZvcm0uIFBsZWFzZSByZXBvcnQgdGhpcyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYFVuZXhwZWN0ZWQ6IG5laXRoZXIgQnVmZmVyIG5vciBUZXh0RGVjb2RlciBhcmUgYXZhaWxhYmxlIGFzIGdsb2JhbHMuIFBsZWFzZSByZXBvcnQgdGhpcyBlcnJvci5gKTtcbiAgICB9XG4gICAgZmx1c2goKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIubGVuZ3RoICYmICF0aGlzLnRyYWlsaW5nQ1IpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lcyA9IFt0aGlzLmJ1ZmZlci5qb2luKCcnKV07XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIHRoaXMudHJhaWxpbmdDUiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxufVxuLy8gcHJldHRpZXItaWdub3JlXG5MaW5lRGVjb2Rlci5ORVdMSU5FX0NIQVJTID0gbmV3IFNldChbJ1xcbicsICdcXHInXSk7XG5MaW5lRGVjb2Rlci5ORVdMSU5FX1JFR0VYUCA9IC9cXHJcXG58W1xcblxccl0vZztcbi8qKiBUaGlzIGlzIGFuIGludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0aGF0J3MganVzdCB1c2VkIGZvciB0ZXN0aW5nICovXG5leHBvcnQgZnVuY3Rpb24gX2RlY29kZUNodW5rcyhjaHVua3MpIHtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IExpbmVEZWNvZGVyKCk7XG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgICAgICBsaW5lcy5wdXNoKC4uLmRlY29kZXIuZGVjb2RlKGNodW5rKSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbn1cbmZ1bmN0aW9uIHBhcnRpdGlvbihzdHIsIGRlbGltaXRlcikge1xuICAgIGNvbnN0IGluZGV4ID0gc3RyLmluZGV4T2YoZGVsaW1pdGVyKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbc3RyLnN1YnN0cmluZygwLCBpbmRleCksIGRlbGltaXRlciwgc3RyLnN1YnN0cmluZyhpbmRleCArIGRlbGltaXRlci5sZW5ndGgpXTtcbiAgICB9XG4gICAgcmV0dXJuIFtzdHIsICcnLCAnJ107XG59XG4vKipcbiAqIE1vc3QgYnJvd3NlcnMgZG9uJ3QgeWV0IGhhdmUgYXN5bmMgaXRlcmFibGUgc3VwcG9ydCBmb3IgUmVhZGFibGVTdHJlYW0sXG4gKiBhbmQgTm9kZSBoYXMgYSB2ZXJ5IGRpZmZlcmVudCB3YXkgb2YgcmVhZGluZyBieXRlcyBmcm9tIGl0cyBcIlJlYWRhYmxlU3RyZWFtXCIuXG4gKlxuICogVGhpcyBwb2x5ZmlsbCB3YXMgcHVsbGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL01hdHRpYXNCdWVsZW5zL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3B1bGwvMTIyI2lzc3VlY29tbWVudC0xNjI3MzU0NDkwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmFibGUoc3RyZWFtKSB7XG4gICAgaWYgKHN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pXG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdD8uZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayB3aGVuIHN0cmVhbSBiZWNvbWVzIGNsb3NlZFxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgd2hlbiBzdHJlYW0gYmVjb21lcyBlcnJvcmVkXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgcmV0dXJuKCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgYXdhaXQgY2FuY2VsUHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgfSxcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJlYW1pbmcubWpzLm1hcCIsImltcG9ydCB7IEZvcm1EYXRhLCBGaWxlLCBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucywgaXNGc1JlYWRTdHJlYW0sIH0gZnJvbSBcIi4vX3NoaW1zL2luZGV4Lm1qc1wiO1xuZXhwb3J0IHsgZmlsZUZyb21QYXRoIH0gZnJvbSBcIi4vX3NoaW1zL2luZGV4Lm1qc1wiO1xuZXhwb3J0IGNvbnN0IGlzUmVzcG9uc2VMaWtlID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsICYmXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB2YWx1ZS51cmwgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIHZhbHVlLmJsb2IgPT09ICdmdW5jdGlvbic7XG5leHBvcnQgY29uc3QgaXNGaWxlTGlrZSA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdmFsdWUubmFtZSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgdmFsdWUubGFzdE1vZGlmaWVkID09PSAnbnVtYmVyJyAmJlxuICAgIGlzQmxvYkxpa2UodmFsdWUpO1xuLyoqXG4gKiBUaGUgQmxvYkxpa2UgdHlwZSBvbWl0cyBhcnJheUJ1ZmZlcigpIGJlY2F1c2UgQHR5cGVzL25vZGUtZmV0Y2hAXjIuNi40IGxhY2tzIGl0OyBidXQgdGhpcyBjaGVja1xuICogYWRkcyB0aGUgYXJyYXlCdWZmZXIoKSBtZXRob2QgdHlwZSBiZWNhdXNlIGl0IGlzIGF2YWlsYWJsZSBhbmQgdXNlZCBhdCBydW50aW1lXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Jsb2JMaWtlID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsICYmXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5zaXplID09PSAnbnVtYmVyJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS50eXBlID09PSAnc3RyaW5nJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS50ZXh0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbHVlLnNsaWNlID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbHVlLmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0IGNvbnN0IGlzVXBsb2FkYWJsZSA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBpc0ZpbGVMaWtlKHZhbHVlKSB8fCBpc1Jlc3BvbnNlTGlrZSh2YWx1ZSkgfHwgaXNGc1JlYWRTdHJlYW0odmFsdWUpO1xufTtcbi8qKlxuICogSGVscGVyIGZvciBjcmVhdGluZyBhIHtAbGluayBGaWxlfSB0byBwYXNzIHRvIGFuIFNESyB1cGxvYWQgbWV0aG9kIGZyb20gYSB2YXJpZXR5IG9mIGRpZmZlcmVudCBkYXRhIGZvcm1hdHNcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgcmF3IGNvbnRlbnQgb2YgdGhlIGZpbGUuICBDYW4gYmUgYW4ge0BsaW5rIFVwbG9hZGFibGV9LCB7QGxpbmsgQmxvYkxpa2VQYXJ0fSwgb3Ige0BsaW5rIEFzeW5jSXRlcmFibGV9IG9mIHtAbGluayBCbG9iTGlrZVBhcnR9c1xuICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlLiBJZiBvbWl0dGVkLCB0b0ZpbGUgd2lsbCB0cnkgdG8gZGV0ZXJtaW5lIGEgZmlsZSBuYW1lIGZyb20gYml0cyBpZiBwb3NzaWJsZVxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLnR5cGUgdGhlIE1JTUUgdHlwZSBvZiB0aGUgY29udGVudFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRpb25zLmxhc3RNb2RpZmllZCB0aGUgbGFzdCBtb2RpZmllZCB0aW1lc3RhbXBcbiAqIEByZXR1cm5zIGEge0BsaW5rIEZpbGV9IHdpdGggdGhlIGdpdmVuIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRvRmlsZSh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xuICAgIC8vIElmIGl0J3MgYSBwcm9taXNlLCByZXNvbHZlIGl0LlxuICAgIHZhbHVlID0gYXdhaXQgdmFsdWU7XG4gICAgLy8gVXNlIHRoZSBmaWxlJ3Mgb3B0aW9ucyBpZiB0aGVyZSBpc24ndCBvbmUgcHJvdmlkZWRcbiAgICBvcHRpb25zID8/IChvcHRpb25zID0gaXNGaWxlTGlrZSh2YWx1ZSkgPyB7IGxhc3RNb2RpZmllZDogdmFsdWUubGFzdE1vZGlmaWVkLCB0eXBlOiB2YWx1ZS50eXBlIH0gOiB7fSk7XG4gICAgaWYgKGlzUmVzcG9uc2VMaWtlKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgdmFsdWUuYmxvYigpO1xuICAgICAgICBuYW1lIHx8IChuYW1lID0gbmV3IFVSTCh2YWx1ZS51cmwpLnBhdGhuYW1lLnNwbGl0KC9bXFxcXC9dLykucG9wKCkgPz8gJ3Vua25vd25fZmlsZScpO1xuICAgICAgICByZXR1cm4gbmV3IEZpbGUoW2Jsb2JdLCBuYW1lLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgYml0cyA9IGF3YWl0IGdldEJ5dGVzKHZhbHVlKTtcbiAgICBuYW1lIHx8IChuYW1lID0gZ2V0TmFtZSh2YWx1ZSkgPz8gJ3Vua25vd25fZmlsZScpO1xuICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBiaXRzWzBdPy50eXBlO1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCB0eXBlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGaWxlKGJpdHMsIG5hbWUsIG9wdGlvbnMpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0Qnl0ZXModmFsdWUpIHtcbiAgICBsZXQgcGFydHMgPSBbXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpIHx8IC8vIGluY2x1ZGVzIFVpbnQ4QXJyYXksIEJ1ZmZlciwgZXRjLlxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHBhcnRzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Jsb2JMaWtlKHZhbHVlKSkge1xuICAgICAgICBwYXJ0cy5wdXNoKGF3YWl0IHZhbHVlLmFycmF5QnVmZmVyKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FzeW5jSXRlcmFibGVJdGVyYXRvcih2YWx1ZSkgLy8gaW5jbHVkZXMgUmVhZGFibGUsIFJlYWRhYmxlU3RyZWFtLCBldGMuXG4gICAgKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goY2h1bmspOyAvLyBUT0RPLCBjb25zaWRlciB2YWxpZGF0aW5nP1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZGF0YSB0eXBlOiAke3R5cGVvZiB2YWx1ZX07IGNvbnN0cnVjdG9yOiAke3ZhbHVlPy5jb25zdHJ1Y3RvclxuICAgICAgICAgICAgPy5uYW1lfTsgcHJvcHM6ICR7cHJvcHNGb3JFcnJvcih2YWx1ZSl9YCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cztcbn1cbmZ1bmN0aW9uIHByb3BzRm9yRXJyb3IodmFsdWUpIHtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgICByZXR1cm4gYFske3Byb3BzLm1hcCgocCkgPT4gYFwiJHtwfVwiYCkuam9pbignLCAnKX1dYDtcbn1cbmZ1bmN0aW9uIGdldE5hbWUodmFsdWUpIHtcbiAgICByZXR1cm4gKGdldFN0cmluZ0Zyb21NYXliZUJ1ZmZlcih2YWx1ZS5uYW1lKSB8fFxuICAgICAgICBnZXRTdHJpbmdGcm9tTWF5YmVCdWZmZXIodmFsdWUuZmlsZW5hbWUpIHx8XG4gICAgICAgIC8vIEZvciBmcy5SZWFkU3RyZWFtXG4gICAgICAgIGdldFN0cmluZ0Zyb21NYXliZUJ1ZmZlcih2YWx1ZS5wYXRoKT8uc3BsaXQoL1tcXFxcL10vKS5wb3AoKSk7XG59XG5jb25zdCBnZXRTdHJpbmdGcm9tTWF5YmVCdWZmZXIgPSAoeCkgPT4ge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB4O1xuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgQnVmZmVyKVxuICAgICAgICByZXR1cm4gU3RyaW5nKHgpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuY29uc3QgaXNBc3luY0l0ZXJhYmxlSXRlcmF0b3IgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0IGNvbnN0IGlzTXVsdGlwYXJ0Qm9keSA9IChib2R5KSA9PiBib2R5ICYmIHR5cGVvZiBib2R5ID09PSAnb2JqZWN0JyAmJiBib2R5LmJvZHkgJiYgYm9keVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTXVsdGlwYXJ0Qm9keSc7XG4vKipcbiAqIFJldHVybnMgYSBtdWx0aXBhcnQvZm9ybS1kYXRhIHJlcXVlc3QgaWYgYW55IHBhcnQgb2YgdGhlIGdpdmVuIHJlcXVlc3QgYm9keSBjb250YWlucyBhIEZpbGUgLyBCbG9iIHZhbHVlLlxuICogT3RoZXJ3aXNlIHJldHVybnMgdGhlIHJlcXVlc3QgYXMgaXMuXG4gKi9cbmV4cG9ydCBjb25zdCBtYXliZU11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyA9IGFzeW5jIChvcHRzKSA9PiB7XG4gICAgaWYgKCFoYXNVcGxvYWRhYmxlVmFsdWUob3B0cy5ib2R5KSlcbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgY29uc3QgZm9ybSA9IGF3YWl0IGNyZWF0ZUZvcm0ob3B0cy5ib2R5KTtcbiAgICByZXR1cm4gZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMoZm9ybSwgb3B0cyk7XG59O1xuZXhwb3J0IGNvbnN0IG11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyA9IGFzeW5jIChvcHRzKSA9PiB7XG4gICAgY29uc3QgZm9ybSA9IGF3YWl0IGNyZWF0ZUZvcm0ob3B0cy5ib2R5KTtcbiAgICByZXR1cm4gZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMoZm9ybSwgb3B0cyk7XG59O1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUZvcm0gPSBhc3luYyAoYm9keSkgPT4ge1xuICAgIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyhib2R5IHx8IHt9KS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYWRkRm9ybVZhbHVlKGZvcm0sIGtleSwgdmFsdWUpKSk7XG4gICAgcmV0dXJuIGZvcm07XG59O1xuY29uc3QgaGFzVXBsb2FkYWJsZVZhbHVlID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKGlzVXBsb2FkYWJsZSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNvbWUoaGFzVXBsb2FkYWJsZVZhbHVlKTtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChoYXNVcGxvYWRhYmxlVmFsdWUodmFsdWVba10pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBhZGRGb3JtVmFsdWUgPSBhc3luYyAoZm9ybSwga2V5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUmVjZWl2ZWQgbnVsbCBmb3IgXCIke2tleX1cIjsgdG8gcGFzcyBudWxsIGluIEZvcm1EYXRhLCB5b3UgbXVzdCB1c2UgdGhlIHN0cmluZyAnbnVsbCdgKTtcbiAgICB9XG4gICAgLy8gVE9ETzogbWFrZSBuZXN0ZWQgZm9ybWF0cyBjb25maWd1cmFibGVcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGZvcm0uYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzVXBsb2FkYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IHRvRmlsZSh2YWx1ZSk7XG4gICAgICAgIGZvcm0uYXBwZW5kKGtleSwgZmlsZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHZhbHVlLm1hcCgoZW50cnkpID0+IGFkZEZvcm1WYWx1ZShmb3JtLCBrZXkgKyAnW10nLCBlbnRyeSkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyh2YWx1ZSkubWFwKChbbmFtZSwgcHJvcF0pID0+IGFkZEZvcm1WYWx1ZShmb3JtLCBgJHtrZXl9WyR7bmFtZX1dYCwgcHJvcCkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgdmFsdWUgZ2l2ZW4gdG8gZm9ybSwgZXhwZWN0ZWQgYSBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb2JqZWN0LCBBcnJheSwgRmlsZSBvciBCbG9iIGJ1dCBnb3QgJHt2YWx1ZX0gaW5zdGVhZGApO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cGxvYWRzLm1qcy5tYXAiLCJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0Fic3RyYWN0UGFnZV9jbGllbnQ7XG5pbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSBcIi4vdmVyc2lvbi5tanNcIjtcbmltcG9ydCB7IFN0cmVhbSB9IGZyb20gXCIuL3N0cmVhbWluZy5tanNcIjtcbmltcG9ydCB7IE9wZW5BSUVycm9yLCBBUElFcnJvciwgQVBJQ29ubmVjdGlvbkVycm9yLCBBUElDb25uZWN0aW9uVGltZW91dEVycm9yLCBBUElVc2VyQWJvcnRFcnJvciwgfSBmcm9tIFwiLi9lcnJvci5tanNcIjtcbmltcG9ydCB7IGtpbmQgYXMgc2hpbXNLaW5kLCBnZXREZWZhdWx0QWdlbnQsIGZldGNoLCB9IGZyb20gXCIuL19zaGltcy9pbmRleC5tanNcIjtcbmltcG9ydCB7IGlzQmxvYkxpa2UsIGlzTXVsdGlwYXJ0Qm9keSB9IGZyb20gXCIuL3VwbG9hZHMubWpzXCI7XG5leHBvcnQgeyBtYXliZU11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucywgbXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zLCBjcmVhdGVGb3JtLCB9IGZyb20gXCIuL3VwbG9hZHMubWpzXCI7XG5hc3luYyBmdW5jdGlvbiBkZWZhdWx0UGFyc2VSZXNwb25zZShwcm9wcykge1xuICAgIGNvbnN0IHsgcmVzcG9uc2UgfSA9IHByb3BzO1xuICAgIGlmIChwcm9wcy5vcHRpb25zLnN0cmVhbSkge1xuICAgICAgICBkZWJ1ZygncmVzcG9uc2UnLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnVybCwgcmVzcG9uc2UuaGVhZGVycywgcmVzcG9uc2UuYm9keSk7XG4gICAgICAgIC8vIE5vdGU6IHRoZXJlIGlzIGFuIGludmFyaWFudCBoZXJlIHRoYXQgaXNuJ3QgcmVwcmVzZW50ZWQgaW4gdGhlIHR5cGUgc3lzdGVtXG4gICAgICAgIC8vIHRoYXQgaWYgeW91IHNldCBgc3RyZWFtOiB0cnVlYCB0aGUgcmVzcG9uc2UgdHlwZSBtdXN0IGFsc28gYmUgYFN0cmVhbTxUPmBcbiAgICAgICAgaWYgKHByb3BzLm9wdGlvbnMuX19zdHJlYW1DbGFzcykge1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLm9wdGlvbnMuX19zdHJlYW1DbGFzcy5mcm9tU1NFUmVzcG9uc2UocmVzcG9uc2UsIHByb3BzLmNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJlYW0uZnJvbVNTRVJlc3BvbnNlKHJlc3BvbnNlLCBwcm9wcy5jb250cm9sbGVyKTtcbiAgICB9XG4gICAgLy8gZmV0Y2ggcmVmdXNlcyB0byByZWFkIHRoZSBib2R5IHdoZW4gdGhlIHN0YXR1cyBjb2RlIGlzIDIwNC5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwcm9wcy5vcHRpb25zLl9fYmluYXJ5UmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICBjb25zdCBpc0pTT04gPSBjb250ZW50VHlwZT8uaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSB8fCBjb250ZW50VHlwZT8uaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL3ZuZC5hcGkranNvbicpO1xuICAgIGlmIChpc0pTT04pIHtcbiAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgZGVidWcoJ3Jlc3BvbnNlJywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS51cmwsIHJlc3BvbnNlLmhlYWRlcnMsIGpzb24pO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICBkZWJ1ZygncmVzcG9uc2UnLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnVybCwgcmVzcG9uc2UuaGVhZGVycywgdGV4dCk7XG4gICAgLy8gVE9ETyBoYW5kbGUgYmxvYiwgYXJyYXlidWZmZXIsIG90aGVyIGNvbnRlbnQgdHlwZXMsIGV0Yy5cbiAgICByZXR1cm4gdGV4dDtcbn1cbi8qKlxuICogQSBzdWJjbGFzcyBvZiBgUHJvbWlzZWAgcHJvdmlkaW5nIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHNcbiAqIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBTREsuXG4gKi9cbmV4cG9ydCBjbGFzcyBBUElQcm9taXNlIGV4dGVuZHMgUHJvbWlzZSB7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2VQcm9taXNlLCBwYXJzZVJlc3BvbnNlID0gZGVmYXVsdFBhcnNlUmVzcG9uc2UpIHtcbiAgICAgICAgc3VwZXIoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbWF5YmUgYSBiaXQgd2VpcmQgYnV0IHRoaXMgaGFzIHRvIGJlIGEgbm8tb3AgdG8gbm90IGltcGxpY2l0bHlcbiAgICAgICAgICAgIC8vIHBhcnNlIHRoZSByZXNwb25zZSBib2R5OyBpbnN0ZWFkIC50aGVuLCAuY2F0Y2gsIC5maW5hbGx5IGFyZSBvdmVycmlkZGVuXG4gICAgICAgICAgICAvLyB0byBwYXJzZSB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlc3BvbnNlUHJvbWlzZSA9IHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgdGhpcy5wYXJzZVJlc3BvbnNlID0gcGFyc2VSZXNwb25zZTtcbiAgICB9XG4gICAgX3RoZW5VbndyYXAodHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiBuZXcgQVBJUHJvbWlzZSh0aGlzLnJlc3BvbnNlUHJvbWlzZSwgYXN5bmMgKHByb3BzKSA9PiB0cmFuc2Zvcm0oYXdhaXQgdGhpcy5wYXJzZVJlc3BvbnNlKHByb3BzKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByYXcgYFJlc3BvbnNlYCBpbnN0YW5jZSBpbnN0ZWFkIG9mIHBhcnNpbmcgdGhlIHJlc3BvbnNlXG4gICAgICogZGF0YS5cbiAgICAgKlxuICAgICAqIElmIHlvdSB3YW50IHRvIHBhcnNlIHRoZSByZXNwb25zZSBib2R5IGJ1dCBzdGlsbCBnZXQgdGhlIGBSZXNwb25zZWBcbiAgICAgKiBpbnN0YW5jZSwgeW91IGNhbiB1c2Uge0BsaW5rIHdpdGhSZXNwb25zZSgpfS5cbiAgICAgKlxuICAgICAqIPCfkYsgR2V0dGluZyB0aGUgd3JvbmcgVHlwZVNjcmlwdCB0eXBlIGZvciBgUmVzcG9uc2VgP1xuICAgICAqIFRyeSBzZXR0aW5nIGBcIm1vZHVsZVJlc29sdXRpb25cIjogXCJOb2RlTmV4dFwiYCBpZiB5b3UgY2FuLFxuICAgICAqIG9yIGFkZCBvbmUgb2YgdGhlc2UgaW1wb3J0cyBiZWZvcmUgeW91ciBmaXJzdCBgaW1wb3J0IOKApiBmcm9tICdvcGVuYWknYDpcbiAgICAgKiAtIGBpbXBvcnQgJ29wZW5haS9zaGltcy9ub2RlJ2AgKGlmIHlvdSdyZSBydW5uaW5nIG9uIE5vZGUpXG4gICAgICogLSBgaW1wb3J0ICdvcGVuYWkvc2hpbXMvd2ViJ2AgKG90aGVyd2lzZSlcbiAgICAgKi9cbiAgICBhc1Jlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZVByb21pc2UudGhlbigocCkgPT4gcC5yZXNwb25zZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBhcnNlZCByZXNwb25zZSBkYXRhIGFuZCB0aGUgcmF3IGBSZXNwb25zZWAgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBJZiB5b3UganVzdCB3YW50IHRvIGdldCB0aGUgcmF3IGBSZXNwb25zZWAgaW5zdGFuY2Ugd2l0aG91dCBwYXJzaW5nIGl0LFxuICAgICAqIHlvdSBjYW4gdXNlIHtAbGluayBhc1Jlc3BvbnNlKCl9LlxuICAgICAqXG4gICAgICpcbiAgICAgKiDwn5GLIEdldHRpbmcgdGhlIHdyb25nIFR5cGVTY3JpcHQgdHlwZSBmb3IgYFJlc3BvbnNlYD9cbiAgICAgKiBUcnkgc2V0dGluZyBgXCJtb2R1bGVSZXNvbHV0aW9uXCI6IFwiTm9kZU5leHRcImAgaWYgeW91IGNhbixcbiAgICAgKiBvciBhZGQgb25lIG9mIHRoZXNlIGltcG9ydHMgYmVmb3JlIHlvdXIgZmlyc3QgYGltcG9ydCDigKYgZnJvbSAnb3BlbmFpJ2A6XG4gICAgICogLSBgaW1wb3J0ICdvcGVuYWkvc2hpbXMvbm9kZSdgIChpZiB5b3UncmUgcnVubmluZyBvbiBOb2RlKVxuICAgICAqIC0gYGltcG9ydCAnb3BlbmFpL3NoaW1zL3dlYidgIChvdGhlcndpc2UpXG4gICAgICovXG4gICAgYXN5bmMgd2l0aFJlc3BvbnNlKCkge1xuICAgICAgICBjb25zdCBbZGF0YSwgcmVzcG9uc2VdID0gYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMucGFyc2UoKSwgdGhpcy5hc1Jlc3BvbnNlKCldKTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YSwgcmVzcG9uc2UgfTtcbiAgICB9XG4gICAgcGFyc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJzZWRQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFByb21pc2UgPSB0aGlzLnJlc3BvbnNlUHJvbWlzZS50aGVuKHRoaXMucGFyc2VSZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkUHJvbWlzZTtcbiAgICB9XG4gICAgdGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZSgpLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xuICAgIH1cbiAgICBjYXRjaChvbnJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlKCkuY2F0Y2gob25yZWplY3RlZCk7XG4gICAgfVxuICAgIGZpbmFsbHkob25maW5hbGx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlKCkuZmluYWxseShvbmZpbmFsbHkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBUElDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHsgYmFzZVVSTCwgbWF4UmV0cmllcyA9IDIsIHRpbWVvdXQgPSA2MDAwMDAsIC8vIDEwIG1pbnV0ZXNcbiAgICBodHRwQWdlbnQsIGZldGNoOiBvdmVycmlkZW5GZXRjaCwgfSkge1xuICAgICAgICB0aGlzLmJhc2VVUkwgPSBiYXNlVVJMO1xuICAgICAgICB0aGlzLm1heFJldHJpZXMgPSB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcignbWF4UmV0cmllcycsIG1heFJldHJpZXMpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcigndGltZW91dCcsIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLmh0dHBBZ2VudCA9IGh0dHBBZ2VudDtcbiAgICAgICAgdGhpcy5mZXRjaCA9IG92ZXJyaWRlbkZldGNoID8/IGZldGNoO1xuICAgIH1cbiAgICBhdXRoSGVhZGVycyhvcHRzKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyB0byBhZGQgeW91ciBvd24gZGVmYXVsdCBoZWFkZXJzLCBmb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqICB7XG4gICAgICogICAgLi4uc3VwZXIuZGVmYXVsdEhlYWRlcnMoKSxcbiAgICAgKiAgICBBdXRob3JpemF0aW9uOiAnQmVhcmVyIDEyMycsXG4gICAgICogIH1cbiAgICAgKi9cbiAgICBkZWZhdWx0SGVhZGVycyhvcHRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnVXNlci1BZ2VudCc6IHRoaXMuZ2V0VXNlckFnZW50KCksXG4gICAgICAgICAgICAuLi5nZXRQbGF0Zm9ybUhlYWRlcnMoKSxcbiAgICAgICAgICAgIC4uLnRoaXMuYXV0aEhlYWRlcnMob3B0cyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgdG8gYWRkIHlvdXIgb3duIGhlYWRlcnMgdmFsaWRhdGlvbjpcbiAgICAgKi9cbiAgICB2YWxpZGF0ZUhlYWRlcnMoaGVhZGVycywgY3VzdG9tSGVhZGVycykgeyB9XG4gICAgZGVmYXVsdElkZW1wb3RlbmN5S2V5KCkge1xuICAgICAgICByZXR1cm4gYHN0YWlubGVzcy1ub2RlLXJldHJ5LSR7dXVpZDQoKX1gO1xuICAgIH1cbiAgICBnZXQocGF0aCwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdnZXQnLCBwYXRoLCBvcHRzKTtcbiAgICB9XG4gICAgcG9zdChwYXRoLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoJ3Bvc3QnLCBwYXRoLCBvcHRzKTtcbiAgICB9XG4gICAgcGF0Y2gocGF0aCwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwYXRjaCcsIHBhdGgsIG9wdHMpO1xuICAgIH1cbiAgICBwdXQocGF0aCwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwdXQnLCBwYXRoLCBvcHRzKTtcbiAgICB9XG4gICAgZGVsZXRlKHBhdGgsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0aG9kUmVxdWVzdCgnZGVsZXRlJywgcGF0aCwgb3B0cyk7XG4gICAgfVxuICAgIG1ldGhvZFJlcXVlc3QobWV0aG9kLCBwYXRoLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoUHJvbWlzZS5yZXNvbHZlKG9wdHMpLnRoZW4oYXN5bmMgKG9wdHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBvcHRzICYmIGlzQmxvYkxpa2Uob3B0cz8uYm9keSkgPyBuZXcgRGF0YVZpZXcoYXdhaXQgb3B0cy5ib2R5LmFycmF5QnVmZmVyKCkpXG4gICAgICAgICAgICAgICAgOiBvcHRzPy5ib2R5IGluc3RhbmNlb2YgRGF0YVZpZXcgPyBvcHRzLmJvZHlcbiAgICAgICAgICAgICAgICAgICAgOiBvcHRzPy5ib2R5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgRGF0YVZpZXcob3B0cy5ib2R5KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvcHRzICYmIEFycmF5QnVmZmVyLmlzVmlldyhvcHRzPy5ib2R5KSA/IG5ldyBEYXRhVmlldyhvcHRzLmJvZHkuYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogb3B0cz8uYm9keTtcbiAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZCwgcGF0aCwgLi4ub3B0cywgYm9keSB9O1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGdldEFQSUxpc3QocGF0aCwgUGFnZSwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QVBJTGlzdChQYWdlLCB7IG1ldGhvZDogJ2dldCcsIHBhdGgsIC4uLm9wdHMgfSk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZUNvbnRlbnRMZW5ndGgoYm9keSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoYm9keSwgJ3V0ZjgnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZXIuZW5jb2RlKGJvZHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVkLmxlbmd0aC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhib2R5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGJvZHkuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBidWlsZFJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IG1ldGhvZCwgcGF0aCwgcXVlcnksIGhlYWRlcnM6IGhlYWRlcnMgPSB7fSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgYm9keSA9IEFycmF5QnVmZmVyLmlzVmlldyhvcHRpb25zLmJvZHkpIHx8IChvcHRpb25zLl9fYmluYXJ5UmVxdWVzdCAmJiB0eXBlb2Ygb3B0aW9ucy5ib2R5ID09PSAnc3RyaW5nJykgP1xuICAgICAgICAgICAgb3B0aW9ucy5ib2R5XG4gICAgICAgICAgICA6IGlzTXVsdGlwYXJ0Qm9keShvcHRpb25zLmJvZHkpID8gb3B0aW9ucy5ib2R5LmJvZHlcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMuYm9keSA/IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9keSwgbnVsbCwgMilcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gdGhpcy5jYWxjdWxhdGVDb250ZW50TGVuZ3RoKGJvZHkpO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmJ1aWxkVVJMKHBhdGgsIHF1ZXJ5KTtcbiAgICAgICAgaWYgKCd0aW1lb3V0JyBpbiBvcHRpb25zKVxuICAgICAgICAgICAgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoJ3RpbWVvdXQnLCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0ID8/IHRoaXMudGltZW91dDtcbiAgICAgICAgY29uc3QgaHR0cEFnZW50ID0gb3B0aW9ucy5odHRwQWdlbnQgPz8gdGhpcy5odHRwQWdlbnQgPz8gZ2V0RGVmYXVsdEFnZW50KHVybCk7XG4gICAgICAgIGNvbnN0IG1pbkFnZW50VGltZW91dCA9IHRpbWVvdXQgKyAxMDAwO1xuICAgICAgICBpZiAodHlwZW9mIGh0dHBBZ2VudD8ub3B0aW9ucz8udGltZW91dCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIG1pbkFnZW50VGltZW91dCA+IChodHRwQWdlbnQub3B0aW9ucy50aW1lb3V0ID8/IDApKSB7XG4gICAgICAgICAgICAvLyBBbGxvdyBhbnkgZ2l2ZW4gcmVxdWVzdCB0byBidW1wIG91ciBhZ2VudCBhY3RpdmUgc29ja2V0IHRpbWVvdXQuXG4gICAgICAgICAgICAvLyBUaGlzIG1heSBzZWVtIHN0cmFuZ2UsIGJ1dCBsZWFraW5nIGFjdGl2ZSBzb2NrZXRzIHNob3VsZCBiZSByYXJlIGFuZCBub3QgcGFydGljdWxhcmx5IHByb2JsZW1hdGljLFxuICAgICAgICAgICAgLy8gYW5kIHdpdGhvdXQgbXV0YXRpbmcgYWdlbnQgd2Ugd291bGQgbmVlZCB0byBjcmVhdGUgbW9yZSBvZiB0aGVtLlxuICAgICAgICAgICAgLy8gVGhpcyB0cmFkZW9mZiBvcHRpbWl6ZXMgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgICAgICAgaHR0cEFnZW50Lm9wdGlvbnMudGltZW91dCA9IG1pbkFnZW50VGltZW91dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pZGVtcG90ZW5jeUhlYWRlciAmJiBtZXRob2QgIT09ICdnZXQnKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuaWRlbXBvdGVuY3lLZXkpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5pZGVtcG90ZW5jeUtleSA9IHRoaXMuZGVmYXVsdElkZW1wb3RlbmN5S2V5KCk7XG4gICAgICAgICAgICBoZWFkZXJzW3RoaXMuaWRlbXBvdGVuY3lIZWFkZXJdID0gb3B0aW9ucy5pZGVtcG90ZW5jeUtleTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXFIZWFkZXJzID0gdGhpcy5idWlsZEhlYWRlcnMoeyBvcHRpb25zLCBoZWFkZXJzLCBjb250ZW50TGVuZ3RoIH0pO1xuICAgICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAuLi4oYm9keSAmJiB7IGJvZHk6IGJvZHkgfSksXG4gICAgICAgICAgICBoZWFkZXJzOiByZXFIZWFkZXJzLFxuICAgICAgICAgICAgLi4uKGh0dHBBZ2VudCAmJiB7IGFnZW50OiBodHRwQWdlbnQgfSksXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIG5vZGUtZmV0Y2ggdXNlcyBhIGN1c3RvbSBBYm9ydFNpZ25hbCB0eXBlIHRoYXQgaXNcbiAgICAgICAgICAgIC8vIG5vdCBjb21wYXRpYmxlIHdpdGggc3RhbmRhcmQgd2ViIHR5cGVzXG4gICAgICAgICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsID8/IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IHJlcSwgdXJsLCB0aW1lb3V0IH07XG4gICAgfVxuICAgIGJ1aWxkSGVhZGVycyh7IG9wdGlvbnMsIGhlYWRlcnMsIGNvbnRlbnRMZW5ndGgsIH0pIHtcbiAgICAgICAgY29uc3QgcmVxSGVhZGVycyA9IHt9O1xuICAgICAgICBpZiAoY29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgcmVxSGVhZGVyc1snY29udGVudC1sZW5ndGgnXSA9IGNvbnRlbnRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmYXVsdEhlYWRlcnMgPSB0aGlzLmRlZmF1bHRIZWFkZXJzKG9wdGlvbnMpO1xuICAgICAgICBhcHBseUhlYWRlcnNNdXQocmVxSGVhZGVycywgZGVmYXVsdEhlYWRlcnMpO1xuICAgICAgICBhcHBseUhlYWRlcnNNdXQocmVxSGVhZGVycywgaGVhZGVycyk7XG4gICAgICAgIC8vIGxldCBidWlsdGluIGZldGNoIHNldCB0aGUgQ29udGVudC1UeXBlIGZvciBtdWx0aXBhcnQgYm9kaWVzXG4gICAgICAgIGlmIChpc011bHRpcGFydEJvZHkob3B0aW9ucy5ib2R5KSAmJiBzaGltc0tpbmQgIT09ICdub2RlJykge1xuICAgICAgICAgICAgZGVsZXRlIHJlcUhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsaWRhdGVIZWFkZXJzKHJlcUhlYWRlcnMsIGhlYWRlcnMpO1xuICAgICAgICByZXR1cm4gcmVxSGVhZGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCBhcyBhIGNhbGxiYWNrIGZvciBtdXRhdGluZyB0aGUgZ2l2ZW4gYEZpbmFsUmVxdWVzdE9wdGlvbnNgIG9iamVjdC5cbiAgICAgKi9cbiAgICBhc3luYyBwcmVwYXJlT3B0aW9ucyhvcHRpb25zKSB7IH1cbiAgICAvKipcbiAgICAgKiBVc2VkIGFzIGEgY2FsbGJhY2sgZm9yIG11dGF0aW5nIHRoZSBnaXZlbiBgUmVxdWVzdEluaXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGZvciBjYXNlcyB3aGVyZSB5b3Ugd2FudCB0byBhZGQgY2VydGFpbiBoZWFkZXJzIGJhc2VkIG9mZiBvZlxuICAgICAqIHRoZSByZXF1ZXN0IHByb3BlcnRpZXMsIGUuZy4gYG1ldGhvZGAgb3IgYHVybGAuXG4gICAgICovXG4gICAgYXN5bmMgcHJlcGFyZVJlcXVlc3QocmVxdWVzdCwgeyB1cmwsIG9wdGlvbnMgfSkgeyB9XG4gICAgcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuICghaGVhZGVycyA/IHt9XG4gICAgICAgICAgICA6IFN5bWJvbC5pdGVyYXRvciBpbiBoZWFkZXJzID9cbiAgICAgICAgICAgICAgICBPYmplY3QuZnJvbUVudHJpZXMoQXJyYXkuZnJvbShoZWFkZXJzKS5tYXAoKGhlYWRlcikgPT4gWy4uLmhlYWRlcl0pKVxuICAgICAgICAgICAgICAgIDogeyAuLi5oZWFkZXJzIH0pO1xuICAgIH1cbiAgICBtYWtlU3RhdHVzRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycykge1xuICAgICAgICByZXR1cm4gQVBJRXJyb3IuZ2VuZXJhdGUoc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuICAgIHJlcXVlc3Qob3B0aW9ucywgcmVtYWluaW5nUmV0cmllcyA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBUElQcm9taXNlKHRoaXMubWFrZVJlcXVlc3Qob3B0aW9ucywgcmVtYWluaW5nUmV0cmllcykpO1xuICAgIH1cbiAgICBhc3luYyBtYWtlUmVxdWVzdChvcHRpb25zSW5wdXQsIHJldHJpZXNSZW1haW5pbmcpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IG9wdGlvbnNJbnB1dDtcbiAgICAgICAgaWYgKHJldHJpZXNSZW1haW5pbmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0cmllc1JlbWFpbmluZyA9IG9wdGlvbnMubWF4UmV0cmllcyA/PyB0aGlzLm1heFJldHJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5wcmVwYXJlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyByZXEsIHVybCwgdGltZW91dCB9ID0gdGhpcy5idWlsZFJlcXVlc3Qob3B0aW9ucyk7XG4gICAgICAgIGF3YWl0IHRoaXMucHJlcGFyZVJlcXVlc3QocmVxLCB7IHVybCwgb3B0aW9ucyB9KTtcbiAgICAgICAgZGVidWcoJ3JlcXVlc3QnLCB1cmwsIG9wdGlvbnMsIHJlcS5oZWFkZXJzKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hXaXRoVGltZW91dCh1cmwsIHJlcSwgdGltZW91dCwgY29udHJvbGxlcikuY2F0Y2goY2FzdFRvRXJyb3IpO1xuICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV0cmllc1JlbWFpbmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChvcHRpb25zLCByZXRyaWVzUmVtYWluaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEFQSUNvbm5lY3Rpb25FcnJvcih7IGNhdXNlOiByZXNwb25zZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBjcmVhdGVSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGlmIChyZXRyaWVzUmVtYWluaW5nICYmIHRoaXMuc2hvdWxkUmV0cnkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlNZXNzYWdlID0gYHJldHJ5aW5nLCAke3JldHJpZXNSZW1haW5pbmd9IGF0dGVtcHRzIHJlbWFpbmluZ2A7XG4gICAgICAgICAgICAgICAgZGVidWcoYHJlc3BvbnNlIChlcnJvcjsgJHtyZXRyeU1lc3NhZ2V9KWAsIHJlc3BvbnNlLnN0YXR1cywgdXJsLCByZXNwb25zZUhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChvcHRpb25zLCByZXRyaWVzUmVtYWluaW5nLCByZXNwb25zZUhlYWRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXJyVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoZSkgPT4gY2FzdFRvRXJyb3IoZSkubWVzc2FnZSk7XG4gICAgICAgICAgICBjb25zdCBlcnJKU09OID0gc2FmZUpTT04oZXJyVGV4dCk7XG4gICAgICAgICAgICBjb25zdCBlcnJNZXNzYWdlID0gZXJySlNPTiA/IHVuZGVmaW5lZCA6IGVyclRleHQ7XG4gICAgICAgICAgICBjb25zdCByZXRyeU1lc3NhZ2UgPSByZXRyaWVzUmVtYWluaW5nID8gYChlcnJvcjsgbm8gbW9yZSByZXRyaWVzIGxlZnQpYCA6IGAoZXJyb3I7IG5vdCByZXRyeWFibGUpYDtcbiAgICAgICAgICAgIGRlYnVnKGByZXNwb25zZSAoZXJyb3I7ICR7cmV0cnlNZXNzYWdlfSlgLCByZXNwb25zZS5zdGF0dXMsIHVybCwgcmVzcG9uc2VIZWFkZXJzLCBlcnJNZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMubWFrZVN0YXR1c0Vycm9yKHJlc3BvbnNlLnN0YXR1cywgZXJySlNPTiwgZXJyTWVzc2FnZSwgcmVzcG9uc2VIZWFkZXJzKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByZXNwb25zZSwgb3B0aW9ucywgY29udHJvbGxlciB9O1xuICAgIH1cbiAgICByZXF1ZXN0QVBJTGlzdChQYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLm1ha2VSZXF1ZXN0KG9wdGlvbnMsIG51bGwpO1xuICAgICAgICByZXR1cm4gbmV3IFBhZ2VQcm9taXNlKHRoaXMsIHJlcXVlc3QsIFBhZ2UpO1xuICAgIH1cbiAgICBidWlsZFVSTChwYXRoLCBxdWVyeSkge1xuICAgICAgICBjb25zdCB1cmwgPSBpc0Fic29sdXRlVVJMKHBhdGgpID9cbiAgICAgICAgICAgIG5ldyBVUkwocGF0aClcbiAgICAgICAgICAgIDogbmV3IFVSTCh0aGlzLmJhc2VVUkwgKyAodGhpcy5iYXNlVVJMLmVuZHNXaXRoKCcvJykgJiYgcGF0aC5zdGFydHNXaXRoKCcvJykgPyBwYXRoLnNsaWNlKDEpIDogcGF0aCkpO1xuICAgICAgICBjb25zdCBkZWZhdWx0UXVlcnkgPSB0aGlzLmRlZmF1bHRRdWVyeSgpO1xuICAgICAgICBpZiAoIWlzRW1wdHlPYmooZGVmYXVsdFF1ZXJ5KSkge1xuICAgICAgICAgICAgcXVlcnkgPSB7IC4uLmRlZmF1bHRRdWVyeSwgLi4ucXVlcnkgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0JyAmJiBxdWVyeSAmJiAhQXJyYXkuaXNBcnJheShxdWVyeSkpIHtcbiAgICAgICAgICAgIHVybC5zZWFyY2ggPSB0aGlzLnN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhxdWVyeSlcbiAgICAgICAgICAgIC5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfT1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBDYW5ub3Qgc3RyaW5naWZ5IHR5cGUgJHt0eXBlb2YgdmFsdWV9OyBFeHBlY3RlZCBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgbnVsbC4gSWYgeW91IG5lZWQgdG8gcGFzcyBuZXN0ZWQgcXVlcnkgcGFyYW1ldGVycywgeW91IGNhbiBtYW51YWxseSBlbmNvZGUgdGhlbSwgZS5nLiB7IHF1ZXJ5OiB7ICdmb29ba2V5MV0nOiB2YWx1ZTEsICdmb29ba2V5Ml0nOiB2YWx1ZTIgfSB9LCBhbmQgcGxlYXNlIG9wZW4gYSBHaXRIdWIgaXNzdWUgcmVxdWVzdGluZyBiZXR0ZXIgc3VwcG9ydCBmb3IgeW91ciB1c2UgY2FzZS5gKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcmJyk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoV2l0aFRpbWVvdXQodXJsLCBpbml0LCBtcywgY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCB7IHNpZ25hbCwgLi4ub3B0aW9ucyB9ID0gaW5pdCB8fCB7fTtcbiAgICAgICAgaWYgKHNpZ25hbClcbiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgbXMpO1xuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0UmVxdWVzdENsaWVudCgpXG4gICAgICAgICAgICAvLyB1c2UgdW5kZWZpbmVkIHRoaXMgYmluZGluZzsgZmV0Y2ggZXJyb3JzIGlmIGJvdW5kIHRvIHNvbWV0aGluZyBlbHNlIGluIGJyb3dzZXIvY2xvdWRmbGFyZVxuICAgICAgICAgICAgLmZldGNoLmNhbGwodW5kZWZpbmVkLCB1cmwsIHsgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCwgLi4ub3B0aW9ucyB9KVxuICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGdldFJlcXVlc3RDbGllbnQoKSB7XG4gICAgICAgIHJldHVybiB7IGZldGNoOiB0aGlzLmZldGNoIH07XG4gICAgfVxuICAgIHNob3VsZFJldHJ5KHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIE5vdGUgdGhpcyBpcyBub3QgYSBzdGFuZGFyZCBoZWFkZXIuXG4gICAgICAgIGNvbnN0IHNob3VsZFJldHJ5SGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtc2hvdWxkLXJldHJ5Jyk7XG4gICAgICAgIC8vIElmIHRoZSBzZXJ2ZXIgZXhwbGljaXRseSBzYXlzIHdoZXRoZXIgb3Igbm90IHRvIHJldHJ5LCBvYmV5LlxuICAgICAgICBpZiAoc2hvdWxkUmV0cnlIZWFkZXIgPT09ICd0cnVlJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoc2hvdWxkUmV0cnlIZWFkZXIgPT09ICdmYWxzZScpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFJldHJ5IG9uIHJlcXVlc3QgdGltZW91dHMuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwOClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBSZXRyeSBvbiBsb2NrIHRpbWVvdXRzLlxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gUmV0cnkgb24gcmF0ZSBsaW1pdHMuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBSZXRyeSBpbnRlcm5hbCBlcnJvcnMuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNTAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgcmV0cnlSZXF1ZXN0KG9wdGlvbnMsIHJldHJpZXNSZW1haW5pbmcsIHJlc3BvbnNlSGVhZGVycykge1xuICAgICAgICBsZXQgdGltZW91dE1pbGxpcztcbiAgICAgICAgLy8gTm90ZSB0aGUgYHJldHJ5LWFmdGVyLW1zYCBoZWFkZXIgbWF5IG5vdCBiZSBzdGFuZGFyZCwgYnV0IGlzIGEgZ29vZCBpZGVhIGFuZCB3ZSdkIGxpa2UgcHJvYWN0aXZlIHN1cHBvcnQgZm9yIGl0LlxuICAgICAgICBjb25zdCByZXRyeUFmdGVyTWlsbGlzSGVhZGVyID0gcmVzcG9uc2VIZWFkZXJzPy5bJ3JldHJ5LWFmdGVyLW1zJ107XG4gICAgICAgIGlmIChyZXRyeUFmdGVyTWlsbGlzSGVhZGVyKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0TXMgPSBwYXJzZUZsb2F0KHJldHJ5QWZ0ZXJNaWxsaXNIZWFkZXIpO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odGltZW91dE1zKSkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXRNaWxsaXMgPSB0aW1lb3V0TXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWJvdXQgdGhlIFJldHJ5LUFmdGVyIGhlYWRlcjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1JldHJ5LUFmdGVyXG4gICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXJIZWFkZXIgPSByZXNwb25zZUhlYWRlcnM/LlsncmV0cnktYWZ0ZXInXTtcbiAgICAgICAgaWYgKHJldHJ5QWZ0ZXJIZWFkZXIgJiYgIXRpbWVvdXRNaWxsaXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRTZWNvbmRzID0gcGFyc2VGbG9hdChyZXRyeUFmdGVySGVhZGVyKTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHRpbWVvdXRTZWNvbmRzKSkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXRNaWxsaXMgPSB0aW1lb3V0U2Vjb25kcyAqIDEwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0TWlsbGlzID0gRGF0ZS5wYXJzZShyZXRyeUFmdGVySGVhZGVyKSAtIERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIEFQSSBhc2tzIHVzIHRvIHdhaXQgYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lIChhbmQgaXQncyBhIHJlYXNvbmFibGUgYW1vdW50KSxcbiAgICAgICAgLy8ganVzdCBkbyB3aGF0IGl0IHNheXMsIGJ1dCBvdGhlcndpc2UgY2FsY3VsYXRlIGEgZGVmYXVsdFxuICAgICAgICBpZiAoISh0aW1lb3V0TWlsbGlzICYmIDAgPD0gdGltZW91dE1pbGxpcyAmJiB0aW1lb3V0TWlsbGlzIDwgNjAgKiAxMDAwKSkge1xuICAgICAgICAgICAgY29uc3QgbWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcyA/PyB0aGlzLm1heFJldHJpZXM7XG4gICAgICAgICAgICB0aW1lb3V0TWlsbGlzID0gdGhpcy5jYWxjdWxhdGVEZWZhdWx0UmV0cnlUaW1lb3V0TWlsbGlzKHJldHJpZXNSZW1haW5pbmcsIG1heFJldHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHNsZWVwKHRpbWVvdXRNaWxsaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdChvcHRpb25zLCByZXRyaWVzUmVtYWluaW5nIC0gMSk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZURlZmF1bHRSZXRyeVRpbWVvdXRNaWxsaXMocmV0cmllc1JlbWFpbmluZywgbWF4UmV0cmllcykge1xuICAgICAgICBjb25zdCBpbml0aWFsUmV0cnlEZWxheSA9IDAuNTtcbiAgICAgICAgY29uc3QgbWF4UmV0cnlEZWxheSA9IDguMDtcbiAgICAgICAgY29uc3QgbnVtUmV0cmllcyA9IG1heFJldHJpZXMgLSByZXRyaWVzUmVtYWluaW5nO1xuICAgICAgICAvLyBBcHBseSBleHBvbmVudGlhbCBiYWNrb2ZmLCBidXQgbm90IG1vcmUgdGhhbiB0aGUgbWF4LlxuICAgICAgICBjb25zdCBzbGVlcFNlY29uZHMgPSBNYXRoLm1pbihpbml0aWFsUmV0cnlEZWxheSAqIE1hdGgucG93KDIsIG51bVJldHJpZXMpLCBtYXhSZXRyeURlbGF5KTtcbiAgICAgICAgLy8gQXBwbHkgc29tZSBqaXR0ZXIsIHRha2UgdXAgdG8gYXQgbW9zdCAyNSBwZXJjZW50IG9mIHRoZSByZXRyeSB0aW1lLlxuICAgICAgICBjb25zdCBqaXR0ZXIgPSAxIC0gTWF0aC5yYW5kb20oKSAqIDAuMjU7XG4gICAgICAgIHJldHVybiBzbGVlcFNlY29uZHMgKiBqaXR0ZXIgKiAxMDAwO1xuICAgIH1cbiAgICBnZXRVc2VyQWdlbnQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9L0pTICR7VkVSU0lPTn1gO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFBhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCwgcmVzcG9uc2UsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgX0Fic3RyYWN0UGFnZV9jbGllbnQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Fic3RyYWN0UGFnZV9jbGllbnQsIGNsaWVudCwgXCJmXCIpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgfVxuICAgIGhhc05leHRQYWdlKCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuZ2V0UGFnaW5hdGVkSXRlbXMoKTtcbiAgICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRQYWdlSW5mbygpICE9IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGdldE5leHRQYWdlKCkge1xuICAgICAgICBjb25zdCBuZXh0SW5mbyA9IHRoaXMubmV4dFBhZ2VJbmZvKCk7XG4gICAgICAgIGlmICghbmV4dEluZm8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcignTm8gbmV4dCBwYWdlIGV4cGVjdGVkOyBwbGVhc2UgY2hlY2sgYC5oYXNOZXh0UGFnZSgpYCBiZWZvcmUgY2FsbGluZyBgLmdldE5leHRQYWdlKClgLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRPcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMgfTtcbiAgICAgICAgaWYgKCdwYXJhbXMnIGluIG5leHRJbmZvICYmIHR5cGVvZiBuZXh0T3B0aW9ucy5xdWVyeSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG5leHRPcHRpb25zLnF1ZXJ5ID0geyAuLi5uZXh0T3B0aW9ucy5xdWVyeSwgLi4ubmV4dEluZm8ucGFyYW1zIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ3VybCcgaW4gbmV4dEluZm8pIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IFsuLi5PYmplY3QuZW50cmllcyhuZXh0T3B0aW9ucy5xdWVyeSB8fCB7fSksIC4uLm5leHRJbmZvLnVybC5zZWFyY2hQYXJhbXMuZW50cmllcygpXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIG5leHRJbmZvLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dE9wdGlvbnMucXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBuZXh0T3B0aW9ucy5wYXRoID0gbmV4dEluZm8udXJsLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fic3RyYWN0UGFnZV9jbGllbnQsIFwiZlwiKS5yZXF1ZXN0QVBJTGlzdCh0aGlzLmNvbnN0cnVjdG9yLCBuZXh0T3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jICppdGVyUGFnZXMoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBsZXQgcGFnZSA9IHRoaXM7XG4gICAgICAgIHlpZWxkIHBhZ2U7XG4gICAgICAgIHdoaWxlIChwYWdlLmhhc05leHRQYWdlKCkpIHtcbiAgICAgICAgICAgIHBhZ2UgPSBhd2FpdCBwYWdlLmdldE5leHRQYWdlKCk7XG4gICAgICAgICAgICB5aWVsZCBwYWdlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICpbKF9BYnN0cmFjdFBhZ2VfY2xpZW50ID0gbmV3IFdlYWtNYXAoKSwgU3ltYm9sLmFzeW5jSXRlcmF0b3IpXSgpIHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwYWdlIG9mIHRoaXMuaXRlclBhZ2VzKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBwYWdlLmdldFBhZ2luYXRlZEl0ZW1zKCkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIHN1YmNsYXNzIG9mIFByb21pc2Ugd2lsbCByZXNvbHZlIHRvIGFuIGluc3RhbnRpYXRlZCBQYWdlIG9uY2UgdGhlIHJlcXVlc3QgY29tcGxldGVzLlxuICpcbiAqIEl0IGFsc28gaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlIHRvIGFsbG93IGF1dG8tcGFnaW5hdGluZyBpdGVyYXRpb24gb24gYW4gdW5hd2FpdGVkIGxpc3QgY2FsbCwgZWc6XG4gKlxuICogICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGNsaWVudC5pdGVtcy5saXN0KCkpIHtcbiAqICAgICAgY29uc29sZS5sb2coaXRlbSlcbiAqICAgIH1cbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2VQcm9taXNlIGV4dGVuZHMgQVBJUHJvbWlzZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50LCByZXF1ZXN0LCBQYWdlKSB7XG4gICAgICAgIHN1cGVyKHJlcXVlc3QsIGFzeW5jIChwcm9wcykgPT4gbmV3IFBhZ2UoY2xpZW50LCBwcm9wcy5yZXNwb25zZSwgYXdhaXQgZGVmYXVsdFBhcnNlUmVzcG9uc2UocHJvcHMpLCBwcm9wcy5vcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93IGF1dG8tcGFnaW5hdGluZyBpdGVyYXRpb24gb24gYW4gdW5hd2FpdGVkIGxpc3QgY2FsbCwgZWc6XG4gICAgICpcbiAgICAgKiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgY2xpZW50Lml0ZW1zLmxpc3QoKSkge1xuICAgICAqICAgICAgY29uc29sZS5sb2coaXRlbSlcbiAgICAgKiAgICB9XG4gICAgICovXG4gICAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCB0aGlzO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgcGFnZSkge1xuICAgICAgICAgICAgeWllbGQgaXRlbTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBjcmVhdGVSZXNwb25zZUhlYWRlcnMgPSAoaGVhZGVycykgPT4ge1xuICAgIHJldHVybiBuZXcgUHJveHkoT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBoZWFkZXJzLmVudHJpZXMoKSksIHtcbiAgICAgICAgZ2V0KHRhcmdldCwgbmFtZSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gbmFtZS50b1N0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXkudG9Mb3dlckNhc2UoKV0gfHwgdGFyZ2V0W2tleV07XG4gICAgICAgIH0sXG4gICAgfSk7XG59O1xuLy8gVGhpcyBpcyByZXF1aXJlZCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgaWYgYSBnaXZlbiBvYmplY3QgbWF0Y2hlcyB0aGUgUmVxdWVzdE9wdGlvbnNcbi8vIHR5cGUgYXQgcnVudGltZS4gV2hpbGUgdGhpcyByZXF1aXJlcyBkdXBsaWNhdGlvbiwgaXQgaXMgZW5mb3JjZWQgYnkgdGhlIFR5cGVTY3JpcHRcbi8vIGNvbXBpbGVyIHN1Y2ggdGhhdCBhbnkgbWlzc2luZyAvIGV4dHJhbmVvdXMga2V5cyB3aWxsIGNhdXNlIGFuIGVycm9yLlxuY29uc3QgcmVxdWVzdE9wdGlvbnNLZXlzID0ge1xuICAgIG1ldGhvZDogdHJ1ZSxcbiAgICBwYXRoOiB0cnVlLFxuICAgIHF1ZXJ5OiB0cnVlLFxuICAgIGJvZHk6IHRydWUsXG4gICAgaGVhZGVyczogdHJ1ZSxcbiAgICBtYXhSZXRyaWVzOiB0cnVlLFxuICAgIHN0cmVhbTogdHJ1ZSxcbiAgICB0aW1lb3V0OiB0cnVlLFxuICAgIGh0dHBBZ2VudDogdHJ1ZSxcbiAgICBzaWduYWw6IHRydWUsXG4gICAgaWRlbXBvdGVuY3lLZXk6IHRydWUsXG4gICAgX19iaW5hcnlSZXF1ZXN0OiB0cnVlLFxuICAgIF9fYmluYXJ5UmVzcG9uc2U6IHRydWUsXG4gICAgX19zdHJlYW1DbGFzczogdHJ1ZSxcbn07XG5leHBvcnQgY29uc3QgaXNSZXF1ZXN0T3B0aW9ucyA9IChvYmopID0+IHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgICAgIG9iaiAhPT0gbnVsbCAmJlxuICAgICAgICAhaXNFbXB0eU9iaihvYmopICYmXG4gICAgICAgIE9iamVjdC5rZXlzKG9iaikuZXZlcnkoKGspID0+IGhhc093bihyZXF1ZXN0T3B0aW9uc0tleXMsIGspKSk7XG59O1xuY29uc3QgZ2V0UGxhdGZvcm1Qcm9wZXJ0aWVzID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcgJiYgRGVuby5idWlsZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1PUyc6IG5vcm1hbGl6ZVBsYXRmb3JtKERlbm8uYnVpbGQub3MpLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiBub3JtYWxpemVBcmNoKERlbm8uYnVpbGQuYXJjaCksXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICdkZW5vJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiB0eXBlb2YgRGVuby52ZXJzaW9uID09PSAnc3RyaW5nJyA/IERlbm8udmVyc2lvbiA6IERlbm8udmVyc2lvbj8uZGVubyA/PyAndW5rbm93bicsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgRWRnZVJ1bnRpbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1PUyc6ICdVbmtub3duJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogYG90aGVyOiR7RWRnZVJ1bnRpbWV9YCxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ2VkZ2UnLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6IHByb2Nlc3MudmVyc2lvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgTm9kZS5qc1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnID8gcHJvY2VzcyA6IDApID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBWRVJTSU9OLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLU9TJzogbm9ybWFsaXplUGxhdGZvcm0ocHJvY2Vzcy5wbGF0Zm9ybSksXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6IG5vcm1hbGl6ZUFyY2gocHJvY2Vzcy5hcmNoKSxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ25vZGUnLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6IHByb2Nlc3MudmVyc2lvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgYnJvd3NlckluZm8gPSBnZXRCcm93c2VySW5mbygpO1xuICAgIGlmIChicm93c2VySW5mbykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IFZFUlNJT04sXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtT1MnOiAnVW5rbm93bicsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6ICd1bmtub3duJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogYGJyb3dzZXI6JHticm93c2VySW5mby5icm93c2VyfWAsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogYnJvd3NlckluZm8udmVyc2lvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gVE9ETyBhZGQgc3VwcG9ydCBmb3IgQ2xvdWRmbGFyZSB3b3JrZXJzLCBldGMuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICAgJ1gtU3RhaW5sZXNzLU9TJzogJ1Vua25vd24nLFxuICAgICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6ICd1bmtub3duJyxcbiAgICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiAndW5rbm93bicsXG4gICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiAndW5rbm93bicsXG4gICAgfTtcbn07XG4vLyBOb3RlOiBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9KUy1EZXZUb29scy9ob3N0LWVudmlyb25tZW50L2Jsb2IvYjFhYjc5ZWNkZTM3ZGI1ZDZlMTYzYzA1MGU1NGZlN2QyODdkN2M5Mi9zcmMvaXNvbW9ycGhpYy5icm93c2VyLnRzXG5mdW5jdGlvbiBnZXRCcm93c2VySW5mbygpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gTk9URTogVGhlIG9yZGVyIG1hdHRlcnMgaGVyZSFcbiAgICBjb25zdCBicm93c2VyUGF0dGVybnMgPSBbXG4gICAgICAgIHsga2V5OiAnZWRnZScsIHBhdHRlcm46IC9FZGdlKD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgICAgIHsga2V5OiAnaWUnLCBwYXR0ZXJuOiAvTVNJRSg/OlxcVysoXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/LyB9LFxuICAgICAgICB7IGtleTogJ2llJywgcGF0dGVybjogL1RyaWRlbnQoPzouKnJ2XFw6KFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICAgICAgeyBrZXk6ICdjaHJvbWUnLCBwYXR0ZXJuOiAvQ2hyb21lKD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgICAgIHsga2V5OiAnZmlyZWZveCcsIHBhdHRlcm46IC9GaXJlZm94KD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgICAgIHsga2V5OiAnc2FmYXJpJywgcGF0dGVybjogLyg/OlZlcnNpb25cXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPyg/OlxcVytNb2JpbGVcXFMqKT9cXFcrU2FmYXJpLyB9LFxuICAgIF07XG4gICAgLy8gRmluZCB0aGUgRklSU1QgbWF0Y2hpbmcgYnJvd3NlclxuICAgIGZvciAoY29uc3QgeyBrZXksIHBhdHRlcm4gfSBvZiBicm93c2VyUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgbWFqb3IgPSBtYXRjaFsxXSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgbWlub3IgPSBtYXRjaFsyXSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgcGF0Y2ggPSBtYXRjaFszXSB8fCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgYnJvd3Nlcjoga2V5LCB2ZXJzaW9uOiBgJHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH1gIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBub3JtYWxpemVBcmNoID0gKGFyY2gpID0+IHtcbiAgICAvLyBOb2RlIGRvY3M6XG4gICAgLy8gLSBodHRwczovL25vZGVqcy5vcmcvYXBpL3Byb2Nlc3MuaHRtbCNwcm9jZXNzYXJjaFxuICAgIC8vIERlbm8gZG9jczpcbiAgICAvLyAtIGh0dHBzOi8vZG9jLmRlbm8ubGFuZC9kZW5vL3N0YWJsZS9+L0Rlbm8uYnVpbGRcbiAgICBpZiAoYXJjaCA9PT0gJ3gzMicpXG4gICAgICAgIHJldHVybiAneDMyJztcbiAgICBpZiAoYXJjaCA9PT0gJ3g4Nl82NCcgfHwgYXJjaCA9PT0gJ3g2NCcpXG4gICAgICAgIHJldHVybiAneDY0JztcbiAgICBpZiAoYXJjaCA9PT0gJ2FybScpXG4gICAgICAgIHJldHVybiAnYXJtJztcbiAgICBpZiAoYXJjaCA9PT0gJ2FhcmNoNjQnIHx8IGFyY2ggPT09ICdhcm02NCcpXG4gICAgICAgIHJldHVybiAnYXJtNjQnO1xuICAgIGlmIChhcmNoKVxuICAgICAgICByZXR1cm4gYG90aGVyOiR7YXJjaH1gO1xuICAgIHJldHVybiAndW5rbm93bic7XG59O1xuY29uc3Qgbm9ybWFsaXplUGxhdGZvcm0gPSAocGxhdGZvcm0pID0+IHtcbiAgICAvLyBOb2RlIHBsYXRmb3JtczpcbiAgICAvLyAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NwbGF0Zm9ybVxuICAgIC8vIERlbm8gcGxhdGZvcm1zOlxuICAgIC8vIC0gaHR0cHM6Ly9kb2MuZGVuby5sYW5kL2Rlbm8vc3RhYmxlL34vRGVuby5idWlsZFxuICAgIC8vIC0gaHR0cHM6Ly9naXRodWIuY29tL2Rlbm9sYW5kL2Rlbm8vaXNzdWVzLzE0Nzk5XG4gICAgcGxhdGZvcm0gPSBwbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIE5PVEU6IHRoaXMgaU9TIGNoZWNrIGlzIHVudGVzdGVkIGFuZCBtYXkgbm90IHdvcmtcbiAgICAvLyBOb2RlIGRvZXMgbm90IHdvcmsgbmF0aXZlbHkgb24gSU9TLCB0aGVyZSBpcyBhIGZvcmsgYXRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzLW1vYmlsZS9ub2RlanMtbW9iaWxlXG4gICAgLy8gaG93ZXZlciBpdCBpcyB1bmtub3duIGF0IHRoZSB0aW1lIG9mIHdyaXRpbmcgaG93IHRvIGRldGVjdCBpZiBpdCBpcyBydW5uaW5nXG4gICAgaWYgKHBsYXRmb3JtLmluY2x1ZGVzKCdpb3MnKSlcbiAgICAgICAgcmV0dXJuICdpT1MnO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKVxuICAgICAgICByZXR1cm4gJ0FuZHJvaWQnO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ2RhcndpbicpXG4gICAgICAgIHJldHVybiAnTWFjT1MnO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ3dpbjMyJylcbiAgICAgICAgcmV0dXJuICdXaW5kb3dzJztcbiAgICBpZiAocGxhdGZvcm0gPT09ICdmcmVlYnNkJylcbiAgICAgICAgcmV0dXJuICdGcmVlQlNEJztcbiAgICBpZiAocGxhdGZvcm0gPT09ICdvcGVuYnNkJylcbiAgICAgICAgcmV0dXJuICdPcGVuQlNEJztcbiAgICBpZiAocGxhdGZvcm0gPT09ICdsaW51eCcpXG4gICAgICAgIHJldHVybiAnTGludXgnO1xuICAgIGlmIChwbGF0Zm9ybSlcbiAgICAgICAgcmV0dXJuIGBPdGhlcjoke3BsYXRmb3JtfWA7XG4gICAgcmV0dXJuICdVbmtub3duJztcbn07XG5sZXQgX3BsYXRmb3JtSGVhZGVycztcbmNvbnN0IGdldFBsYXRmb3JtSGVhZGVycyA9ICgpID0+IHtcbiAgICByZXR1cm4gKF9wbGF0Zm9ybUhlYWRlcnMgPz8gKF9wbGF0Zm9ybUhlYWRlcnMgPSBnZXRQbGF0Zm9ybVByb3BlcnRpZXMoKSkpO1xufTtcbmV4cG9ydCBjb25zdCBzYWZlSlNPTiA9ICh0ZXh0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5NzA5ODQ2XG5jb25zdCBzdGFydHNXaXRoU2NoZW1lUmVnZXhwID0gbmV3IFJlZ0V4cCgnXig/OlthLXpdKzopPy8vJywgJ2knKTtcbmNvbnN0IGlzQWJzb2x1dGVVUkwgPSAodXJsKSA9PiB7XG4gICAgcmV0dXJuIHN0YXJ0c1dpdGhTY2hlbWVSZWdleHAudGVzdCh1cmwpO1xufTtcbmV4cG9ydCBjb25zdCBzbGVlcCA9IChtcykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbmNvbnN0IHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyID0gKG5hbWUsIG4pID0+IHtcbiAgICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKG4pKSB7XG4gICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgJHtuYW1lfSBtdXN0IGJlIGFuIGludGVnZXJgKTtcbiAgICB9XG4gICAgaWYgKG4gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgJHtuYW1lfSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcmApO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn07XG5leHBvcnQgY29uc3QgY2FzdFRvRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgICByZXR1cm4gZXJyO1xuICAgIHJldHVybiBuZXcgRXJyb3IoZXJyKTtcbn07XG5leHBvcnQgY29uc3QgZW5zdXJlUHJlc2VudCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYEV4cGVjdGVkIGEgdmFsdWUgdG8gYmUgZ2l2ZW4gYnV0IHJlY2VpdmVkICR7dmFsdWV9IGluc3RlYWQuYCk7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbi8qKlxuICogUmVhZCBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAqXG4gKiBUcmltcyBiZWdpbm5pbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuXG4gKlxuICogV2lsbCByZXR1cm4gdW5kZWZpbmVkIGlmIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBkb2Vzbid0IGV4aXN0IG9yIGNhbm5vdCBiZSBhY2Nlc3NlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRFbnYgPSAoZW52KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnY/LltlbnZdPy50cmltKCkgPz8gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBEZW5vLmVudj8uZ2V0Py4oZW52KT8udHJpbSgpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmV4cG9ydCBjb25zdCBjb2VyY2VJbnRlZ2VyID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBDb3VsZCBub3QgY29lcmNlICR7dmFsdWV9ICh0eXBlOiAke3R5cGVvZiB2YWx1ZX0pIGludG8gYSBudW1iZXJgKTtcbn07XG5leHBvcnQgY29uc3QgY29lcmNlRmxvYXQgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBDb3VsZCBub3QgY29lcmNlICR7dmFsdWV9ICh0eXBlOiAke3R5cGVvZiB2YWx1ZX0pIGludG8gYSBudW1iZXJgKTtcbn07XG5leHBvcnQgY29uc3QgY29lcmNlQm9vbGVhbiA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJylcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdmFsdWUgPT09ICd0cnVlJztcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XG59O1xuZXhwb3J0IGNvbnN0IG1heWJlQ29lcmNlSW50ZWdlciA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBjb2VyY2VJbnRlZ2VyKHZhbHVlKTtcbn07XG5leHBvcnQgY29uc3QgbWF5YmVDb2VyY2VGbG9hdCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBjb2VyY2VGbG9hdCh2YWx1ZSk7XG59O1xuZXhwb3J0IGNvbnN0IG1heWJlQ29lcmNlQm9vbGVhbiA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBjb2VyY2VCb29sZWFuKHZhbHVlKTtcbn07XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQ0OTEyODdcbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5T2JqKG9iaikge1xuICAgIGlmICghb2JqKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IF9rIGluIG9iailcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gaHR0cHM6Ly9lc2xpbnQub3JnL2RvY3MvbGF0ZXN0L3J1bGVzL25vLXByb3RvdHlwZS1idWlsdGluc1xuZXhwb3J0IGZ1bmN0aW9uIGhhc093bihvYmosIGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuLyoqXG4gKiBDb3BpZXMgaGVhZGVycyBmcm9tIFwibmV3SGVhZGVyc1wiIG9udG8gXCJ0YXJnZXRIZWFkZXJzXCIsXG4gKiB1c2luZyBsb3dlci1jYXNlIGZvciBhbGwgcHJvcGVydGllcyxcbiAqIGlnbm9yaW5nIGFueSBrZXlzIHdpdGggdW5kZWZpbmVkIHZhbHVlcyxcbiAqIGFuZCBkZWxldGluZyBhbnkga2V5cyB3aXRoIG51bGwgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBhcHBseUhlYWRlcnNNdXQodGFyZ2V0SGVhZGVycywgbmV3SGVhZGVycykge1xuICAgIGZvciAoY29uc3QgayBpbiBuZXdIZWFkZXJzKSB7XG4gICAgICAgIGlmICghaGFzT3duKG5ld0hlYWRlcnMsIGspKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGxvd2VyS2V5ID0gay50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIWxvd2VyS2V5KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHZhbCA9IG5ld0hlYWRlcnNba107XG4gICAgICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRIZWFkZXJzW2xvd2VyS2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGFyZ2V0SGVhZGVyc1tsb3dlcktleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZGVidWcoYWN0aW9uLCAuLi5hcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzPy5lbnY/LlsnREVCVUcnXSA9PT0gJ3RydWUnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBPcGVuQUk6REVCVUc6JHthY3Rpb259YCwgLi4uYXJncyk7XG4gICAgfVxufVxuLyoqXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjExNzUyM1xuICovXG5jb25zdCB1dWlkNCA9ICgpID0+IHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCAoYykgPT4ge1xuICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwO1xuICAgICAgICBjb25zdCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufTtcbmV4cG9ydCBjb25zdCBpc1J1bm5pbmdJbkJyb3dzZXIgPSAoKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKTtcbn07XG5leHBvcnQgY29uc3QgaXNIZWFkZXJzUHJvdG9jb2wgPSAoaGVhZGVycykgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgaGVhZGVycz8uZ2V0ID09PSAnZnVuY3Rpb24nO1xufTtcbmV4cG9ydCBjb25zdCBnZXRSZXF1aXJlZEhlYWRlciA9IChoZWFkZXJzLCBoZWFkZXIpID0+IHtcbiAgICBjb25zdCBsb3dlckNhc2VkSGVhZGVyID0gaGVhZGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGlzSGVhZGVyc1Byb3RvY29sKGhlYWRlcnMpKSB7XG4gICAgICAgIC8vIHRvIGRlYWwgd2l0aCB0aGUgY2FzZSB3aGVyZSB0aGUgaGVhZGVyIGxvb2tzIGxpa2UgU3RhaW5sZXNzLUV2ZW50LUlkXG4gICAgICAgIGNvbnN0IGludGVyY2Fwc0hlYWRlciA9IGhlYWRlclswXT8udG9VcHBlckNhc2UoKSArXG4gICAgICAgICAgICBoZWFkZXIuc3Vic3RyaW5nKDEpLnJlcGxhY2UoLyhbXlxcd10pKFxcdykvZywgKF9tLCBnMSwgZzIpID0+IGcxICsgZzIudG9VcHBlckNhc2UoKSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFtoZWFkZXIsIGxvd2VyQ2FzZWRIZWFkZXIsIGhlYWRlci50b1VwcGVyQ2FzZSgpLCBpbnRlcmNhcHNIZWFkZXJdKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSBsb3dlckNhc2VkSGVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoIDw9IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVswXTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFJlY2VpdmVkICR7dmFsdWUubGVuZ3RofSBlbnRyaWVzIGZvciB0aGUgJHtoZWFkZXJ9IGhlYWRlciwgdXNpbmcgdGhlIGZpcnN0IGVudHJ5LmApO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kICR7aGVhZGVyfSBoZWFkZXJgKTtcbn07XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgdG8gQmFzZTY0IGZvcm1hdC5cbiAqL1xuZXhwb3J0IGNvbnN0IHRvQmFzZTY0ID0gKHN0cikgPT4ge1xuICAgIGlmICghc3RyKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gYnRvYShzdHIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoJ0Nhbm5vdCBnZW5lcmF0ZSBiNjQgc3RyaW5nOyBFeHBlY3RlZCBgQnVmZmVyYCBvciBgYnRvYWAgdG8gYmUgZGVmaW5lZCcpO1xufTtcbmV4cG9ydCBmdW5jdGlvbiBpc09iaihvYmopIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob2JqKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBjYXN0VG9FcnJvciB9IGZyb20gXCIuL2NvcmUubWpzXCI7XG5leHBvcnQgY2xhc3MgT3BlbkFJRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5leHBvcnQgY2xhc3MgQVBJRXJyb3IgZXh0ZW5kcyBPcGVuQUlFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycykge1xuICAgICAgICBzdXBlcihgJHtBUElFcnJvci5tYWtlTWVzc2FnZShzdGF0dXMsIGVycm9yLCBtZXNzYWdlKX1gKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMucmVxdWVzdF9pZCA9IGhlYWRlcnM/LlsneC1yZXF1ZXN0LWlkJ107XG4gICAgICAgIGNvbnN0IGRhdGEgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5lcnJvciA9IGRhdGE7XG4gICAgICAgIHRoaXMuY29kZSA9IGRhdGE/LlsnY29kZSddO1xuICAgICAgICB0aGlzLnBhcmFtID0gZGF0YT8uWydwYXJhbSddO1xuICAgICAgICB0aGlzLnR5cGUgPSBkYXRhPy5bJ3R5cGUnXTtcbiAgICB9XG4gICAgc3RhdGljIG1ha2VNZXNzYWdlKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbXNnID0gZXJyb3I/Lm1lc3NhZ2UgP1xuICAgICAgICAgICAgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShlcnJvci5tZXNzYWdlKVxuICAgICAgICAgICAgOiBlcnJvciA/IEpTT04uc3RyaW5naWZ5KGVycm9yKVxuICAgICAgICAgICAgICAgIDogbWVzc2FnZTtcbiAgICAgICAgaWYgKHN0YXR1cyAmJiBtc2cpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtzdGF0dXN9ICR7bXNnfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgcmV0dXJuIGAke3N0YXR1c30gc3RhdHVzIGNvZGUgKG5vIGJvZHkpYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXNnKSB7XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnKG5vIHN0YXR1cyBjb2RlIG9yIGJvZHkpJztcbiAgICB9XG4gICAgc3RhdGljIGdlbmVyYXRlKHN0YXR1cywgZXJyb3JSZXNwb25zZSwgbWVzc2FnZSwgaGVhZGVycykge1xuICAgICAgICBpZiAoIXN0YXR1cykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBUElDb25uZWN0aW9uRXJyb3IoeyBjYXVzZTogY2FzdFRvRXJyb3IoZXJyb3JSZXNwb25zZSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvclJlc3BvbnNlPy5bJ2Vycm9yJ107XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDQwMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCYWRSZXF1ZXN0RXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcm1pc3Npb25EZW5pZWRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm90Rm91bmRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uZmxpY3RFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSA0MjIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDQyOSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYXRlTGltaXRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID49IDUwMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbFNlcnZlckVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQVBJRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFQSVVzZXJBYm9ydEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIodW5kZWZpbmVkLCB1bmRlZmluZWQsIG1lc3NhZ2UgfHwgJ1JlcXVlc3Qgd2FzIGFib3J0ZWQuJywgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFQSUNvbm5lY3Rpb25FcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UsIGNhdXNlIH0pIHtcbiAgICAgICAgc3VwZXIodW5kZWZpbmVkLCB1bmRlZmluZWQsIG1lc3NhZ2UgfHwgJ0Nvbm5lY3Rpb24gZXJyb3IuJywgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIGluIHNvbWUgZW52aXJvbm1lbnRzIHRoZSAnY2F1c2UnIHByb3BlcnR5IGlzIGFscmVhZHkgZGVjbGFyZWRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoY2F1c2UpXG4gICAgICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IgZXh0ZW5kcyBBUElDb25uZWN0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoeyBtZXNzYWdlOiBtZXNzYWdlID8/ICdSZXF1ZXN0IHRpbWVkIG91dC4nIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCYWRSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gNDAwO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBdXRoZW50aWNhdGlvbkVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IDQwMTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUGVybWlzc2lvbkRlbmllZEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IDQwMztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTm90Rm91bmRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSA0MDQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbmZsaWN0RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gNDA5O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gNDIyO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSYXRlTGltaXRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSA0Mjk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEludGVybmFsU2VydmVyRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnQgY2xhc3MgTGVuZ3RoRmluaXNoUmVhc29uRXJyb3IgZXh0ZW5kcyBPcGVuQUlFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKGBDb3VsZCBub3QgcGFyc2UgcmVzcG9uc2UgY29udGVudCBhcyB0aGUgbGVuZ3RoIGxpbWl0IHdhcyByZWFjaGVkYCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbnRlbnRGaWx0ZXJGaW5pc2hSZWFzb25FcnJvciBleHRlbmRzIE9wZW5BSUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoYENvdWxkIG5vdCBwYXJzZSByZXNwb25zZSBjb250ZW50IGFzIHRoZSByZXF1ZXN0IHdhcyByZWplY3RlZCBieSB0aGUgY29udGVudCBmaWx0ZXJgKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFic3RyYWN0UGFnZSB9IGZyb20gXCIuL2NvcmUubWpzXCI7XG4vKipcbiAqIE5vdGU6IG5vIHBhZ2luYXRpb24gYWN0dWFsbHkgb2NjdXJzIHlldCwgdGhpcyBpcyBmb3IgZm9yd2FyZHMtY29tcGF0aWJpbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2UgZXh0ZW5kcyBBYnN0cmFjdFBhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCwgcmVzcG9uc2UsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoY2xpZW50LCByZXNwb25zZSwgYm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGJvZHkuZGF0YSB8fCBbXTtcbiAgICAgICAgdGhpcy5vYmplY3QgPSBib2R5Lm9iamVjdDtcbiAgICB9XG4gICAgZ2V0UGFnaW5hdGVkSXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEgPz8gW107XG4gICAgfVxuICAgIC8vIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYG5leHRQYWdlSW5mbygpYCBpbnN0ZWFkXG4gICAgLyoqXG4gICAgICogVGhpcyBwYWdlIHJlcHJlc2VudHMgYSByZXNwb25zZSB0aGF0IGlzbid0IGFjdHVhbGx5IHBhZ2luYXRlZCBhdCB0aGUgQVBJIGxldmVsXG4gICAgICogc28gdGhlcmUgd2lsbCBuZXZlciBiZSBhbnkgbmV4dCBwYWdlIHBhcmFtcy5cbiAgICAgKi9cbiAgICBuZXh0UGFnZVBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG5leHRQYWdlSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEN1cnNvclBhZ2UgZXh0ZW5kcyBBYnN0cmFjdFBhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCwgcmVzcG9uc2UsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoY2xpZW50LCByZXNwb25zZSwgYm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGJvZHkuZGF0YSB8fCBbXTtcbiAgICB9XG4gICAgZ2V0UGFnaW5hdGVkSXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEgPz8gW107XG4gICAgfVxuICAgIC8vIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYG5leHRQYWdlSW5mbygpYCBpbnN0ZWFkXG4gICAgbmV4dFBhZ2VQYXJhbXMoKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLm5leHRQYWdlSW5mbygpO1xuICAgICAgICBpZiAoIWluZm8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCdwYXJhbXMnIGluIGluZm8pXG4gICAgICAgICAgICByZXR1cm4gaW5mby5wYXJhbXM7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5mcm9tRW50cmllcyhpbmZvLnVybC5zZWFyY2hQYXJhbXMpO1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIG5leHRQYWdlSW5mbygpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0UGFnaW5hdGVkSXRlbXMoKTtcbiAgICAgICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0/LmlkO1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwYXJhbXM6IHsgYWZ0ZXI6IGlkIH0gfTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdpbmF0aW9uLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuZXhwb3J0IGNsYXNzIEFQSVJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc291cmNlLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vcmVzb3VyY2UubWpzXCI7XG5leHBvcnQgY2xhc3MgQ29tcGxldGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgY3JlYXRlKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvY2hhdC9jb21wbGV0aW9ucycsIHsgYm9keSwgLi4ub3B0aW9ucywgc3RyZWFtOiBib2R5LnN0cmVhbSA/PyBmYWxzZSB9KTtcbiAgICB9XG59XG4oZnVuY3Rpb24gKENvbXBsZXRpb25zKSB7XG59KShDb21wbGV0aW9ucyB8fCAoQ29tcGxldGlvbnMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGxldGlvbnMubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi9yZXNvdXJjZS5tanNcIjtcbmltcG9ydCAqIGFzIENvbXBsZXRpb25zQVBJIGZyb20gXCIuL2NvbXBsZXRpb25zLm1qc1wiO1xuZXhwb3J0IGNsYXNzIENoYXQgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY29tcGxldGlvbnMgPSBuZXcgQ29tcGxldGlvbnNBUEkuQ29tcGxldGlvbnModGhpcy5fY2xpZW50KTtcbiAgICB9XG59XG4oZnVuY3Rpb24gKENoYXQpIHtcbiAgICBDaGF0LkNvbXBsZXRpb25zID0gQ29tcGxldGlvbnNBUEkuQ29tcGxldGlvbnM7XG59KShDaGF0IHx8IChDaGF0ID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYXQubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi9yZXNvdXJjZS5tanNcIjtcbmV4cG9ydCBjbGFzcyBTcGVlY2ggZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGF1ZGlvIGZyb20gdGhlIGlucHV0IHRleHQuXG4gICAgICovXG4gICAgY3JlYXRlKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvYXVkaW8vc3BlZWNoJywgeyBib2R5LCAuLi5vcHRpb25zLCBfX2JpbmFyeVJlc3BvbnNlOiB0cnVlIH0pO1xuICAgIH1cbn1cbihmdW5jdGlvbiAoU3BlZWNoKSB7XG59KShTcGVlY2ggfHwgKFNwZWVjaCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcGVlY2gubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi9yZXNvdXJjZS5tanNcIjtcbmltcG9ydCAqIGFzIENvcmUgZnJvbSBcIi4uLy4uL2NvcmUubWpzXCI7XG5leHBvcnQgY2xhc3MgVHJhbnNjcmlwdGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogVHJhbnNjcmliZXMgYXVkaW8gaW50byB0aGUgaW5wdXQgbGFuZ3VhZ2UuXG4gICAgICovXG4gICAgY3JlYXRlKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvYXVkaW8vdHJhbnNjcmlwdGlvbnMnLCBDb3JlLm11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyh7IGJvZHksIC4uLm9wdGlvbnMgfSkpO1xuICAgIH1cbn1cbihmdW5jdGlvbiAoVHJhbnNjcmlwdGlvbnMpIHtcbn0pKFRyYW5zY3JpcHRpb25zIHx8IChUcmFuc2NyaXB0aW9ucyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2NyaXB0aW9ucy5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tIFwiLi4vLi4vY29yZS5tanNcIjtcbmV4cG9ydCBjbGFzcyBUcmFuc2xhdGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBhdWRpbyBpbnRvIEVuZ2xpc2guXG4gICAgICovXG4gICAgY3JlYXRlKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvYXVkaW8vdHJhbnNsYXRpb25zJywgQ29yZS5tdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgICB9XG59XG4oZnVuY3Rpb24gKFRyYW5zbGF0aW9ucykge1xufSkoVHJhbnNsYXRpb25zIHx8IChUcmFuc2xhdGlvbnMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNsYXRpb25zLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgKiBhcyBTcGVlY2hBUEkgZnJvbSBcIi4vc3BlZWNoLm1qc1wiO1xuaW1wb3J0ICogYXMgVHJhbnNjcmlwdGlvbnNBUEkgZnJvbSBcIi4vdHJhbnNjcmlwdGlvbnMubWpzXCI7XG5pbXBvcnQgKiBhcyBUcmFuc2xhdGlvbnNBUEkgZnJvbSBcIi4vdHJhbnNsYXRpb25zLm1qc1wiO1xuZXhwb3J0IGNsYXNzIEF1ZGlvIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnRyYW5zY3JpcHRpb25zID0gbmV3IFRyYW5zY3JpcHRpb25zQVBJLlRyYW5zY3JpcHRpb25zKHRoaXMuX2NsaWVudCk7XG4gICAgICAgIHRoaXMudHJhbnNsYXRpb25zID0gbmV3IFRyYW5zbGF0aW9uc0FQSS5UcmFuc2xhdGlvbnModGhpcy5fY2xpZW50KTtcbiAgICAgICAgdGhpcy5zcGVlY2ggPSBuZXcgU3BlZWNoQVBJLlNwZWVjaCh0aGlzLl9jbGllbnQpO1xuICAgIH1cbn1cbihmdW5jdGlvbiAoQXVkaW8pIHtcbiAgICBBdWRpby5UcmFuc2NyaXB0aW9ucyA9IFRyYW5zY3JpcHRpb25zQVBJLlRyYW5zY3JpcHRpb25zO1xuICAgIEF1ZGlvLlRyYW5zbGF0aW9ucyA9IFRyYW5zbGF0aW9uc0FQSS5UcmFuc2xhdGlvbnM7XG4gICAgQXVkaW8uU3BlZWNoID0gU3BlZWNoQVBJLlNwZWVjaDtcbn0pKEF1ZGlvIHx8IChBdWRpbyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdWRpby5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCIuLi9jb3JlLm1qc1wiO1xuaW1wb3J0ICogYXMgQmF0Y2hlc0FQSSBmcm9tIFwiLi9iYXRjaGVzLm1qc1wiO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSB9IGZyb20gXCIuLi9wYWdpbmF0aW9uLm1qc1wiO1xuZXhwb3J0IGNsYXNzIEJhdGNoZXMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgZXhlY3V0ZXMgYSBiYXRjaCBmcm9tIGFuIHVwbG9hZGVkIGZpbGUgb2YgcmVxdWVzdHNcbiAgICAgKi9cbiAgICBjcmVhdGUoYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9iYXRjaGVzJywgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBiYXRjaC5cbiAgICAgKi9cbiAgICByZXRyaWV2ZShiYXRjaElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvYmF0Y2hlcy8ke2JhdGNoSWR9YCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGxpc3QocXVlcnkgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Qoe30sIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoJy9iYXRjaGVzJywgQmF0Y2hlc1BhZ2UsIHsgcXVlcnksIC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYW4gaW4tcHJvZ3Jlc3MgYmF0Y2guIFRoZSBiYXRjaCB3aWxsIGJlIGluIHN0YXR1cyBgY2FuY2VsbGluZ2AgZm9yIHVwIHRvXG4gICAgICogMTAgbWludXRlcywgYmVmb3JlIGNoYW5naW5nIHRvIGBjYW5jZWxsZWRgLCB3aGVyZSBpdCB3aWxsIGhhdmUgcGFydGlhbCByZXN1bHRzXG4gICAgICogKGlmIGFueSkgYXZhaWxhYmxlIGluIHRoZSBvdXRwdXQgZmlsZS5cbiAgICAgKi9cbiAgICBjYW5jZWwoYmF0Y2hJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC9iYXRjaGVzLyR7YmF0Y2hJZH0vY2FuY2VsYCwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJhdGNoZXNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZSB7XG59XG4oZnVuY3Rpb24gKEJhdGNoZXMpIHtcbiAgICBCYXRjaGVzLkJhdGNoZXNQYWdlID0gQmF0Y2hlc0FQSS5CYXRjaGVzUGFnZTtcbn0pKEJhdGNoZXMgfHwgKEJhdGNoZXMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmF0Y2hlcy5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCIuLi8uLi9jb3JlLm1qc1wiO1xuaW1wb3J0ICogYXMgQXNzaXN0YW50c0FQSSBmcm9tIFwiLi9hc3Npc3RhbnRzLm1qc1wiO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSB9IGZyb20gXCIuLi8uLi9wYWdpbmF0aW9uLm1qc1wiO1xuZXhwb3J0IGNsYXNzIEFzc2lzdGFudHMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGFzc2lzdGFudCB3aXRoIGEgbW9kZWwgYW5kIGluc3RydWN0aW9ucy5cbiAgICAgKi9cbiAgICBjcmVhdGUoYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9hc3Npc3RhbnRzJywge1xuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuIGFzc2lzdGFudC5cbiAgICAgKi9cbiAgICByZXRyaWV2ZShhc3Npc3RhbnRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH1gLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIGFuIGFzc2lzdGFudC5cbiAgICAgKi9cbiAgICB1cGRhdGUoYXNzaXN0YW50SWQsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvYXNzaXN0YW50cy8ke2Fzc2lzdGFudElkfWAsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3QocXVlcnkgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Qoe30sIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoJy9hc3Npc3RhbnRzJywgQXNzaXN0YW50c1BhZ2UsIHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYW4gYXNzaXN0YW50LlxuICAgICAqL1xuICAgIGRlbChhc3Npc3RhbnRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH1gLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFzc2lzdGFudHNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZSB7XG59XG4oZnVuY3Rpb24gKEFzc2lzdGFudHMpIHtcbiAgICBBc3Npc3RhbnRzLkFzc2lzdGFudHNQYWdlID0gQXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRzUGFnZTtcbn0pKEFzc2lzdGFudHMgfHwgKEFzc2lzdGFudHMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzaXN0YW50cy5tanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGlzUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZShmbikge1xuICAgIHJldHVybiB0eXBlb2YgZm4ucGFyc2UgPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIFRoaXMgaXMgaGVscGVyIGNsYXNzIGZvciBwYXNzaW5nIGEgYGZ1bmN0aW9uYCBhbmQgYHBhcnNlYCB3aGVyZSB0aGUgYGZ1bmN0aW9uYFxuICogYXJndW1lbnQgdHlwZSBtYXRjaGVzIHRoZSBgcGFyc2VgIHJldHVybiB0eXBlLlxuICpcbiAqIEBkZXByZWNhdGVkIC0gcGxlYXNlIHVzZSBQYXJzaW5nVG9vbEZ1bmN0aW9uIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJzaW5nRnVuY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHRoaXMuZnVuY3Rpb24gPSBpbnB1dC5mdW5jdGlvbjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IGlucHV0LnBhcnNlO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBpbnB1dC5wYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gaW5wdXQuZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMubmFtZSA9IGlucHV0Lm5hbWU7XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGlzIGhlbHBlciBjbGFzcyBmb3IgcGFzc2luZyBhIGBmdW5jdGlvbmAgYW5kIGBwYXJzZWAgd2hlcmUgdGhlIGBmdW5jdGlvbmBcbiAqIGFyZ3VtZW50IHR5cGUgbWF0Y2hlcyB0aGUgYHBhcnNlYCByZXR1cm4gdHlwZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhcnNpbmdUb29sRnVuY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHRoaXMuZnVuY3Rpb24gPSBpbnB1dDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SdW5uYWJsZUZ1bmN0aW9uLm1qcy5tYXAiLCJleHBvcnQgY29uc3QgaXNBc3Npc3RhbnRNZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICByZXR1cm4gbWVzc2FnZT8ucm9sZSA9PT0gJ2Fzc2lzdGFudCc7XG59O1xuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb25NZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICByZXR1cm4gbWVzc2FnZT8ucm9sZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG5leHBvcnQgY29uc3QgaXNUb29sTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgcmV0dXJuIG1lc3NhZ2U/LnJvbGUgPT09ICd0b29sJztcbn07XG5leHBvcnQgZnVuY3Rpb24gaXNQcmVzZW50KG9iaikge1xuICAgIHJldHVybiBvYmogIT0gbnVsbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYXRDb21wbGV0aW9uVXRpbHMubWpzLm1hcCIsInZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfRXZlbnRTdHJlYW1faW5zdGFuY2VzLCBfRXZlbnRTdHJlYW1fY29ubmVjdGVkUHJvbWlzZSwgX0V2ZW50U3RyZWFtX3Jlc29sdmVDb25uZWN0ZWRQcm9taXNlLCBfRXZlbnRTdHJlYW1fcmVqZWN0Q29ubmVjdGVkUHJvbWlzZSwgX0V2ZW50U3RyZWFtX2VuZFByb21pc2UsIF9FdmVudFN0cmVhbV9yZXNvbHZlRW5kUHJvbWlzZSwgX0V2ZW50U3RyZWFtX3JlamVjdEVuZFByb21pc2UsIF9FdmVudFN0cmVhbV9saXN0ZW5lcnMsIF9FdmVudFN0cmVhbV9lbmRlZCwgX0V2ZW50U3RyZWFtX2Vycm9yZWQsIF9FdmVudFN0cmVhbV9hYm9ydGVkLCBfRXZlbnRTdHJlYW1fY2F0Y2hpbmdQcm9taXNlQ3JlYXRlZCwgX0V2ZW50U3RyZWFtX2hhbmRsZUVycm9yO1xuaW1wb3J0IHsgQVBJVXNlckFib3J0RXJyb3IsIE9wZW5BSUVycm9yIH0gZnJvbSAnb3BlbmFpL2Vycm9yJztcbmV4cG9ydCBjbGFzcyBFdmVudFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIF9FdmVudFN0cmVhbV9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIF9FdmVudFN0cmVhbV9jb25uZWN0ZWRQcm9taXNlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfRXZlbnRTdHJlYW1fcmVzb2x2ZUNvbm5lY3RlZFByb21pc2Uuc2V0KHRoaXMsICgpID0+IHsgfSk7XG4gICAgICAgIF9FdmVudFN0cmVhbV9yZWplY3RDb25uZWN0ZWRQcm9taXNlLnNldCh0aGlzLCAoKSA9PiB7IH0pO1xuICAgICAgICBfRXZlbnRTdHJlYW1fZW5kUHJvbWlzZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0V2ZW50U3RyZWFtX3Jlc29sdmVFbmRQcm9taXNlLnNldCh0aGlzLCAoKSA9PiB7IH0pO1xuICAgICAgICBfRXZlbnRTdHJlYW1fcmVqZWN0RW5kUHJvbWlzZS5zZXQodGhpcywgKCkgPT4geyB9KTtcbiAgICAgICAgX0V2ZW50U3RyZWFtX2xpc3RlbmVycy5zZXQodGhpcywge30pO1xuICAgICAgICBfRXZlbnRTdHJlYW1fZW5kZWQuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICAgICAgX0V2ZW50U3RyZWFtX2Vycm9yZWQuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICAgICAgX0V2ZW50U3RyZWFtX2Fib3J0ZWQuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICAgICAgX0V2ZW50U3RyZWFtX2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRXZlbnRTdHJlYW1fY29ubmVjdGVkUHJvbWlzZSwgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRXZlbnRTdHJlYW1fcmVzb2x2ZUNvbm5lY3RlZFByb21pc2UsIHJlc29sdmUsIFwiZlwiKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0V2ZW50U3RyZWFtX3JlamVjdENvbm5lY3RlZFByb21pc2UsIHJlamVjdCwgXCJmXCIpO1xuICAgICAgICB9KSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FdmVudFN0cmVhbV9lbmRQcm9taXNlLCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FdmVudFN0cmVhbV9yZXNvbHZlRW5kUHJvbWlzZSwgcmVzb2x2ZSwgXCJmXCIpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRXZlbnRTdHJlYW1fcmVqZWN0RW5kUHJvbWlzZSwgcmVqZWN0LCBcImZcIik7XG4gICAgICAgIH0pLCBcImZcIik7XG4gICAgICAgIC8vIERvbid0IGxldCB0aGVzZSBwcm9taXNlcyBjYXVzZSB1bmhhbmRsZWQgcmVqZWN0aW9uIGVycm9ycy5cbiAgICAgICAgLy8gd2Ugd2lsbCBtYW51YWxseSBjYXVzZSBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uIGVycm9yIGxhdGVyXG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIGhhc24ndCByZWdpc3RlcmVkIGFueSBlcnJvciBsaXN0ZW5lciBvciBjYWxsZWRcbiAgICAgICAgLy8gYW55IHByb21pc2UtcmV0dXJuaW5nIG1ldGhvZC5cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1fY29ubmVjdGVkUHJvbWlzZSwgXCJmXCIpLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50U3RyZWFtX2VuZFByb21pc2UsIFwiZlwiKS5jYXRjaCgoKSA9PiB7IH0pO1xuICAgIH1cbiAgICBfcnVuKGV4ZWN1dG9yKSB7XG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHkgaWYgd2UgY2FsbCBgZXhlY3V0b3IoKWAgaW1tZWRpYXRlbHkgd2UgZ2V0IHJ1bnRpbWUgZXJyb3JzIGFib3V0XG4gICAgICAgIC8vIHJlZmVyZW5jZXMgdG8gYHRoaXNgIGJlZm9yZSB0aGUgYHN1cGVyKClgIGNvbnN0cnVjdG9yIGNhbGwgcmV0dXJucy5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBleGVjdXRvcigpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRGaW5hbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2VuZCcpO1xuICAgICAgICAgICAgfSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX0V2ZW50U3RyZWFtX2hhbmRsZUVycm9yKS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIF9jb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudFN0cmVhbV9yZXNvbHZlQ29ubmVjdGVkUHJvbWlzZSwgXCJmXCIpLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2VtaXQoJ2Nvbm5lY3QnKTtcbiAgICB9XG4gICAgZ2V0IGVuZGVkKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1fZW5kZWQsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGVycm9yZWQoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudFN0cmVhbV9lcnJvcmVkLCBcImZcIik7XG4gICAgfVxuICAgIGdldCBhYm9ydGVkKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1fYWJvcnRlZCwgXCJmXCIpO1xuICAgIH1cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhlIGV2ZW50LlxuICAgICAqIE5vIGNoZWNrcyBhcmUgbWFkZSB0byBzZWUgaWYgdGhlIGxpc3RlbmVyIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQuIE11bHRpcGxlIGNhbGxzIHBhc3NpbmdcbiAgICAgKiB0aGUgc2FtZSBjb21iaW5hdGlvbiBvZiBldmVudCBhbmQgbGlzdGVuZXIgd2lsbCByZXN1bHQgaW4gdGhlIGxpc3RlbmVyIGJlaW5nIGFkZGVkLCBhbmRcbiAgICAgKiBjYWxsZWQsIG11bHRpcGxlIHRpbWVzLlxuICAgICAqIEByZXR1cm5zIHRoaXMgQ2hhdENvbXBsZXRpb25TdHJlYW0sIHNvIHRoYXQgY2FsbHMgY2FuIGJlIGNoYWluZWRcbiAgICAgKi9cbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1fbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdIHx8IChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudFN0cmVhbV9saXN0ZW5lcnMsIFwiZlwiKVtldmVudF0gPSBbXSk7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgZnJvbSB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBldmVudC5cbiAgICAgKiBvZmYoKSB3aWxsIHJlbW92ZSwgYXQgbW9zdCwgb25lIGluc3RhbmNlIG9mIGEgbGlzdGVuZXIgZnJvbSB0aGUgbGlzdGVuZXIgYXJyYXkuIElmIGFueSBzaW5nbGVcbiAgICAgKiBsaXN0ZW5lciBoYXMgYmVlbiBhZGRlZCBtdWx0aXBsZSB0aW1lcyB0byB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQsIHRoZW5cbiAgICAgKiBvZmYoKSBtdXN0IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byByZW1vdmUgZWFjaCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB0aGlzIENoYXRDb21wbGV0aW9uU3RyZWFtLCBzbyB0aGF0IGNhbGxzIGNhbiBiZSBjaGFpbmVkXG4gICAgICovXG4gICAgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudFN0cmVhbV9saXN0ZW5lcnMsIFwiZlwiKVtldmVudF07XG4gICAgICAgIGlmICghbGlzdGVuZXJzKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmZpbmRJbmRleCgobCkgPT4gbC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMClcbiAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG9uZS10aW1lIGxpc3RlbmVyIGZ1bmN0aW9uIGZvciB0aGUgZXZlbnQuIFRoZSBuZXh0IHRpbWUgdGhlIGV2ZW50IGlzIHRyaWdnZXJlZCxcbiAgICAgKiB0aGlzIGxpc3RlbmVyIGlzIHJlbW92ZWQgYW5kIHRoZW4gaW52b2tlZC5cbiAgICAgKiBAcmV0dXJucyB0aGlzIENoYXRDb21wbGV0aW9uU3RyZWFtLCBzbyB0aGF0IGNhbGxzIGNhbiBiZSBjaGFpbmVkXG4gICAgICovXG4gICAgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1fbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdIHx8IChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudFN0cmVhbV9saXN0ZW5lcnMsIFwiZlwiKVtldmVudF0gPSBbXSk7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHNpbWlsYXIgdG8gYC5vbmNlKClgLCBidXQgcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0aGUgbmV4dCB0aW1lXG4gICAgICogdGhlIGV2ZW50IGlzIHRyaWdnZXJlZCwgaW5zdGVhZCBvZiBjYWxsaW5nIGEgbGlzdGVuZXIgY2FsbGJhY2suXG4gICAgICogQHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdGhlIG5leHQgdGltZSBnaXZlbiBldmVudCBpcyB0cmlnZ2VyZWQsXG4gICAgICogb3IgcmVqZWN0cyBpZiBhbiBlcnJvciBpcyBlbWl0dGVkLiAgKElmIHlvdSByZXF1ZXN0IHRoZSAnZXJyb3InIGV2ZW50LFxuICAgICAqIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXJyb3IpLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHN0cmVhbS5lbWl0dGVkKCdtZXNzYWdlJykgLy8gcmVqZWN0cyBpZiB0aGUgc3RyZWFtIGVycm9yc1xuICAgICAqL1xuICAgIGVtaXR0ZWQoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0V2ZW50U3RyZWFtX2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQsIHRydWUsIFwiZlwiKTtcbiAgICAgICAgICAgIGlmIChldmVudCAhPT0gJ2Vycm9yJylcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICAgIHRoaXMub25jZShldmVudCwgcmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBkb25lKCkge1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FdmVudFN0cmVhbV9jYXRjaGluZ1Byb21pc2VDcmVhdGVkLCB0cnVlLCBcImZcIik7XG4gICAgICAgIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50U3RyZWFtX2VuZFByb21pc2UsIFwiZlwiKTtcbiAgICB9XG4gICAgX2VtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGRvbid0IGVtaXQgYW55IGV2ZW50cyBhZnRlciBlbmRcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50U3RyZWFtX2VuZGVkLCBcImZcIikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FdmVudFN0cmVhbV9lbmRlZCwgdHJ1ZSwgXCJmXCIpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1fcmVzb2x2ZUVuZFByb21pc2UsIFwiZlwiKS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50U3RyZWFtX2xpc3RlbmVycywgXCJmXCIpW2V2ZW50XTtcbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1fbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdID0gbGlzdGVuZXJzLmZpbHRlcigobCkgPT4gIWwub25jZSk7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lciguLi5hcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50ID09PSAnYWJvcnQnKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGFyZ3NbMF07XG4gICAgICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50U3RyZWFtX2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQsIFwiZlwiKSAmJiAhbGlzdGVuZXJzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudFN0cmVhbV9yZWplY3RDb25uZWN0ZWRQcm9taXNlLCBcImZcIikuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudFN0cmVhbV9yZWplY3RFbmRQcm9taXNlLCBcImZcIikuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdlbmQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IF9lbWl0KCdlcnJvcicsIGVycm9yKSBzaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSAjaGFuZGxlRXJyb3IoKS5cbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gYXJnc1swXTtcbiAgICAgICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1fY2F0Y2hpbmdQcm9taXNlQ3JlYXRlZCwgXCJmXCIpICYmICFsaXN0ZW5lcnM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgYW4gdW5oYW5kbGVkIHJlamVjdGlvbiBpZiB0aGUgdXNlciBoYXNuJ3QgcmVnaXN0ZXJlZCBhbnkgZXJyb3IgaGFuZGxlcnMuXG4gICAgICAgICAgICAgICAgLy8gSWYgeW91IGFyZSBzZWVpbmcgc3RhY2sgdHJhY2VzIGhlcmUsIG1ha2Ugc3VyZSB0byBoYW5kbGUgZXJyb3JzIHZpYSBlaXRoZXI6XG4gICAgICAgICAgICAgICAgLy8gLSBydW5uZXIub24oJ2Vycm9yJywgKCkgPT4gLi4uKVxuICAgICAgICAgICAgICAgIC8vIC0gYXdhaXQgcnVubmVyLmRvbmUoKVxuICAgICAgICAgICAgICAgIC8vIC0gYXdhaXQgcnVubmVyLmZpbmFsQ2hhdENvbXBsZXRpb24oKVxuICAgICAgICAgICAgICAgIC8vIC0gZXRjLlxuICAgICAgICAgICAgICAgIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50U3RyZWFtX3JlamVjdENvbm5lY3RlZFByb21pc2UsIFwiZlwiKS5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50U3RyZWFtX3JlamVjdEVuZFByb21pc2UsIFwiZlwiKS5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9lbWl0RmluYWwoKSB7IH1cbn1cbl9FdmVudFN0cmVhbV9jb25uZWN0ZWRQcm9taXNlID0gbmV3IFdlYWtNYXAoKSwgX0V2ZW50U3RyZWFtX3Jlc29sdmVDb25uZWN0ZWRQcm9taXNlID0gbmV3IFdlYWtNYXAoKSwgX0V2ZW50U3RyZWFtX3JlamVjdENvbm5lY3RlZFByb21pc2UgPSBuZXcgV2Vha01hcCgpLCBfRXZlbnRTdHJlYW1fZW5kUHJvbWlzZSA9IG5ldyBXZWFrTWFwKCksIF9FdmVudFN0cmVhbV9yZXNvbHZlRW5kUHJvbWlzZSA9IG5ldyBXZWFrTWFwKCksIF9FdmVudFN0cmVhbV9yZWplY3RFbmRQcm9taXNlID0gbmV3IFdlYWtNYXAoKSwgX0V2ZW50U3RyZWFtX2xpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCksIF9FdmVudFN0cmVhbV9lbmRlZCA9IG5ldyBXZWFrTWFwKCksIF9FdmVudFN0cmVhbV9lcnJvcmVkID0gbmV3IFdlYWtNYXAoKSwgX0V2ZW50U3RyZWFtX2Fib3J0ZWQgPSBuZXcgV2Vha01hcCgpLCBfRXZlbnRTdHJlYW1fY2F0Y2hpbmdQcm9taXNlQ3JlYXRlZCA9IG5ldyBXZWFrTWFwKCksIF9FdmVudFN0cmVhbV9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpLCBfRXZlbnRTdHJlYW1faGFuZGxlRXJyb3IgPSBmdW5jdGlvbiBfRXZlbnRTdHJlYW1faGFuZGxlRXJyb3IoZXJyb3IpIHtcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FdmVudFN0cmVhbV9lcnJvcmVkLCB0cnVlLCBcImZcIik7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIGVycm9yID0gbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFQSVVzZXJBYm9ydEVycm9yKSB7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0V2ZW50U3RyZWFtX2Fib3J0ZWQsIHRydWUsIFwiZlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXQoJ2Fib3J0JywgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBPcGVuQUlFcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGNvbnN0IG9wZW5BSUVycm9yID0gbmV3IE9wZW5BSUVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIG9wZW5BSUVycm9yLmNhdXNlID0gZXJyb3I7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbWl0KCdlcnJvcicsIG9wZW5BSUVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VtaXQoJ2Vycm9yJywgbmV3IE9wZW5BSUVycm9yKFN0cmluZyhlcnJvcikpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudFN0cmVhbS5tanMubWFwIiwiaW1wb3J0IHsgQ29udGVudEZpbHRlckZpbmlzaFJlYXNvbkVycm9yLCBMZW5ndGhGaW5pc2hSZWFzb25FcnJvciwgT3BlbkFJRXJyb3IgfSBmcm9tICdvcGVuYWkvZXJyb3InO1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQYXJzZWFibGVSZXNwb25zZUZvcm1hdChyZXNwb25zZV9mb3JtYXQsIHBhcnNlcikge1xuICAgIGNvbnN0IG9iaiA9IHsgLi4ucmVzcG9uc2VfZm9ybWF0IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqLCB7XG4gICAgICAgICRicmFuZDoge1xuICAgICAgICAgICAgdmFsdWU6ICdhdXRvLXBhcnNlYWJsZS1yZXNwb25zZS1mb3JtYXQnLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgICRwYXJzZVJhdzoge1xuICAgICAgICAgICAgdmFsdWU6IHBhcnNlcixcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRvUGFyc2FibGVSZXNwb25zZUZvcm1hdChyZXNwb25zZV9mb3JtYXQpIHtcbiAgICByZXR1cm4gcmVzcG9uc2VfZm9ybWF0Py5bJyRicmFuZCddID09PSAnYXV0by1wYXJzZWFibGUtcmVzcG9uc2UtZm9ybWF0Jztcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUGFyc2VhYmxlVG9vbCh0b29sLCB7IHBhcnNlciwgY2FsbGJhY2ssIH0pIHtcbiAgICBjb25zdCBvYmogPSB7IC4uLnRvb2wgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmosIHtcbiAgICAgICAgJGJyYW5kOiB7XG4gICAgICAgICAgICB2YWx1ZTogJ2F1dG8tcGFyc2VhYmxlLXRvb2wnLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgICRwYXJzZVJhdzoge1xuICAgICAgICAgICAgdmFsdWU6IHBhcnNlcixcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICAkY2FsbGJhY2s6IHtcbiAgICAgICAgICAgIHZhbHVlOiBjYWxsYmFjayxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRvUGFyc2FibGVUb29sKHRvb2wpIHtcbiAgICByZXR1cm4gdG9vbD8uWyckYnJhbmQnXSA9PT0gJ2F1dG8tcGFyc2VhYmxlLXRvb2wnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlUGFyc2VDaGF0Q29tcGxldGlvbihjb21wbGV0aW9uLCBwYXJhbXMpIHtcbiAgICBpZiAoIXBhcmFtcyB8fCAhaGFzQXV0b1BhcnNlYWJsZUlucHV0KHBhcmFtcykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbXBsZXRpb24sXG4gICAgICAgICAgICBjaG9pY2VzOiBjb21wbGV0aW9uLmNob2ljZXMubWFwKChjaG9pY2UpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uY2hvaWNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHsgLi4uY2hvaWNlLm1lc3NhZ2UsIHBhcnNlZDogbnVsbCwgdG9vbF9jYWxsczogY2hvaWNlLm1lc3NhZ2UudG9vbF9jYWxscyA/PyBbXSB9LFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VDaGF0Q29tcGxldGlvbihjb21wbGV0aW9uLCBwYXJhbXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ2hhdENvbXBsZXRpb24oY29tcGxldGlvbiwgcGFyYW1zKSB7XG4gICAgY29uc3QgY2hvaWNlcyA9IGNvbXBsZXRpb24uY2hvaWNlcy5tYXAoKGNob2ljZSkgPT4ge1xuICAgICAgICBpZiAoY2hvaWNlLmZpbmlzaF9yZWFzb24gPT09ICdsZW5ndGgnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTGVuZ3RoRmluaXNoUmVhc29uRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hvaWNlLmZpbmlzaF9yZWFzb24gPT09ICdjb250ZW50X2ZpbHRlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb250ZW50RmlsdGVyRmluaXNoUmVhc29uRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY2hvaWNlLFxuICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgIC4uLmNob2ljZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IGNob2ljZS5tZXNzYWdlLnRvb2xfY2FsbHM/Lm1hcCgodG9vbENhbGwpID0+IHBhcnNlVG9vbENhbGwocGFyYW1zLCB0b29sQ2FsbCkpID8/IFtdLFxuICAgICAgICAgICAgICAgIHBhcnNlZDogY2hvaWNlLm1lc3NhZ2UuY29udGVudCAmJiAhY2hvaWNlLm1lc3NhZ2UucmVmdXNhbCA/XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlUmVzcG9uc2VGb3JtYXQocGFyYW1zLCBjaG9pY2UubWVzc2FnZS5jb250ZW50KVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7IC4uLmNvbXBsZXRpb24sIGNob2ljZXMgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VGb3JtYXQocGFyYW1zLCBjb250ZW50KSB7XG4gICAgaWYgKHBhcmFtcy5yZXNwb25zZV9mb3JtYXQ/LnR5cGUgIT09ICdqc29uX3NjaGVtYScpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwYXJhbXMucmVzcG9uc2VfZm9ybWF0Py50eXBlID09PSAnanNvbl9zY2hlbWEnKSB7XG4gICAgICAgIGlmICgnJHBhcnNlUmF3JyBpbiBwYXJhbXMucmVzcG9uc2VfZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZV9mb3JtYXQgPSBwYXJhbXMucmVzcG9uc2VfZm9ybWF0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlX2Zvcm1hdC4kcGFyc2VSYXcoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoY29udGVudCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VUb29sQ2FsbChwYXJhbXMsIHRvb2xDYWxsKSB7XG4gICAgY29uc3QgaW5wdXRUb29sID0gcGFyYW1zLnRvb2xzPy5maW5kKChpbnB1dFRvb2wpID0+IGlucHV0VG9vbC5mdW5jdGlvbj8ubmFtZSA9PT0gdG9vbENhbGwuZnVuY3Rpb24ubmFtZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4udG9vbENhbGwsXG4gICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAuLi50b29sQ2FsbC5mdW5jdGlvbixcbiAgICAgICAgICAgIHBhcnNlZF9hcmd1bWVudHM6IGlzQXV0b1BhcnNhYmxlVG9vbChpbnB1dFRvb2wpID8gaW5wdXRUb29sLiRwYXJzZVJhdyh0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgOiBpbnB1dFRvb2w/LmZ1bmN0aW9uLnN0cmljdCA/IEpTT04ucGFyc2UodG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRQYXJzZVRvb2xDYWxsKHBhcmFtcywgdG9vbENhbGwpIHtcbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0VG9vbCA9IHBhcmFtcy50b29scz8uZmluZCgoaW5wdXRUb29sKSA9PiBpbnB1dFRvb2wuZnVuY3Rpb24/Lm5hbWUgPT09IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUpO1xuICAgIHJldHVybiBpc0F1dG9QYXJzYWJsZVRvb2woaW5wdXRUb29sKSB8fCBpbnB1dFRvb2w/LmZ1bmN0aW9uLnN0cmljdCB8fCBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNBdXRvUGFyc2VhYmxlSW5wdXQocGFyYW1zKSB7XG4gICAgaWYgKGlzQXV0b1BhcnNhYmxlUmVzcG9uc2VGb3JtYXQocGFyYW1zLnJlc3BvbnNlX2Zvcm1hdCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAocGFyYW1zLnRvb2xzPy5zb21lKCh0KSA9PiBpc0F1dG9QYXJzYWJsZVRvb2wodCkgfHwgKHQudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0LmZ1bmN0aW9uLnN0cmljdCA9PT0gdHJ1ZSkpID8/IGZhbHNlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUlucHV0VG9vbHModG9vbHMpIHtcbiAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbHMgPz8gW10pIHtcbiAgICAgICAgaWYgKHRvb2wudHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBDdXJyZW50bHkgb25seSBcXGBmdW5jdGlvblxcYCB0b29sIHR5cGVzIHN1cHBvcnQgYXV0by1wYXJzaW5nOyBSZWNlaXZlZCBcXGAke3Rvb2wudHlwZX1cXGBgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9vbC5mdW5jdGlvbi5zdHJpY3QgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgVGhlIFxcYCR7dG9vbC5mdW5jdGlvbi5uYW1lfVxcYCB0b29sIGlzIG5vdCBtYXJrZWQgd2l0aCBcXGBzdHJpY3Q6IHRydWVcXGAuIE9ubHkgc3RyaWN0IGZ1bmN0aW9uIHRvb2xzIGNhbiBiZSBhdXRvLXBhcnNlZGApO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VyLm1qcy5tYXAiLCJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9pbnN0YW5jZXMsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsQ29udGVudCwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxNZXNzYWdlLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbEZ1bmN0aW9uQ2FsbCwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxGdW5jdGlvbkNhbGxSZXN1bHQsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2NhbGN1bGF0ZVRvdGFsVXNhZ2UsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX3ZhbGlkYXRlUGFyYW1zLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9zdHJpbmdpZnlGdW5jdGlvbkNhbGxSZXN1bHQ7XG5pbXBvcnQgeyBPcGVuQUlFcnJvciB9IGZyb20gJ29wZW5haS9lcnJvcic7XG5pbXBvcnQgeyBpc1J1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2UsIH0gZnJvbSBcIi4vUnVubmFibGVGdW5jdGlvbi5tanNcIjtcbmltcG9ydCB7IGlzQXNzaXN0YW50TWVzc2FnZSwgaXNGdW5jdGlvbk1lc3NhZ2UsIGlzVG9vbE1lc3NhZ2UgfSBmcm9tIFwiLi9jaGF0Q29tcGxldGlvblV0aWxzLm1qc1wiO1xuaW1wb3J0IHsgRXZlbnRTdHJlYW0gfSBmcm9tIFwiLi9FdmVudFN0cmVhbS5tanNcIjtcbmltcG9ydCB7IGlzQXV0b1BhcnNhYmxlVG9vbCwgcGFyc2VDaGF0Q29tcGxldGlvbiB9IGZyb20gJ29wZW5haS9saWIvcGFyc2VyJztcbmNvbnN0IERFRkFVTFRfTUFYX0NIQVRfQ09NUExFVElPTlMgPSAxMDtcbmV4cG9ydCBjbGFzcyBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyIGV4dGVuZHMgRXZlbnRTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICB0aGlzLl9jaGF0Q29tcGxldGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgIH1cbiAgICBfYWRkQ2hhdENvbXBsZXRpb24oY2hhdENvbXBsZXRpb24pIHtcbiAgICAgICAgdGhpcy5fY2hhdENvbXBsZXRpb25zLnB1c2goY2hhdENvbXBsZXRpb24pO1xuICAgICAgICB0aGlzLl9lbWl0KCdjaGF0Q29tcGxldGlvbicsIGNoYXRDb21wbGV0aW9uKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNoYXRDb21wbGV0aW9uLmNob2ljZXNbMF0/Lm1lc3NhZ2U7XG4gICAgICAgIGlmIChtZXNzYWdlKVxuICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGNoYXRDb21wbGV0aW9uO1xuICAgIH1cbiAgICBfYWRkTWVzc2FnZShtZXNzYWdlLCBlbWl0ID0gdHJ1ZSkge1xuICAgICAgICBpZiAoISgnY29udGVudCcgaW4gbWVzc2FnZSkpXG4gICAgICAgICAgICBtZXNzYWdlLmNvbnRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoKGlzRnVuY3Rpb25NZXNzYWdlKG1lc3NhZ2UpIHx8IGlzVG9vbE1lc3NhZ2UobWVzc2FnZSkpICYmIG1lc3NhZ2UuY29udGVudCkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGUsIHRoaXMgYXNzdW1lcyB0aGF0IHtyb2xlOiAndG9vbCcsIGNvbnRlbnQ6IOKApn0gaXMgYWx3YXlzIHRoZSByZXN1bHQgb2YgYSBjYWxsIG9mIHRvb2wgb2YgdHlwZT1mdW5jdGlvbi5cbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCdmdW5jdGlvbkNhbGxSZXN1bHQnLCBtZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNBc3Npc3RhbnRNZXNzYWdlKG1lc3NhZ2UpICYmIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2Z1bmN0aW9uQ2FsbCcsIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2UobWVzc2FnZSkgJiYgbWVzc2FnZS50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b29sX2NhbGwgb2YgbWVzc2FnZS50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29sX2NhbGwudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgnZnVuY3Rpb25DYWxsJywgdG9vbF9jYWxsLmZ1bmN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBmaW5hbCBDaGF0Q29tcGxldGlvbiwgb3IgcmVqZWN0c1xuICAgICAqIGlmIGFuIGVycm9yIG9jY3VycmVkIG9yIHRoZSBzdHJlYW0gZW5kZWQgcHJlbWF0dXJlbHkgd2l0aG91dCBwcm9kdWNpbmcgYSBDaGF0Q29tcGxldGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBmaW5hbENoYXRDb21wbGV0aW9uKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICAgICAgY29uc3QgY29tcGxldGlvbiA9IHRoaXMuX2NoYXRDb21wbGV0aW9uc1t0aGlzLl9jaGF0Q29tcGxldGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICghY29tcGxldGlvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcignc3RyZWFtIGVuZGVkIHdpdGhvdXQgcHJvZHVjaW5nIGEgQ2hhdENvbXBsZXRpb24nKTtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGNvbnRlbnQgb2YgdGhlIGZpbmFsIENoYXRDb21wbGV0aW9uTWVzc2FnZSwgb3IgcmVqZWN0c1xuICAgICAqIGlmIGFuIGVycm9yIG9jY3VycmVkIG9yIHRoZSBzdHJlYW0gZW5kZWQgcHJlbWF0dXJlbHkgd2l0aG91dCBwcm9kdWNpbmcgYSBDaGF0Q29tcGxldGlvbk1lc3NhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgZmluYWxDb250ZW50KCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxDb250ZW50KS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSB0aGUgZmluYWwgYXNzaXN0YW50IENoYXRDb21wbGV0aW9uTWVzc2FnZSByZXNwb25zZSxcbiAgICAgKiBvciByZWplY3RzIGlmIGFuIGVycm9yIG9jY3VycmVkIG9yIHRoZSBzdHJlYW0gZW5kZWQgcHJlbWF0dXJlbHkgd2l0aG91dCBwcm9kdWNpbmcgYSBDaGF0Q29tcGxldGlvbk1lc3NhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgZmluYWxNZXNzYWdlKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxNZXNzYWdlKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBjb250ZW50IG9mIHRoZSBmaW5hbCBGdW5jdGlvbkNhbGwsIG9yIHJlamVjdHNcbiAgICAgKiBpZiBhbiBlcnJvciBvY2N1cnJlZCBvciB0aGUgc3RyZWFtIGVuZGVkIHByZW1hdHVyZWx5IHdpdGhvdXQgcHJvZHVjaW5nIGEgQ2hhdENvbXBsZXRpb25NZXNzYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIGZpbmFsRnVuY3Rpb25DYWxsKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxGdW5jdGlvbkNhbGwpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGFzeW5jIGZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0KCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxGdW5jdGlvbkNhbGxSZXN1bHQpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGFzeW5jIHRvdGFsVXNhZ2UoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9pbnN0YW5jZXMsIFwibVwiLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9jYWxjdWxhdGVUb3RhbFVzYWdlKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBhbGxDaGF0Q29tcGxldGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5fY2hhdENvbXBsZXRpb25zXTtcbiAgICB9XG4gICAgX2VtaXRGaW5hbCgpIHtcbiAgICAgICAgY29uc3QgY29tcGxldGlvbiA9IHRoaXMuX2NoYXRDb21wbGV0aW9uc1t0aGlzLl9jaGF0Q29tcGxldGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChjb21wbGV0aW9uKVxuICAgICAgICAgICAgdGhpcy5fZW1pdCgnZmluYWxDaGF0Q29tcGxldGlvbicsIGNvbXBsZXRpb24pO1xuICAgICAgICBjb25zdCBmaW5hbE1lc3NhZ2UgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2luc3RhbmNlcywgXCJtXCIsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsTWVzc2FnZSkuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKGZpbmFsTWVzc2FnZSlcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2ZpbmFsTWVzc2FnZScsIGZpbmFsTWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IGZpbmFsQ29udGVudCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxDb250ZW50KS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAoZmluYWxDb250ZW50KVxuICAgICAgICAgICAgdGhpcy5fZW1pdCgnZmluYWxDb250ZW50JywgZmluYWxDb250ZW50KTtcbiAgICAgICAgY29uc3QgZmluYWxGdW5jdGlvbkNhbGwgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2luc3RhbmNlcywgXCJtXCIsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsRnVuY3Rpb25DYWxsKS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAoZmluYWxGdW5jdGlvbkNhbGwpXG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdmaW5hbEZ1bmN0aW9uQ2FsbCcsIGZpbmFsRnVuY3Rpb25DYWxsKTtcbiAgICAgICAgY29uc3QgZmluYWxGdW5jdGlvbkNhbGxSZXN1bHQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2luc3RhbmNlcywgXCJtXCIsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0KS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAoZmluYWxGdW5jdGlvbkNhbGxSZXN1bHQgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2ZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0JywgZmluYWxGdW5jdGlvbkNhbGxSZXN1bHQpO1xuICAgICAgICBpZiAodGhpcy5fY2hhdENvbXBsZXRpb25zLnNvbWUoKGMpID0+IGMudXNhZ2UpKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCd0b3RhbFVzYWdlJywgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9pbnN0YW5jZXMsIFwibVwiLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9jYWxjdWxhdGVUb3RhbFVzYWdlKS5jYWxsKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfY3JlYXRlQ2hhdENvbXBsZXRpb24oY2xpZW50LCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9pbnN0YW5jZXMsIFwibVwiLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl92YWxpZGF0ZVBhcmFtcykuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBjaGF0Q29tcGxldGlvbiA9IGF3YWl0IGNsaWVudC5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7IC4uLnBhcmFtcywgc3RyZWFtOiBmYWxzZSB9LCB7IC4uLm9wdGlvbnMsIHNpZ25hbDogdGhpcy5jb250cm9sbGVyLnNpZ25hbCB9KTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGF0Q29tcGxldGlvbihwYXJzZUNoYXRDb21wbGV0aW9uKGNoYXRDb21wbGV0aW9uLCBwYXJhbXMpKTtcbiAgICB9XG4gICAgYXN5bmMgX3J1bkNoYXRDb21wbGV0aW9uKGNsaWVudCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwYXJhbXMubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UobWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9jcmVhdGVDaGF0Q29tcGxldGlvbihjbGllbnQsIHBhcmFtcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIF9ydW5GdW5jdGlvbnMoY2xpZW50LCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgcm9sZSA9ICdmdW5jdGlvbic7XG4gICAgICAgIGNvbnN0IHsgZnVuY3Rpb25fY2FsbCA9ICdhdXRvJywgc3RyZWFtLCAuLi5yZXN0UGFyYW1zIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IHNpbmdsZUZ1bmN0aW9uVG9DYWxsID0gdHlwZW9mIGZ1bmN0aW9uX2NhbGwgIT09ICdzdHJpbmcnICYmIGZ1bmN0aW9uX2NhbGw/Lm5hbWU7XG4gICAgICAgIGNvbnN0IHsgbWF4Q2hhdENvbXBsZXRpb25zID0gREVGQVVMVF9NQVhfQ0hBVF9DT01QTEVUSU9OUyB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25zQnlOYW1lID0ge307XG4gICAgICAgIGZvciAoY29uc3QgZiBvZiBwYXJhbXMuZnVuY3Rpb25zKSB7XG4gICAgICAgICAgICBmdW5jdGlvbnNCeU5hbWVbZi5uYW1lIHx8IGYuZnVuY3Rpb24ubmFtZV0gPSBmO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9ucyA9IHBhcmFtcy5mdW5jdGlvbnMubWFwKChmKSA9PiAoe1xuICAgICAgICAgICAgbmFtZTogZi5uYW1lIHx8IGYuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IGYucGFyYW1ldGVycyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBmLmRlc2NyaXB0aW9uLFxuICAgICAgICB9KSk7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwYXJhbXMubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UobWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4Q2hhdENvbXBsZXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXRDb21wbGV0aW9uID0gYXdhaXQgdGhpcy5fY3JlYXRlQ2hhdENvbXBsZXRpb24oY2xpZW50LCB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdFBhcmFtcyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9ucyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogWy4uLnRoaXMubWVzc2FnZXNdLFxuICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gY2hhdENvbXBsZXRpb24uY2hvaWNlc1swXT8ubWVzc2FnZTtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyBtZXNzYWdlIGluIENoYXRDb21wbGV0aW9uIHJlc3BvbnNlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UuZnVuY3Rpb25fY2FsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIGFyZ3VtZW50czogYXJncyB9ID0gbWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICAgICAgY29uc3QgZm4gPSBmdW5jdGlvbnNCeU5hbWVbbmFtZV07XG4gICAgICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGBJbnZhbGlkIGZ1bmN0aW9uX2NhbGw6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9LiBBdmFpbGFibGUgb3B0aW9ucyBhcmU6ICR7ZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGYpID0+IEpTT04uc3RyaW5naWZ5KGYubmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfS4gUGxlYXNlIHRyeSBhZ2FpbmA7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7IHJvbGUsIG5hbWUsIGNvbnRlbnQgfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaW5nbGVGdW5jdGlvblRvQ2FsbCAmJiBzaW5nbGVGdW5jdGlvblRvQ2FsbCAhPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBgSW52YWxpZCBmdW5jdGlvbl9jYWxsOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfS4gJHtKU09OLnN0cmluZ2lmeShzaW5nbGVGdW5jdGlvblRvQ2FsbCl9IHJlcXVlc3RlZC4gUGxlYXNlIHRyeSBhZ2FpbmA7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7IHJvbGUsIG5hbWUsIGNvbnRlbnQgfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGFyc2VkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBpc1J1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2UoZm4pID8gYXdhaXQgZm4ucGFyc2UoYXJncykgOiBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHJvbGUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaXQgY2FuJ3QgcnVsZSBvdXQgYG5ldmVyYCB0eXBlLlxuICAgICAgICAgICAgY29uc3QgcmF3Q29udGVudCA9IGF3YWl0IGZuLmZ1bmN0aW9uKHBhcnNlZCwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9pbnN0YW5jZXMsIFwibVwiLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9zdHJpbmdpZnlGdW5jdGlvbkNhbGxSZXN1bHQpLmNhbGwodGhpcywgcmF3Q29udGVudCk7XG4gICAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgbmFtZSwgY29udGVudCB9KTtcbiAgICAgICAgICAgIGlmIChzaW5nbGVGdW5jdGlvblRvQ2FsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3J1blRvb2xzKGNsaWVudCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJvbGUgPSAndG9vbCc7XG4gICAgICAgIGNvbnN0IHsgdG9vbF9jaG9pY2UgPSAnYXV0bycsIHN0cmVhbSwgLi4ucmVzdFBhcmFtcyB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCBzaW5nbGVGdW5jdGlvblRvQ2FsbCA9IHR5cGVvZiB0b29sX2Nob2ljZSAhPT0gJ3N0cmluZycgJiYgdG9vbF9jaG9pY2U/LmZ1bmN0aW9uPy5uYW1lO1xuICAgICAgICBjb25zdCB7IG1heENoYXRDb21wbGV0aW9ucyA9IERFRkFVTFRfTUFYX0NIQVRfQ09NUExFVElPTlMgfSA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIC8vIFRPRE8oc29tZWRheSk6IGNsZWFuIHRoaXMgbG9naWMgdXBcbiAgICAgICAgY29uc3QgaW5wdXRUb29scyA9IHBhcmFtcy50b29scy5tYXAoKHRvb2wpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0F1dG9QYXJzYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRvb2wuJGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcignVG9vbCBnaXZlbiB0byBgLnJ1blRvb2xzKClgIHRoYXQgZG9lcyBub3QgaGF2ZSBhbiBhc3NvY2lhdGVkIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjogdG9vbC4kY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5mdW5jdGlvbi5kZXNjcmlwdGlvbiB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHRvb2wuZnVuY3Rpb24ucGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlOiB0b29sLiRwYXJzZVJhdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvb2w7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmdW5jdGlvbnNCeU5hbWUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBmIG9mIGlucHV0VG9vbHMpIHtcbiAgICAgICAgICAgIGlmIChmLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbnNCeU5hbWVbZi5mdW5jdGlvbi5uYW1lIHx8IGYuZnVuY3Rpb24uZnVuY3Rpb24ubmFtZV0gPSBmLmZ1bmN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvb2xzID0gJ3Rvb2xzJyBpbiBwYXJhbXMgP1xuICAgICAgICAgICAgaW5wdXRUb29scy5tYXAoKHQpID0+IHQudHlwZSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdC5mdW5jdGlvbi5uYW1lIHx8IHQuZnVuY3Rpb24uZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHQuZnVuY3Rpb24ucGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0LmZ1bmN0aW9uLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0OiB0LmZ1bmN0aW9uLnN0cmljdCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB0KVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwYXJhbXMubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UobWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4Q2hhdENvbXBsZXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXRDb21wbGV0aW9uID0gYXdhaXQgdGhpcy5fY3JlYXRlQ2hhdENvbXBsZXRpb24oY2xpZW50LCB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdFBhcmFtcyxcbiAgICAgICAgICAgICAgICB0b29sX2Nob2ljZSxcbiAgICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogWy4uLnRoaXMubWVzc2FnZXNdLFxuICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gY2hhdENvbXBsZXRpb24uY2hvaWNlc1swXT8ubWVzc2FnZTtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyBtZXNzYWdlIGluIENoYXRDb21wbGV0aW9uIHJlc3BvbnNlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UudG9vbF9jYWxscz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sX2NhbGwgb2YgbWVzc2FnZS50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2xfY2FsbC50eXBlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sX2NhbGxfaWQgPSB0b29sX2NhbGwuaWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBhcmd1bWVudHM6IGFyZ3MgfSA9IHRvb2xfY2FsbC5mdW5jdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBmbiA9IGZ1bmN0aW9uc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBgSW52YWxpZCB0b29sX2NhbGw6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9LiBBdmFpbGFibGUgb3B0aW9ucyBhcmU6ICR7T2JqZWN0LmtleXMoZnVuY3Rpb25zQnlOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgobmFtZSkgPT4gSlNPTi5zdHJpbmdpZnkobmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKX0uIFBsZWFzZSB0cnkgYWdhaW5gO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgdG9vbF9jYWxsX2lkLCBjb250ZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2luZ2xlRnVuY3Rpb25Ub0NhbGwgJiYgc2luZ2xlRnVuY3Rpb25Ub0NhbGwgIT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGBJbnZhbGlkIHRvb2xfY2FsbDogJHtKU09OLnN0cmluZ2lmeShuYW1lKX0uICR7SlNPTi5zdHJpbmdpZnkoc2luZ2xlRnVuY3Rpb25Ub0NhbGwpfSByZXF1ZXN0ZWQuIFBsZWFzZSB0cnkgYWdhaW5gO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgdG9vbF9jYWxsX2lkLCBjb250ZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBpc1J1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2UoZm4pID8gYXdhaXQgZm4ucGFyc2UoYXJncykgOiBhcmdzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7IHJvbGUsIHRvb2xfY2FsbF9pZCwgY29udGVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaXQgY2FuJ3QgcnVsZSBvdXQgYG5ldmVyYCB0eXBlLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJhd0NvbnRlbnQgPSBhd2FpdCBmbi5mdW5jdGlvbihwYXJzZWQsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2luc3RhbmNlcywgXCJtXCIsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX3N0cmluZ2lmeUZ1bmN0aW9uQ2FsbFJlc3VsdCkuY2FsbCh0aGlzLCByYXdDb250ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgdG9vbF9jYWxsX2lkLCBjb250ZW50IH0pO1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVGdW5jdGlvblRvQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG5fQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbENvbnRlbnQgPSBmdW5jdGlvbiBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxNZXNzYWdlKS5jYWxsKHRoaXMpLmNvbnRlbnQgPz8gbnVsbDtcbn0sIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsTWVzc2FnZSA9IGZ1bmN0aW9uIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsTWVzc2FnZSgpIHtcbiAgICBsZXQgaSA9IHRoaXMubWVzc2FnZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW2ldO1xuICAgICAgICBpZiAoaXNBc3Npc3RhbnRNZXNzYWdlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZ1bmN0aW9uX2NhbGwsIC4uLnJlc3QgfSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQgPz8gbnVsbCxcbiAgICAgICAgICAgICAgICByZWZ1c2FsOiBtZXNzYWdlLnJlZnVzYWwgPz8gbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25fY2FsbCkge1xuICAgICAgICAgICAgICAgIHJldC5mdW5jdGlvbl9jYWxsID0gZnVuY3Rpb25fY2FsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKCdzdHJlYW0gZW5kZWQgd2l0aG91dCBwcm9kdWNpbmcgYSBDaGF0Q29tcGxldGlvbk1lc3NhZ2Ugd2l0aCByb2xlPWFzc2lzdGFudCcpO1xufSwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbEZ1bmN0aW9uQ2FsbCgpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5tZXNzYWdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5tZXNzYWdlc1tpXTtcbiAgICAgICAgaWYgKGlzQXNzaXN0YW50TWVzc2FnZShtZXNzYWdlKSAmJiBtZXNzYWdlPy5mdW5jdGlvbl9jYWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2UobWVzc2FnZSkgJiYgbWVzc2FnZT8udG9vbF9jYWxscz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZS50b29sX2NhbGxzLmF0KC0xKT8uZnVuY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufSwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxGdW5jdGlvbkNhbGxSZXN1bHQgPSBmdW5jdGlvbiBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbEZ1bmN0aW9uQ2FsbFJlc3VsdCgpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5tZXNzYWdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5tZXNzYWdlc1tpXTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25NZXNzYWdlKG1lc3NhZ2UpICYmIG1lc3NhZ2UuY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Rvb2xNZXNzYWdlKG1lc3NhZ2UpICYmXG4gICAgICAgICAgICBtZXNzYWdlLmNvbnRlbnQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZXMuc29tZSgoeCkgPT4geC5yb2xlID09PSAnYXNzaXN0YW50JyAmJlxuICAgICAgICAgICAgICAgIHgudG9vbF9jYWxscz8uc29tZSgoeSkgPT4geS50eXBlID09PSAnZnVuY3Rpb24nICYmIHkuaWQgPT09IG1lc3NhZ2UudG9vbF9jYWxsX2lkKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufSwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfY2FsY3VsYXRlVG90YWxVc2FnZSA9IGZ1bmN0aW9uIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2NhbGN1bGF0ZVRvdGFsVXNhZ2UoKSB7XG4gICAgY29uc3QgdG90YWwgPSB7XG4gICAgICAgIGNvbXBsZXRpb25fdG9rZW5zOiAwLFxuICAgICAgICBwcm9tcHRfdG9rZW5zOiAwLFxuICAgICAgICB0b3RhbF90b2tlbnM6IDAsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHsgdXNhZ2UgfSBvZiB0aGlzLl9jaGF0Q29tcGxldGlvbnMpIHtcbiAgICAgICAgaWYgKHVzYWdlKSB7XG4gICAgICAgICAgICB0b3RhbC5jb21wbGV0aW9uX3Rva2VucyArPSB1c2FnZS5jb21wbGV0aW9uX3Rva2VucztcbiAgICAgICAgICAgIHRvdGFsLnByb21wdF90b2tlbnMgKz0gdXNhZ2UucHJvbXB0X3Rva2VucztcbiAgICAgICAgICAgIHRvdGFsLnRvdGFsX3Rva2VucyArPSB1c2FnZS50b3RhbF90b2tlbnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xufSwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfdmFsaWRhdGVQYXJhbXMgPSBmdW5jdGlvbiBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl92YWxpZGF0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zLm4gIT0gbnVsbCAmJiBwYXJhbXMubiA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKCdDaGF0Q29tcGxldGlvbiBjb252ZW5pZW5jZSBoZWxwZXJzIG9ubHkgc3VwcG9ydCBuPTEgYXQgdGhpcyB0aW1lLiBUbyB1c2Ugbj4xLCBwbGVhc2UgdXNlIGNoYXQuY29tcGxldGlvbnMuY3JlYXRlKCkgZGlyZWN0bHkuJyk7XG4gICAgfVxufSwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfc3RyaW5naWZ5RnVuY3Rpb25DYWxsUmVzdWx0ID0gZnVuY3Rpb24gX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfc3RyaW5naWZ5RnVuY3Rpb25DYWxsUmVzdWx0KHJhd0NvbnRlbnQpIHtcbiAgICByZXR1cm4gKHR5cGVvZiByYXdDb250ZW50ID09PSAnc3RyaW5nJyA/IHJhd0NvbnRlbnRcbiAgICAgICAgOiByYXdDb250ZW50ID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShyYXdDb250ZW50KSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lci5tanMubWFwIiwiaW1wb3J0IHsgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lciwgfSBmcm9tIFwiLi9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyLm1qc1wiO1xuaW1wb3J0IHsgaXNBc3Npc3RhbnRNZXNzYWdlIH0gZnJvbSBcIi4vY2hhdENvbXBsZXRpb25VdGlscy5tanNcIjtcbmV4cG9ydCBjbGFzcyBDaGF0Q29tcGxldGlvblJ1bm5lciBleHRlbmRzIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXIge1xuICAgIC8qKiBAZGVwcmVjYXRlZCAtIHBsZWFzZSB1c2UgYHJ1blRvb2xzYCBpbnN0ZWFkLiAqL1xuICAgIHN0YXRpYyBydW5GdW5jdGlvbnMoY2xpZW50LCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gbmV3IENoYXRDb21wbGV0aW9uUnVubmVyKCk7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtSGVscGVyLU1ldGhvZCc6ICdydW5GdW5jdGlvbnMnIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fcnVuRnVuY3Rpb25zKGNsaWVudCwgcGFyYW1zLCBvcHRzKSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIHN0YXRpYyBydW5Ub29scyhjbGllbnQsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBuZXcgQ2hhdENvbXBsZXRpb25SdW5uZXIoKTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3J1blRvb2xzJyB9LFxuICAgICAgICB9O1xuICAgICAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX3J1blRvb2xzKGNsaWVudCwgcGFyYW1zLCBvcHRzKSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIF9hZGRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIuX2FkZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2UobWVzc2FnZSkgJiYgbWVzc2FnZS5jb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdjb250ZW50JywgbWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoYXRDb21wbGV0aW9uUnVubmVyLm1qcy5tYXAiLCJjb25zdCB0b2tlbml6ZSA9IChpbnB1dCkgPT4ge1xuICAgIGxldCBjdXJyZW50ID0gMDtcbiAgICBsZXQgdG9rZW5zID0gW107XG4gICAgd2hpbGUgKGN1cnJlbnQgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGNoYXIgPSBpbnB1dFtjdXJyZW50XTtcbiAgICAgICAgaWYgKGNoYXIgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09ICd7Jykge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdicmFjZScsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICd7JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09ICd9Jykge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdicmFjZScsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICd9JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09ICdbJykge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwYXJlbicsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICdbJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09ICddJykge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwYXJlbicsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICddJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09ICc6Jykge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzZXBhcmF0b3InLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnOicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnJlbnQrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSAnLCcpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGVsaW1pdGVyJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJywnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJ1wiJykge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gJyc7XG4gICAgICAgICAgICBsZXQgZGFuZ2xpbmdRdW90ZSA9IGZhbHNlO1xuICAgICAgICAgICAgY2hhciA9IGlucHV0WysrY3VycmVudF07XG4gICAgICAgICAgICB3aGlsZSAoY2hhciAhPT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGFuZ2xpbmdRdW90ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGFuZ2xpbmdRdW90ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBjaGFyICsgaW5wdXRbY3VycmVudF07XG4gICAgICAgICAgICAgICAgICAgIGNoYXIgPSBpbnB1dFsrK2N1cnJlbnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgY2hhciA9IGlucHV0WysrY3VycmVudF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhciA9IGlucHV0WysrY3VycmVudF07XG4gICAgICAgICAgICBpZiAoIWRhbmdsaW5nUXVvdGUpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBXSElURVNQQUNFID0gL1xccy87XG4gICAgICAgIGlmIChjaGFyICYmIFdISVRFU1BBQ0UudGVzdChjaGFyKSkge1xuICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IE5VTUJFUlMgPSAvWzAtOV0vO1xuICAgICAgICBpZiAoKGNoYXIgJiYgTlVNQkVSUy50ZXN0KGNoYXIpKSB8fCBjaGFyID09PSAnLScgfHwgY2hhciA9PT0gJy4nKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBjaGFyO1xuICAgICAgICAgICAgICAgIGNoYXIgPSBpbnB1dFsrK2N1cnJlbnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKChjaGFyICYmIE5VTUJFUlMudGVzdChjaGFyKSkgfHwgY2hhciA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gY2hhcjtcbiAgICAgICAgICAgICAgICBjaGFyID0gaW5wdXRbKytjdXJyZW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IExFVFRFUlMgPSAvW2Etel0vaTtcbiAgICAgICAgaWYgKGNoYXIgJiYgTEVUVEVSUy50ZXN0KGNoYXIpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIHdoaWxlIChjaGFyICYmIExFVFRFUlMudGVzdChjaGFyKSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlICs9IGNoYXI7XG4gICAgICAgICAgICAgICAgY2hhciA9IGlucHV0WysrY3VycmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gJ3RydWUnIHx8IHZhbHVlID09ICdmYWxzZScgfHwgdmFsdWUgPT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ25hbWUnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVua25vd24gdG9rZW4sIGUuZy4gYG51bGAgd2hpY2ggaXNuJ3QgcXVpdGUgYG51bGxgXG4gICAgICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCsrO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zO1xufSwgc3RyaXAgPSAodG9rZW5zKSA9PiB7XG4gICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgbGV0IGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgc3dpdGNoIChsYXN0VG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdzZXBhcmF0b3InOlxuICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLnNsaWNlKDAsIHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJpcCh0b2tlbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBsZXQgbGFzdENoYXJhY3Rlck9mTGFzdFRva2VuID0gbGFzdFRva2VuLnZhbHVlW2xhc3RUb2tlbi52YWx1ZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0Q2hhcmFjdGVyT2ZMYXN0VG9rZW4gPT09ICcuJyB8fCBsYXN0Q2hhcmFjdGVyT2ZMYXN0VG9rZW4gPT09ICctJykge1xuICAgICAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5zbGljZSgwLCB0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmlwKHRva2Vucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBsZXQgdG9rZW5CZWZvcmVUaGVMYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgaWYgKHRva2VuQmVmb3JlVGhlTGFzdFRva2VuPy50eXBlID09PSAnZGVsaW1pdGVyJykge1xuICAgICAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5zbGljZSgwLCB0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmlwKHRva2Vucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbkJlZm9yZVRoZUxhc3RUb2tlbj8udHlwZSA9PT0gJ2JyYWNlJyAmJiB0b2tlbkJlZm9yZVRoZUxhc3RUb2tlbi52YWx1ZSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLnNsaWNlKDAsIHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaXAodG9rZW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkZWxpbWl0ZXInOlxuICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLnNsaWNlKDAsIHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJpcCh0b2tlbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnM7XG59LCB1bnN0cmlwID0gKHRva2VucykgPT4ge1xuICAgIGxldCB0YWlsID0gW107XG4gICAgdG9rZW5zLm1hcCgodG9rZW4pID0+IHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdicmFjZScpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgdGFpbC5wdXNoKCd9Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YWlsLnNwbGljZSh0YWlsLmxhc3RJbmRleE9mKCd9JyksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAncGFyZW4nKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdbJykge1xuICAgICAgICAgICAgICAgIHRhaWwucHVzaCgnXScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFpbC5zcGxpY2UodGFpbC5sYXN0SW5kZXhPZignXScpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0YWlsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGFpbC5yZXZlcnNlKCkubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYnJhY2UnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ30nLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbSA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGFyZW4nLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ10nLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2Vucztcbn0sIGdlbmVyYXRlID0gKHRva2VucykgPT4ge1xuICAgIGxldCBvdXRwdXQgPSAnJztcbiAgICB0b2tlbnMubWFwKCh0b2tlbikgPT4ge1xuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICdcIicgKyB0b2tlbi52YWx1ZSArICdcIic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG91dHB1dCArPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvdXRwdXQ7XG59LCBwYXJ0aWFsUGFyc2UgPSAoaW5wdXQpID0+IEpTT04ucGFyc2UoZ2VuZXJhdGUodW5zdHJpcChzdHJpcCh0b2tlbml6ZShpbnB1dCkpKSkpO1xuZXhwb3J0IHsgcGFydGlhbFBhcnNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZXIubWpzLm1hcCIsInZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQ2hhdENvbXBsZXRpb25TdHJlYW1faW5zdGFuY2VzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fcGFyYW1zLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fY2hvaWNlRXZlbnRTdGF0ZXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9jdXJyZW50Q2hhdENvbXBsZXRpb25TbmFwc2hvdCwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2JlZ2luUmVxdWVzdCwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2dldENob2ljZUV2ZW50U3RhdGUsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9hZGRDaHVuaywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRUb29sQ2FsbERvbmVFdmVudCwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRDb250ZW50RG9uZUV2ZW50cywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VuZFJlcXVlc3QsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9hY2N1bXVsYXRlQ2hhdENvbXBsZXRpb247XG5pbXBvcnQgeyBPcGVuQUlFcnJvciwgQVBJVXNlckFib3J0RXJyb3IsIExlbmd0aEZpbmlzaFJlYXNvbkVycm9yLCBDb250ZW50RmlsdGVyRmluaXNoUmVhc29uRXJyb3IsIH0gZnJvbSAnb3BlbmFpL2Vycm9yJztcbmltcG9ydCB7IEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXIsIH0gZnJvbSBcIi4vQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lci5tanNcIjtcbmltcG9ydCB7IFN0cmVhbSB9IGZyb20gJ29wZW5haS9zdHJlYW1pbmcnO1xuaW1wb3J0IHsgaGFzQXV0b1BhcnNlYWJsZUlucHV0LCBpc0F1dG9QYXJzYWJsZVJlc3BvbnNlRm9ybWF0LCBpc0F1dG9QYXJzYWJsZVRvb2wsIG1heWJlUGFyc2VDaGF0Q29tcGxldGlvbiwgc2hvdWxkUGFyc2VUb29sQ2FsbCwgfSBmcm9tICdvcGVuYWkvbGliL3BhcnNlcic7XG5pbXBvcnQgeyBwYXJ0aWFsUGFyc2UgfSBmcm9tIFwiLi4vX3ZlbmRvci9wYXJ0aWFsLWpzb24tcGFyc2VyL3BhcnNlci5tanNcIjtcbmV4cG9ydCBjbGFzcyBDaGF0Q29tcGxldGlvblN0cmVhbSBleHRlbmRzIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBfQ2hhdENvbXBsZXRpb25TdHJlYW1faW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgX0NoYXRDb21wbGV0aW9uU3RyZWFtX3BhcmFtcy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2Nob2ljZUV2ZW50U3RhdGVzLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ2hhdENvbXBsZXRpb25TdHJlYW1fY3VycmVudENoYXRDb21wbGV0aW9uU25hcHNob3Quc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX3BhcmFtcywgcGFyYW1zLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2Nob2ljZUV2ZW50U3RhdGVzLCBbXSwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudENoYXRDb21wbGV0aW9uU25hcHNob3QoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9jdXJyZW50Q2hhdENvbXBsZXRpb25TbmFwc2hvdCwgXCJmXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlbmRlZCBmb3IgdXNlIG9uIHRoZSBmcm9udGVuZCwgY29uc3VtaW5nIGEgc3RyZWFtIHByb2R1Y2VkIHdpdGhcbiAgICAgKiBgLnRvUmVhZGFibGVTdHJlYW0oKWAgb24gdGhlIGJhY2tlbmQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgbWVzc2FnZXMgc2VudCB0byB0aGUgbW9kZWwgZG8gbm90IGFwcGVhciBpbiBgLm9uKCdtZXNzYWdlJylgXG4gICAgICogaW4gdGhpcyBjb250ZXh0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBDaGF0Q29tcGxldGlvblN0cmVhbShudWxsKTtcbiAgICAgICAgcnVubmVyLl9ydW4oKCkgPT4gcnVubmVyLl9mcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVDaGF0Q29tcGxldGlvbihjbGllbnQsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBuZXcgQ2hhdENvbXBsZXRpb25TdHJlYW0ocGFyYW1zKTtcbiAgICAgICAgcnVubmVyLl9ydW4oKCkgPT4gcnVubmVyLl9ydW5DaGF0Q29tcGxldGlvbihjbGllbnQsIHsgLi4ucGFyYW1zLCBzdHJlYW06IHRydWUgfSwgeyAuLi5vcHRpb25zLCBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3N0cmVhbScgfSB9KSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIGFzeW5jIF9jcmVhdGVDaGF0Q29tcGxldGlvbihjbGllbnQsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBzdXBlci5fY3JlYXRlQ2hhdENvbXBsZXRpb247XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnM/LnNpZ25hbDtcbiAgICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gdGhpcy5jb250cm9sbGVyLmFib3J0KCkpO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9iZWdpblJlcXVlc3QpLmNhbGwodGhpcyk7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IGNsaWVudC5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7IC4uLnBhcmFtcywgc3RyZWFtOiB0cnVlIH0sIHsgLi4ub3B0aW9ucywgc2lnbmFsOiB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsIH0pO1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWQoKTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9hZGRDaHVuaykuY2FsbCh0aGlzLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5jb250cm9sbGVyLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoYXRDb21wbGV0aW9uKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9lbmRSZXF1ZXN0KS5jYWxsKHRoaXMpKTtcbiAgICB9XG4gICAgYXN5bmMgX2Zyb21SZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZClcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRoaXMuY29udHJvbGxlci5hYm9ydCgpKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fYmVnaW5SZXF1ZXN0KS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWQoKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSwgdGhpcy5jb250cm9sbGVyKTtcbiAgICAgICAgbGV0IGNoYXRJZDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgIGlmIChjaGF0SWQgJiYgY2hhdElkICE9PSBjaHVuay5pZCkge1xuICAgICAgICAgICAgICAgIC8vIEEgbmV3IHJlcXVlc3QgaGFzIGJlZW4gbWFkZS5cbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRDaGF0Q29tcGxldGlvbihfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fZW5kUmVxdWVzdCkuY2FsbCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fYWRkQ2h1bmspLmNhbGwodGhpcywgY2h1bmspO1xuICAgICAgICAgICAgY2hhdElkID0gY2h1bmsuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5jb250cm9sbGVyLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoYXRDb21wbGV0aW9uKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9lbmRSZXF1ZXN0KS5jYWxsKHRoaXMpKTtcbiAgICB9XG4gICAgWyhfQ2hhdENvbXBsZXRpb25TdHJlYW1fcGFyYW1zID0gbmV3IFdlYWtNYXAoKSwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2Nob2ljZUV2ZW50U3RhdGVzID0gbmV3IFdlYWtNYXAoKSwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2N1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90ID0gbmV3IFdlYWtNYXAoKSwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9DaGF0Q29tcGxldGlvblN0cmVhbV9iZWdpblJlcXVlc3QgPSBmdW5jdGlvbiBfQ2hhdENvbXBsZXRpb25TdHJlYW1fYmVnaW5SZXF1ZXN0KCkge1xuICAgICAgICBpZiAodGhpcy5lbmRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fY3VycmVudENoYXRDb21wbGV0aW9uU25hcHNob3QsIHVuZGVmaW5lZCwgXCJmXCIpO1xuICAgIH0sIF9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRDaG9pY2VFdmVudFN0YXRlID0gZnVuY3Rpb24gX0NoYXRDb21wbGV0aW9uU3RyZWFtX2dldENob2ljZUV2ZW50U3RhdGUoY2hvaWNlKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2Nob2ljZUV2ZW50U3RhdGVzLCBcImZcIilbY2hvaWNlLmluZGV4XTtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICBjb250ZW50X2RvbmU6IGZhbHNlLFxuICAgICAgICAgICAgcmVmdXNhbF9kb25lOiBmYWxzZSxcbiAgICAgICAgICAgIGxvZ3Byb2JzX2NvbnRlbnRfZG9uZTogZmFsc2UsXG4gICAgICAgICAgICBsb2dwcm9ic19yZWZ1c2FsX2RvbmU6IGZhbHNlLFxuICAgICAgICAgICAgZG9uZV90b29sX2NhbGxzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICBjdXJyZW50X3Rvb2xfY2FsbF9pbmRleDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fY2hvaWNlRXZlbnRTdGF0ZXMsIFwiZlwiKVtjaG9pY2UuaW5kZXhdID0gc3RhdGU7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fYWRkQ2h1bmsgPSBmdW5jdGlvbiBfQ2hhdENvbXBsZXRpb25TdHJlYW1fYWRkQ2h1bmsoY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGNvbXBsZXRpb24gPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fYWNjdW11bGF0ZUNoYXRDb21wbGV0aW9uKS5jYWxsKHRoaXMsIGNodW5rKTtcbiAgICAgICAgdGhpcy5fZW1pdCgnY2h1bmsnLCBjaHVuaywgY29tcGxldGlvbik7XG4gICAgICAgIGZvciAoY29uc3QgY2hvaWNlIG9mIGNodW5rLmNob2ljZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNob2ljZVNuYXBzaG90ID0gY29tcGxldGlvbi5jaG9pY2VzW2Nob2ljZS5pbmRleF07XG4gICAgICAgICAgICBpZiAoY2hvaWNlLmRlbHRhLmNvbnRlbnQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIGNob2ljZVNuYXBzaG90Lm1lc3NhZ2U/LnJvbGUgPT09ICdhc3Npc3RhbnQnICYmXG4gICAgICAgICAgICAgICAgY2hvaWNlU25hcHNob3QubWVzc2FnZT8uY29udGVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2NvbnRlbnQnLCBjaG9pY2UuZGVsdGEuY29udGVudCwgY2hvaWNlU25hcHNob3QubWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCdjb250ZW50LmRlbHRhJywge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YTogY2hvaWNlLmRlbHRhLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHNuYXBzaG90OiBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZDogY2hvaWNlU25hcHNob3QubWVzc2FnZS5wYXJzZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hvaWNlLmRlbHRhLnJlZnVzYWwgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIGNob2ljZVNuYXBzaG90Lm1lc3NhZ2U/LnJvbGUgPT09ICdhc3Npc3RhbnQnICYmXG4gICAgICAgICAgICAgICAgY2hvaWNlU25hcHNob3QubWVzc2FnZT8ucmVmdXNhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3JlZnVzYWwuZGVsdGEnLCB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhOiBjaG9pY2UuZGVsdGEucmVmdXNhbCxcbiAgICAgICAgICAgICAgICAgICAgc25hcHNob3Q6IGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UucmVmdXNhbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaG9pY2UubG9ncHJvYnM/LmNvbnRlbnQgIT0gbnVsbCAmJiBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlPy5yb2xlID09PSAnYXNzaXN0YW50Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2xvZ3Byb2JzLmNvbnRlbnQuZGVsdGEnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNob2ljZS5sb2dwcm9icz8uY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgc25hcHNob3Q6IGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzPy5jb250ZW50ID8/IFtdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNob2ljZS5sb2dwcm9icz8ucmVmdXNhbCAhPSBudWxsICYmIGNob2ljZVNuYXBzaG90Lm1lc3NhZ2U/LnJvbGUgPT09ICdhc3Npc3RhbnQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgnbG9ncHJvYnMucmVmdXNhbC5kZWx0YScsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmdXNhbDogY2hvaWNlLmxvZ3Byb2JzPy5yZWZ1c2FsLFxuICAgICAgICAgICAgICAgICAgICBzbmFwc2hvdDogY2hvaWNlU25hcHNob3QubG9ncHJvYnM/LnJlZnVzYWwgPz8gW10sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRDaG9pY2VFdmVudFN0YXRlKS5jYWxsKHRoaXMsIGNob2ljZVNuYXBzaG90KTtcbiAgICAgICAgICAgIGlmIChjaG9pY2VTbmFwc2hvdC5maW5pc2hfcmVhc29uKSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRDb250ZW50RG9uZUV2ZW50cykuY2FsbCh0aGlzLCBjaG9pY2VTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRfdG9vbF9jYWxsX2luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRUb29sQ2FsbERvbmVFdmVudCkuY2FsbCh0aGlzLCBjaG9pY2VTbmFwc2hvdCwgc3RhdGUuY3VycmVudF90b29sX2NhbGxfaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgY2hvaWNlLmRlbHRhLnRvb2xfY2FsbHMgPz8gW10pIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuY3VycmVudF90b29sX2NhbGxfaW5kZXggIT09IHRvb2xDYWxsLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9lbWl0Q29udGVudERvbmVFdmVudHMpLmNhbGwodGhpcywgY2hvaWNlU25hcHNob3QpO1xuICAgICAgICAgICAgICAgICAgICAvLyBuZXcgdG9vbCBjYWxsIHN0YXJ0ZWQsIHRoZSBwcmV2aW91cyBvbmUgaXMgZG9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuY3VycmVudF90b29sX2NhbGxfaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRUb29sQ2FsbERvbmVFdmVudCkuY2FsbCh0aGlzLCBjaG9pY2VTbmFwc2hvdCwgc3RhdGUuY3VycmVudF90b29sX2NhbGxfaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRfdG9vbF9jYWxsX2luZGV4ID0gdG9vbENhbGwuaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsRGVsdGEgb2YgY2hvaWNlLmRlbHRhLnRvb2xfY2FsbHMgPz8gW10pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sQ2FsbFNuYXBzaG90ID0gY2hvaWNlU25hcHNob3QubWVzc2FnZS50b29sX2NhbGxzPy5bdG9vbENhbGxEZWx0YS5pbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKCF0b29sQ2FsbFNuYXBzaG90Py50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9vbENhbGxTbmFwc2hvdD8udHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCd0b29sX2NhbGxzLmZ1bmN0aW9uLmFyZ3VtZW50cy5kZWx0YScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRvb2xDYWxsU25hcHNob3QuZnVuY3Rpb24/Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogdG9vbENhbGxEZWx0YS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogdG9vbENhbGxTbmFwc2hvdC5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRfYXJndW1lbnRzOiB0b29sQ2FsbFNuYXBzaG90LmZ1bmN0aW9uLnBhcnNlZF9hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNfZGVsdGE6IHRvb2xDYWxsRGVsdGEuZnVuY3Rpb24/LmFyZ3VtZW50cyA/PyAnJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnROZXZlcih0b29sQ2FsbFNuYXBzaG90Py50eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fZW1pdFRvb2xDYWxsRG9uZUV2ZW50ID0gZnVuY3Rpb24gX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRUb29sQ2FsbERvbmVFdmVudChjaG9pY2VTbmFwc2hvdCwgdG9vbENhbGxJbmRleCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRDaG9pY2VFdmVudFN0YXRlKS5jYWxsKHRoaXMsIGNob2ljZVNuYXBzaG90KTtcbiAgICAgICAgaWYgKHN0YXRlLmRvbmVfdG9vbF9jYWxscy5oYXModG9vbENhbGxJbmRleCkpIHtcbiAgICAgICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgZmlyZWQgdGhlIGRvbmUgZXZlbnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b29sQ2FsbFNuYXBzaG90ID0gY2hvaWNlU25hcHNob3QubWVzc2FnZS50b29sX2NhbGxzPy5bdG9vbENhbGxJbmRleF07XG4gICAgICAgIGlmICghdG9vbENhbGxTbmFwc2hvdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyB0b29sIGNhbGwgc25hcHNob3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvb2xDYWxsU25hcHNob3QudHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29sIGNhbGwgc25hcHNob3QgbWlzc2luZyBgdHlwZWAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9vbENhbGxTbmFwc2hvdC50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFRvb2wgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9wYXJhbXMsIFwiZlwiKT8udG9vbHM/LmZpbmQoKHRvb2wpID0+IHRvb2wudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0b29sLmZ1bmN0aW9uLm5hbWUgPT09IHRvb2xDYWxsU25hcHNob3QuZnVuY3Rpb24ubmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCd0b29sX2NhbGxzLmZ1bmN0aW9uLmFyZ3VtZW50cy5kb25lJywge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRvb2xDYWxsU25hcHNob3QuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBpbmRleDogdG9vbENhbGxJbmRleCxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IHRvb2xDYWxsU25hcHNob3QuZnVuY3Rpb24uYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgIHBhcnNlZF9hcmd1bWVudHM6IGlzQXV0b1BhcnNhYmxlVG9vbChpbnB1dFRvb2wpID8gaW5wdXRUb29sLiRwYXJzZVJhdyh0b29sQ2FsbFNuYXBzaG90LmZ1bmN0aW9uLmFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dFRvb2w/LmZ1bmN0aW9uLnN0cmljdCA/IEpTT04ucGFyc2UodG9vbENhbGxTbmFwc2hvdC5mdW5jdGlvbi5hcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydE5ldmVyKHRvb2xDYWxsU25hcHNob3QudHlwZSk7XG4gICAgICAgIH1cbiAgICB9LCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fZW1pdENvbnRlbnREb25lRXZlbnRzID0gZnVuY3Rpb24gX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRDb250ZW50RG9uZUV2ZW50cyhjaG9pY2VTbmFwc2hvdCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRDaG9pY2VFdmVudFN0YXRlKS5jYWxsKHRoaXMsIGNob2ljZVNuYXBzaG90KTtcbiAgICAgICAgaWYgKGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UuY29udGVudCAmJiAhc3RhdGUuY29udGVudF9kb25lKSB7XG4gICAgICAgICAgICBzdGF0ZS5jb250ZW50X2RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VGb3JtYXQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fZ2V0QXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0KS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdCgnY29udGVudC5kb25lJywge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgICAgICAgICBwYXJzZWQ6IHJlc3BvbnNlRm9ybWF0ID8gcmVzcG9uc2VGb3JtYXQuJHBhcnNlUmF3KGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UuY29udGVudCkgOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UucmVmdXNhbCAmJiAhc3RhdGUucmVmdXNhbF9kb25lKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZWZ1c2FsX2RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZW1pdCgncmVmdXNhbC5kb25lJywgeyByZWZ1c2FsOiBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLnJlZnVzYWwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzPy5jb250ZW50ICYmICFzdGF0ZS5sb2dwcm9ic19jb250ZW50X2RvbmUpIHtcbiAgICAgICAgICAgIHN0YXRlLmxvZ3Byb2JzX2NvbnRlbnRfZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdsb2dwcm9icy5jb250ZW50LmRvbmUnLCB7IGNvbnRlbnQ6IGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzLmNvbnRlbnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzPy5yZWZ1c2FsICYmICFzdGF0ZS5sb2dwcm9ic19yZWZ1c2FsX2RvbmUpIHtcbiAgICAgICAgICAgIHN0YXRlLmxvZ3Byb2JzX3JlZnVzYWxfZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdsb2dwcm9icy5yZWZ1c2FsLmRvbmUnLCB7IHJlZnVzYWw6IGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzLnJlZnVzYWwgfSk7XG4gICAgICAgIH1cbiAgICB9LCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIF9DaGF0Q29tcGxldGlvblN0cmVhbV9lbmRSZXF1ZXN0KCkge1xuICAgICAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBzdHJlYW0gaGFzIGVuZGVkLCB0aGlzIHNob3VsZG4ndCBoYXBwZW5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzbmFwc2hvdCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2N1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90LCBcImZcIik7XG4gICAgICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgcmVxdWVzdCBlbmRlZCB3aXRob3V0IHNlbmRpbmcgYW55IGNodW5rc2ApO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2N1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90LCB1bmRlZmluZWQsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fY2hvaWNlRXZlbnRTdGF0ZXMsIFtdLCBcImZcIik7XG4gICAgICAgIHJldHVybiBmaW5hbGl6ZUNoYXRDb21wbGV0aW9uKHNuYXBzaG90LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9wYXJhbXMsIFwiZlwiKSk7XG4gICAgfSwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2dldEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdCA9IGZ1bmN0aW9uIF9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRm9ybWF0ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fcGFyYW1zLCBcImZcIik/LnJlc3BvbnNlX2Zvcm1hdDtcbiAgICAgICAgaWYgKGlzQXV0b1BhcnNhYmxlUmVzcG9uc2VGb3JtYXQocmVzcG9uc2VGb3JtYXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2FjY3VtdWxhdGVDaGF0Q29tcGxldGlvbiA9IGZ1bmN0aW9uIF9DaGF0Q29tcGxldGlvblN0cmVhbV9hY2N1bXVsYXRlQ2hhdENvbXBsZXRpb24oY2h1bmspIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgc25hcHNob3QgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9jdXJyZW50Q2hhdENvbXBsZXRpb25TbmFwc2hvdCwgXCJmXCIpO1xuICAgICAgICBjb25zdCB7IGNob2ljZXMsIC4uLnJlc3QgfSA9IGNodW5rO1xuICAgICAgICBpZiAoIXNuYXBzaG90KSB7XG4gICAgICAgICAgICBzbmFwc2hvdCA9IF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2N1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90LCB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgICAgICBjaG9pY2VzOiBbXSxcbiAgICAgICAgICAgIH0sIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc25hcHNob3QsIHJlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgeyBkZWx0YSwgZmluaXNoX3JlYXNvbiwgaW5kZXgsIGxvZ3Byb2JzID0gbnVsbCwgLi4ub3RoZXIgfSBvZiBjaHVuay5jaG9pY2VzKSB7XG4gICAgICAgICAgICBsZXQgY2hvaWNlID0gc25hcHNob3QuY2hvaWNlc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIWNob2ljZSkge1xuICAgICAgICAgICAgICAgIGNob2ljZSA9IHNuYXBzaG90LmNob2ljZXNbaW5kZXhdID0geyBmaW5pc2hfcmVhc29uLCBpbmRleCwgbWVzc2FnZToge30sIGxvZ3Byb2JzLCAuLi5vdGhlciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvZ3Byb2JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaG9pY2UubG9ncHJvYnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlLmxvZ3Byb2JzID0gT2JqZWN0LmFzc2lnbih7fSwgbG9ncHJvYnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjb250ZW50LCByZWZ1c2FsLCAuLi5yZXN0IH0gPSBsb2dwcm9icztcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0SXNFbXB0eShyZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjaG9pY2UubG9ncHJvYnMsIHJlc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gY2hvaWNlLmxvZ3Byb2JzKS5jb250ZW50ID8/IChfYS5jb250ZW50ID0gW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hvaWNlLmxvZ3Byb2JzLmNvbnRlbnQucHVzaCguLi5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVmdXNhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gY2hvaWNlLmxvZ3Byb2JzKS5yZWZ1c2FsID8/IChfYi5yZWZ1c2FsID0gW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hvaWNlLmxvZ3Byb2JzLnJlZnVzYWwucHVzaCguLi5yZWZ1c2FsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaW5pc2hfcmVhc29uKSB7XG4gICAgICAgICAgICAgICAgY2hvaWNlLmZpbmlzaF9yZWFzb24gPSBmaW5pc2hfcmVhc29uO1xuICAgICAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9wYXJhbXMsIFwiZlwiKSAmJiBoYXNBdXRvUGFyc2VhYmxlSW5wdXQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fcGFyYW1zLCBcImZcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5pc2hfcmVhc29uID09PSAnbGVuZ3RoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IExlbmd0aEZpbmlzaFJlYXNvbkVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmlzaF9yZWFzb24gPT09ICdjb250ZW50X2ZpbHRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb250ZW50RmlsdGVyRmluaXNoUmVhc29uRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY2hvaWNlLCBvdGhlcik7XG4gICAgICAgICAgICBpZiAoIWRlbHRhKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTaG91bGRuJ3QgaGFwcGVuOyBqdXN0IGluIGNhc2UuXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRlbnQsIHJlZnVzYWwsIGZ1bmN0aW9uX2NhbGwsIHJvbGUsIHRvb2xfY2FsbHMsIC4uLnJlc3QgfSA9IGRlbHRhO1xuICAgICAgICAgICAgYXNzZXJ0SXNFbXB0eShyZXN0KTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY2hvaWNlLm1lc3NhZ2UsIHJlc3QpO1xuICAgICAgICAgICAgaWYgKHJlZnVzYWwpIHtcbiAgICAgICAgICAgICAgICBjaG9pY2UubWVzc2FnZS5yZWZ1c2FsID0gKGNob2ljZS5tZXNzYWdlLnJlZnVzYWwgfHwgJycpICsgcmVmdXNhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb2xlKVxuICAgICAgICAgICAgICAgIGNob2ljZS5tZXNzYWdlLnJvbGUgPSByb2xlO1xuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uX2NhbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNob2ljZS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlLm1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9IGZ1bmN0aW9uX2NhbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25fY2FsbC5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hvaWNlLm1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5uYW1lID0gZnVuY3Rpb25fY2FsbC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYyA9IGNob2ljZS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwpLmFyZ3VtZW50cyA/PyAoX2MuYXJndW1lbnRzID0gJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hvaWNlLm1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgKz0gZnVuY3Rpb25fY2FsbC5hcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgIGNob2ljZS5tZXNzYWdlLmNvbnRlbnQgPSAoY2hvaWNlLm1lc3NhZ2UuY29udGVudCB8fCAnJykgKyBjb250ZW50O1xuICAgICAgICAgICAgICAgIGlmICghY2hvaWNlLm1lc3NhZ2UucmVmdXNhbCAmJiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fZ2V0QXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0KS5jYWxsKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNob2ljZS5tZXNzYWdlLnBhcnNlZCA9IHBhcnRpYWxQYXJzZShjaG9pY2UubWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9vbF9jYWxscykge1xuICAgICAgICAgICAgICAgIGlmICghY2hvaWNlLm1lc3NhZ2UudG9vbF9jYWxscylcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlLm1lc3NhZ2UudG9vbF9jYWxscyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBpbmRleCwgaWQsIHR5cGUsIGZ1bmN0aW9uOiBmbiwgLi4ucmVzdCB9IG9mIHRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbF9jYWxsID0gKChfZCA9IGNob2ljZS5tZXNzYWdlLnRvb2xfY2FsbHMpW2luZGV4XSA/PyAoX2RbaW5kZXhdID0ge30pKTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0b29sX2NhbGwsIHJlc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGwuaWQgPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGwudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbC5mdW5jdGlvbiA/PyAodG9vbF9jYWxsLmZ1bmN0aW9uID0geyBuYW1lOiBmbi5uYW1lID8/ICcnLCBhcmd1bWVudHM6ICcnIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm4/Lm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGwuZnVuY3Rpb24ubmFtZSA9IGZuLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbj8uYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGwuZnVuY3Rpb24uYXJndW1lbnRzICs9IGZuLmFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRQYXJzZVRvb2xDYWxsKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX3BhcmFtcywgXCJmXCIpLCB0b29sX2NhbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsLmZ1bmN0aW9uLnBhcnNlZF9hcmd1bWVudHMgPSBwYXJ0aWFsUGFyc2UodG9vbF9jYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgIH0sIFN5bWJvbC5hc3luY0l0ZXJhdG9yKV0oKSB7XG4gICAgICAgIGNvbnN0IHB1c2hRdWV1ZSA9IFtdO1xuICAgICAgICBjb25zdCByZWFkUXVldWUgPSBbXTtcbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbignY2h1bmsnLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHJlYWRRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHJlYWRlcikge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZXNvbHZlKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHB1c2hRdWV1ZS5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgcmVhZFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRRdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbignYWJvcnQnLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHJlYWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRRdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHJlYWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRRdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXB1c2hRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gcmVhZFF1ZXVlLnB1c2goeyByZXNvbHZlLCByZWplY3QgfSkpLnRoZW4oKGNodW5rKSA9PiAoY2h1bmsgPyB7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfSA6IHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gcHVzaFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHVybjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0b1JlYWRhYmxlU3RyZWFtKCkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgU3RyZWFtKHRoaXNbU3ltYm9sLmFzeW5jSXRlcmF0b3JdLmJpbmQodGhpcyksIHRoaXMuY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiBzdHJlYW0udG9SZWFkYWJsZVN0cmVhbSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmFsaXplQ2hhdENvbXBsZXRpb24oc25hcHNob3QsIHBhcmFtcykge1xuICAgIGNvbnN0IHsgaWQsIGNob2ljZXMsIGNyZWF0ZWQsIG1vZGVsLCBzeXN0ZW1fZmluZ2VycHJpbnQsIC4uLnJlc3QgfSA9IHNuYXBzaG90O1xuICAgIGNvbnN0IGNvbXBsZXRpb24gPSB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGlkLFxuICAgICAgICBjaG9pY2VzOiBjaG9pY2VzLm1hcCgoeyBtZXNzYWdlLCBmaW5pc2hfcmVhc29uLCBpbmRleCwgbG9ncHJvYnMsIC4uLmNob2ljZVJlc3QgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFmaW5pc2hfcmVhc29uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIGZpbmlzaF9yZWFzb24gZm9yIGNob2ljZSAke2luZGV4fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBjb250ZW50ID0gbnVsbCwgZnVuY3Rpb25fY2FsbCwgdG9vbF9jYWxscywgLi4ubWVzc2FnZVJlc3QgfSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBjb25zdCByb2xlID0gbWVzc2FnZS5yb2xlOyAvLyB0aGlzIGlzIHdoYXQgd2UgZXhwZWN0OyBpbiB0aGVvcnkgaXQgY291bGQgYmUgZGlmZmVyZW50IHdoaWNoIHdvdWxkIG1ha2Ugb3VyIHR5cGVzIGEgc2xpZ2h0IGxpZSBidXQgd291bGQgYmUgZmluZS5cbiAgICAgICAgICAgIGlmICghcm9sZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyByb2xlIGZvciBjaG9pY2UgJHtpbmRleH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmdW5jdGlvbl9jYWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhcmd1bWVudHM6IGFyZ3MsIG5hbWUgfSA9IGZ1bmN0aW9uX2NhbGw7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYG1pc3NpbmcgZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgZm9yIGNob2ljZSAke2luZGV4fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIGZ1bmN0aW9uX2NhbGwubmFtZSBmb3IgY2hvaWNlICR7aW5kZXh9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNob2ljZVJlc3QsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiB7IGFyZ3VtZW50czogYXJncywgbmFtZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnVzYWw6IG1lc3NhZ2UucmVmdXNhbCA/PyBudWxsLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hfcmVhc29uLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgbG9ncHJvYnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2hvaWNlUmVzdCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaF9yZWFzb24sXG4gICAgICAgICAgICAgICAgICAgIGxvZ3Byb2JzLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5tZXNzYWdlUmVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmdXNhbDogbWVzc2FnZS5yZWZ1c2FsID8/IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiB0b29sX2NhbGxzLm1hcCgodG9vbF9jYWxsLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmdW5jdGlvbjogZm4sIHR5cGUsIGlkLCAuLi50b29sUmVzdCB9ID0gdG9vbF9jYWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYXJndW1lbnRzOiBhcmdzLCBuYW1lLCAuLi5mblJlc3QgfSA9IGZuIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyBjaG9pY2VzWyR7aW5kZXh9XS50b29sX2NhbGxzWyR7aX1dLmlkXFxuJHtzdHIoc25hcHNob3QpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyBjaG9pY2VzWyR7aW5kZXh9XS50b29sX2NhbGxzWyR7aX1dLnR5cGVcXG4ke3N0cihzbmFwc2hvdCl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIGNob2ljZXNbJHtpbmRleH1dLnRvb2xfY2FsbHNbJHtpfV0uZnVuY3Rpb24ubmFtZVxcbiR7c3RyKHNuYXBzaG90KX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYG1pc3NpbmcgY2hvaWNlc1ske2luZGV4fV0udG9vbF9jYWxsc1ske2l9XS5mdW5jdGlvbi5hcmd1bWVudHNcXG4ke3N0cihzbmFwc2hvdCl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnRvb2xSZXN0LCBpZCwgdHlwZSwgZnVuY3Rpb246IHsgLi4uZm5SZXN0LCBuYW1lLCBhcmd1bWVudHM6IGFyZ3MgfSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2hvaWNlUmVzdCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB7IC4uLm1lc3NhZ2VSZXN0LCBjb250ZW50LCByb2xlLCByZWZ1c2FsOiBtZXNzYWdlLnJlZnVzYWwgPz8gbnVsbCB9LFxuICAgICAgICAgICAgICAgIGZpbmlzaF9yZWFzb24sXG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgbG9ncHJvYnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgY3JlYXRlZCxcbiAgICAgICAgbW9kZWwsXG4gICAgICAgIG9iamVjdDogJ2NoYXQuY29tcGxldGlvbicsXG4gICAgICAgIC4uLihzeXN0ZW1fZmluZ2VycHJpbnQgPyB7IHN5c3RlbV9maW5nZXJwcmludCB9IDoge30pLFxuICAgIH07XG4gICAgcmV0dXJuIG1heWJlUGFyc2VDaGF0Q29tcGxldGlvbihjb21wbGV0aW9uLCBwYXJhbXMpO1xufVxuZnVuY3Rpb24gc3RyKHgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeCk7XG59XG4vKipcbiAqIEVuc3VyZXMgdGhlIGdpdmVuIGFyZ3VtZW50IGlzIGFuIGVtcHR5IG9iamVjdCwgdXNlZnVsIGZvclxuICogYXNzZXJ0aW5nIHRoYXQgYWxsIGtub3duIHByb3BlcnRpZXMgb24gYW4gb2JqZWN0IGhhdmUgYmVlblxuICogZGVzdHJ1Y3R1cmVkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0VtcHR5KG9iaikge1xuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7IH1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoYXRDb21wbGV0aW9uU3RyZWFtLm1qcy5tYXAiLCJpbXBvcnQgeyBDaGF0Q29tcGxldGlvblN0cmVhbSB9IGZyb20gXCIuL0NoYXRDb21wbGV0aW9uU3RyZWFtLm1qc1wiO1xuZXhwb3J0IGNsYXNzIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25TdHJlYW0ge1xuICAgIHN0YXRpYyBmcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcihudWxsKTtcbiAgICAgICAgcnVubmVyLl9ydW4oKCkgPT4gcnVubmVyLl9mcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAtIHBsZWFzZSB1c2UgYHJ1blRvb2xzYCBpbnN0ZWFkLiAqL1xuICAgIHN0YXRpYyBydW5GdW5jdGlvbnMoY2xpZW50LCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gbmV3IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyKG51bGwpO1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAncnVuRnVuY3Rpb25zJyB9LFxuICAgICAgICB9O1xuICAgICAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX3J1bkZ1bmN0aW9ucyhjbGllbnQsIHBhcmFtcywgb3B0cykpO1xuICAgICAgICByZXR1cm4gcnVubmVyO1xuICAgIH1cbiAgICBzdGF0aWMgcnVuVG9vbHMoY2xpZW50LCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gbmV3IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gdGhlc2UgdHlwZXMgYXJlIGluY29tcGF0aWJsZVxuICAgICAgICBwYXJhbXMpO1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAncnVuVG9vbHMnIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fcnVuVG9vbHMoY2xpZW50LCBwYXJhbXMsIG9wdHMpKTtcbiAgICAgICAgcmV0dXJuIHJ1bm5lcjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lci5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uLy4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgQ2hhdENvbXBsZXRpb25SdW5uZXIgfSBmcm9tIFwiLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uUnVubmVyLm1qc1wiO1xuZXhwb3J0IHsgQ2hhdENvbXBsZXRpb25SdW5uZXIgfSBmcm9tIFwiLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uUnVubmVyLm1qc1wiO1xuaW1wb3J0IHsgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXIsIH0gZnJvbSBcIi4uLy4uLy4uL2xpYi9DaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lci5tanNcIjtcbmV4cG9ydCB7IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyLCB9IGZyb20gXCIuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXIubWpzXCI7XG5leHBvcnQgeyBQYXJzaW5nRnVuY3Rpb24sIFBhcnNpbmdUb29sRnVuY3Rpb24sIH0gZnJvbSBcIi4uLy4uLy4uL2xpYi9SdW5uYWJsZUZ1bmN0aW9uLm1qc1wiO1xuaW1wb3J0IHsgQ2hhdENvbXBsZXRpb25TdHJlYW0gfSBmcm9tIFwiLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtLm1qc1wiO1xuaW1wb3J0IHsgcGFyc2VDaGF0Q29tcGxldGlvbiwgdmFsaWRhdGVJbnB1dFRvb2xzIH0gZnJvbSBcIi4uLy4uLy4uL2xpYi9wYXJzZXIubWpzXCI7XG5leHBvcnQgeyBDaGF0Q29tcGxldGlvblN0cmVhbSB9IGZyb20gXCIuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25TdHJlYW0ubWpzXCI7XG5leHBvcnQgY2xhc3MgQ29tcGxldGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgYXN5bmMgcGFyc2UoYm9keSwgb3B0aW9ucykge1xuICAgICAgICB2YWxpZGF0ZUlucHV0VG9vbHMoYm9keS50b29scyk7XG4gICAgICAgIGNvbnN0IGNvbXBsZXRpb24gPSBhd2FpdCB0aGlzLl9jbGllbnQuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoYm9keSwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ2JldGEuY2hhdC5jb21wbGV0aW9ucy5wYXJzZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlQ2hhdENvbXBsZXRpb24oY29tcGxldGlvbiwgYm9keSk7XG4gICAgfVxuICAgIHJ1bkZ1bmN0aW9ucyhib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChib2R5LnN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyLnJ1bkZ1bmN0aW9ucyh0aGlzLl9jbGllbnQsIGJvZHksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDaGF0Q29tcGxldGlvblJ1bm5lci5ydW5GdW5jdGlvbnModGhpcy5fY2xpZW50LCBib2R5LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcnVuVG9vbHMoYm9keSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoYm9keS5zdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybiBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lci5ydW5Ub29scyh0aGlzLl9jbGllbnQsIGJvZHksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDaGF0Q29tcGxldGlvblJ1bm5lci5ydW5Ub29scyh0aGlzLl9jbGllbnQsIGJvZHksIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2hhdCBjb21wbGV0aW9uIHN0cmVhbVxuICAgICAqL1xuICAgIHN0cmVhbShib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBDaGF0Q29tcGxldGlvblN0cmVhbS5jcmVhdGVDaGF0Q29tcGxldGlvbih0aGlzLl9jbGllbnQsIGJvZHksIG9wdGlvbnMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBsZXRpb25zLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vLi4vcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgKiBhcyBDb21wbGV0aW9uc0FQSSBmcm9tIFwiLi9jb21wbGV0aW9ucy5tanNcIjtcbmV4cG9ydCBjbGFzcyBDaGF0IGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNvbXBsZXRpb25zID0gbmV3IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25zKHRoaXMuX2NsaWVudCk7XG4gICAgfVxufVxuKGZ1bmN0aW9uIChDaGF0KSB7XG4gICAgQ2hhdC5Db21wbGV0aW9ucyA9IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25zO1xufSkoQ2hhdCB8fCAoQ2hhdCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGF0Lm1qcy5tYXAiLCJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX0Fzc2lzdGFudFN0cmVhbV9pbnN0YW5jZXMsIF9Bc3Npc3RhbnRTdHJlYW1fZXZlbnRzLCBfQXNzaXN0YW50U3RyZWFtX3J1blN0ZXBTbmFwc2hvdHMsIF9Bc3Npc3RhbnRTdHJlYW1fbWVzc2FnZVNuYXBzaG90cywgX0Fzc2lzdGFudFN0cmVhbV9tZXNzYWdlU25hcHNob3QsIF9Bc3Npc3RhbnRTdHJlYW1fZmluYWxSdW4sIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudENvbnRlbnRJbmRleCwgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50Q29udGVudCwgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50VG9vbENhbGxJbmRleCwgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50VG9vbENhbGwsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudEV2ZW50LCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRSdW5TbmFwc2hvdCwgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50UnVuU3RlcFNuYXBzaG90LCBfQXNzaXN0YW50U3RyZWFtX2FkZEV2ZW50LCBfQXNzaXN0YW50U3RyZWFtX2VuZFJlcXVlc3QsIF9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlTWVzc2FnZSwgX0Fzc2lzdGFudFN0cmVhbV9oYW5kbGVSdW5TdGVwLCBfQXNzaXN0YW50U3RyZWFtX2hhbmRsZUV2ZW50LCBfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVSdW5TdGVwLCBfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVNZXNzYWdlLCBfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVDb250ZW50LCBfQXNzaXN0YW50U3RyZWFtX2hhbmRsZVJ1bjtcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnb3BlbmFpL2NvcmUnO1xuaW1wb3J0IHsgU3RyZWFtIH0gZnJvbSAnb3BlbmFpL3N0cmVhbWluZyc7XG5pbXBvcnQgeyBBUElVc2VyQWJvcnRFcnJvciwgT3BlbkFJRXJyb3IgfSBmcm9tICdvcGVuYWkvZXJyb3InO1xuaW1wb3J0IHsgRXZlbnRTdHJlYW0gfSBmcm9tIFwiLi9FdmVudFN0cmVhbS5tanNcIjtcbmV4cG9ydCBjbGFzcyBBc3Npc3RhbnRTdHJlYW0gZXh0ZW5kcyBFdmVudFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIF9Bc3Npc3RhbnRTdHJlYW1faW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgLy9UcmFjayBhbGwgZXZlbnRzIGluIGEgc2luZ2xlIGxpc3QgZm9yIHJlZmVyZW5jZVxuICAgICAgICBfQXNzaXN0YW50U3RyZWFtX2V2ZW50cy5zZXQodGhpcywgW10pO1xuICAgICAgICAvL1VzZWQgdG8gYWNjdW11bGF0ZSBkZWx0YXNcbiAgICAgICAgLy9XZSBhcmUgYWNjdW11bGF0aW5nIG1hbnkgdHlwZXMgc28gdGhlIHZhbHVlIGhlcmUgaXMgbm90IHN0cmljdFxuICAgICAgICBfQXNzaXN0YW50U3RyZWFtX3J1blN0ZXBTbmFwc2hvdHMuc2V0KHRoaXMsIHt9KTtcbiAgICAgICAgX0Fzc2lzdGFudFN0cmVhbV9tZXNzYWdlU25hcHNob3RzLnNldCh0aGlzLCB7fSk7XG4gICAgICAgIF9Bc3Npc3RhbnRTdHJlYW1fbWVzc2FnZVNuYXBzaG90LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQXNzaXN0YW50U3RyZWFtX2ZpbmFsUnVuLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRDb250ZW50SW5kZXguc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudENvbnRlbnQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsSW5kZXguc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICAvL0ZvciBjdXJyZW50IHNuYXBzaG90IG1ldGhvZHNcbiAgICAgICAgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50RXZlbnQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFJ1blNuYXBzaG90LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRSdW5TdGVwU25hcHNob3Quc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgfVxuICAgIFsoX0Fzc2lzdGFudFN0cmVhbV9ldmVudHMgPSBuZXcgV2Vha01hcCgpLCBfQXNzaXN0YW50U3RyZWFtX3J1blN0ZXBTbmFwc2hvdHMgPSBuZXcgV2Vha01hcCgpLCBfQXNzaXN0YW50U3RyZWFtX21lc3NhZ2VTbmFwc2hvdHMgPSBuZXcgV2Vha01hcCgpLCBfQXNzaXN0YW50U3RyZWFtX21lc3NhZ2VTbmFwc2hvdCA9IG5ldyBXZWFrTWFwKCksIF9Bc3Npc3RhbnRTdHJlYW1fZmluYWxSdW4gPSBuZXcgV2Vha01hcCgpLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRDb250ZW50SW5kZXggPSBuZXcgV2Vha01hcCgpLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRDb250ZW50ID0gbmV3IFdlYWtNYXAoKSwgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50VG9vbENhbGxJbmRleCA9IG5ldyBXZWFrTWFwKCksIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsID0gbmV3IFdlYWtNYXAoKSwgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50RXZlbnQgPSBuZXcgV2Vha01hcCgpLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRSdW5TbmFwc2hvdCA9IG5ldyBXZWFrTWFwKCksIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFJ1blN0ZXBTbmFwc2hvdCA9IG5ldyBXZWFrTWFwKCksIF9Bc3Npc3RhbnRTdHJlYW1faW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgU3ltYm9sLmFzeW5jSXRlcmF0b3IpXSgpIHtcbiAgICAgICAgY29uc3QgcHVzaFF1ZXVlID0gW107XG4gICAgICAgIGNvbnN0IHJlYWRRdWV1ZSA9IFtdO1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAvL0NhdGNoIGFsbCBmb3IgcGFzc2luZyBhbG9uZyBhbGwgZXZlbnRzXG4gICAgICAgIHRoaXMub24oJ2V2ZW50JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSByZWFkUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVzb2x2ZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdXNoUXVldWUucHVzaChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHJlYWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2Fib3J0JywgKGVycikgPT4ge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiByZWFkUXVldWUpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiByZWFkUXVldWUpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwdXNoUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHJlYWRRdWV1ZS5wdXNoKHsgcmVzb2x2ZSwgcmVqZWN0IH0pKS50aGVuKChjaHVuaykgPT4gKGNodW5rID8geyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0gOiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IHB1c2hRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXR1cm46IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21SZWFkYWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gbmV3IEFzc2lzdGFudFN0cmVhbSgpO1xuICAgICAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX2Zyb21SZWFkYWJsZVN0cmVhbShzdHJlYW0pKTtcbiAgICAgICAgcmV0dXJuIHJ1bm5lcjtcbiAgICB9XG4gICAgYXN5bmMgX2Zyb21SZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZClcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRoaXMuY29udHJvbGxlci5hYm9ydCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25uZWN0ZWQoKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSwgdGhpcy5jb250cm9sbGVyKTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBldmVudCBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQXNzaXN0YW50U3RyZWFtX2FkZEV2ZW50KS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLmNvbnRyb2xsZXIuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkUnVuKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQXNzaXN0YW50U3RyZWFtX2VuZFJlcXVlc3QpLmNhbGwodGhpcykpO1xuICAgIH1cbiAgICB0b1JlYWRhYmxlU3RyZWFtKCkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgU3RyZWFtKHRoaXNbU3ltYm9sLmFzeW5jSXRlcmF0b3JdLmJpbmQodGhpcyksIHRoaXMuY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiBzdHJlYW0udG9SZWFkYWJsZVN0cmVhbSgpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlVG9vbEFzc2lzdGFudFN0cmVhbSh0aHJlYWRJZCwgcnVuSWQsIHJ1bnMsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBuZXcgQXNzaXN0YW50U3RyZWFtKCk7XG4gICAgICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fcnVuVG9vbEFzc2lzdGFudFN0cmVhbSh0aHJlYWRJZCwgcnVuSWQsIHJ1bnMsIHBhcmFtcywge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAnc3RyZWFtJyB9LFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIGFzeW5jIF9jcmVhdGVUb29sQXNzaXN0YW50U3RyZWFtKHJ1biwgdGhyZWFkSWQsIHJ1bklkLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHsgLi4ucGFyYW1zLCBzdHJlYW06IHRydWUgfTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgcnVuLnN1Ym1pdFRvb2xPdXRwdXRzKHRocmVhZElkLCBydW5JZCwgYm9keSwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHNpZ25hbDogdGhpcy5jb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCgpO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGV2ZW50IG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9Bc3Npc3RhbnRTdHJlYW1fYWRkRXZlbnQpLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uY29udHJvbGxlci5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSdW4oX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9Bc3Npc3RhbnRTdHJlYW1fZW5kUmVxdWVzdCkuY2FsbCh0aGlzKSk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVUaHJlYWRBc3Npc3RhbnRTdHJlYW0ocGFyYW1zLCB0aHJlYWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gbmV3IEFzc2lzdGFudFN0cmVhbSgpO1xuICAgICAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX3RocmVhZEFzc2lzdGFudFN0cmVhbShwYXJhbXMsIHRocmVhZCwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAnc3RyZWFtJyB9LFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVBc3Npc3RhbnRTdHJlYW0odGhyZWFkSWQsIHJ1bnMsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBuZXcgQXNzaXN0YW50U3RyZWFtKCk7XG4gICAgICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fcnVuQXNzaXN0YW50U3RyZWFtKHRocmVhZElkLCBydW5zLCBwYXJhbXMsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3N0cmVhbScgfSxcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gcnVubmVyO1xuICAgIH1cbiAgICBjdXJyZW50RXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudEV2ZW50LCBcImZcIik7XG4gICAgfVxuICAgIGN1cnJlbnRSdW4oKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFJ1blNuYXBzaG90LCBcImZcIik7XG4gICAgfVxuICAgIGN1cnJlbnRNZXNzYWdlU25hcHNob3QoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fbWVzc2FnZVNuYXBzaG90LCBcImZcIik7XG4gICAgfVxuICAgIGN1cnJlbnRSdW5TdGVwU25hcHNob3QoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFJ1blN0ZXBTbmFwc2hvdCwgXCJmXCIpO1xuICAgIH1cbiAgICBhc3luYyBmaW5hbFJ1blN0ZXBzKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX3J1blN0ZXBTbmFwc2hvdHMsIFwiZlwiKSk7XG4gICAgfVxuICAgIGFzeW5jIGZpbmFsTWVzc2FnZXMoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fbWVzc2FnZVNuYXBzaG90cywgXCJmXCIpKTtcbiAgICB9XG4gICAgYXN5bmMgZmluYWxSdW4oKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9maW5hbFJ1biwgXCJmXCIpKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ZpbmFsIHJ1biB3YXMgbm90IHJlY2VpdmVkLicpO1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2ZpbmFsUnVuLCBcImZcIik7XG4gICAgfVxuICAgIGFzeW5jIF9jcmVhdGVUaHJlYWRBc3Npc3RhbnRTdHJlYW0odGhyZWFkLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHsgLi4ucGFyYW1zLCBzdHJlYW06IHRydWUgfTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgdGhyZWFkLmNyZWF0ZUFuZFJ1bihib2R5LCB7IC4uLm9wdGlvbnMsIHNpZ25hbDogdGhpcy5jb250cm9sbGVyLnNpZ25hbCB9KTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkKCk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgZXZlbnQgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX0Fzc2lzdGFudFN0cmVhbV9hZGRFdmVudCkuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5jb250cm9sbGVyLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJ1bihfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX0Fzc2lzdGFudFN0cmVhbV9lbmRSZXF1ZXN0KS5jYWxsKHRoaXMpKTtcbiAgICB9XG4gICAgYXN5bmMgX2NyZWF0ZUFzc2lzdGFudFN0cmVhbShydW4sIHRocmVhZElkLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHsgLi4ucGFyYW1zLCBzdHJlYW06IHRydWUgfTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgcnVuLmNyZWF0ZSh0aHJlYWRJZCwgYm9keSwgeyAuLi5vcHRpb25zLCBzaWduYWw6IHRoaXMuY29udHJvbGxlci5zaWduYWwgfSk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCgpO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGV2ZW50IG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9Bc3Npc3RhbnRTdHJlYW1fYWRkRXZlbnQpLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uY29udHJvbGxlci5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSdW4oX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9Bc3Npc3RhbnRTdHJlYW1fZW5kUmVxdWVzdCkuY2FsbCh0aGlzKSk7XG4gICAgfVxuICAgIHN0YXRpYyBhY2N1bXVsYXRlRGVsdGEoYWNjLCBkZWx0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGRlbHRhVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRlbHRhKSkge1xuICAgICAgICAgICAgaWYgKCFhY2MuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gZGVsdGFWYWx1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhY2NWYWx1ZSA9IGFjY1trZXldO1xuICAgICAgICAgICAgaWYgKGFjY1ZhbHVlID09PSBudWxsIHx8IGFjY1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IGRlbHRhVmFsdWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBhY2N1bXVsYXRlIHRoZXNlIHNwZWNpYWwgcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2luZGV4JyB8fCBrZXkgPT09ICd0eXBlJykge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gZGVsdGFWYWx1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFR5cGUtc3BlY2lmaWMgYWNjdW11bGF0aW9uIGxvZ2ljXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFjY1ZhbHVlID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGVsdGFWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBhY2NWYWx1ZSArPSBkZWx0YVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFjY1ZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgZGVsdGFWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBhY2NWYWx1ZSArPSBkZWx0YVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQ29yZS5pc09iaihhY2NWYWx1ZSkgJiYgQ29yZS5pc09iaihkZWx0YVZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGFjY1ZhbHVlID0gdGhpcy5hY2N1bXVsYXRlRGVsdGEoYWNjVmFsdWUsIGRlbHRhVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhY2NWYWx1ZSkgJiYgQXJyYXkuaXNBcnJheShkZWx0YVZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChhY2NWYWx1ZS5ldmVyeSgoeCkgPT4gdHlwZW9mIHggPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB4ID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjVmFsdWUucHVzaCguLi5kZWx0YVZhbHVlKTsgLy8gVXNlIHNwcmVhZCBzeW50YXggZm9yIGVmZmljaWVudCBhZGRpdGlvblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgVW5oYW5kbGVkIHJlY29yZCB0eXBlOiAke2tleX0sIGRlbHRhVmFsdWU6ICR7ZGVsdGFWYWx1ZX0sIGFjY1ZhbHVlOiAke2FjY1ZhbHVlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjW2tleV0gPSBhY2NWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBfYWRkUnVuKHJ1bikge1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBfdGhyZWFkQXNzaXN0YW50U3RyZWFtKHBhcmFtcywgdGhyZWFkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9jcmVhdGVUaHJlYWRBc3Npc3RhbnRTdHJlYW0odGhyZWFkLCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBfcnVuQXNzaXN0YW50U3RyZWFtKHRocmVhZElkLCBydW5zLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2NyZWF0ZUFzc2lzdGFudFN0cmVhbShydW5zLCB0aHJlYWRJZCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgX3J1blRvb2xBc3Npc3RhbnRTdHJlYW0odGhyZWFkSWQsIHJ1bklkLCBydW5zLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2NyZWF0ZVRvb2xBc3Npc3RhbnRTdHJlYW0ocnVucywgdGhyZWFkSWQsIHJ1bklkLCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgIH1cbn1cbl9Bc3Npc3RhbnRTdHJlYW1fYWRkRXZlbnQgPSBmdW5jdGlvbiBfQXNzaXN0YW50U3RyZWFtX2FkZEV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZW5kZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudEV2ZW50LCBldmVudCwgXCJmXCIpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQXNzaXN0YW50U3RyZWFtX2hhbmRsZUV2ZW50KS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICBzd2l0Y2ggKGV2ZW50LmV2ZW50KSB7XG4gICAgICAgIGNhc2UgJ3RocmVhZC5jcmVhdGVkJzpcbiAgICAgICAgICAgIC8vTm8gYWN0aW9uIG9uIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jcmVhdGVkJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5xdWV1ZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLmluX3Byb2dyZXNzJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5yZXF1aXJlc19hY3Rpb24nOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLmNvbXBsZXRlZCc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uZmFpbGVkJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jYW5jZWxsaW5nJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jYW5jZWxsZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLmV4cGlyZWQnOlxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlUnVuKS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY3JlYXRlZCc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5pbl9wcm9ncmVzcyc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5kZWx0YSc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jb21wbGV0ZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZmFpbGVkJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmNhbmNlbGxlZCc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5leHBpcmVkJzpcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQXNzaXN0YW50U3RyZWFtX2hhbmRsZVJ1blN0ZXApLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmNyZWF0ZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5pbl9wcm9ncmVzcyc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmRlbHRhJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuY29tcGxldGVkJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuaW5jb21wbGV0ZSc6XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX0Fzc2lzdGFudFN0cmVhbV9oYW5kbGVNZXNzYWdlKS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAvL1RoaXMgaXMgaW5jbHVkZWQgZm9yIGNvbXBsZXRlbmVzcywgYnV0IGVycm9ycyBhcmUgcHJvY2Vzc2VkIGluIHRoZSBTU0UgZXZlbnQgcHJvY2Vzc2luZyBzbyB0aGlzIHNob3VsZCBub3Qgb2NjdXJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jb3VudGVyZWQgYW4gZXJyb3IgZXZlbnQgaW4gZXZlbnQgcHJvY2Vzc2luZyAtIGVycm9ycyBzaG91bGQgYmUgcHJvY2Vzc2VkIGVhcmxpZXInKTtcbiAgICB9XG59LCBfQXNzaXN0YW50U3RyZWFtX2VuZFJlcXVlc3QgPSBmdW5jdGlvbiBfQXNzaXN0YW50U3RyZWFtX2VuZFJlcXVlc3QoKSB7XG4gICAgaWYgKHRoaXMuZW5kZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBzdHJlYW0gaGFzIGVuZGVkLCB0aGlzIHNob3VsZG4ndCBoYXBwZW5gKTtcbiAgICB9XG4gICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fZmluYWxSdW4sIFwiZlwiKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ZpbmFsIHJ1biBoYXMgbm90IGJlZW4gcmVjZWl2ZWQnKTtcbiAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2ZpbmFsUnVuLCBcImZcIik7XG59LCBfQXNzaXN0YW50U3RyZWFtX2hhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiBfQXNzaXN0YW50U3RyZWFtX2hhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICBjb25zdCBbYWNjdW11bGF0ZWRNZXNzYWdlLCBuZXdDb250ZW50XSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVNZXNzYWdlKS5jYWxsKHRoaXMsIGV2ZW50LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fbWVzc2FnZVNuYXBzaG90LCBcImZcIikpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9tZXNzYWdlU25hcHNob3QsIGFjY3VtdWxhdGVkTWVzc2FnZSwgXCJmXCIpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9tZXNzYWdlU25hcHNob3RzLCBcImZcIilbYWNjdW11bGF0ZWRNZXNzYWdlLmlkXSA9IGFjY3VtdWxhdGVkTWVzc2FnZTtcbiAgICBmb3IgKGNvbnN0IGNvbnRlbnQgb2YgbmV3Q29udGVudCkge1xuICAgICAgICBjb25zdCBzbmFwc2hvdENvbnRlbnQgPSBhY2N1bXVsYXRlZE1lc3NhZ2UuY29udGVudFtjb250ZW50LmluZGV4XTtcbiAgICAgICAgaWYgKHNuYXBzaG90Q29udGVudD8udHlwZSA9PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3RleHRDcmVhdGVkJywgc25hcHNob3RDb250ZW50LnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoZXZlbnQuZXZlbnQpIHtcbiAgICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuY3JlYXRlZCc6XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdtZXNzYWdlQ3JlYXRlZCcsIGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmluX3Byb2dyZXNzJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5kZWx0YSc6XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdtZXNzYWdlRGVsdGEnLCBldmVudC5kYXRhLmRlbHRhLCBhY2N1bXVsYXRlZE1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEuZGVsdGEuY29udGVudCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udGVudCBvZiBldmVudC5kYXRhLmRlbHRhLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9JZiBpdCBpcyB0ZXh0IGRlbHRhLCBlbWl0IGEgdGV4dCBkZWx0YSBldmVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09ICd0ZXh0JyAmJiBjb250ZW50LnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0RGVsdGEgPSBjb250ZW50LnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc25hcHNob3QgPSBhY2N1bXVsYXRlZE1lc3NhZ2UuY29udGVudFtjb250ZW50LmluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbmFwc2hvdCAmJiBzbmFwc2hvdC50eXBlID09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3RleHREZWx0YScsIHRleHREZWx0YSwgc25hcHNob3QudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVGhlIHNuYXBzaG90IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRleHQgZGVsdGEgaXMgbm90IHRleHQgb3IgbWlzc2luZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50LmluZGV4ICE9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50Q29udGVudEluZGV4LCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vU2VlIGlmIHdlIGhhdmUgaW4gcHJvZ3Jlc3MgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50Q29udGVudCwgXCJmXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudENvbnRlbnQsIFwiZlwiKS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgndGV4dERvbmUnLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudENvbnRlbnQsIFwiZlwiKS50ZXh0LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fbWVzc2FnZVNuYXBzaG90LCBcImZcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ltYWdlX2ZpbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgnaW1hZ2VGaWxlRG9uZScsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50Q29udGVudCwgXCJmXCIpLmltYWdlX2ZpbGUsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9tZXNzYWdlU25hcHNob3QsIFwiZlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudENvbnRlbnRJbmRleCwgY29udGVudC5pbmRleCwgXCJmXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50Q29udGVudCwgYWNjdW11bGF0ZWRNZXNzYWdlLmNvbnRlbnRbY29udGVudC5pbmRleF0sIFwiZlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuY29tcGxldGVkJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuaW5jb21wbGV0ZSc6XG4gICAgICAgICAgICAvL1dlIGVtaXQgdGhlIGxhdGVzdCBjb250ZW50IHdlIHdlcmUgd29ya2luZyBvbiBvbiBjb21wbGV0aW9uIChpbmNsdWRpbmcgaW5jb21wbGV0ZSlcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudENvbnRlbnRJbmRleCwgXCJmXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q29udGVudCA9IGV2ZW50LmRhdGEuY29udGVudFtfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudENvbnRlbnRJbmRleCwgXCJmXCIpXTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjdXJyZW50Q29udGVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbWFnZV9maWxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCdpbWFnZUZpbGVEb25lJywgY3VycmVudENvbnRlbnQuaW1hZ2VfZmlsZSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX21lc3NhZ2VTbmFwc2hvdCwgXCJmXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3RleHREb25lJywgY3VycmVudENvbnRlbnQudGV4dCwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX21lc3NhZ2VTbmFwc2hvdCwgXCJmXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fbWVzc2FnZVNuYXBzaG90LCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCdtZXNzYWdlRG9uZScsIGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX21lc3NhZ2VTbmFwc2hvdCwgdW5kZWZpbmVkLCBcImZcIik7XG4gICAgfVxufSwgX0Fzc2lzdGFudFN0cmVhbV9oYW5kbGVSdW5TdGVwID0gZnVuY3Rpb24gX0Fzc2lzdGFudFN0cmVhbV9oYW5kbGVSdW5TdGVwKGV2ZW50KSB7XG4gICAgY29uc3QgYWNjdW11bGF0ZWRSdW5TdGVwID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9Bc3Npc3RhbnRTdHJlYW1fYWNjdW11bGF0ZVJ1blN0ZXApLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50UnVuU3RlcFNuYXBzaG90LCBhY2N1bXVsYXRlZFJ1blN0ZXAsIFwiZlwiKTtcbiAgICBzd2l0Y2ggKGV2ZW50LmV2ZW50KSB7XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jcmVhdGVkJzpcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3J1blN0ZXBDcmVhdGVkJywgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmRlbHRhJzpcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZXZlbnQuZGF0YS5kZWx0YTtcbiAgICAgICAgICAgIGlmIChkZWx0YS5zdGVwX2RldGFpbHMgJiZcbiAgICAgICAgICAgICAgICBkZWx0YS5zdGVwX2RldGFpbHMudHlwZSA9PSAndG9vbF9jYWxscycgJiZcbiAgICAgICAgICAgICAgICBkZWx0YS5zdGVwX2RldGFpbHMudG9vbF9jYWxscyAmJlxuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkUnVuU3RlcC5zdGVwX2RldGFpbHMudHlwZSA9PSAndG9vbF9jYWxscycpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIGRlbHRhLnN0ZXBfZGV0YWlscy50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29sQ2FsbC5pbmRleCA9PSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsSW5kZXgsIFwiZlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgndG9vbENhbGxEZWx0YScsIHRvb2xDYWxsLCBhY2N1bXVsYXRlZFJ1blN0ZXAuc3RlcF9kZXRhaWxzLnRvb2xfY2FsbHNbdG9vbENhbGwuaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsLCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCd0b29sQ2FsbERvbmUnLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsLCBcImZcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRUb29sQ2FsbEluZGV4LCB0b29sQ2FsbC5pbmRleCwgXCJmXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRUb29sQ2FsbCwgYWNjdW11bGF0ZWRSdW5TdGVwLnN0ZXBfZGV0YWlscy50b29sX2NhbGxzW3Rvb2xDYWxsLmluZGV4XSwgXCJmXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50VG9vbENhbGwsIFwiZlwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCd0b29sQ2FsbENyZWF0ZWQnLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsLCBcImZcIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZW1pdCgncnVuU3RlcERlbHRhJywgZXZlbnQuZGF0YS5kZWx0YSwgYWNjdW11bGF0ZWRSdW5TdGVwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY29tcGxldGVkJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmZhaWxlZCc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jYW5jZWxsZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZXhwaXJlZCc6XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFJ1blN0ZXBTbmFwc2hvdCwgdW5kZWZpbmVkLCBcImZcIik7XG4gICAgICAgICAgICBjb25zdCBkZXRhaWxzID0gZXZlbnQuZGF0YS5zdGVwX2RldGFpbHM7XG4gICAgICAgICAgICBpZiAoZGV0YWlscy50eXBlID09ICd0b29sX2NhbGxzJykge1xuICAgICAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsLCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgndG9vbENhbGxEb25lJywgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRUb29sQ2FsbCwgXCJmXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRUb29sQ2FsbCwgdW5kZWZpbmVkLCBcImZcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZW1pdCgncnVuU3RlcERvbmUnLCBldmVudC5kYXRhLCBhY2N1bXVsYXRlZFJ1blN0ZXApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5pbl9wcm9ncmVzcyc6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59LCBfQXNzaXN0YW50U3RyZWFtX2hhbmRsZUV2ZW50ID0gZnVuY3Rpb24gX0Fzc2lzdGFudFN0cmVhbV9oYW5kbGVFdmVudChldmVudCkge1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9ldmVudHMsIFwiZlwiKS5wdXNoKGV2ZW50KTtcbiAgICB0aGlzLl9lbWl0KCdldmVudCcsIGV2ZW50KTtcbn0sIF9Bc3Npc3RhbnRTdHJlYW1fYWNjdW11bGF0ZVJ1blN0ZXAgPSBmdW5jdGlvbiBfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVSdW5TdGVwKGV2ZW50KSB7XG4gICAgc3dpdGNoIChldmVudC5ldmVudCkge1xuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY3JlYXRlZCc6XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fcnVuU3RlcFNuYXBzaG90cywgXCJmXCIpW2V2ZW50LmRhdGEuaWRdID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJldHVybiBldmVudC5kYXRhO1xuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZGVsdGEnOlxuICAgICAgICAgICAgbGV0IHNuYXBzaG90ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX3J1blN0ZXBTbmFwc2hvdHMsIFwiZlwiKVtldmVudC5kYXRhLmlkXTtcbiAgICAgICAgICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignUmVjZWl2ZWQgYSBSdW5TdGVwRGVsdGEgYmVmb3JlIGNyZWF0aW9uIG9mIGEgc25hcHNob3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhLmRlbHRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjdW11bGF0ZWQgPSBBc3Npc3RhbnRTdHJlYW0uYWNjdW11bGF0ZURlbHRhKHNuYXBzaG90LCBkYXRhLmRlbHRhKTtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fcnVuU3RlcFNuYXBzaG90cywgXCJmXCIpW2V2ZW50LmRhdGEuaWRdID0gYWNjdW11bGF0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX3J1blN0ZXBTbmFwc2hvdHMsIFwiZlwiKVtldmVudC5kYXRhLmlkXTtcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmNvbXBsZXRlZCc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5mYWlsZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY2FuY2VsbGVkJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmV4cGlyZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuaW5fcHJvZ3Jlc3MnOlxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX3J1blN0ZXBTbmFwc2hvdHMsIFwiZlwiKVtldmVudC5kYXRhLmlkXSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9ydW5TdGVwU25hcHNob3RzLCBcImZcIilbZXZlbnQuZGF0YS5pZF0pXG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fcnVuU3RlcFNuYXBzaG90cywgXCJmXCIpW2V2ZW50LmRhdGEuaWRdO1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gc25hcHNob3QgYXZhaWxhYmxlJyk7XG59LCBfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVNZXNzYWdlID0gZnVuY3Rpb24gX0Fzc2lzdGFudFN0cmVhbV9hY2N1bXVsYXRlTWVzc2FnZShldmVudCwgc25hcHNob3QpIHtcbiAgICBsZXQgbmV3Q29udGVudCA9IFtdO1xuICAgIHN3aXRjaCAoZXZlbnQuZXZlbnQpIHtcbiAgICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuY3JlYXRlZCc6XG4gICAgICAgICAgICAvL09uIGNyZWF0aW9uIHRoZSBzbmFwc2hvdCBpcyBqdXN0IHRoZSBpbml0aWFsIG1lc3NhZ2VcbiAgICAgICAgICAgIHJldHVybiBbZXZlbnQuZGF0YSwgbmV3Q29udGVudF07XG4gICAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmRlbHRhJzpcbiAgICAgICAgICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignUmVjZWl2ZWQgYSBkZWx0YSB3aXRoIG5vIGV4aXN0aW5nIHNuYXBzaG90ICh0aGVyZSBzaG91bGQgYmUgb25lIGZyb20gbWVzc2FnZSBjcmVhdGlvbiknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIC8vSWYgdGhpcyBkZWx0YSBkb2VzIG5vdCBoYXZlIGNvbnRlbnQsIG5vdGhpbmcgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKGRhdGEuZGVsdGEuY29udGVudCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udGVudEVsZW1lbnQgb2YgZGF0YS5kZWx0YS5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50RWxlbWVudC5pbmRleCBpbiBzbmFwc2hvdC5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudENvbnRlbnQgPSBzbmFwc2hvdC5jb250ZW50W2NvbnRlbnRFbGVtZW50LmluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBzaG90LmNvbnRlbnRbY29udGVudEVsZW1lbnQuaW5kZXhdID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9Bc3Npc3RhbnRTdHJlYW1fYWNjdW11bGF0ZUNvbnRlbnQpLmNhbGwodGhpcywgY29udGVudEVsZW1lbnQsIGN1cnJlbnRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBzaG90LmNvbnRlbnRbY29udGVudEVsZW1lbnQuaW5kZXhdID0gY29udGVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRlbnQucHVzaChjb250ZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3NuYXBzaG90LCBuZXdDb250ZW50XTtcbiAgICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuaW5fcHJvZ3Jlc3MnOlxuICAgICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5jb21wbGV0ZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5pbmNvbXBsZXRlJzpcbiAgICAgICAgICAgIC8vTm8gY2hhbmdlcyBvbiBvdGhlciB0aHJlYWQgZXZlbnRzXG4gICAgICAgICAgICBpZiAoc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NuYXBzaG90LCBuZXdDb250ZW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdSZWNlaXZlZCB0aHJlYWQgbWVzc2FnZSBldmVudCB3aXRoIG5vIGV4aXN0aW5nIHNuYXBzaG90Jyk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdUcmllZCB0byBhY2N1bXVsYXRlIGEgbm9uLW1lc3NhZ2UgZXZlbnQnKTtcbn0sIF9Bc3Npc3RhbnRTdHJlYW1fYWNjdW11bGF0ZUNvbnRlbnQgPSBmdW5jdGlvbiBfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVDb250ZW50KGNvbnRlbnRFbGVtZW50LCBjdXJyZW50Q29udGVudCkge1xuICAgIHJldHVybiBBc3Npc3RhbnRTdHJlYW0uYWNjdW11bGF0ZURlbHRhKGN1cnJlbnRDb250ZW50LCBjb250ZW50RWxlbWVudCk7XG59LCBfQXNzaXN0YW50U3RyZWFtX2hhbmRsZVJ1biA9IGZ1bmN0aW9uIF9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlUnVuKGV2ZW50KSB7XG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRSdW5TbmFwc2hvdCwgZXZlbnQuZGF0YSwgXCJmXCIpO1xuICAgIHN3aXRjaCAoZXZlbnQuZXZlbnQpIHtcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jcmVhdGVkJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnF1ZXVlZCc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5pbl9wcm9ncmVzcyc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5yZXF1aXJlc19hY3Rpb24nOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLmNhbmNlbGxlZCc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uZmFpbGVkJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jb21wbGV0ZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLmV4cGlyZWQnOlxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2ZpbmFsUnVuLCBldmVudC5kYXRhLCBcImZcIik7XG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRUb29sQ2FsbCwgXCJmXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgndG9vbENhbGxEb25lJywgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRUb29sQ2FsbCwgXCJmXCIpKTtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsLCB1bmRlZmluZWQsIFwiZlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0aHJlYWQucnVuLmNhbmNlbGxpbmcnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzc2lzdGFudFN0cmVhbS5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uLy4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCIuLi8uLi8uLi9jb3JlLm1qc1wiO1xuaW1wb3J0ICogYXMgTWVzc2FnZXNBUEkgZnJvbSBcIi4vbWVzc2FnZXMubWpzXCI7XG5pbXBvcnQgeyBDdXJzb3JQYWdlIH0gZnJvbSBcIi4uLy4uLy4uL3BhZ2luYXRpb24ubWpzXCI7XG5leHBvcnQgY2xhc3MgTWVzc2FnZXMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBjcmVhdGUodGhyZWFkSWQsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9tZXNzYWdlc2AsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgbWVzc2FnZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZSh0aHJlYWRJZCwgbWVzc2FnZUlkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9tZXNzYWdlcy8ke21lc3NhZ2VJZH1gLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIGEgbWVzc2FnZS5cbiAgICAgKi9cbiAgICB1cGRhdGUodGhyZWFkSWQsIG1lc3NhZ2VJZCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L21lc3NhZ2VzLyR7bWVzc2FnZUlkfWAsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3QodGhyZWFkSWQsIHF1ZXJ5ID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0KHRocmVhZElkLCB7fSwgcXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vbWVzc2FnZXNgLCBNZXNzYWdlc1BhZ2UsIHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBkZWwodGhyZWFkSWQsIG1lc3NhZ2VJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL3RocmVhZHMvJHt0aHJlYWRJZH0vbWVzc2FnZXMvJHttZXNzYWdlSWR9YCwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBNZXNzYWdlc1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlIHtcbn1cbihmdW5jdGlvbiAoTWVzc2FnZXMpIHtcbiAgICBNZXNzYWdlcy5NZXNzYWdlc1BhZ2UgPSBNZXNzYWdlc0FQSS5NZXNzYWdlc1BhZ2U7XG59KShNZXNzYWdlcyB8fCAoTWVzc2FnZXMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZXMubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9yZXNvdXJjZS5tanNcIjtcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vY29yZS5tanNcIjtcbmltcG9ydCAqIGFzIFN0ZXBzQVBJIGZyb20gXCIuL3N0ZXBzLm1qc1wiO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9wYWdpbmF0aW9uLm1qc1wiO1xuZXhwb3J0IGNsYXNzIFN0ZXBzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIHJ1biBzdGVwLlxuICAgICAqL1xuICAgIHJldHJpZXZlKHRocmVhZElkLCBydW5JZCwgc3RlcElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9L3N0ZXBzLyR7c3RlcElkfWAsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGlzdCh0aHJlYWRJZCwgcnVuSWQsIHF1ZXJ5ID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0KHRocmVhZElkLCBydW5JZCwge30sIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvJHtydW5JZH0vc3RlcHNgLCBSdW5TdGVwc1BhZ2UsIHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSdW5TdGVwc1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlIHtcbn1cbihmdW5jdGlvbiAoU3RlcHMpIHtcbiAgICBTdGVwcy5SdW5TdGVwc1BhZ2UgPSBTdGVwc0FQSS5SdW5TdGVwc1BhZ2U7XG59KShTdGVwcyB8fCAoU3RlcHMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RlcHMubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9yZXNvdXJjZS5tanNcIjtcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vY29yZS5tanNcIjtcbmltcG9ydCB7IEFzc2lzdGFudFN0cmVhbSB9IGZyb20gXCIuLi8uLi8uLi8uLi9saWIvQXNzaXN0YW50U3RyZWFtLm1qc1wiO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tIFwiLi4vLi4vLi4vLi4vY29yZS5tanNcIjtcbmltcG9ydCAqIGFzIFJ1bnNBUEkgZnJvbSBcIi4vcnVucy5tanNcIjtcbmltcG9ydCAqIGFzIFN0ZXBzQVBJIGZyb20gXCIuL3N0ZXBzLm1qc1wiO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9wYWdpbmF0aW9uLm1qc1wiO1xuZXhwb3J0IGNsYXNzIFJ1bnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RlcHMgPSBuZXcgU3RlcHNBUEkuU3RlcHModGhpcy5fY2xpZW50KTtcbiAgICB9XG4gICAgY3JlYXRlKHRocmVhZElkLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVuc2AsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgICAgIHN0cmVhbTogYm9keS5zdHJlYW0gPz8gZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBydW4uXG4gICAgICovXG4gICAgcmV0cmlldmUodGhyZWFkSWQsIHJ1bklkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9YCwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb2RpZmllcyBhIHJ1bi5cbiAgICAgKi9cbiAgICB1cGRhdGUodGhyZWFkSWQsIHJ1bklkLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfWAsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3QodGhyZWFkSWQsIHF1ZXJ5ID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0KHRocmVhZElkLCB7fSwgcXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVuc2AsIFJ1bnNQYWdlLCB7XG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhIHJ1biB0aGF0IGlzIGBpbl9wcm9ncmVzc2AuXG4gICAgICovXG4gICAgY2FuY2VsKHRocmVhZElkLCBydW5JZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvJHtydW5JZH0vY2FuY2VsYCwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciB0byBjcmVhdGUgYSBydW4gYW4gcG9sbCBmb3IgYSB0ZXJtaW5hbCBzdGF0ZS4gTW9yZSBpbmZvcm1hdGlvbiBvbiBSdW5cbiAgICAgKiBsaWZlY3ljbGVzIGNhbiBiZSBmb3VuZCBoZXJlOlxuICAgICAqIGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvaG93LWl0LXdvcmtzL3J1bnMtYW5kLXJ1bi1zdGVwc1xuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUFuZFBvbGwodGhyZWFkSWQsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcnVuID0gYXdhaXQgdGhpcy5jcmVhdGUodGhyZWFkSWQsIGJvZHksIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb2xsKHRocmVhZElkLCBydW4uaWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBSdW4gc3RyZWFtXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2UgYHN0cmVhbWAgaW5zdGVhZFxuICAgICAqL1xuICAgIGNyZWF0ZUFuZFN0cmVhbSh0aHJlYWRJZCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gQXNzaXN0YW50U3RyZWFtLmNyZWF0ZUFzc2lzdGFudFN0cmVhbSh0aHJlYWRJZCwgdGhpcy5fY2xpZW50LmJldGEudGhyZWFkcy5ydW5zLCBib2R5LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgdG8gcG9sbCBhIHJ1biBzdGF0dXMgdW50aWwgaXQgcmVhY2hlcyBhIHRlcm1pbmFsIHN0YXRlLiBNb3JlXG4gICAgICogaW5mb3JtYXRpb24gb24gUnVuIGxpZmVjeWNsZXMgY2FuIGJlIGZvdW5kIGhlcmU6XG4gICAgICogaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy9ob3ctaXQtd29ya3MvcnVucy1hbmQtcnVuLXN0ZXBzXG4gICAgICovXG4gICAgYXN5bmMgcG9sbCh0aHJlYWRJZCwgcnVuSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLVBvbGwtSGVscGVyJzogJ3RydWUnIH07XG4gICAgICAgIGlmIChvcHRpb25zPy5wb2xsSW50ZXJ2YWxNcykge1xuICAgICAgICAgICAgaGVhZGVyc1snWC1TdGFpbmxlc3MtQ3VzdG9tLVBvbGwtSW50ZXJ2YWwnXSA9IG9wdGlvbnMucG9sbEludGVydmFsTXMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBydW4sIHJlc3BvbnNlIH0gPSBhd2FpdCB0aGlzLnJldHJpZXZlKHRocmVhZElkLCBydW5JZCwge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi5vcHRpb25zPy5oZWFkZXJzLCAuLi5oZWFkZXJzIH0sXG4gICAgICAgICAgICB9KS53aXRoUmVzcG9uc2UoKTtcbiAgICAgICAgICAgIHN3aXRjaCAocnVuLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIC8vSWYgd2UgYXJlIGluIGFueSBzb3J0IG9mIGludGVybWVkaWF0ZSBzdGF0ZSB3ZSBwb2xsXG4gICAgICAgICAgICAgICAgY2FzZSAncXVldWVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdpbl9wcm9ncmVzcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY2FuY2VsbGluZyc6XG4gICAgICAgICAgICAgICAgICAgIGxldCBzbGVlcEludGVydmFsID0gNTAwMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnM/LnBvbGxJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbGVlcEludGVydmFsID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlckludGVydmFsID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ29wZW5haS1wb2xsLWFmdGVyLW1zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVySW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJJbnRlcnZhbE1zID0gcGFyc2VJbnQoaGVhZGVySW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4oaGVhZGVySW50ZXJ2YWxNcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xlZXBJbnRlcnZhbCA9IGhlYWRlckludGVydmFsTXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKHNsZWVwSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvL1dlIHJldHVybiB0aGUgcnVuIGluIGFueSB0ZXJtaW5hbCBzdGF0ZS5cbiAgICAgICAgICAgICAgICBjYXNlICdyZXF1aXJlc19hY3Rpb24nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2luY29tcGxldGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NhbmNlbGxlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2V4cGlyZWQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFJ1biBzdHJlYW1cbiAgICAgKi9cbiAgICBzdHJlYW0odGhyZWFkSWQsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIEFzc2lzdGFudFN0cmVhbS5jcmVhdGVBc3Npc3RhbnRTdHJlYW0odGhyZWFkSWQsIHRoaXMuX2NsaWVudC5iZXRhLnRocmVhZHMucnVucywgYm9keSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN1Ym1pdFRvb2xPdXRwdXRzKHRocmVhZElkLCBydW5JZCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvJHtydW5JZH0vc3VibWl0X3Rvb2xfb3V0cHV0c2AsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgICAgIHN0cmVhbTogYm9keS5zdHJlYW0gPz8gZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciB0byBzdWJtaXQgYSB0b29sIG91dHB1dCB0byBhIHJ1biBhbmQgcG9sbCBmb3IgYSB0ZXJtaW5hbCBydW4gc3RhdGUuXG4gICAgICogTW9yZSBpbmZvcm1hdGlvbiBvbiBSdW4gbGlmZWN5Y2xlcyBjYW4gYmUgZm91bmQgaGVyZTpcbiAgICAgKiBodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL2hvdy1pdC13b3Jrcy9ydW5zLWFuZC1ydW4tc3RlcHNcbiAgICAgKi9cbiAgICBhc3luYyBzdWJtaXRUb29sT3V0cHV0c0FuZFBvbGwodGhyZWFkSWQsIHJ1bklkLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IGF3YWl0IHRoaXMuc3VibWl0VG9vbE91dHB1dHModGhyZWFkSWQsIHJ1bklkLCBib2R5LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9sbCh0aHJlYWRJZCwgcnVuLmlkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VibWl0IHRoZSB0b29sIG91dHB1dHMgZnJvbSBhIHByZXZpb3VzIHJ1biBhbmQgc3RyZWFtIHRoZSBydW4gdG8gYSB0ZXJtaW5hbFxuICAgICAqIHN0YXRlLiBNb3JlIGluZm9ybWF0aW9uIG9uIFJ1biBsaWZlY3ljbGVzIGNhbiBiZSBmb3VuZCBoZXJlOlxuICAgICAqIGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvaG93LWl0LXdvcmtzL3J1bnMtYW5kLXJ1bi1zdGVwc1xuICAgICAqL1xuICAgIHN1Ym1pdFRvb2xPdXRwdXRzU3RyZWFtKHRocmVhZElkLCBydW5JZCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gQXNzaXN0YW50U3RyZWFtLmNyZWF0ZVRvb2xBc3Npc3RhbnRTdHJlYW0odGhyZWFkSWQsIHJ1bklkLCB0aGlzLl9jbGllbnQuYmV0YS50aHJlYWRzLnJ1bnMsIGJvZHksIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSdW5zUGFnZSBleHRlbmRzIEN1cnNvclBhZ2Uge1xufVxuKGZ1bmN0aW9uIChSdW5zKSB7XG4gICAgUnVucy5SdW5zUGFnZSA9IFJ1bnNBUEkuUnVuc1BhZ2U7XG4gICAgUnVucy5TdGVwcyA9IFN0ZXBzQVBJLlN0ZXBzO1xuICAgIFJ1bnMuUnVuU3RlcHNQYWdlID0gU3RlcHNBUEkuUnVuU3RlcHNQYWdlO1xufSkoUnVucyB8fCAoUnVucyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ydW5zLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vLi4vcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUubWpzXCI7XG5pbXBvcnQgeyBBc3Npc3RhbnRTdHJlYW0gfSBmcm9tIFwiLi4vLi4vLi4vbGliL0Fzc2lzdGFudFN0cmVhbS5tanNcIjtcbmltcG9ydCAqIGFzIE1lc3NhZ2VzQVBJIGZyb20gXCIuL21lc3NhZ2VzLm1qc1wiO1xuaW1wb3J0ICogYXMgUnVuc0FQSSBmcm9tIFwiLi9ydW5zL3J1bnMubWpzXCI7XG5leHBvcnQgY2xhc3MgVGhyZWFkcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ydW5zID0gbmV3IFJ1bnNBUEkuUnVucyh0aGlzLl9jbGllbnQpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gbmV3IE1lc3NhZ2VzQVBJLk1lc3NhZ2VzKHRoaXMuX2NsaWVudCk7XG4gICAgfVxuICAgIGNyZWF0ZShib2R5ID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMoYm9keSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh7fSwgYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvdGhyZWFkcycsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIHRocmVhZC5cbiAgICAgKi9cbiAgICByZXRyaWV2ZSh0aHJlYWRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL3RocmVhZHMvJHt0aHJlYWRJZH1gLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIGEgdGhyZWFkLlxuICAgICAqL1xuICAgIHVwZGF0ZSh0aHJlYWRJZCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9YCwge1xuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgdGhyZWFkLlxuICAgICAqL1xuICAgIGRlbCh0aHJlYWRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL3RocmVhZHMvJHt0aHJlYWRJZH1gLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZUFuZFJ1bihib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL3RocmVhZHMvcnVucycsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgICAgIHN0cmVhbTogYm9keS5zdHJlYW0gPz8gZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciB0byBjcmVhdGUgYSB0aHJlYWQsIHN0YXJ0IGEgcnVuIGFuZCB0aGVuIHBvbGwgZm9yIGEgdGVybWluYWwgc3RhdGUuXG4gICAgICogTW9yZSBpbmZvcm1hdGlvbiBvbiBSdW4gbGlmZWN5Y2xlcyBjYW4gYmUgZm91bmQgaGVyZTpcbiAgICAgKiBodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL2hvdy1pdC13b3Jrcy9ydW5zLWFuZC1ydW4tc3RlcHNcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVBbmRSdW5Qb2xsKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcnVuID0gYXdhaXQgdGhpcy5jcmVhdGVBbmRSdW4oYm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJ1bnMucG9sbChydW4udGhyZWFkX2lkLCBydW4uaWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB0aHJlYWQgYW5kIHN0cmVhbSB0aGUgcnVuIGJhY2tcbiAgICAgKi9cbiAgICBjcmVhdGVBbmRSdW5TdHJlYW0oYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gQXNzaXN0YW50U3RyZWFtLmNyZWF0ZVRocmVhZEFzc2lzdGFudFN0cmVhbShib2R5LCB0aGlzLl9jbGllbnQuYmV0YS50aHJlYWRzLCBvcHRpb25zKTtcbiAgICB9XG59XG4oZnVuY3Rpb24gKFRocmVhZHMpIHtcbiAgICBUaHJlYWRzLlJ1bnMgPSBSdW5zQVBJLlJ1bnM7XG4gICAgVGhyZWFkcy5SdW5zUGFnZSA9IFJ1bnNBUEkuUnVuc1BhZ2U7XG4gICAgVGhyZWFkcy5NZXNzYWdlcyA9IE1lc3NhZ2VzQVBJLk1lc3NhZ2VzO1xuICAgIFRocmVhZHMuTWVzc2FnZXNQYWdlID0gTWVzc2FnZXNBUEkuTWVzc2FnZXNQYWdlO1xufSkoVGhyZWFkcyB8fCAoVGhyZWFkcyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJlYWRzLm1qcy5tYXAiLCIvKipcbiAqIExpa2UgYFByb21pc2UuYWxsU2V0dGxlZCgpYCBidXQgdGhyb3dzIGFuIGVycm9yIGlmIGFueSBwcm9taXNlcyBhcmUgcmVqZWN0ZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBhbGxTZXR0bGVkV2l0aFRocm93ID0gYXN5bmMgKHByb21pc2VzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChwcm9taXNlcyk7XG4gICAgY29uc3QgcmVqZWN0ZWQgPSByZXN1bHRzLmZpbHRlcigocmVzdWx0KSA9PiByZXN1bHQuc3RhdHVzID09PSAncmVqZWN0ZWQnKTtcbiAgICBpZiAocmVqZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlamVjdGVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlc3VsdC5yZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZWplY3RlZC5sZW5ndGh9IHByb21pc2UocykgZmFpbGVkIC0gc2VlIHRoZSBhYm92ZSBlcnJvcnNgKTtcbiAgICB9XG4gICAgLy8gTm90ZTogVFMgd2FzIGNvbXBsYWluaW5nIGFib3V0IHVzaW5nIGAuZmlsdGVyKCkubWFwKClgIGhlcmUgZm9yIHNvbWUgcmVhc29uXG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VdGlsLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vLi4vcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBzbGVlcCwgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCIuLi8uLi8uLi9jb3JlLm1qc1wiO1xuaW1wb3J0ICogYXMgRmlsZXNBUEkgZnJvbSBcIi4vZmlsZXMubWpzXCI7XG5pbXBvcnQgeyBDdXJzb3JQYWdlIH0gZnJvbSBcIi4uLy4uLy4uL3BhZ2luYXRpb24ubWpzXCI7XG5leHBvcnQgY2xhc3MgRmlsZXMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdmVjdG9yIHN0b3JlIGZpbGUgYnkgYXR0YWNoaW5nIGFcbiAgICAgKiBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgdG8gYVxuICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpLlxuICAgICAqL1xuICAgIGNyZWF0ZSh2ZWN0b3JTdG9yZUlkLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlc2AsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIHZlY3RvciBzdG9yZSBmaWxlLlxuICAgICAqL1xuICAgIHJldHJpZXZlKHZlY3RvclN0b3JlSWQsIGZpbGVJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlcy8ke2ZpbGVJZH1gLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3QodmVjdG9yU3RvcmVJZCwgcXVlcnkgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3QodmVjdG9yU3RvcmVJZCwge30sIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH0vZmlsZXNgLCBWZWN0b3JTdG9yZUZpbGVzUGFnZSwge1xuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHZlY3RvciBzdG9yZSBmaWxlLiBUaGlzIHdpbGwgcmVtb3ZlIHRoZSBmaWxlIGZyb20gdGhlIHZlY3RvciBzdG9yZSBidXRcbiAgICAgKiB0aGUgZmlsZSBpdHNlbGYgd2lsbCBub3QgYmUgZGVsZXRlZC4gVG8gZGVsZXRlIHRoZSBmaWxlLCB1c2UgdGhlXG4gICAgICogW2RlbGV0ZSBmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL2RlbGV0ZSlcbiAgICAgKiBlbmRwb2ludC5cbiAgICAgKi9cbiAgICBkZWwodmVjdG9yU3RvcmVJZCwgZmlsZUlkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZGVsZXRlKGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9L2ZpbGVzLyR7ZmlsZUlkfWAsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoIGEgZmlsZSB0byB0aGUgZ2l2ZW4gdmVjdG9yIHN0b3JlIGFuZCB3YWl0IGZvciBpdCB0byBiZSBwcm9jZXNzZWQuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQW5kUG9sbCh2ZWN0b3JTdG9yZUlkLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0aGlzLmNyZWF0ZSh2ZWN0b3JTdG9yZUlkLCBib2R5LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9sbCh2ZWN0b3JTdG9yZUlkLCBmaWxlLmlkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdCBmb3IgdGhlIHZlY3RvciBzdG9yZSBmaWxlIHRvIGZpbmlzaCBwcm9jZXNzaW5nLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyB3aWxsIHJldHVybiBldmVuIGlmIHRoZSBmaWxlIGZhaWxlZCB0byBwcm9jZXNzLCB5b3UgbmVlZCB0byBjaGVja1xuICAgICAqIGZpbGUubGFzdF9lcnJvciBhbmQgZmlsZS5zdGF0dXMgdG8gaGFuZGxlIHRoZXNlIGNhc2VzXG4gICAgICovXG4gICAgYXN5bmMgcG9sbCh2ZWN0b3JTdG9yZUlkLCBmaWxlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLVBvbGwtSGVscGVyJzogJ3RydWUnIH07XG4gICAgICAgIGlmIChvcHRpb25zPy5wb2xsSW50ZXJ2YWxNcykge1xuICAgICAgICAgICAgaGVhZGVyc1snWC1TdGFpbmxlc3MtQ3VzdG9tLVBvbGwtSW50ZXJ2YWwnXSA9IG9wdGlvbnMucG9sbEludGVydmFsTXMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgZmlsZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXRyaWV2ZSh2ZWN0b3JTdG9yZUlkLCBmaWxlSWQsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICB9KS53aXRoUmVzcG9uc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBmaWxlUmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmlsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpbl9wcm9ncmVzcyc6XG4gICAgICAgICAgICAgICAgICAgIGxldCBzbGVlcEludGVydmFsID0gNTAwMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnM/LnBvbGxJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbGVlcEludGVydmFsID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlckludGVydmFsID0gZmlsZVJlc3BvbnNlLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdvcGVuYWktcG9sbC1hZnRlci1tcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlckludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVySW50ZXJ2YWxNcyA9IHBhcnNlSW50KGhlYWRlckludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGhlYWRlckludGVydmFsTXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsZWVwSW50ZXJ2YWwgPSBoZWFkZXJJbnRlcnZhbE1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcChzbGVlcEludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYSBmaWxlIHRvIHRoZSBgZmlsZXNgIEFQSSBhbmQgdGhlbiBhdHRhY2ggaXQgdG8gdGhlIGdpdmVuIHZlY3RvciBzdG9yZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhlIGZpbGUgd2lsbCBiZSBhc3luY2hyb25vdXNseSBwcm9jZXNzZWQgKHlvdSBjYW4gdXNlIHRoZSBhbHRlcm5hdGl2ZVxuICAgICAqIHBvbGxpbmcgaGVscGVyIG1ldGhvZCB0byB3YWl0IGZvciBwcm9jZXNzaW5nIHRvIGNvbXBsZXRlKS5cbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWQodmVjdG9yU3RvcmVJZCwgZmlsZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBmaWxlSW5mbyA9IGF3YWl0IHRoaXMuX2NsaWVudC5maWxlcy5jcmVhdGUoeyBmaWxlOiBmaWxlLCBwdXJwb3NlOiAnYXNzaXN0YW50cycgfSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh2ZWN0b3JTdG9yZUlkLCB7IGZpbGVfaWQ6IGZpbGVJbmZvLmlkIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBmaWxlIHRvIGEgdmVjdG9yIHN0b3JlIGFuZCBwb2xsIHVudGlsIHByb2Nlc3NpbmcgaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkQW5kUG9sbCh2ZWN0b3JTdG9yZUlkLCBmaWxlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZpbGVJbmZvID0gYXdhaXQgdGhpcy51cGxvYWQodmVjdG9yU3RvcmVJZCwgZmlsZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvbGwodmVjdG9yU3RvcmVJZCwgZmlsZUluZm8uaWQsIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBWZWN0b3JTdG9yZUZpbGVzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2Uge1xufVxuKGZ1bmN0aW9uIChGaWxlcykge1xuICAgIEZpbGVzLlZlY3RvclN0b3JlRmlsZXNQYWdlID0gRmlsZXNBUEkuVmVjdG9yU3RvcmVGaWxlc1BhZ2U7XG59KShGaWxlcyB8fCAoRmlsZXMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsZXMubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi8uLi9yZXNvdXJjZS5tanNcIjtcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS5tanNcIjtcbmltcG9ydCB7IHNsZWVwIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUubWpzXCI7XG5pbXBvcnQgeyBhbGxTZXR0bGVkV2l0aFRocm93IH0gZnJvbSBcIi4uLy4uLy4uL2xpYi9VdGlsLm1qc1wiO1xuaW1wb3J0IHsgVmVjdG9yU3RvcmVGaWxlc1BhZ2UgfSBmcm9tIFwiLi9maWxlcy5tanNcIjtcbmV4cG9ydCBjbGFzcyBGaWxlQmF0Y2hlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB2ZWN0b3Igc3RvcmUgZmlsZSBiYXRjaC5cbiAgICAgKi9cbiAgICBjcmVhdGUodmVjdG9yU3RvcmVJZCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH0vZmlsZV9iYXRjaGVzYCwge1xuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgdmVjdG9yIHN0b3JlIGZpbGUgYmF0Y2guXG4gICAgICovXG4gICAgcmV0cmlldmUodmVjdG9yU3RvcmVJZCwgYmF0Y2hJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlX2JhdGNoZXMvJHtiYXRjaElkfWAsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VsIGEgdmVjdG9yIHN0b3JlIGZpbGUgYmF0Y2guIFRoaXMgYXR0ZW1wdHMgdG8gY2FuY2VsIHRoZSBwcm9jZXNzaW5nIG9mXG4gICAgICogZmlsZXMgaW4gdGhpcyBiYXRjaCBhcyBzb29uIGFzIHBvc3NpYmxlLlxuICAgICAqL1xuICAgIGNhbmNlbCh2ZWN0b3JTdG9yZUlkLCBiYXRjaElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlX2JhdGNoZXMvJHtiYXRjaElkfS9jYW5jZWxgLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHZlY3RvciBzdG9yZSBiYXRjaCBhbmQgcG9sbCB1bnRpbCBhbGwgZmlsZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZC5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVBbmRQb2xsKHZlY3RvclN0b3JlSWQsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYmF0Y2ggPSBhd2FpdCB0aGlzLmNyZWF0ZSh2ZWN0b3JTdG9yZUlkLCBib2R5KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9sbCh2ZWN0b3JTdG9yZUlkLCBiYXRjaC5pZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGxpc3RGaWxlcyh2ZWN0b3JTdG9yZUlkLCBiYXRjaElkLCBxdWVyeSA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdEZpbGVzKHZlY3RvclN0b3JlSWQsIGJhdGNoSWQsIHt9LCBxdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9L2ZpbGVfYmF0Y2hlcy8ke2JhdGNoSWR9L2ZpbGVzYCwgVmVjdG9yU3RvcmVGaWxlc1BhZ2UsIHsgcXVlcnksIC4uLm9wdGlvbnMsIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXQgZm9yIHRoZSBnaXZlbiBmaWxlIGJhdGNoIHRvIGJlIHByb2Nlc3NlZC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgd2lsbCByZXR1cm4gZXZlbiBpZiBvbmUgb2YgdGhlIGZpbGVzIGZhaWxlZCB0byBwcm9jZXNzLCB5b3UgbmVlZCB0b1xuICAgICAqIGNoZWNrIGJhdGNoLmZpbGVfY291bnRzLmZhaWxlZF9jb3VudCB0byBoYW5kbGUgdGhpcyBjYXNlLlxuICAgICAqL1xuICAgIGFzeW5jIHBvbGwodmVjdG9yU3RvcmVJZCwgYmF0Y2hJZCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0geyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtUG9sbC1IZWxwZXInOiAndHJ1ZScgfTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LnBvbGxJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydYLVN0YWlubGVzcy1DdXN0b20tUG9sbC1JbnRlcnZhbCddID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNcy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGJhdGNoLCByZXNwb25zZSB9ID0gYXdhaXQgdGhpcy5yZXRyaWV2ZSh2ZWN0b3JTdG9yZUlkLCBiYXRjaElkLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgfSkud2l0aFJlc3BvbnNlKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGJhdGNoLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2luX3Byb2dyZXNzJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNsZWVwSW50ZXJ2YWwgPSA1MDAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucz8ucG9sbEludGVydmFsTXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsZWVwSW50ZXJ2YWwgPSBvcHRpb25zLnBvbGxJbnRlcnZhbE1zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVySW50ZXJ2YWwgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnb3BlbmFpLXBvbGwtYWZ0ZXItbXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZWFkZXJJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlckludGVydmFsTXMgPSBwYXJzZUludChoZWFkZXJJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihoZWFkZXJJbnRlcnZhbE1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGVlcEludGVydmFsID0gaGVhZGVySW50ZXJ2YWxNcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAoc2xlZXBJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY2FuY2VsbGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyB0aGUgZ2l2ZW4gZmlsZXMgY29uY3VycmVudGx5IGFuZCB0aGVuIGNyZWF0ZXMgYSB2ZWN0b3Igc3RvcmUgZmlsZSBiYXRjaC5cbiAgICAgKlxuICAgICAqIFRoZSBjb25jdXJyZW5jeSBsaW1pdCBpcyBjb25maWd1cmFibGUgdXNpbmcgdGhlIGBtYXhDb25jdXJyZW5jeWAgcGFyYW1ldGVyLlxuICAgICAqL1xuICAgIGFzeW5jIHVwbG9hZEFuZFBvbGwodmVjdG9yU3RvcmVJZCwgeyBmaWxlcywgZmlsZUlkcyA9IFtdIH0sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGZpbGVzID09IG51bGwgfHwgZmlsZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gXFxgZmlsZXNcXGAgcHJvdmlkZWQgdG8gcHJvY2Vzcy4gSWYgeW91J3ZlIGFscmVhZHkgdXBsb2FkZWQgZmlsZXMgeW91IHNob3VsZCB1c2UgXFxgLmNyZWF0ZUFuZFBvbGwoKVxcYCBpbnN0ZWFkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlndXJlZENvbmN1cnJlbmN5ID0gb3B0aW9ucz8ubWF4Q29uY3VycmVuY3kgPz8gNTtcbiAgICAgICAgLy8gV2UgY2FwIHRoZSBudW1iZXIgb2Ygd29ya2VycyBhdCB0aGUgbnVtYmVyIG9mIGZpbGVzIChzbyB3ZSBkb24ndCBzdGFydCBhbnkgdW5uZWNlc3Nhcnkgd29ya2VycylcbiAgICAgICAgY29uc3QgY29uY3VycmVuY3lMaW1pdCA9IE1hdGgubWluKGNvbmZpZ3VyZWRDb25jdXJyZW5jeSwgZmlsZXMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5fY2xpZW50O1xuICAgICAgICBjb25zdCBmaWxlSXRlcmF0b3IgPSBmaWxlcy52YWx1ZXMoKTtcbiAgICAgICAgY29uc3QgYWxsRmlsZUlkcyA9IFsuLi5maWxlSWRzXTtcbiAgICAgICAgLy8gVGhpcyBjb2RlIGlzIGJhc2VkIG9uIHRoaXMgZGVzaWduLiBUaGUgbGlicmFyaWVzIGRvbid0IGFjY29tbW9kYXRlIG91ciBlbnZpcm9ubWVudCBsaW1pdHMuXG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQwNjM5NDMyL3doYXQtaXMtdGhlLWJlc3Qtd2F5LXRvLWxpbWl0LWNvbmN1cnJlbmN5LXdoZW4tdXNpbmctZXM2cy1wcm9taXNlLWFsbFxuICAgICAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzRmlsZXMoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgaXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlT2JqID0gYXdhaXQgY2xpZW50LmZpbGVzLmNyZWF0ZSh7IGZpbGU6IGl0ZW0sIHB1cnBvc2U6ICdhc3Npc3RhbnRzJyB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBhbGxGaWxlSWRzLnB1c2goZmlsZU9iai5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQgd29ya2VycyB0byBwcm9jZXNzIHJlc3VsdHNcbiAgICAgICAgY29uc3Qgd29ya2VycyA9IEFycmF5KGNvbmN1cnJlbmN5TGltaXQpLmZpbGwoZmlsZUl0ZXJhdG9yKS5tYXAocHJvY2Vzc0ZpbGVzKTtcbiAgICAgICAgLy8gV2FpdCBmb3IgYWxsIHByb2Nlc3NpbmcgdG8gY29tcGxldGUuXG4gICAgICAgIGF3YWl0IGFsbFNldHRsZWRXaXRoVGhyb3cod29ya2Vycyk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZUFuZFBvbGwodmVjdG9yU3RvcmVJZCwge1xuICAgICAgICAgICAgZmlsZV9pZHM6IGFsbEZpbGVJZHMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbihmdW5jdGlvbiAoRmlsZUJhdGNoZXMpIHtcbn0pKEZpbGVCYXRjaGVzIHx8IChGaWxlQmF0Y2hlcyA9IHt9KSk7XG5leHBvcnQgeyBWZWN0b3JTdG9yZUZpbGVzUGFnZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsZS1iYXRjaGVzLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vLi4vcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUubWpzXCI7XG5pbXBvcnQgKiBhcyBWZWN0b3JTdG9yZXNBUEkgZnJvbSBcIi4vdmVjdG9yLXN0b3Jlcy5tanNcIjtcbmltcG9ydCAqIGFzIEZpbGVCYXRjaGVzQVBJIGZyb20gXCIuL2ZpbGUtYmF0Y2hlcy5tanNcIjtcbmltcG9ydCAqIGFzIEZpbGVzQVBJIGZyb20gXCIuL2ZpbGVzLm1qc1wiO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSB9IGZyb20gXCIuLi8uLi8uLi9wYWdpbmF0aW9uLm1qc1wiO1xuZXhwb3J0IGNsYXNzIFZlY3RvclN0b3JlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5maWxlcyA9IG5ldyBGaWxlc0FQSS5GaWxlcyh0aGlzLl9jbGllbnQpO1xuICAgICAgICB0aGlzLmZpbGVCYXRjaGVzID0gbmV3IEZpbGVCYXRjaGVzQVBJLkZpbGVCYXRjaGVzKHRoaXMuX2NsaWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHZlY3RvciBzdG9yZS5cbiAgICAgKi9cbiAgICBjcmVhdGUoYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy92ZWN0b3Jfc3RvcmVzJywge1xuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgdmVjdG9yIHN0b3JlLlxuICAgICAqL1xuICAgIHJldHJpZXZlKHZlY3RvclN0b3JlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH1gLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIGEgdmVjdG9yIHN0b3JlLlxuICAgICAqL1xuICAgIHVwZGF0ZSh2ZWN0b3JTdG9yZUlkLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfWAsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3QocXVlcnkgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Qoe30sIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoJy92ZWN0b3Jfc3RvcmVzJywgVmVjdG9yU3RvcmVzUGFnZSwge1xuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHZlY3RvciBzdG9yZS5cbiAgICAgKi9cbiAgICBkZWwodmVjdG9yU3RvcmVJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfWAsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVmVjdG9yU3RvcmVzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2Uge1xufVxuKGZ1bmN0aW9uIChWZWN0b3JTdG9yZXMpIHtcbiAgICBWZWN0b3JTdG9yZXMuVmVjdG9yU3RvcmVzUGFnZSA9IFZlY3RvclN0b3Jlc0FQSS5WZWN0b3JTdG9yZXNQYWdlO1xuICAgIFZlY3RvclN0b3Jlcy5GaWxlcyA9IEZpbGVzQVBJLkZpbGVzO1xuICAgIFZlY3RvclN0b3Jlcy5WZWN0b3JTdG9yZUZpbGVzUGFnZSA9IEZpbGVzQVBJLlZlY3RvclN0b3JlRmlsZXNQYWdlO1xuICAgIFZlY3RvclN0b3Jlcy5GaWxlQmF0Y2hlcyA9IEZpbGVCYXRjaGVzQVBJLkZpbGVCYXRjaGVzO1xufSkoVmVjdG9yU3RvcmVzIHx8IChWZWN0b3JTdG9yZXMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVjdG9yLXN0b3Jlcy5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0ICogYXMgQXNzaXN0YW50c0FQSSBmcm9tIFwiLi9hc3Npc3RhbnRzLm1qc1wiO1xuaW1wb3J0ICogYXMgQ2hhdEFQSSBmcm9tIFwiLi9jaGF0L2NoYXQubWpzXCI7XG5pbXBvcnQgKiBhcyBUaHJlYWRzQVBJIGZyb20gXCIuL3RocmVhZHMvdGhyZWFkcy5tanNcIjtcbmltcG9ydCAqIGFzIFZlY3RvclN0b3Jlc0FQSSBmcm9tIFwiLi92ZWN0b3Itc3RvcmVzL3ZlY3Rvci1zdG9yZXMubWpzXCI7XG5leHBvcnQgY2xhc3MgQmV0YSBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52ZWN0b3JTdG9yZXMgPSBuZXcgVmVjdG9yU3RvcmVzQVBJLlZlY3RvclN0b3Jlcyh0aGlzLl9jbGllbnQpO1xuICAgICAgICB0aGlzLmNoYXQgPSBuZXcgQ2hhdEFQSS5DaGF0KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIHRoaXMuYXNzaXN0YW50cyA9IG5ldyBBc3Npc3RhbnRzQVBJLkFzc2lzdGFudHModGhpcy5fY2xpZW50KTtcbiAgICAgICAgdGhpcy50aHJlYWRzID0gbmV3IFRocmVhZHNBUEkuVGhyZWFkcyh0aGlzLl9jbGllbnQpO1xuICAgIH1cbn1cbihmdW5jdGlvbiAoQmV0YSkge1xuICAgIEJldGEuVmVjdG9yU3RvcmVzID0gVmVjdG9yU3RvcmVzQVBJLlZlY3RvclN0b3JlcztcbiAgICBCZXRhLlZlY3RvclN0b3Jlc1BhZ2UgPSBWZWN0b3JTdG9yZXNBUEkuVmVjdG9yU3RvcmVzUGFnZTtcbiAgICBCZXRhLkNoYXQgPSBDaGF0QVBJLkNoYXQ7XG4gICAgQmV0YS5Bc3Npc3RhbnRzID0gQXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRzO1xuICAgIEJldGEuQXNzaXN0YW50c1BhZ2UgPSBBc3Npc3RhbnRzQVBJLkFzc2lzdGFudHNQYWdlO1xuICAgIEJldGEuVGhyZWFkcyA9IFRocmVhZHNBUEkuVGhyZWFkcztcbn0pKEJldGEgfHwgKEJldGEgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmV0YS5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uL3Jlc291cmNlLm1qc1wiO1xuZXhwb3J0IGNsYXNzIENvbXBsZXRpb25zIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIGNyZWF0ZShib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2NvbXBsZXRpb25zJywgeyBib2R5LCAuLi5vcHRpb25zLCBzdHJlYW06IGJvZHkuc3RyZWFtID8/IGZhbHNlIH0pO1xuICAgIH1cbn1cbihmdW5jdGlvbiAoQ29tcGxldGlvbnMpIHtcbn0pKENvbXBsZXRpb25zIHx8IChDb21wbGV0aW9ucyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wbGV0aW9ucy5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uL3Jlc291cmNlLm1qc1wiO1xuZXhwb3J0IGNsYXNzIEVtYmVkZGluZ3MgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlbWJlZGRpbmcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgaW5wdXQgdGV4dC5cbiAgICAgKi9cbiAgICBjcmVhdGUoYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9lbWJlZGRpbmdzJywgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICAgIH1cbn1cbihmdW5jdGlvbiAoRW1iZWRkaW5ncykge1xufSkoRW1iZWRkaW5ncyB8fCAoRW1iZWRkaW5ncyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbWJlZGRpbmdzLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSBcIi4uL2NvcmUubWpzXCI7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gXCIuLi9jb3JlLm1qc1wiO1xuaW1wb3J0IHsgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvciB9IGZyb20gXCIuLi9lcnJvci5tanNcIjtcbmltcG9ydCAqIGFzIENvcmUgZnJvbSBcIi4uL2NvcmUubWpzXCI7XG5pbXBvcnQgKiBhcyBGaWxlc0FQSSBmcm9tIFwiLi9maWxlcy5tanNcIjtcbmltcG9ydCB7IFBhZ2UgfSBmcm9tIFwiLi4vcGFnaW5hdGlvbi5tanNcIjtcbmV4cG9ydCBjbGFzcyBGaWxlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYSBmaWxlIHRoYXQgY2FuIGJlIHVzZWQgYWNyb3NzIHZhcmlvdXMgZW5kcG9pbnRzLiBJbmRpdmlkdWFsIGZpbGVzIGNhbiBiZVxuICAgICAqIHVwIHRvIDUxMiBNQiwgYW5kIHRoZSBzaXplIG9mIGFsbCBmaWxlcyB1cGxvYWRlZCBieSBvbmUgb3JnYW5pemF0aW9uIGNhbiBiZSB1cFxuICAgICAqIHRvIDEwMCBHQi5cbiAgICAgKlxuICAgICAqIFRoZSBBc3Npc3RhbnRzIEFQSSBzdXBwb3J0cyBmaWxlcyB1cCB0byAyIG1pbGxpb24gdG9rZW5zIGFuZCBvZiBzcGVjaWZpYyBmaWxlXG4gICAgICogdHlwZXMuIFNlZSB0aGVcbiAgICAgKiBbQXNzaXN0YW50cyBUb29scyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy90b29scykgZm9yXG4gICAgICogZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoZSBGaW5lLXR1bmluZyBBUEkgb25seSBzdXBwb3J0cyBgLmpzb25sYCBmaWxlcy4gVGhlIGlucHV0IGFsc28gaGFzIGNlcnRhaW5cbiAgICAgKiByZXF1aXJlZCBmb3JtYXRzIGZvciBmaW5lLXR1bmluZ1xuICAgICAqIFtjaGF0XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbmUtdHVuaW5nL2NoYXQtaW5wdXQpIG9yXG4gICAgICogW2NvbXBsZXRpb25zXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbmUtdHVuaW5nL2NvbXBsZXRpb25zLWlucHV0KVxuICAgICAqIG1vZGVscy5cbiAgICAgKlxuICAgICAqIFRoZSBCYXRjaCBBUEkgb25seSBzdXBwb3J0cyBgLmpzb25sYCBmaWxlcyB1cCB0byAxMDAgTUIgaW4gc2l6ZS4gVGhlIGlucHV0IGFsc29cbiAgICAgKiBoYXMgYSBzcGVjaWZpYyByZXF1aXJlZFxuICAgICAqIFtmb3JtYXRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYmF0Y2gvcmVxdWVzdC1pbnB1dCkuXG4gICAgICpcbiAgICAgKiBQbGVhc2UgW2NvbnRhY3QgdXNdKGh0dHBzOi8vaGVscC5vcGVuYWkuY29tLykgaWYgeW91IG5lZWQgdG8gaW5jcmVhc2UgdGhlc2VcbiAgICAgKiBzdG9yYWdlIGxpbWl0cy5cbiAgICAgKi9cbiAgICBjcmVhdGUoYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9maWxlcycsIENvcmUubXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zKHsgYm9keSwgLi4ub3B0aW9ucyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgYSBzcGVjaWZpYyBmaWxlLlxuICAgICAqL1xuICAgIHJldHJpZXZlKGZpbGVJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL2ZpbGVzLyR7ZmlsZUlkfWAsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBsaXN0KHF1ZXJ5ID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0KHt9LCBxdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KCcvZmlsZXMnLCBGaWxlT2JqZWN0c1BhZ2UsIHsgcXVlcnksIC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIGZpbGUuXG4gICAgICovXG4gICAgZGVsKGZpbGVJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL2ZpbGVzLyR7ZmlsZUlkfWAsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiB0aGUgc3BlY2lmaWVkIGZpbGUuXG4gICAgICovXG4gICAgY29udGVudChmaWxlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC9maWxlcy8ke2ZpbGVJZH0vY29udGVudGAsIHsgLi4ub3B0aW9ucywgX19iaW5hcnlSZXNwb25zZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlIHNwZWNpZmllZCBmaWxlLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhlIGAuY29udGVudCgpYCBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZFxuICAgICAqL1xuICAgIHJldHJpZXZlQ29udGVudChmaWxlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC9maWxlcy8ke2ZpbGVJZH0vY29udGVudGAsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgdGhlIGdpdmVuIGZpbGUgdG8gYmUgcHJvY2Vzc2VkLCBkZWZhdWx0IHRpbWVvdXQgaXMgMzAgbWlucy5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yUHJvY2Vzc2luZyhpZCwgeyBwb2xsSW50ZXJ2YWwgPSA1MDAwLCBtYXhXYWl0ID0gMzAgKiA2MCAqIDEwMDAgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IFRFUk1JTkFMX1NUQVRFUyA9IG5ldyBTZXQoWydwcm9jZXNzZWQnLCAnZXJyb3InLCAnZGVsZXRlZCddKTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICBsZXQgZmlsZSA9IGF3YWl0IHRoaXMucmV0cmlldmUoaWQpO1xuICAgICAgICB3aGlsZSAoIWZpbGUuc3RhdHVzIHx8ICFURVJNSU5BTF9TVEFURVMuaGFzKGZpbGUuc3RhdHVzKSkge1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAocG9sbEludGVydmFsKTtcbiAgICAgICAgICAgIGZpbGUgPSBhd2FpdCB0aGlzLnJldHJpZXZlKGlkKTtcbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnQgPiBtYXhXYWl0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgR2l2aW5nIHVwIG9uIHdhaXRpbmcgZm9yIGZpbGUgJHtpZH0gdG8gZmluaXNoIHByb2Nlc3NpbmcgYWZ0ZXIgJHttYXhXYWl0fSBtaWxsaXNlY29uZHMuYCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICB9XG59XG4vKipcbiAqIE5vdGU6IG5vIHBhZ2luYXRpb24gYWN0dWFsbHkgb2NjdXJzIHlldCwgdGhpcyBpcyBmb3IgZm9yd2FyZHMtY29tcGF0aWJpbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVPYmplY3RzUGFnZSBleHRlbmRzIFBhZ2Uge1xufVxuKGZ1bmN0aW9uIChGaWxlcykge1xuICAgIEZpbGVzLkZpbGVPYmplY3RzUGFnZSA9IEZpbGVzQVBJLkZpbGVPYmplY3RzUGFnZTtcbn0pKEZpbGVzIHx8IChGaWxlcyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWxlcy5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uLy4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCIuLi8uLi8uLi9jb3JlLm1qc1wiO1xuaW1wb3J0ICogYXMgQ2hlY2twb2ludHNBUEkgZnJvbSBcIi4vY2hlY2twb2ludHMubWpzXCI7XG5pbXBvcnQgeyBDdXJzb3JQYWdlIH0gZnJvbSBcIi4uLy4uLy4uL3BhZ2luYXRpb24ubWpzXCI7XG5leHBvcnQgY2xhc3MgQ2hlY2twb2ludHMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgbGlzdChmaW5lVHVuaW5nSm9iSWQsIHF1ZXJ5ID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0KGZpbmVUdW5pbmdKb2JJZCwge30sIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoYC9maW5lX3R1bmluZy9qb2JzLyR7ZmluZVR1bmluZ0pvYklkfS9jaGVja3BvaW50c2AsIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UsIHsgcXVlcnksIC4uLm9wdGlvbnMgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlIHtcbn1cbihmdW5jdGlvbiAoQ2hlY2twb2ludHMpIHtcbiAgICBDaGVja3BvaW50cy5GaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlID0gQ2hlY2twb2ludHNBUEkuRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZTtcbn0pKENoZWNrcG9pbnRzIHx8IChDaGVja3BvaW50cyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3BvaW50cy5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uLy4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCIuLi8uLi8uLi9jb3JlLm1qc1wiO1xuaW1wb3J0ICogYXMgSm9ic0FQSSBmcm9tIFwiLi9qb2JzLm1qc1wiO1xuaW1wb3J0ICogYXMgQ2hlY2twb2ludHNBUEkgZnJvbSBcIi4vY2hlY2twb2ludHMubWpzXCI7XG5pbXBvcnQgeyBDdXJzb3JQYWdlIH0gZnJvbSBcIi4uLy4uLy4uL3BhZ2luYXRpb24ubWpzXCI7XG5leHBvcnQgY2xhc3MgSm9icyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jaGVja3BvaW50cyA9IG5ldyBDaGVja3BvaW50c0FQSS5DaGVja3BvaW50cyh0aGlzLl9jbGllbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmluZS10dW5pbmcgam9iIHdoaWNoIGJlZ2lucyB0aGUgcHJvY2VzcyBvZiBjcmVhdGluZyBhIG5ldyBtb2RlbCBmcm9tXG4gICAgICogYSBnaXZlbiBkYXRhc2V0LlxuICAgICAqXG4gICAgICogUmVzcG9uc2UgaW5jbHVkZXMgZGV0YWlscyBvZiB0aGUgZW5xdWV1ZWQgam9iIGluY2x1ZGluZyBqb2Igc3RhdHVzIGFuZCB0aGUgbmFtZVxuICAgICAqIG9mIHRoZSBmaW5lLXR1bmVkIG1vZGVscyBvbmNlIGNvbXBsZXRlLlxuICAgICAqXG4gICAgICogW0xlYXJuIG1vcmUgYWJvdXQgZmluZS10dW5pbmddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9maW5lLXR1bmluZylcbiAgICAgKi9cbiAgICBjcmVhdGUoYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9maW5lX3R1bmluZy9qb2JzJywgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgaW5mbyBhYm91dCBhIGZpbmUtdHVuaW5nIGpvYi5cbiAgICAgKlxuICAgICAqIFtMZWFybiBtb3JlIGFib3V0IGZpbmUtdHVuaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAgICovXG4gICAgcmV0cmlldmUoZmluZVR1bmluZ0pvYklkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvZmluZV90dW5pbmcvam9icy8ke2ZpbmVUdW5pbmdKb2JJZH1gLCBvcHRpb25zKTtcbiAgICB9XG4gICAgbGlzdChxdWVyeSA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdCh7fSwgcXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdCgnL2ZpbmVfdHVuaW5nL2pvYnMnLCBGaW5lVHVuaW5nSm9ic1BhZ2UsIHsgcXVlcnksIC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IGNhbmNlbCBhIGZpbmUtdHVuZSBqb2IuXG4gICAgICovXG4gICAgY2FuY2VsKGZpbmVUdW5pbmdKb2JJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC9maW5lX3R1bmluZy9qb2JzLyR7ZmluZVR1bmluZ0pvYklkfS9jYW5jZWxgLCBvcHRpb25zKTtcbiAgICB9XG4gICAgbGlzdEV2ZW50cyhmaW5lVHVuaW5nSm9iSWQsIHF1ZXJ5ID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0RXZlbnRzKGZpbmVUdW5pbmdKb2JJZCwge30sIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoYC9maW5lX3R1bmluZy9qb2JzLyR7ZmluZVR1bmluZ0pvYklkfS9ldmVudHNgLCBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSwge1xuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRmluZVR1bmluZ0pvYnNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZSB7XG59XG5leHBvcnQgY2xhc3MgRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlIHtcbn1cbihmdW5jdGlvbiAoSm9icykge1xuICAgIEpvYnMuRmluZVR1bmluZ0pvYnNQYWdlID0gSm9ic0FQSS5GaW5lVHVuaW5nSm9ic1BhZ2U7XG4gICAgSm9icy5GaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSA9IEpvYnNBUEkuRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2U7XG4gICAgSm9icy5DaGVja3BvaW50cyA9IENoZWNrcG9pbnRzQVBJLkNoZWNrcG9pbnRzO1xuICAgIEpvYnMuRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSA9IENoZWNrcG9pbnRzQVBJLkZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2U7XG59KShKb2JzIHx8IChKb2JzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpvYnMubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi9yZXNvdXJjZS5tanNcIjtcbmltcG9ydCAqIGFzIEpvYnNBUEkgZnJvbSBcIi4vam9icy9qb2JzLm1qc1wiO1xuZXhwb3J0IGNsYXNzIEZpbmVUdW5pbmcgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuam9icyA9IG5ldyBKb2JzQVBJLkpvYnModGhpcy5fY2xpZW50KTtcbiAgICB9XG59XG4oZnVuY3Rpb24gKEZpbmVUdW5pbmcpIHtcbiAgICBGaW5lVHVuaW5nLkpvYnMgPSBKb2JzQVBJLkpvYnM7XG4gICAgRmluZVR1bmluZy5GaW5lVHVuaW5nSm9ic1BhZ2UgPSBKb2JzQVBJLkZpbmVUdW5pbmdKb2JzUGFnZTtcbiAgICBGaW5lVHVuaW5nLkZpbmVUdW5pbmdKb2JFdmVudHNQYWdlID0gSm9ic0FQSS5GaW5lVHVuaW5nSm9iRXZlbnRzUGFnZTtcbn0pKEZpbmVUdW5pbmcgfHwgKEZpbmVUdW5pbmcgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZS10dW5pbmcubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi9yZXNvdXJjZS5tanNcIjtcbmltcG9ydCAqIGFzIENvcmUgZnJvbSBcIi4uL2NvcmUubWpzXCI7XG5leHBvcnQgY2xhc3MgSW1hZ2VzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB2YXJpYXRpb24gb2YgYSBnaXZlbiBpbWFnZS5cbiAgICAgKi9cbiAgICBjcmVhdGVWYXJpYXRpb24oYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9pbWFnZXMvdmFyaWF0aW9ucycsIENvcmUubXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zKHsgYm9keSwgLi4ub3B0aW9ucyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZWRpdGVkIG9yIGV4dGVuZGVkIGltYWdlIGdpdmVuIGFuIG9yaWdpbmFsIGltYWdlIGFuZCBhIHByb21wdC5cbiAgICAgKi9cbiAgICBlZGl0KGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvaW1hZ2VzL2VkaXRzJywgQ29yZS5tdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbWFnZSBnaXZlbiBhIHByb21wdC5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZShib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2ltYWdlcy9nZW5lcmF0aW9ucycsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgICB9XG59XG4oZnVuY3Rpb24gKEltYWdlcykge1xufSkoSW1hZ2VzIHx8IChJbWFnZXMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2VzLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgKiBhcyBNb2RlbHNBUEkgZnJvbSBcIi4vbW9kZWxzLm1qc1wiO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gXCIuLi9wYWdpbmF0aW9uLm1qc1wiO1xuZXhwb3J0IGNsYXNzIE1vZGVscyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBtb2RlbCBpbnN0YW5jZSwgcHJvdmlkaW5nIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IHRoZSBtb2RlbCBzdWNoIGFzXG4gICAgICogdGhlIG93bmVyIGFuZCBwZXJtaXNzaW9uaW5nLlxuICAgICAqL1xuICAgIHJldHJpZXZlKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvbW9kZWxzLyR7bW9kZWx9YCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIHRoZSBjdXJyZW50bHkgYXZhaWxhYmxlIG1vZGVscywgYW5kIHByb3ZpZGVzIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IGVhY2hcbiAgICAgKiBvbmUgc3VjaCBhcyB0aGUgb3duZXIgYW5kIGF2YWlsYWJpbGl0eS5cbiAgICAgKi9cbiAgICBsaXN0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KCcvbW9kZWxzJywgTW9kZWxzUGFnZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIGZpbmUtdHVuZWQgbW9kZWwuIFlvdSBtdXN0IGhhdmUgdGhlIE93bmVyIHJvbGUgaW4geW91ciBvcmdhbml6YXRpb24gdG9cbiAgICAgKiBkZWxldGUgYSBtb2RlbC5cbiAgICAgKi9cbiAgICBkZWwobW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5kZWxldGUoYC9tb2RlbHMvJHttb2RlbH1gLCBvcHRpb25zKTtcbiAgICB9XG59XG4vKipcbiAqIE5vdGU6IG5vIHBhZ2luYXRpb24gYWN0dWFsbHkgb2NjdXJzIHlldCwgdGhpcyBpcyBmb3IgZm9yd2FyZHMtY29tcGF0aWJpbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIE1vZGVsc1BhZ2UgZXh0ZW5kcyBQYWdlIHtcbn1cbihmdW5jdGlvbiAoTW9kZWxzKSB7XG4gICAgTW9kZWxzLk1vZGVsc1BhZ2UgPSBNb2RlbHNBUEkuTW9kZWxzUGFnZTtcbn0pKE1vZGVscyB8fCAoTW9kZWxzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVscy5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uL3Jlc291cmNlLm1qc1wiO1xuZXhwb3J0IGNsYXNzIE1vZGVyYXRpb25zIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIC8qKlxuICAgICAqIENsYXNzaWZpZXMgaWYgdGV4dCBpcyBwb3RlbnRpYWxseSBoYXJtZnVsLlxuICAgICAqL1xuICAgIGNyZWF0ZShib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL21vZGVyYXRpb25zJywgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICAgIH1cbn1cbihmdW5jdGlvbiAoTW9kZXJhdGlvbnMpIHtcbn0pKE1vZGVyYXRpb25zIHx8IChNb2RlcmF0aW9ucyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlcmF0aW9ucy5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tIFwiLi4vLi4vY29yZS5tanNcIjtcbmV4cG9ydCBjbGFzcyBQYXJ0cyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICAvKipcbiAgICAgKiBBZGRzIGFcbiAgICAgKiBbUGFydF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS91cGxvYWRzL3BhcnQtb2JqZWN0KSB0byBhblxuICAgICAqIFtVcGxvYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdXBsb2Fkcy9vYmplY3QpIG9iamVjdC5cbiAgICAgKiBBIFBhcnQgcmVwcmVzZW50cyBhIGNodW5rIG9mIGJ5dGVzIGZyb20gdGhlIGZpbGUgeW91IGFyZSB0cnlpbmcgdG8gdXBsb2FkLlxuICAgICAqXG4gICAgICogRWFjaCBQYXJ0IGNhbiBiZSBhdCBtb3N0IDY0IE1CLCBhbmQgeW91IGNhbiBhZGQgUGFydHMgdW50aWwgeW91IGhpdCB0aGUgVXBsb2FkXG4gICAgICogbWF4aW11bSBvZiA4IEdCLlxuICAgICAqXG4gICAgICogSXQgaXMgcG9zc2libGUgdG8gYWRkIG11bHRpcGxlIFBhcnRzIGluIHBhcmFsbGVsLiBZb3UgY2FuIGRlY2lkZSB0aGUgaW50ZW5kZWRcbiAgICAgKiBvcmRlciBvZiB0aGUgUGFydHMgd2hlbiB5b3VcbiAgICAgKiBbY29tcGxldGUgdGhlIFVwbG9hZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS91cGxvYWRzL2NvbXBsZXRlKS5cbiAgICAgKi9cbiAgICBjcmVhdGUodXBsb2FkSWQsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdXBsb2Fkcy8ke3VwbG9hZElkfS9wYXJ0c2AsIENvcmUubXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zKHsgYm9keSwgLi4ub3B0aW9ucyB9KSk7XG4gICAgfVxufVxuKGZ1bmN0aW9uIChQYXJ0cykge1xufSkoUGFydHMgfHwgKFBhcnRzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnRzLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgKiBhcyBQYXJ0c0FQSSBmcm9tIFwiLi9wYXJ0cy5tanNcIjtcbmV4cG9ydCBjbGFzcyBVcGxvYWRzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnBhcnRzID0gbmV3IFBhcnRzQVBJLlBhcnRzKHRoaXMuX2NsaWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW50ZXJtZWRpYXRlXG4gICAgICogW1VwbG9hZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS91cGxvYWRzL29iamVjdCkgb2JqZWN0XG4gICAgICogdGhhdCB5b3UgY2FuIGFkZFxuICAgICAqIFtQYXJ0c10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS91cGxvYWRzL3BhcnQtb2JqZWN0KSB0by5cbiAgICAgKiBDdXJyZW50bHksIGFuIFVwbG9hZCBjYW4gYWNjZXB0IGF0IG1vc3QgOCBHQiBpbiB0b3RhbCBhbmQgZXhwaXJlcyBhZnRlciBhbiBob3VyXG4gICAgICogYWZ0ZXIgeW91IGNyZWF0ZSBpdC5cbiAgICAgKlxuICAgICAqIE9uY2UgeW91IGNvbXBsZXRlIHRoZSBVcGxvYWQsIHdlIHdpbGwgY3JlYXRlIGFcbiAgICAgKiBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9vYmplY3QpIG9iamVjdCB0aGF0XG4gICAgICogY29udGFpbnMgYWxsIHRoZSBwYXJ0cyB5b3UgdXBsb2FkZWQuIFRoaXMgRmlsZSBpcyB1c2FibGUgaW4gdGhlIHJlc3Qgb2Ygb3VyXG4gICAgICogcGxhdGZvcm0gYXMgYSByZWd1bGFyIEZpbGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogRm9yIGNlcnRhaW4gYHB1cnBvc2VgcywgdGhlIGNvcnJlY3QgYG1pbWVfdHlwZWAgbXVzdCBiZSBzcGVjaWZpZWQuIFBsZWFzZSByZWZlclxuICAgICAqIHRvIGRvY3VtZW50YXRpb24gZm9yIHRoZSBzdXBwb3J0ZWQgTUlNRSB0eXBlcyBmb3IgeW91ciB1c2UgY2FzZTpcbiAgICAgKlxuICAgICAqIC0gW0Fzc2lzdGFudHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvdG9vbHMvZmlsZS1zZWFyY2gvc3VwcG9ydGVkLWZpbGVzKVxuICAgICAqXG4gICAgICogRm9yIGd1aWRhbmNlIG9uIHRoZSBwcm9wZXIgZmlsZW5hbWUgZXh0ZW5zaW9ucyBmb3IgZWFjaCBwdXJwb3NlLCBwbGVhc2UgZm9sbG93XG4gICAgICogdGhlIGRvY3VtZW50YXRpb24gb25cbiAgICAgKiBbY3JlYXRpbmcgYSBGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL2NyZWF0ZSkuXG4gICAgICovXG4gICAgY3JlYXRlKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvdXBsb2FkcycsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyB0aGUgVXBsb2FkLiBObyBQYXJ0cyBtYXkgYmUgYWRkZWQgYWZ0ZXIgYW4gVXBsb2FkIGlzIGNhbmNlbGxlZC5cbiAgICAgKi9cbiAgICBjYW5jZWwodXBsb2FkSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdXBsb2Fkcy8ke3VwbG9hZElkfS9jYW5jZWxgLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGxldGVzIHRoZVxuICAgICAqIFtVcGxvYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdXBsb2Fkcy9vYmplY3QpLlxuICAgICAqXG4gICAgICogV2l0aGluIHRoZSByZXR1cm5lZCBVcGxvYWQgb2JqZWN0LCB0aGVyZSBpcyBhIG5lc3RlZFxuICAgICAqIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL29iamVjdCkgb2JqZWN0IHRoYXRcbiAgICAgKiBpcyByZWFkeSB0byB1c2UgaW4gdGhlIHJlc3Qgb2YgdGhlIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogWW91IGNhbiBzcGVjaWZ5IHRoZSBvcmRlciBvZiB0aGUgUGFydHMgYnkgcGFzc2luZyBpbiBhbiBvcmRlcmVkIGxpc3Qgb2YgdGhlIFBhcnRcbiAgICAgKiBJRHMuXG4gICAgICpcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHVwbG9hZGVkIHVwb24gY29tcGxldGlvbiBtdXN0IG1hdGNoIHRoZSBudW1iZXIgb2YgYnl0ZXNcbiAgICAgKiBpbml0aWFsbHkgc3BlY2lmaWVkIHdoZW4gY3JlYXRpbmcgdGhlIFVwbG9hZCBvYmplY3QuIE5vIFBhcnRzIG1heSBiZSBhZGRlZCBhZnRlclxuICAgICAqIGFuIFVwbG9hZCBpcyBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgY29tcGxldGUodXBsb2FkSWQsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdXBsb2Fkcy8ke3VwbG9hZElkfS9jb21wbGV0ZWAsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgICB9XG59XG4oZnVuY3Rpb24gKFVwbG9hZHMpIHtcbiAgICBVcGxvYWRzLlBhcnRzID0gUGFydHNBUEkuUGFydHM7XG59KShVcGxvYWRzIHx8IChVcGxvYWRzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVwbG9hZHMubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG52YXIgX2E7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSBcIi4vZXJyb3IubWpzXCI7XG5pbXBvcnQgKiBhcyBVcGxvYWRzIGZyb20gXCIuL3VwbG9hZHMubWpzXCI7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gXCIuL2NvcmUubWpzXCI7XG5pbXBvcnQgKiBhcyBQYWdpbmF0aW9uIGZyb20gXCIuL3BhZ2luYXRpb24ubWpzXCI7XG5pbXBvcnQgKiBhcyBBUEkgZnJvbSBcIi4vcmVzb3VyY2VzL2luZGV4Lm1qc1wiO1xuLyoqXG4gKiBBUEkgQ2xpZW50IGZvciBpbnRlcmZhY2luZyB3aXRoIHRoZSBPcGVuQUkgQVBJLlxuICovXG5leHBvcnQgY2xhc3MgT3BlbkFJIGV4dGVuZHMgQ29yZS5BUElDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEFQSSBDbGllbnQgZm9yIGludGVyZmFjaW5nIHdpdGggdGhlIE9wZW5BSSBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW29wdHMuYXBpS2V5PXByb2Nlc3MuZW52WydPUEVOQUlfQVBJX0tFWSddID8/IHVuZGVmaW5lZF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRzLm9yZ2FuaXphdGlvbj1wcm9jZXNzLmVudlsnT1BFTkFJX09SR19JRCddID8/IG51bGxdXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0cy5wcm9qZWN0PXByb2Nlc3MuZW52WydPUEVOQUlfUFJPSkVDVF9JRCddID8/IG51bGxdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhc2VVUkw9cHJvY2Vzcy5lbnZbJ09QRU5BSV9CQVNFX1VSTCddID8/IGh0dHBzOi8vYXBpLm9wZW5haS5jb20vdjFdIC0gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmFzZSBVUkwgZm9yIHRoZSBBUEkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVvdXQ9MTAgbWludXRlc10gLSBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSB0aGUgY2xpZW50IHdpbGwgd2FpdCBmb3IgYSByZXNwb25zZSBiZWZvcmUgdGltaW5nIG91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaHR0cEFnZW50XSAtIEFuIEhUVFAgYWdlbnQgdXNlZCB0byBtYW5hZ2UgSFRUUChzKSBjb25uZWN0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0NvcmUuRmV0Y2h9IFtvcHRzLmZldGNoXSAtIFNwZWNpZnkgYSBjdXN0b20gYGZldGNoYCBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMubWF4UmV0cmllcz0yXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyB0aGUgY2xpZW50IHdpbGwgcmV0cnkgYSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7Q29yZS5IZWFkZXJzfSBvcHRzLmRlZmF1bHRIZWFkZXJzIC0gRGVmYXVsdCBoZWFkZXJzIHRvIGluY2x1ZGUgd2l0aCBldmVyeSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAgICogQHBhcmFtIHtDb3JlLkRlZmF1bHRRdWVyeX0gb3B0cy5kZWZhdWx0UXVlcnkgLSBEZWZhdWx0IHF1ZXJ5IHBhcmFtZXRlcnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIEFQSS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmRhbmdlcm91c2x5QWxsb3dCcm93c2VyPWZhbHNlXSAtIEJ5IGRlZmF1bHQsIGNsaWVudC1zaWRlIHVzZSBvZiB0aGlzIGxpYnJhcnkgaXMgbm90IGFsbG93ZWQsIGFzIGl0IHJpc2tzIGV4cG9zaW5nIHlvdXIgc2VjcmV0IEFQSSBjcmVkZW50aWFscyB0byBhdHRhY2tlcnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBiYXNlVVJMID0gQ29yZS5yZWFkRW52KCdPUEVOQUlfQkFTRV9VUkwnKSwgYXBpS2V5ID0gQ29yZS5yZWFkRW52KCdPUEVOQUlfQVBJX0tFWScpLCBvcmdhbml6YXRpb24gPSBDb3JlLnJlYWRFbnYoJ09QRU5BSV9PUkdfSUQnKSA/PyBudWxsLCBwcm9qZWN0ID0gQ29yZS5yZWFkRW52KCdPUEVOQUlfUFJPSkVDVF9JRCcpID8/IG51bGwsIC4uLm9wdHMgfSA9IHt9KSB7XG4gICAgICAgIGlmIChhcGlLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcihcIlRoZSBPUEVOQUlfQVBJX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBtaXNzaW5nIG9yIGVtcHR5OyBlaXRoZXIgcHJvdmlkZSBpdCwgb3IgaW5zdGFudGlhdGUgdGhlIE9wZW5BSSBjbGllbnQgd2l0aCBhbiBhcGlLZXkgb3B0aW9uLCBsaWtlIG5ldyBPcGVuQUkoeyBhcGlLZXk6ICdNeSBBUEkgS2V5JyB9KS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFwaUtleSxcbiAgICAgICAgICAgIG9yZ2FuaXphdGlvbixcbiAgICAgICAgICAgIHByb2plY3QsXG4gICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgYmFzZVVSTDogYmFzZVVSTCB8fCBgaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MWAsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93QnJvd3NlciAmJiBDb3JlLmlzUnVubmluZ0luQnJvd3NlcigpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKFwiSXQgbG9va3MgbGlrZSB5b3UncmUgcnVubmluZyBpbiBhIGJyb3dzZXItbGlrZSBlbnZpcm9ubWVudC5cXG5cXG5UaGlzIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGFzIGl0IHJpc2tzIGV4cG9zaW5nIHlvdXIgc2VjcmV0IEFQSSBjcmVkZW50aWFscyB0byBhdHRhY2tlcnMuXFxuSWYgeW91IHVuZGVyc3RhbmQgdGhlIHJpc2tzIGFuZCBoYXZlIGFwcHJvcHJpYXRlIG1pdGlnYXRpb25zIGluIHBsYWNlLFxcbnlvdSBjYW4gc2V0IHRoZSBgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXJgIG9wdGlvbiB0byBgdHJ1ZWAsIGUuZy4sXFxuXFxubmV3IE9wZW5BSSh7IGFwaUtleSwgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI6IHRydWUgfSk7XFxuXFxuaHR0cHM6Ly9oZWxwLm9wZW5haS5jb20vZW4vYXJ0aWNsZXMvNTExMjU5NS1iZXN0LXByYWN0aWNlcy1mb3ItYXBpLWtleS1zYWZldHlcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgYmFzZVVSTDogb3B0aW9ucy5iYXNlVVJMLFxuICAgICAgICAgICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0ID8/IDYwMDAwMCAvKiAxMCBtaW51dGVzICovLFxuICAgICAgICAgICAgaHR0cEFnZW50OiBvcHRpb25zLmh0dHBBZ2VudCxcbiAgICAgICAgICAgIG1heFJldHJpZXM6IG9wdGlvbnMubWF4UmV0cmllcyxcbiAgICAgICAgICAgIGZldGNoOiBvcHRpb25zLmZldGNoLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21wbGV0aW9ucyA9IG5ldyBBUEkuQ29tcGxldGlvbnModGhpcyk7XG4gICAgICAgIHRoaXMuY2hhdCA9IG5ldyBBUEkuQ2hhdCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbWJlZGRpbmdzID0gbmV3IEFQSS5FbWJlZGRpbmdzKHRoaXMpO1xuICAgICAgICB0aGlzLmZpbGVzID0gbmV3IEFQSS5GaWxlcyh0aGlzKTtcbiAgICAgICAgdGhpcy5pbWFnZXMgPSBuZXcgQVBJLkltYWdlcyh0aGlzKTtcbiAgICAgICAgdGhpcy5hdWRpbyA9IG5ldyBBUEkuQXVkaW8odGhpcyk7XG4gICAgICAgIHRoaXMubW9kZXJhdGlvbnMgPSBuZXcgQVBJLk1vZGVyYXRpb25zKHRoaXMpO1xuICAgICAgICB0aGlzLm1vZGVscyA9IG5ldyBBUEkuTW9kZWxzKHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmVUdW5pbmcgPSBuZXcgQVBJLkZpbmVUdW5pbmcodGhpcyk7XG4gICAgICAgIHRoaXMuYmV0YSA9IG5ldyBBUEkuQmV0YSh0aGlzKTtcbiAgICAgICAgdGhpcy5iYXRjaGVzID0gbmV3IEFQSS5CYXRjaGVzKHRoaXMpO1xuICAgICAgICB0aGlzLnVwbG9hZHMgPSBuZXcgQVBJLlVwbG9hZHModGhpcyk7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICAgICAgdGhpcy5vcmdhbml6YXRpb24gPSBvcmdhbml6YXRpb247XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgfVxuICAgIGRlZmF1bHRRdWVyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZGVmYXVsdFF1ZXJ5O1xuICAgIH1cbiAgICBkZWZhdWx0SGVhZGVycyhvcHRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci5kZWZhdWx0SGVhZGVycyhvcHRzKSxcbiAgICAgICAgICAgICdPcGVuQUktT3JnYW5pemF0aW9uJzogdGhpcy5vcmdhbml6YXRpb24sXG4gICAgICAgICAgICAnT3BlbkFJLVByb2plY3QnOiB0aGlzLnByb2plY3QsXG4gICAgICAgICAgICAuLi50aGlzLl9vcHRpb25zLmRlZmF1bHRIZWFkZXJzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhdXRoSGVhZGVycyhvcHRzKSB7XG4gICAgICAgIHJldHVybiB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLmFwaUtleX1gIH07XG4gICAgfVxufVxuX2EgPSBPcGVuQUk7XG5PcGVuQUkuT3BlbkFJID0gX2E7XG5PcGVuQUkuREVGQVVMVF9USU1FT1VUID0gNjAwMDAwOyAvLyAxMCBtaW51dGVzXG5PcGVuQUkuT3BlbkFJRXJyb3IgPSBFcnJvcnMuT3BlbkFJRXJyb3I7XG5PcGVuQUkuQVBJRXJyb3IgPSBFcnJvcnMuQVBJRXJyb3I7XG5PcGVuQUkuQVBJQ29ubmVjdGlvbkVycm9yID0gRXJyb3JzLkFQSUNvbm5lY3Rpb25FcnJvcjtcbk9wZW5BSS5BUElDb25uZWN0aW9uVGltZW91dEVycm9yID0gRXJyb3JzLkFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3I7XG5PcGVuQUkuQVBJVXNlckFib3J0RXJyb3IgPSBFcnJvcnMuQVBJVXNlckFib3J0RXJyb3I7XG5PcGVuQUkuTm90Rm91bmRFcnJvciA9IEVycm9ycy5Ob3RGb3VuZEVycm9yO1xuT3BlbkFJLkNvbmZsaWN0RXJyb3IgPSBFcnJvcnMuQ29uZmxpY3RFcnJvcjtcbk9wZW5BSS5SYXRlTGltaXRFcnJvciA9IEVycm9ycy5SYXRlTGltaXRFcnJvcjtcbk9wZW5BSS5CYWRSZXF1ZXN0RXJyb3IgPSBFcnJvcnMuQmFkUmVxdWVzdEVycm9yO1xuT3BlbkFJLkF1dGhlbnRpY2F0aW9uRXJyb3IgPSBFcnJvcnMuQXV0aGVudGljYXRpb25FcnJvcjtcbk9wZW5BSS5JbnRlcm5hbFNlcnZlckVycm9yID0gRXJyb3JzLkludGVybmFsU2VydmVyRXJyb3I7XG5PcGVuQUkuUGVybWlzc2lvbkRlbmllZEVycm9yID0gRXJyb3JzLlBlcm1pc3Npb25EZW5pZWRFcnJvcjtcbk9wZW5BSS5VbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IgPSBFcnJvcnMuVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yO1xuT3BlbkFJLnRvRmlsZSA9IFVwbG9hZHMudG9GaWxlO1xuT3BlbkFJLmZpbGVGcm9tUGF0aCA9IFVwbG9hZHMuZmlsZUZyb21QYXRoO1xuZXhwb3J0IGNvbnN0IHsgT3BlbkFJRXJyb3IsIEFQSUVycm9yLCBBUElDb25uZWN0aW9uRXJyb3IsIEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IsIEFQSVVzZXJBYm9ydEVycm9yLCBOb3RGb3VuZEVycm9yLCBDb25mbGljdEVycm9yLCBSYXRlTGltaXRFcnJvciwgQmFkUmVxdWVzdEVycm9yLCBBdXRoZW50aWNhdGlvbkVycm9yLCBJbnRlcm5hbFNlcnZlckVycm9yLCBQZXJtaXNzaW9uRGVuaWVkRXJyb3IsIFVucHJvY2Vzc2FibGVFbnRpdHlFcnJvciwgfSA9IEVycm9ycztcbmV4cG9ydCB2YXIgdG9GaWxlID0gVXBsb2Fkcy50b0ZpbGU7XG5leHBvcnQgdmFyIGZpbGVGcm9tUGF0aCA9IFVwbG9hZHMuZmlsZUZyb21QYXRoO1xuKGZ1bmN0aW9uIChPcGVuQUkpIHtcbiAgICBPcGVuQUkuUGFnZSA9IFBhZ2luYXRpb24uUGFnZTtcbiAgICBPcGVuQUkuQ3Vyc29yUGFnZSA9IFBhZ2luYXRpb24uQ3Vyc29yUGFnZTtcbiAgICBPcGVuQUkuQ29tcGxldGlvbnMgPSBBUEkuQ29tcGxldGlvbnM7XG4gICAgT3BlbkFJLkNoYXQgPSBBUEkuQ2hhdDtcbiAgICBPcGVuQUkuRW1iZWRkaW5ncyA9IEFQSS5FbWJlZGRpbmdzO1xuICAgIE9wZW5BSS5GaWxlcyA9IEFQSS5GaWxlcztcbiAgICBPcGVuQUkuRmlsZU9iamVjdHNQYWdlID0gQVBJLkZpbGVPYmplY3RzUGFnZTtcbiAgICBPcGVuQUkuSW1hZ2VzID0gQVBJLkltYWdlcztcbiAgICBPcGVuQUkuQXVkaW8gPSBBUEkuQXVkaW87XG4gICAgT3BlbkFJLk1vZGVyYXRpb25zID0gQVBJLk1vZGVyYXRpb25zO1xuICAgIE9wZW5BSS5Nb2RlbHMgPSBBUEkuTW9kZWxzO1xuICAgIE9wZW5BSS5Nb2RlbHNQYWdlID0gQVBJLk1vZGVsc1BhZ2U7XG4gICAgT3BlbkFJLkZpbmVUdW5pbmcgPSBBUEkuRmluZVR1bmluZztcbiAgICBPcGVuQUkuQmV0YSA9IEFQSS5CZXRhO1xuICAgIE9wZW5BSS5CYXRjaGVzID0gQVBJLkJhdGNoZXM7XG4gICAgT3BlbkFJLkJhdGNoZXNQYWdlID0gQVBJLkJhdGNoZXNQYWdlO1xuICAgIE9wZW5BSS5VcGxvYWRzID0gQVBJLlVwbG9hZHM7XG59KShPcGVuQUkgfHwgKE9wZW5BSSA9IHt9KSk7XG4vKiogQVBJIENsaWVudCBmb3IgaW50ZXJmYWNpbmcgd2l0aCB0aGUgQXp1cmUgT3BlbkFJIEFQSS4gKi9cbmV4cG9ydCBjbGFzcyBBenVyZU9wZW5BSSBleHRlbmRzIE9wZW5BSSB7XG4gICAgLyoqXG4gICAgICogQVBJIENsaWVudCBmb3IgaW50ZXJmYWNpbmcgd2l0aCB0aGUgQXp1cmUgT3BlbkFJIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbb3B0cy5hcGlWZXJzaW9uPXByb2Nlc3MuZW52WydPUEVOQUlfQVBJX1ZFUlNJT04nXSA/PyB1bmRlZmluZWRdXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtvcHRzLmVuZHBvaW50PXByb2Nlc3MuZW52WydBWlVSRV9PUEVOQUlfRU5EUE9JTlQnXSA/PyB1bmRlZmluZWRdIC0gWW91ciBBenVyZSBlbmRwb2ludCwgaW5jbHVkaW5nIHRoZSByZXNvdXJjZSwgZS5nLiBgaHR0cHM6Ly9leGFtcGxlLXJlc291cmNlLmF6dXJlLm9wZW5haS5jb20vYFxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbb3B0cy5hcGlLZXk9cHJvY2Vzcy5lbnZbJ0FaVVJFX09QRU5BSV9BUElfS0VZJ10gPz8gdW5kZWZpbmVkXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBvcHRzLmRlcGxveW1lbnQgLSBBIG1vZGVsIGRlcGxveW1lbnQsIGlmIGdpdmVuLCBzZXRzIHRoZSBiYXNlIGNsaWVudCBVUkwgdG8gaW5jbHVkZSBgL2RlcGxveW1lbnRzL3tkZXBsb3ltZW50fWAuXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0cy5vcmdhbml6YXRpb249cHJvY2Vzcy5lbnZbJ09QRU5BSV9PUkdfSUQnXSA/PyBudWxsXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYXNlVVJMPXByb2Nlc3MuZW52WydPUEVOQUlfQkFTRV9VUkwnXV0gLSBTZXRzIHRoZSBiYXNlIFVSTCBmb3IgdGhlIEFQSS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZW91dD0xMCBtaW51dGVzXSAtIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRoZSBjbGllbnQgd2lsbCB3YWl0IGZvciBhIHJlc3BvbnNlIGJlZm9yZSB0aW1pbmcgb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5odHRwQWdlbnRdIC0gQW4gSFRUUCBhZ2VudCB1c2VkIHRvIG1hbmFnZSBIVFRQKHMpIGNvbm5lY3Rpb25zLlxuICAgICAqIEBwYXJhbSB7Q29yZS5GZXRjaH0gW29wdHMuZmV0Y2hdIC0gU3BlY2lmeSBhIGN1c3RvbSBgZmV0Y2hgIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5tYXhSZXRyaWVzPTJdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHRoZSBjbGllbnQgd2lsbCByZXRyeSBhIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHtDb3JlLkhlYWRlcnN9IG9wdHMuZGVmYXVsdEhlYWRlcnMgLSBEZWZhdWx0IGhlYWRlcnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIEFQSS5cbiAgICAgKiBAcGFyYW0ge0NvcmUuRGVmYXVsdFF1ZXJ5fSBvcHRzLmRlZmF1bHRRdWVyeSAtIERlZmF1bHQgcXVlcnkgcGFyYW1ldGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI9ZmFsc2VdIC0gQnkgZGVmYXVsdCwgY2xpZW50LXNpZGUgdXNlIG9mIHRoaXMgbGlicmFyeSBpcyBub3QgYWxsb3dlZCwgYXMgaXQgcmlza3MgZXhwb3NpbmcgeW91ciBzZWNyZXQgQVBJIGNyZWRlbnRpYWxzIHRvIGF0dGFja2Vycy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGJhc2VVUkwgPSBDb3JlLnJlYWRFbnYoJ09QRU5BSV9CQVNFX1VSTCcpLCBhcGlLZXkgPSBDb3JlLnJlYWRFbnYoJ0FaVVJFX09QRU5BSV9BUElfS0VZJyksIGFwaVZlcnNpb24gPSBDb3JlLnJlYWRFbnYoJ09QRU5BSV9BUElfVkVSU0lPTicpLCBlbmRwb2ludCwgZGVwbG95bWVudCwgYXp1cmVBRFRva2VuUHJvdmlkZXIsIGRhbmdlcm91c2x5QWxsb3dCcm93c2VyLCAuLi5vcHRzIH0gPSB7fSkge1xuICAgICAgICBpZiAoIWFwaVZlcnNpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcnMuT3BlbkFJRXJyb3IoXCJUaGUgT1BFTkFJX0FQSV9WRVJTSU9OIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG1pc3Npbmcgb3IgZW1wdHk7IGVpdGhlciBwcm92aWRlIGl0LCBvciBpbnN0YW50aWF0ZSB0aGUgQXp1cmVPcGVuQUkgY2xpZW50IHdpdGggYW4gYXBpVmVyc2lvbiBvcHRpb24sIGxpa2UgbmV3IEF6dXJlT3BlbkFJKHsgYXBpVmVyc2lvbjogJ015IEFQSSBWZXJzaW9uJyB9KS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhenVyZUFEVG9rZW5Qcm92aWRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXp1cmVBRFRva2VuUHJvdmlkZXIgJiYgIWFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcignTWlzc2luZyBjcmVkZW50aWFscy4gUGxlYXNlIHBhc3Mgb25lIG9mIGBhcGlLZXlgIGFuZCBgYXp1cmVBRFRva2VuUHJvdmlkZXJgLCBvciBzZXQgdGhlIGBBWlVSRV9PUEVOQUlfQVBJX0tFWWAgZW52aXJvbm1lbnQgdmFyaWFibGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF6dXJlQURUb2tlblByb3ZpZGVyICYmIGFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcignVGhlIGBhcGlLZXlgIGFuZCBgYXp1cmVBRFRva2VuUHJvdmlkZXJgIGFyZ3VtZW50cyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlOyBvbmx5IG9uZSBjYW4gYmUgcGFzc2VkIGF0IGEgdGltZS4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWZpbmUgYSBzZW50aW5lbCB2YWx1ZSB0byBhdm9pZCBhbnkgdHlwaW5nIGlzc3Vlc1xuICAgICAgICBhcGlLZXkgPz8gKGFwaUtleSA9IEFQSV9LRVlfU0VOVElORUwpO1xuICAgICAgICBvcHRzLmRlZmF1bHRRdWVyeSA9IHsgLi4ub3B0cy5kZWZhdWx0UXVlcnksICdhcGktdmVyc2lvbic6IGFwaVZlcnNpb24gfTtcbiAgICAgICAgaWYgKCFiYXNlVVJMKSB7XG4gICAgICAgICAgICBpZiAoIWVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgZW5kcG9pbnQgPSBwcm9jZXNzLmVudlsnQVpVUkVfT1BFTkFJX0VORFBPSU5UJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcignTXVzdCBwcm92aWRlIG9uZSBvZiB0aGUgYGJhc2VVUkxgIG9yIGBlbmRwb2ludGAgYXJndW1lbnRzLCBvciB0aGUgYEFaVVJFX09QRU5BSV9FTkRQT0lOVGAgZW52aXJvbm1lbnQgdmFyaWFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2VVUkwgPSBgJHtlbmRwb2ludH0vb3BlbmFpYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcnMuT3BlbkFJRXJyb3IoJ2Jhc2VVUkwgYW5kIGVuZHBvaW50IGFyZSBtdXR1YWxseSBleGNsdXNpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICBiYXNlVVJMLFxuICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgIC4uLihkYW5nZXJvdXNseUFsbG93QnJvd3NlciAhPT0gdW5kZWZpbmVkID8geyBkYW5nZXJvdXNseUFsbG93QnJvd3NlciB9IDoge30pLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcGlWZXJzaW9uID0gJyc7XG4gICAgICAgIHRoaXMuX2F6dXJlQURUb2tlblByb3ZpZGVyID0gYXp1cmVBRFRva2VuUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuYXBpVmVyc2lvbiA9IGFwaVZlcnNpb247XG4gICAgICAgIHRoaXMuX2RlcGxveW1lbnQgPSBkZXBsb3ltZW50O1xuICAgIH1cbiAgICBidWlsZFJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICBpZiAoX2RlcGxveW1lbnRzX2VuZHBvaW50cy5oYXMob3B0aW9ucy5wYXRoKSAmJiBvcHRpb25zLm1ldGhvZCA9PT0gJ3Bvc3QnICYmIG9wdGlvbnMuYm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUNvcmUuaXNPYmoob3B0aW9ucy5ib2R5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmVxdWVzdCBib2R5IHRvIGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9kZXBsb3ltZW50IHx8IG9wdGlvbnMuYm9keVsnbW9kZWwnXTtcbiAgICAgICAgICAgIGlmIChtb2RlbCAhPT0gdW5kZWZpbmVkICYmICF0aGlzLmJhc2VVUkwuaW5jbHVkZXMoJy9kZXBsb3ltZW50cycpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoID0gYC9kZXBsb3ltZW50cy8ke21vZGVsfSR7b3B0aW9ucy5wYXRofWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmJ1aWxkUmVxdWVzdChvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgX2dldEF6dXJlQURUb2tlbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9henVyZUFEVG9rZW5Qcm92aWRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLl9henVyZUFEVG9rZW5Qcm92aWRlcigpO1xuICAgICAgICAgICAgaWYgKCF0b2tlbiB8fCB0eXBlb2YgdG9rZW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcihgRXhwZWN0ZWQgJ2F6dXJlQURUb2tlblByb3ZpZGVyJyBhcmd1bWVudCB0byByZXR1cm4gYSBzdHJpbmcgYnV0IGl0IHJldHVybmVkICR7dG9rZW59YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXV0aEhlYWRlcnMob3B0cykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGFzeW5jIHByZXBhcmVPcHRpb25zKG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMuaGVhZGVycz8uWydBdXRob3JpemF0aW9uJ10gfHwgb3B0cy5oZWFkZXJzPy5bJ2FwaS1rZXknXSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnByZXBhcmVPcHRpb25zKG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdGhpcy5fZ2V0QXp1cmVBRFRva2VuKCk7XG4gICAgICAgIG9wdHMuaGVhZGVycyA/PyAob3B0cy5oZWFkZXJzID0ge30pO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3Rva2VufWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcGlLZXkgIT09IEFQSV9LRVlfU0VOVElORUwpIHtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVyc1snYXBpLWtleSddID0gdGhpcy5hcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKCdVbmFibGUgdG8gaGFuZGxlIGF1dGgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIucHJlcGFyZU9wdGlvbnMob3B0cyk7XG4gICAgfVxufVxuY29uc3QgX2RlcGxveW1lbnRzX2VuZHBvaW50cyA9IG5ldyBTZXQoW1xuICAgICcvY29tcGxldGlvbnMnLFxuICAgICcvY2hhdC9jb21wbGV0aW9ucycsXG4gICAgJy9lbWJlZGRpbmdzJyxcbiAgICAnL2F1ZGlvL3RyYW5zY3JpcHRpb25zJyxcbiAgICAnL2F1ZGlvL3RyYW5zbGF0aW9ucycsXG4gICAgJy9hdWRpby9zcGVlY2gnLFxuICAgICcvaW1hZ2VzL2dlbmVyYXRpb25zJyxcbl0pO1xuY29uc3QgQVBJX0tFWV9TRU5USU5FTCA9ICc8TWlzc2luZyBLZXk+Jztcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRW5kIEF6dXJlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBkZWZhdWx0IE9wZW5BSTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiLCJpbXBvcnQgKiBhcyBWdWUgZnJvbSAndnVlJ1xuXG52YXIgaXNWdWUyID0gZmFsc2VcbnZhciBpc1Z1ZTMgPSB0cnVlXG52YXIgVnVlMiA9IHVuZGVmaW5lZFxuXG5mdW5jdGlvbiBpbnN0YWxsKCkge31cblxuZXhwb3J0IGZ1bmN0aW9uIHNldCh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KVxuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpXG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHRhcmdldFtrZXldID0gdmFsXG4gIHJldHVybiB2YWxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbCh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpXG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldXG59XG5cbmV4cG9ydCAqIGZyb20gJ3Z1ZSdcbmV4cG9ydCB7XG4gIFZ1ZSxcbiAgVnVlMixcbiAgaXNWdWUyLFxuICBpc1Z1ZTMsXG4gIGluc3RhbGwsXG59XG4iLCIvKiFcbiAqIHBpbmlhIHYyLjIuNFxuICogKGMpIDIwMjQgRWR1YXJkbyBTYW4gTWFydGluIE1vcm90ZVxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IGhhc0luamVjdGlvbkNvbnRleHQsIGluamVjdCwgdG9SYXcsIHdhdGNoLCB1bnJlZiwgbWFya1JhdywgZWZmZWN0U2NvcGUsIHJlZiwgaXNWdWUyLCBpc1JlZiwgaXNSZWFjdGl2ZSwgc2V0LCBnZXRDdXJyZW50U2NvcGUsIG9uU2NvcGVEaXNwb3NlLCBnZXRDdXJyZW50SW5zdGFuY2UsIHJlYWN0aXZlLCB0b1JlZiwgZGVsLCBuZXh0VGljaywgY29tcHV0ZWQsIHRvUmVmcyB9IGZyb20gJ3Z1ZS1kZW1pJztcbmltcG9ydCB7IHNldHVwRGV2dG9vbHNQbHVnaW4gfSBmcm9tICdAdnVlL2RldnRvb2xzLWFwaSc7XG5cbi8qKlxuICogc2V0QWN0aXZlUGluaWEgbXVzdCBiZSBjYWxsZWQgdG8gaGFuZGxlIFNTUiBhdCB0aGUgdG9wIG9mIGZ1bmN0aW9ucyBsaWtlXG4gKiBgZmV0Y2hgLCBgc2V0dXBgLCBgc2VydmVyUHJlZmV0Y2hgIGFuZCBvdGhlcnNcbiAqL1xubGV0IGFjdGl2ZVBpbmlhO1xuLyoqXG4gKiBTZXRzIG9yIHVuc2V0cyB0aGUgYWN0aXZlIHBpbmlhLiBVc2VkIGluIFNTUiBhbmQgaW50ZXJuYWxseSB3aGVuIGNhbGxpbmdcbiAqIGFjdGlvbnMgYW5kIGdldHRlcnNcbiAqXG4gKiBAcGFyYW0gcGluaWEgLSBQaW5pYSBpbnN0YW5jZVxuICovXG4vLyBAdHMtZXhwZWN0LWVycm9yOiBjYW5ub3QgY29uc3RyYWluIHRoZSB0eXBlIG9mIHRoZSByZXR1cm5cbmNvbnN0IHNldEFjdGl2ZVBpbmlhID0gKHBpbmlhKSA9PiAoYWN0aXZlUGluaWEgPSBwaW5pYSk7XG4vKipcbiAqIEdldCB0aGUgY3VycmVudGx5IGFjdGl2ZSBwaW5pYSBpZiB0aGVyZSBpcyBhbnkuXG4gKi9cbmNvbnN0IGdldEFjdGl2ZVBpbmlhID0gKCkgPT4gKGhhc0luamVjdGlvbkNvbnRleHQoKSAmJiBpbmplY3QocGluaWFTeW1ib2wpKSB8fCBhY3RpdmVQaW5pYTtcbmNvbnN0IHBpbmlhU3ltYm9sID0gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IFN5bWJvbCgncGluaWEnKSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFN5bWJvbCgpKTtcblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5vKSB7XG4gICAgcmV0dXJuIChvICYmXG4gICAgICAgIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmXG4gICAgICAgIHR5cGVvZiBvLnRvSlNPTiAhPT0gJ2Z1bmN0aW9uJyk7XG59XG4vLyB0eXBlIERlZXBSZWFkb25seTxUPiA9IHsgcmVhZG9ubHkgW1AgaW4ga2V5b2YgVF06IERlZXBSZWFkb25seTxUW1BdPiB9XG4vLyBUT0RPOiBjYW4gd2UgY2hhbmdlIHRoZXNlIHRvIG51bWJlcnM/XG4vKipcbiAqIFBvc3NpYmxlIHR5cGVzIGZvciBTdWJzY3JpcHRpb25DYWxsYmFja1xuICovXG52YXIgTXV0YXRpb25UeXBlO1xuKGZ1bmN0aW9uIChNdXRhdGlvblR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBEaXJlY3QgbXV0YXRpb24gb2YgdGhlIHN0YXRlOlxuICAgICAqXG4gICAgICogLSBgc3RvcmUubmFtZSA9ICduZXcgbmFtZSdgXG4gICAgICogLSBgc3RvcmUuJHN0YXRlLm5hbWUgPSAnbmV3IG5hbWUnYFxuICAgICAqIC0gYHN0b3JlLmxpc3QucHVzaCgnbmV3IGl0ZW0nKWBcbiAgICAgKi9cbiAgICBNdXRhdGlvblR5cGVbXCJkaXJlY3RcIl0gPSBcImRpcmVjdFwiO1xuICAgIC8qKlxuICAgICAqIE11dGF0ZWQgdGhlIHN0YXRlIHdpdGggYCRwYXRjaGAgYW5kIGFuIG9iamVjdFxuICAgICAqXG4gICAgICogLSBgc3RvcmUuJHBhdGNoKHsgbmFtZTogJ25ld05hbWUnIH0pYFxuICAgICAqL1xuICAgIE11dGF0aW9uVHlwZVtcInBhdGNoT2JqZWN0XCJdID0gXCJwYXRjaCBvYmplY3RcIjtcbiAgICAvKipcbiAgICAgKiBNdXRhdGVkIHRoZSBzdGF0ZSB3aXRoIGAkcGF0Y2hgIGFuZCBhIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiAtIGBzdG9yZS4kcGF0Y2goc3RhdGUgPT4gc3RhdGUubmFtZSA9ICduZXdOYW1lJylgXG4gICAgICovXG4gICAgTXV0YXRpb25UeXBlW1wicGF0Y2hGdW5jdGlvblwiXSA9IFwicGF0Y2ggZnVuY3Rpb25cIjtcbiAgICAvLyBtYXliZSByZXNldD8gZm9yICRzdGF0ZSA9IHt9IGFuZCAkcmVzZXRcbn0pKE11dGF0aW9uVHlwZSB8fCAoTXV0YXRpb25UeXBlID0ge30pKTtcblxuY29uc3QgSVNfQ0xJRU5UID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qXG4gKiBGaWxlU2F2ZXIuanMgQSBzYXZlQXMoKSBGaWxlU2F2ZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogT3JpZ2luYWxseSBieSBFbGkgR3JleSwgYWRhcHRlZCBhcyBhbiBFU00gbW9kdWxlIGJ5IEVkdWFyZG8gU2FuIE1hcnRpblxuICogTW9yb3RlLlxuICpcbiAqIExpY2Vuc2UgOiBNSVRcbiAqL1xuLy8gVGhlIG9uZSBhbmQgb25seSB3YXkgb2YgZ2V0dGluZyBnbG9iYWwgc2NvcGUgaW4gYWxsIGVudmlyb25tZW50c1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzMyNzcxODIvMTAwODk5OVxuY29uc3QgX2dsb2JhbCA9IC8qI19fUFVSRV9fKi8gKCgpID0+IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy53aW5kb3cgPT09IHdpbmRvd1xuICAgID8gd2luZG93XG4gICAgOiB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgc2VsZi5zZWxmID09PSBzZWxmXG4gICAgICAgID8gc2VsZlxuICAgICAgICA6IHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnICYmIGdsb2JhbC5nbG9iYWwgPT09IGdsb2JhbFxuICAgICAgICAgICAgPyBnbG9iYWxcbiAgICAgICAgICAgIDogdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzXG4gICAgICAgICAgICAgICAgOiB7IEhUTUxFbGVtZW50OiBudWxsIH0pKCk7XG5mdW5jdGlvbiBib20oYmxvYiwgeyBhdXRvQm9tID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgLy8gcHJlcGVuZCBCT00gZm9yIFVURi04IFhNTCBhbmQgdGV4dC8qIHR5cGVzIChpbmNsdWRpbmcgSFRNTClcbiAgICAvLyBub3RlOiB5b3VyIGJyb3dzZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgVVRGLTE2IFUrRkVGRiB0byBFRiBCQiBCRlxuICAgIGlmIChhdXRvQm9tICYmXG4gICAgICAgIC9eXFxzKig/OnRleHRcXC9cXFMqfGFwcGxpY2F0aW9uXFwveG1sfFxcUypcXC9cXFMqXFwreG1sKVxccyo7LipjaGFyc2V0XFxzKj1cXHMqdXRmLTgvaS50ZXN0KGJsb2IudHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFtTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZmVmZiksIGJsb2JdLCB7IHR5cGU6IGJsb2IudHlwZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2I7XG59XG5mdW5jdGlvbiBkb3dubG9hZCh1cmwsIG5hbWUsIG9wdHMpIHtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNhdmVBcyh4aHIucmVzcG9uc2UsIG5hbWUsIG9wdHMpO1xuICAgIH07XG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2NvdWxkIG5vdCBkb3dubG9hZCBmaWxlJyk7XG4gICAgfTtcbiAgICB4aHIuc2VuZCgpO1xufVxuZnVuY3Rpb24gY29yc0VuYWJsZWQodXJsKSB7XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgLy8gdXNlIHN5bmMgdG8gYXZvaWQgcG9wdXAgYmxvY2tlclxuICAgIHhoci5vcGVuKCdIRUFEJywgdXJsLCBmYWxzZSk7XG4gICAgdHJ5IHtcbiAgICAgICAgeGhyLnNlbmQoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIHJldHVybiB4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDw9IDI5OTtcbn1cbi8vIGBhLmNsaWNrKClgIGRvZXNuJ3Qgd29yayBmb3IgYWxsIGJyb3dzZXJzICgjNDY1KVxuZnVuY3Rpb24gY2xpY2sobm9kZSkge1xuICAgIHRyeSB7XG4gICAgICAgIG5vZGUuZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudCgnY2xpY2snKSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuICAgICAgICBldnQuaW5pdE1vdXNlRXZlbnQoJ2NsaWNrJywgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAwLCAwLCAwLCA4MCwgMjAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgfVxufVxuY29uc3QgX25hdmlnYXRvciA9IHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnID8gbmF2aWdhdG9yIDogeyB1c2VyQWdlbnQ6ICcnIH07XG4vLyBEZXRlY3QgV2ViVmlldyBpbnNpZGUgYSBuYXRpdmUgbWFjT1MgYXBwIGJ5IHJ1bGluZyBvdXQgYWxsIGJyb3dzZXJzXG4vLyBXZSBqdXN0IG5lZWQgdG8gY2hlY2sgZm9yICdTYWZhcmknIGJlY2F1c2UgYWxsIG90aGVyIGJyb3dzZXJzIChiZXNpZGVzIEZpcmVmb3gpIGluY2x1ZGUgdGhhdCB0b29cbi8vIGh0dHBzOi8vd3d3LndoYXRpc215YnJvd3Nlci5jb20vZ3VpZGVzL3RoZS1sYXRlc3QtdXNlci1hZ2VudC9tYWNvc1xuY29uc3QgaXNNYWNPU1dlYlZpZXcgPSAvKiNfX1BVUkVfXyovICgoKSA9PiAvTWFjaW50b3NoLy50ZXN0KF9uYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgIC9BcHBsZVdlYktpdC8udGVzdChfbmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAhL1NhZmFyaS8udGVzdChfbmF2aWdhdG9yLnVzZXJBZ2VudCkpKCk7XG5jb25zdCBzYXZlQXMgPSAhSVNfQ0xJRU5UXG4gICAgPyAoKSA9PiB7IH0gLy8gbm9vcFxuICAgIDogLy8gVXNlIGRvd25sb2FkIGF0dHJpYnV0ZSBmaXJzdCBpZiBwb3NzaWJsZSAoIzE5MyBMdW1pYSBtb2JpbGUpIHVubGVzcyB0aGlzIGlzIGEgbWFjT1MgV2ViVmlldyBvciBtaW5pIHByb2dyYW1cbiAgICAgICAgdHlwZW9mIEhUTUxBbmNob3JFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgJ2Rvd25sb2FkJyBpbiBIVE1MQW5jaG9yRWxlbWVudC5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgICFpc01hY09TV2ViVmlld1xuICAgICAgICAgICAgPyBkb3dubG9hZFNhdmVBc1xuICAgICAgICAgICAgOiAvLyBVc2UgbXNTYXZlT3JPcGVuQmxvYiBhcyBhIHNlY29uZCBhcHByb2FjaFxuICAgICAgICAgICAgICAgICdtc1NhdmVPck9wZW5CbG9iJyBpbiBfbmF2aWdhdG9yXG4gICAgICAgICAgICAgICAgICAgID8gbXNTYXZlQXNcbiAgICAgICAgICAgICAgICAgICAgOiAvLyBGYWxsYmFjayB0byB1c2luZyBGaWxlUmVhZGVyIGFuZCBhIHBvcHVwXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlU2F2ZXJTYXZlQXM7XG5mdW5jdGlvbiBkb3dubG9hZFNhdmVBcyhibG9iLCBuYW1lID0gJ2Rvd25sb2FkJywgb3B0cykge1xuICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgYS5kb3dubG9hZCA9IG5hbWU7XG4gICAgYS5yZWwgPSAnbm9vcGVuZXInOyAvLyB0YWJuYWJiaW5nXG4gICAgLy8gVE9ETzogZGV0ZWN0IGNocm9tZSBleHRlbnNpb25zICYgcGFja2FnZWQgYXBwc1xuICAgIC8vIGEudGFyZ2V0ID0gJ19ibGFuaydcbiAgICBpZiAodHlwZW9mIGJsb2IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgcmVndWxhciBsaW5rc1xuICAgICAgICBhLmhyZWYgPSBibG9iO1xuICAgICAgICBpZiAoYS5vcmlnaW4gIT09IGxvY2F0aW9uLm9yaWdpbikge1xuICAgICAgICAgICAgaWYgKGNvcnNFbmFibGVkKGEuaHJlZikpIHtcbiAgICAgICAgICAgICAgICBkb3dubG9hZChibG9iLCBuYW1lLCBvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGEudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgICAgICAgICAgY2xpY2soYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGljayhhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gU3VwcG9ydCBibG9ic1xuICAgICAgICBhLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYS5ocmVmKTtcbiAgICAgICAgfSwgNGU0KTsgLy8gNDBzXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xpY2soYSk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1zU2F2ZUFzKGJsb2IsIG5hbWUgPSAnZG93bmxvYWQnLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBibG9iID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoY29yc0VuYWJsZWQoYmxvYikpIHtcbiAgICAgICAgICAgIGRvd25sb2FkKGJsb2IsIG5hbWUsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgICAgIGEuaHJlZiA9IGJsb2I7XG4gICAgICAgICAgICBhLnRhcmdldCA9ICdfYmxhbmsnO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2xpY2soYSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZTogd29ya3Mgb24gd2luZG93c1xuICAgICAgICBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYihib20oYmxvYiwgb3B0cyksIG5hbWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbGVTYXZlclNhdmVBcyhibG9iLCBuYW1lLCBvcHRzLCBwb3B1cCkge1xuICAgIC8vIE9wZW4gYSBwb3B1cCBpbW1lZGlhdGVseSBkbyBnbyBhcm91bmQgcG9wdXAgYmxvY2tlclxuICAgIC8vIE1vc3RseSBvbmx5IGF2YWlsYWJsZSBvbiB1c2VyIGludGVyYWN0aW9uIGFuZCB0aGUgZmlsZVJlYWRlciBpcyBhc3luYyBzby4uLlxuICAgIHBvcHVwID0gcG9wdXAgfHwgb3BlbignJywgJ19ibGFuaycpO1xuICAgIGlmIChwb3B1cCkge1xuICAgICAgICBwb3B1cC5kb2N1bWVudC50aXRsZSA9IHBvcHVwLmRvY3VtZW50LmJvZHkuaW5uZXJUZXh0ID0gJ2Rvd25sb2FkaW5nLi4uJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBibG9iID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGRvd25sb2FkKGJsb2IsIG5hbWUsIG9wdHMpO1xuICAgIGNvbnN0IGZvcmNlID0gYmxvYi50eXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICBjb25zdCBpc1NhZmFyaSA9IC9jb25zdHJ1Y3Rvci9pLnRlc3QoU3RyaW5nKF9nbG9iYWwuSFRNTEVsZW1lbnQpKSB8fCAnc2FmYXJpJyBpbiBfZ2xvYmFsO1xuICAgIGNvbnN0IGlzQ2hyb21lSU9TID0gL0NyaU9TXFwvW1xcZF0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIGlmICgoaXNDaHJvbWVJT1MgfHwgKGZvcmNlICYmIGlzU2FmYXJpKSB8fCBpc01hY09TV2ViVmlldykgJiZcbiAgICAgICAgdHlwZW9mIEZpbGVSZWFkZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IGFsbG93IGRvd25sb2FkaW5nIG9mIGJsb2IgVVJMc1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGV0IHVybCA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwb3B1cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyByZWFkZXIucmVzdWx0IHR5cGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybCA9IGlzQ2hyb21lSU9TXG4gICAgICAgICAgICAgICAgPyB1cmxcbiAgICAgICAgICAgICAgICA6IHVybC5yZXBsYWNlKC9eZGF0YTpbXjtdKjsvLCAnZGF0YTphdHRhY2htZW50L2ZpbGU7Jyk7XG4gICAgICAgICAgICBpZiAocG9wdXApIHtcbiAgICAgICAgICAgICAgICBwb3B1cC5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3B1cCA9IG51bGw7IC8vIHJldmVyc2UtdGFibmFiYmluZyAjNDYwXG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgaWYgKHBvcHVwKVxuICAgICAgICAgICAgcG9wdXAubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgIHBvcHVwID0gbnVsbDsgLy8gcmV2ZXJzZS10YWJuYWJiaW5nICM0NjBcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICAgIH0sIDRlNCk7IC8vIDQwc1xuICAgIH1cbn1cblxuLyoqXG4gKiBTaG93cyBhIHRvYXN0IG9yIGNvbnNvbGUubG9nXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIHRvIGxvZ1xuICogQHBhcmFtIHR5cGUgLSBkaWZmZXJlbnQgY29sb3Igb2YgdGhlIHRvb2x0aXBcbiAqL1xuZnVuY3Rpb24gdG9hc3RNZXNzYWdlKG1lc3NhZ2UsIHR5cGUpIHtcbiAgICBjb25zdCBwaW5pYU1lc3NhZ2UgPSAn8J+NjSAnICsgbWVzc2FnZTtcbiAgICBpZiAodHlwZW9mIF9fVlVFX0RFVlRPT0xTX1RPQVNUX18gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gTm8gbG9uZ2VyIGF2YWlsYWJsZSA6KFxuICAgICAgICBfX1ZVRV9ERVZUT09MU19UT0FTVF9fKHBpbmlhTWVzc2FnZSwgdHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihwaW5pYU1lc3NhZ2UpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnd2FybicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKHBpbmlhTWVzc2FnZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhwaW5pYU1lc3NhZ2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUGluaWEobykge1xuICAgIHJldHVybiAnX2EnIGluIG8gJiYgJ2luc3RhbGwnIGluIG87XG59XG5cbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW4gZGV2dG9vbHMgYWN0aW9ucywgdGhleSBhcmUgbm90IFBpbmlhIGFjdGlvbnMuXG4gKi9cbi8vIC0tLVxuZnVuY3Rpb24gY2hlY2tDbGlwYm9hcmRBY2Nlc3MoKSB7XG4gICAgaWYgKCEoJ2NsaXBib2FyZCcgaW4gbmF2aWdhdG9yKSkge1xuICAgICAgICB0b2FzdE1lc3NhZ2UoYFlvdXIgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIENsaXBib2FyZCBBUElgLCAnZXJyb3InKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tOb3RGb2N1c2VkRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICBlcnJvci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2RvY3VtZW50IGlzIG5vdCBmb2N1c2VkJykpIHtcbiAgICAgICAgdG9hc3RNZXNzYWdlKCdZb3UgbmVlZCB0byBhY3RpdmF0ZSB0aGUgXCJFbXVsYXRlIGEgZm9jdXNlZCBwYWdlXCIgc2V0dGluZyBpbiB0aGUgXCJSZW5kZXJpbmdcIiBwYW5lbCBvZiBkZXZ0b29scy4nLCAnd2FybicpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuYXN5bmMgZnVuY3Rpb24gYWN0aW9uR2xvYmFsQ29weVN0YXRlKHBpbmlhKSB7XG4gICAgaWYgKGNoZWNrQ2xpcGJvYXJkQWNjZXNzKCkpXG4gICAgICAgIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChKU09OLnN0cmluZ2lmeShwaW5pYS5zdGF0ZS52YWx1ZSkpO1xuICAgICAgICB0b2FzdE1lc3NhZ2UoJ0dsb2JhbCBzdGF0ZSBjb3BpZWQgdG8gY2xpcGJvYXJkLicpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGNoZWNrTm90Rm9jdXNlZEVycm9yKGVycm9yKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdG9hc3RNZXNzYWdlKGBGYWlsZWQgdG8gc2VyaWFsaXplIHRoZSBzdGF0ZS4gQ2hlY2sgdGhlIGNvbnNvbGUgZm9yIG1vcmUgZGV0YWlscy5gLCAnZXJyb3InKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gYWN0aW9uR2xvYmFsUGFzdGVTdGF0ZShwaW5pYSkge1xuICAgIGlmIChjaGVja0NsaXBib2FyZEFjY2VzcygpKVxuICAgICAgICByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgICAgbG9hZFN0b3Jlc1N0YXRlKHBpbmlhLCBKU09OLnBhcnNlKGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQucmVhZFRleHQoKSkpO1xuICAgICAgICB0b2FzdE1lc3NhZ2UoJ0dsb2JhbCBzdGF0ZSBwYXN0ZWQgZnJvbSBjbGlwYm9hcmQuJyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoY2hlY2tOb3RGb2N1c2VkRXJyb3IoZXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0b2FzdE1lc3NhZ2UoYEZhaWxlZCB0byBkZXNlcmlhbGl6ZSB0aGUgc3RhdGUgZnJvbSBjbGlwYm9hcmQuIENoZWNrIHRoZSBjb25zb2xlIGZvciBtb3JlIGRldGFpbHMuYCwgJ2Vycm9yJyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGFjdGlvbkdsb2JhbFNhdmVTdGF0ZShwaW5pYSkge1xuICAgIHRyeSB7XG4gICAgICAgIHNhdmVBcyhuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkocGluaWEuc3RhdGUudmFsdWUpXSwge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQvcGxhaW47Y2hhcnNldD11dGYtOCcsXG4gICAgICAgIH0pLCAncGluaWEtc3RhdGUuanNvbicpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdG9hc3RNZXNzYWdlKGBGYWlsZWQgdG8gZXhwb3J0IHRoZSBzdGF0ZSBhcyBKU09OLiBDaGVjayB0aGUgY29uc29sZSBmb3IgbW9yZSBkZXRhaWxzLmAsICdlcnJvcicpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG59XG5sZXQgZmlsZUlucHV0O1xuZnVuY3Rpb24gZ2V0RmlsZU9wZW5lcigpIHtcbiAgICBpZiAoIWZpbGVJbnB1dCkge1xuICAgICAgICBmaWxlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBmaWxlSW5wdXQudHlwZSA9ICdmaWxlJztcbiAgICAgICAgZmlsZUlucHV0LmFjY2VwdCA9ICcuanNvbic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9wZW5GaWxlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZmlsZUlucHV0Lm9uY2hhbmdlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gZmlsZUlucHV0LmZpbGVzO1xuICAgICAgICAgICAgICAgIGlmICghZmlsZXMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBmaWxlcy5pdGVtKDApO1xuICAgICAgICAgICAgICAgIGlmICghZmlsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyB0ZXh0OiBhd2FpdCBmaWxlLnRleHQoKSwgZmlsZSB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlOiBUT0RPOiBjaGFuZ2VkIGZyb20gNC4zIHRvIDQuNFxuICAgICAgICAgICAgZmlsZUlucHV0Lm9uY2FuY2VsID0gKCkgPT4gcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIGZpbGVJbnB1dC5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgICAgZmlsZUlucHV0LmNsaWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3BlbkZpbGU7XG59XG5hc3luYyBmdW5jdGlvbiBhY3Rpb25HbG9iYWxPcGVuU3RhdGVGaWxlKHBpbmlhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3BlbiA9IGdldEZpbGVPcGVuZXIoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3BlbigpO1xuICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyB0ZXh0LCBmaWxlIH0gPSByZXN1bHQ7XG4gICAgICAgIGxvYWRTdG9yZXNTdGF0ZShwaW5pYSwgSlNPTi5wYXJzZSh0ZXh0KSk7XG4gICAgICAgIHRvYXN0TWVzc2FnZShgR2xvYmFsIHN0YXRlIGltcG9ydGVkIGZyb20gXCIke2ZpbGUubmFtZX1cIi5gKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRvYXN0TWVzc2FnZShgRmFpbGVkIHRvIGltcG9ydCB0aGUgc3RhdGUgZnJvbSBKU09OLiBDaGVjayB0aGUgY29uc29sZSBmb3IgbW9yZSBkZXRhaWxzLmAsICdlcnJvcicpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsb2FkU3RvcmVzU3RhdGUocGluaWEsIHN0YXRlKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHBpbmlhLnN0YXRlLnZhbHVlW2tleV07XG4gICAgICAgIC8vIHN0b3JlIGlzIGFscmVhZHkgaW5zdGFudGlhdGVkLCBwYXRjaCBpdFxuICAgICAgICBpZiAoc3RvcmVTdGF0ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdG9yZVN0YXRlLCBzdGF0ZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIGlzIG5vdCBpbnN0YW50aWF0ZWQsIHNldCB0aGUgaW5pdGlhbCBzdGF0ZVxuICAgICAgICAgICAgcGluaWEuc3RhdGUudmFsdWVba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERpc3BsYXkoZGlzcGxheSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIF9jdXN0b206IHtcbiAgICAgICAgICAgIGRpc3BsYXksXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmNvbnN0IFBJTklBX1JPT1RfTEFCRUwgPSAn8J+NjSBQaW5pYSAocm9vdCknO1xuY29uc3QgUElOSUFfUk9PVF9JRCA9ICdfcm9vdCc7XG5mdW5jdGlvbiBmb3JtYXRTdG9yZUZvckluc3BlY3RvclRyZWUoc3RvcmUpIHtcbiAgICByZXR1cm4gaXNQaW5pYShzdG9yZSlcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBpZDogUElOSUFfUk9PVF9JRCxcbiAgICAgICAgICAgIGxhYmVsOiBQSU5JQV9ST09UX0xBQkVMLFxuICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgaWQ6IHN0b3JlLiRpZCxcbiAgICAgICAgICAgIGxhYmVsOiBzdG9yZS4kaWQsXG4gICAgICAgIH07XG59XG5mdW5jdGlvbiBmb3JtYXRTdG9yZUZvckluc3BlY3RvclN0YXRlKHN0b3JlKSB7XG4gICAgaWYgKGlzUGluaWEoc3RvcmUpKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlTmFtZXMgPSBBcnJheS5mcm9tKHN0b3JlLl9zLmtleXMoKSk7XG4gICAgICAgIGNvbnN0IHN0b3JlTWFwID0gc3RvcmUuX3M7XG4gICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgc3RhdGU6IHN0b3JlTmFtZXMubWFwKChzdG9yZUlkKSA9PiAoe1xuICAgICAgICAgICAgICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtleTogc3RvcmVJZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3RvcmUuc3RhdGUudmFsdWVbc3RvcmVJZF0sXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBnZXR0ZXJzOiBzdG9yZU5hbWVzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoaWQpID0+IHN0b3JlTWFwLmdldChpZCkuX2dldHRlcnMpXG4gICAgICAgICAgICAgICAgLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHN0b3JlTWFwLmdldChpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGlkLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3RvcmUuX2dldHRlcnMucmVkdWNlKChnZXR0ZXJzLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldHRlcnNba2V5XSA9IHN0b3JlW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVycztcbiAgICAgICAgICAgICAgICAgICAgfSwge30pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgc3RhdGU6IE9iamVjdC5rZXlzKHN0b3JlLiRzdGF0ZSkubWFwKChrZXkpID0+ICh7XG4gICAgICAgICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBzdG9yZS4kc3RhdGVba2V5XSxcbiAgICAgICAgfSkpLFxuICAgIH07XG4gICAgLy8gYXZvaWQgYWRkaW5nIGVtcHR5IGdldHRlcnNcbiAgICBpZiAoc3RvcmUuX2dldHRlcnMgJiYgc3RvcmUuX2dldHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHN0YXRlLmdldHRlcnMgPSBzdG9yZS5fZ2V0dGVycy5tYXAoKGdldHRlck5hbWUpID0+ICh7XG4gICAgICAgICAgICBlZGl0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBrZXk6IGdldHRlck5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogc3RvcmVbZ2V0dGVyTmFtZV0sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHN0b3JlLl9jdXN0b21Qcm9wZXJ0aWVzLnNpemUpIHtcbiAgICAgICAgc3RhdGUuY3VzdG9tUHJvcGVydGllcyA9IEFycmF5LmZyb20oc3RvcmUuX2N1c3RvbVByb3BlcnRpZXMpLm1hcCgoa2V5KSA9PiAoe1xuICAgICAgICAgICAgZWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZTogc3RvcmVba2V5XSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBmb3JtYXRFdmVudERhdGEoZXZlbnRzKSB7XG4gICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudHMpKSB7XG4gICAgICAgIC8vIFRPRE86IGhhbmRsZSBhZGQgYW5kIGRlbGV0ZSBmb3IgYXJyYXlzIGFuZCBvYmplY3RzXG4gICAgICAgIHJldHVybiBldmVudHMucmVkdWNlKChkYXRhLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgZGF0YS5rZXlzLnB1c2goZXZlbnQua2V5KTtcbiAgICAgICAgICAgIGRhdGEub3BlcmF0aW9ucy5wdXNoKGV2ZW50LnR5cGUpO1xuICAgICAgICAgICAgZGF0YS5vbGRWYWx1ZVtldmVudC5rZXldID0gZXZlbnQub2xkVmFsdWU7XG4gICAgICAgICAgICBkYXRhLm5ld1ZhbHVlW2V2ZW50LmtleV0gPSBldmVudC5uZXdWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvbGRWYWx1ZToge30sXG4gICAgICAgICAgICBrZXlzOiBbXSxcbiAgICAgICAgICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgICAgICAgICAgbmV3VmFsdWU6IHt9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcGVyYXRpb246IGZvcm1hdERpc3BsYXkoZXZlbnRzLnR5cGUpLFxuICAgICAgICAgICAga2V5OiBmb3JtYXREaXNwbGF5KGV2ZW50cy5rZXkpLFxuICAgICAgICAgICAgb2xkVmFsdWU6IGV2ZW50cy5vbGRWYWx1ZSxcbiAgICAgICAgICAgIG5ld1ZhbHVlOiBldmVudHMubmV3VmFsdWUsXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZm9ybWF0TXV0YXRpb25UeXBlKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBNdXRhdGlvblR5cGUuZGlyZWN0OlxuICAgICAgICAgICAgcmV0dXJuICdtdXRhdGlvbic7XG4gICAgICAgIGNhc2UgTXV0YXRpb25UeXBlLnBhdGNoRnVuY3Rpb246XG4gICAgICAgICAgICByZXR1cm4gJyRwYXRjaCc7XG4gICAgICAgIGNhc2UgTXV0YXRpb25UeXBlLnBhdGNoT2JqZWN0OlxuICAgICAgICAgICAgcmV0dXJuICckcGF0Y2gnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICB9XG59XG5cbi8vIHRpbWVsaW5lIGNhbiBiZSBwYXVzZWQgd2hlbiBkaXJlY3RseSBjaGFuZ2luZyB0aGUgc3RhdGVcbmxldCBpc1RpbWVsaW5lQWN0aXZlID0gdHJ1ZTtcbmNvbnN0IGNvbXBvbmVudFN0YXRlVHlwZXMgPSBbXTtcbmNvbnN0IE1VVEFUSU9OU19MQVlFUl9JRCA9ICdwaW5pYTptdXRhdGlvbnMnO1xuY29uc3QgSU5TUEVDVE9SX0lEID0gJ3BpbmlhJztcbmNvbnN0IHsgYXNzaWduOiBhc3NpZ24kMSB9ID0gT2JqZWN0O1xuLyoqXG4gKiBHZXRzIHRoZSBkaXNwbGF5ZWQgbmFtZSBvZiBhIHN0b3JlIGluIGRldnRvb2xzXG4gKlxuICogQHBhcmFtIGlkIC0gaWQgb2YgdGhlIHN0b3JlXG4gKiBAcmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmdcbiAqL1xuY29uc3QgZ2V0U3RvcmVUeXBlID0gKGlkKSA9PiAn8J+NjSAnICsgaWQ7XG4vKipcbiAqIEFkZCB0aGUgcGluaWEgcGx1Z2luIHdpdGhvdXQgYW55IHN0b3JlLiBBbGxvd3MgZGlzcGxheWluZyBhIFBpbmlhIHBsdWdpbiB0YWJcbiAqIGFzIHNvb24gYXMgaXQgaXMgYWRkZWQgdG8gdGhlIGFwcGxpY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBhcHAgLSBWdWUgYXBwbGljYXRpb25cbiAqIEBwYXJhbSBwaW5pYSAtIHBpbmlhIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyUGluaWFEZXZ0b29scyhhcHAsIHBpbmlhKSB7XG4gICAgc2V0dXBEZXZ0b29sc1BsdWdpbih7XG4gICAgICAgIGlkOiAnZGV2LmVzbS5waW5pYScsXG4gICAgICAgIGxhYmVsOiAnUGluaWEg8J+NjScsXG4gICAgICAgIGxvZ286ICdodHRwczovL3BpbmlhLnZ1ZWpzLm9yZy9sb2dvLnN2ZycsXG4gICAgICAgIHBhY2thZ2VOYW1lOiAncGluaWEnLFxuICAgICAgICBob21lcGFnZTogJ2h0dHBzOi8vcGluaWEudnVlanMub3JnJyxcbiAgICAgICAgY29tcG9uZW50U3RhdGVUeXBlcyxcbiAgICAgICAgYXBwLFxuICAgIH0sIChhcGkpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcGkubm93ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0b2FzdE1lc3NhZ2UoJ1lvdSBzZWVtIHRvIGJlIHVzaW5nIGFuIG91dGRhdGVkIHZlcnNpb24gb2YgVnVlIERldnRvb2xzLiBBcmUgeW91IHN0aWxsIHVzaW5nIHRoZSBCZXRhIHJlbGVhc2UgaW5zdGVhZCBvZiB0aGUgc3RhYmxlIG9uZT8gWW91IGNhbiBmaW5kIHRoZSBsaW5rcyBhdCBodHRwczovL2RldnRvb2xzLnZ1ZWpzLm9yZy9ndWlkZS9pbnN0YWxsYXRpb24uaHRtbC4nKTtcbiAgICAgICAgfVxuICAgICAgICBhcGkuYWRkVGltZWxpbmVMYXllcih7XG4gICAgICAgICAgICBpZDogTVVUQVRJT05TX0xBWUVSX0lELFxuICAgICAgICAgICAgbGFiZWw6IGBQaW5pYSDwn42NYCxcbiAgICAgICAgICAgIGNvbG9yOiAweGU1ZGY4OCxcbiAgICAgICAgfSk7XG4gICAgICAgIGFwaS5hZGRJbnNwZWN0b3Ioe1xuICAgICAgICAgICAgaWQ6IElOU1BFQ1RPUl9JRCxcbiAgICAgICAgICAgIGxhYmVsOiAnUGluaWEg8J+NjScsXG4gICAgICAgICAgICBpY29uOiAnc3RvcmFnZScsXG4gICAgICAgICAgICB0cmVlRmlsdGVyUGxhY2Vob2xkZXI6ICdTZWFyY2ggc3RvcmVzJyxcbiAgICAgICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGljb246ICdjb250ZW50X2NvcHknLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkdsb2JhbENvcHlTdGF0ZShwaW5pYSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdTZXJpYWxpemUgYW5kIGNvcHkgdGhlIHN0YXRlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2NvbnRlbnRfcGFzdGUnLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGFjdGlvbkdsb2JhbFBhc3RlU3RhdGUocGluaWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JUcmVlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclN0YXRlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdSZXBsYWNlIHRoZSBzdGF0ZSB3aXRoIHRoZSBjb250ZW50IG9mIHlvdXIgY2xpcGJvYXJkJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ3NhdmUnLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkdsb2JhbFNhdmVTdGF0ZShwaW5pYSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdTYXZlIHRoZSBzdGF0ZSBhcyBhIEpTT04gZmlsZScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGljb246ICdmb2xkZXJfb3BlbicsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgYWN0aW9uR2xvYmFsT3BlblN0YXRlRmlsZShwaW5pYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclRyZWUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ0ltcG9ydCB0aGUgc3RhdGUgZnJvbSBhIEpTT04gZmlsZScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBub2RlQWN0aW9uczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ3Jlc3RvcmUnLFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiAnUmVzZXQgdGhlIHN0YXRlICh3aXRoIFwiJHJlc2V0XCIpJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAobm9kZUlkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHBpbmlhLl9zLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvYXN0TWVzc2FnZShgQ2Fubm90IHJlc2V0IFwiJHtub2RlSWR9XCIgc3RvcmUgYmVjYXVzZSBpdCB3YXNuJ3QgZm91bmQuYCwgJ3dhcm4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdG9yZS4kcmVzZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2FzdE1lc3NhZ2UoYENhbm5vdCByZXNldCBcIiR7bm9kZUlkfVwiIHN0b3JlIGJlY2F1c2UgaXQgZG9lc24ndCBoYXZlIGEgXCIkcmVzZXRcIiBtZXRob2QgaW1wbGVtZW50ZWQuYCwgJ3dhcm4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLiRyZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvYXN0TWVzc2FnZShgU3RvcmUgXCIke25vZGVJZH1cIiByZXNldC5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGFwaS5vbi5pbnNwZWN0Q29tcG9uZW50KChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gKHBheWxvYWQuY29tcG9uZW50SW5zdGFuY2UgJiZcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmNvbXBvbmVudEluc3RhbmNlLnByb3h5KTtcbiAgICAgICAgICAgIGlmIChwcm94eSAmJiBwcm94eS5fcFN0b3Jlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpbmlhU3RvcmVzID0gcGF5bG9hZC5jb21wb25lbnRJbnN0YW5jZS5wcm94eS5fcFN0b3JlcztcbiAgICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKHBpbmlhU3RvcmVzKS5mb3JFYWNoKChzdG9yZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmluc3RhbmNlRGF0YS5zdGF0ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGdldFN0b3JlVHlwZShzdG9yZS4kaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnc3RhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3RvcmUuX2lzT3B0aW9uc0FQSVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3VzdG9tOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG9SYXcoc3RvcmUuJHN0YXRlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb246ICdyZXN0b3JlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ1Jlc2V0IHRoZSBzdGF0ZSBvZiB0aGlzIHN0b3JlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAoKSA9PiBzdG9yZS4kcmVzZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAvLyBOT1RFOiB3b3JrYXJvdW5kIHRvIHVud3JhcCB0cmFuc2ZlcnJlZCByZWZzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0b3JlLiRzdGF0ZSkucmVkdWNlKChzdGF0ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVtrZXldID0gc3RvcmUuJHN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9yZS5fZ2V0dGVycyAmJiBzdG9yZS5fZ2V0dGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaW5zdGFuY2VEYXRhLnN0YXRlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGdldFN0b3JlVHlwZShzdG9yZS4kaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2dldHRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3RvcmUuX2dldHRlcnMucmVkdWNlKChnZXR0ZXJzLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldHRlcnNba2V5XSA9IHN0b3JlW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZSBqdXN0IHdhbnQgdG8gc2hvdyBpdCBpbiBkZXZ0b29sc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGVyc1trZXldID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldHRlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFwaS5vbi5nZXRJbnNwZWN0b3JUcmVlKChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5hcHAgPT09IGFwcCAmJiBwYXlsb2FkLmluc3BlY3RvcklkID09PSBJTlNQRUNUT1JfSUQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RvcmVzID0gW3BpbmlhXTtcbiAgICAgICAgICAgICAgICBzdG9yZXMgPSBzdG9yZXMuY29uY2F0KEFycmF5LmZyb20ocGluaWEuX3MudmFsdWVzKCkpKTtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnJvb3ROb2RlcyA9IChwYXlsb2FkLmZpbHRlclxuICAgICAgICAgICAgICAgICAgICA/IHN0b3Jlcy5maWx0ZXIoKHN0b3JlKSA9PiAnJGlkJyBpbiBzdG9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzdG9yZS4kaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbmNsdWRlcyhwYXlsb2FkLmZpbHRlci50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBQSU5JQV9ST09UX0xBQkVMLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocGF5bG9hZC5maWx0ZXIudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgICAgICAgICAgICAgIDogc3RvcmVzKS5tYXAoZm9ybWF0U3RvcmVGb3JJbnNwZWN0b3JUcmVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEV4cG9zZSBwaW5pYSBpbnN0YW5jZSBhcyAkcGluaWEgdG8gd2luZG93XG4gICAgICAgIGdsb2JhbFRoaXMuJHBpbmlhID0gcGluaWE7XG4gICAgICAgIGFwaS5vbi5nZXRJbnNwZWN0b3JTdGF0ZSgocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQuYXBwID09PSBhcHAgJiYgcGF5bG9hZC5pbnNwZWN0b3JJZCA9PT0gSU5TUEVDVE9SX0lEKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zcGVjdGVkU3RvcmUgPSBwYXlsb2FkLm5vZGVJZCA9PT0gUElOSUFfUk9PVF9JRFxuICAgICAgICAgICAgICAgICAgICA/IHBpbmlhXG4gICAgICAgICAgICAgICAgICAgIDogcGluaWEuX3MuZ2V0KHBheWxvYWQubm9kZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWluc3BlY3RlZFN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY291bGQgYmUgdGhlIHNlbGVjdGVkIHN0b3JlIHJlc3RvcmVkIGZvciBhIGRpZmZlcmVudCBwcm9qZWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGl0J3MgYmV0dGVyIG5vdCB0byBzYXkgYW55dGhpbmcgaGVyZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbnNwZWN0ZWRTdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHBvc2Ugc2VsZWN0ZWQgc3RvcmUgYXMgJHN0b3JlIHRvIHdpbmRvd1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5ub2RlSWQgIT09IFBJTklBX1JPT1RfSUQpXG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLiRzdG9yZSA9IHRvUmF3KGluc3BlY3RlZFN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5zdGF0ZSA9IGZvcm1hdFN0b3JlRm9ySW5zcGVjdG9yU3RhdGUoaW5zcGVjdGVkU3RvcmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFwaS5vbi5lZGl0SW5zcGVjdG9yU3RhdGUoKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQuYXBwID09PSBhcHAgJiYgcGF5bG9hZC5pbnNwZWN0b3JJZCA9PT0gSU5TUEVDVE9SX0lEKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zcGVjdGVkU3RvcmUgPSBwYXlsb2FkLm5vZGVJZCA9PT0gUElOSUFfUk9PVF9JRFxuICAgICAgICAgICAgICAgICAgICA/IHBpbmlhXG4gICAgICAgICAgICAgICAgICAgIDogcGluaWEuX3MuZ2V0KHBheWxvYWQubm9kZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWluc3BlY3RlZFN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2FzdE1lc3NhZ2UoYHN0b3JlIFwiJHtwYXlsb2FkLm5vZGVJZH1cIiBub3QgZm91bmRgLCAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXRoIH0gPSBwYXlsb2FkO1xuICAgICAgICAgICAgICAgIGlmICghaXNQaW5pYShpbnNwZWN0ZWRTdG9yZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXNzIG9ubHkgdGhlIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWluc3BlY3RlZFN0b3JlLl9jdXN0b21Qcm9wZXJ0aWVzLmhhcyhwYXRoWzBdKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFswXSBpbiBpbnNwZWN0ZWRTdG9yZS4kc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgudW5zaGlmdCgnJHN0YXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJvb3QgYWNjZXNzLCB3ZSBjYW4gb21pdCB0aGUgYC52YWx1ZWAgYmVjYXVzZSB0aGUgZGV2dG9vbHMgQVBJIGRvZXMgaXQgZm9yIHVzXG4gICAgICAgICAgICAgICAgICAgIHBhdGgudW5zaGlmdCgnc3RhdGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXNUaW1lbGluZUFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHBheWxvYWQuc2V0KGluc3BlY3RlZFN0b3JlLCBwYXRoLCBwYXlsb2FkLnN0YXRlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpc1RpbWVsaW5lQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFwaS5vbi5lZGl0Q29tcG9uZW50U3RhdGUoKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLnR5cGUuc3RhcnRzV2l0aCgn8J+NjScpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmVJZCA9IHBheWxvYWQudHlwZS5yZXBsYWNlKC9e8J+NjVxccyovLCAnJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSBwaW5pYS5fcy5nZXQoc3RvcmVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9hc3RNZXNzYWdlKGBzdG9yZSBcIiR7c3RvcmVJZH1cIiBub3QgZm91bmRgLCAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXRoIH0gPSBwYXlsb2FkO1xuICAgICAgICAgICAgICAgIGlmIChwYXRoWzBdICE9PSAnc3RhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2FzdE1lc3NhZ2UoYEludmFsaWQgcGF0aCBmb3Igc3RvcmUgXCIke3N0b3JlSWR9XCI6XFxuJHtwYXRofVxcbk9ubHkgc3RhdGUgY2FuIGJlIG1vZGlmaWVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZXdyaXRlIHRoZSBmaXJzdCBlbnRyeSB0byBiZSBhYmxlIHRvIGRpcmVjdGx5IHNldCB0aGUgc3RhdGUgYXNcbiAgICAgICAgICAgICAgICAvLyB3ZWxsIGFzIGFueSBvdGhlciBwYXRoXG4gICAgICAgICAgICAgICAgcGF0aFswXSA9ICckc3RhdGUnO1xuICAgICAgICAgICAgICAgIGlzVGltZWxpbmVBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnNldChzdG9yZSwgcGF0aCwgcGF5bG9hZC5zdGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaXNUaW1lbGluZUFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYWRkU3RvcmVUb0RldnRvb2xzKGFwcCwgc3RvcmUpIHtcbiAgICBpZiAoIWNvbXBvbmVudFN0YXRlVHlwZXMuaW5jbHVkZXMoZ2V0U3RvcmVUeXBlKHN0b3JlLiRpZCkpKSB7XG4gICAgICAgIGNvbXBvbmVudFN0YXRlVHlwZXMucHVzaChnZXRTdG9yZVR5cGUoc3RvcmUuJGlkKSk7XG4gICAgfVxuICAgIHNldHVwRGV2dG9vbHNQbHVnaW4oe1xuICAgICAgICBpZDogJ2Rldi5lc20ucGluaWEnLFxuICAgICAgICBsYWJlbDogJ1BpbmlhIPCfjY0nLFxuICAgICAgICBsb2dvOiAnaHR0cHM6Ly9waW5pYS52dWVqcy5vcmcvbG9nby5zdmcnLFxuICAgICAgICBwYWNrYWdlTmFtZTogJ3BpbmlhJyxcbiAgICAgICAgaG9tZXBhZ2U6ICdodHRwczovL3BpbmlhLnZ1ZWpzLm9yZycsXG4gICAgICAgIGNvbXBvbmVudFN0YXRlVHlwZXMsXG4gICAgICAgIGFwcCxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxvZ1N0b3JlQ2hhbmdlczoge1xuICAgICAgICAgICAgICAgIGxhYmVsOiAnTm90aWZ5IGFib3V0IG5ldy9kZWxldGVkIHN0b3JlcycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyB1c2VFbW9qaXM6IHtcbiAgICAgICAgICAgIC8vICAgbGFiZWw6ICdVc2UgZW1vamlzIGluIG1lc3NhZ2VzIOKaoe+4jycsXG4gICAgICAgICAgICAvLyAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgIC8vICAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgLy8gfSxcbiAgICAgICAgfSxcbiAgICB9LCAoYXBpKSA9PiB7XG4gICAgICAgIC8vIGdyYWNlZnVsbHkgaGFuZGxlIGVycm9yc1xuICAgICAgICBjb25zdCBub3cgPSB0eXBlb2YgYXBpLm5vdyA9PT0gJ2Z1bmN0aW9uJyA/IGFwaS5ub3cuYmluZChhcGkpIDogRGF0ZS5ub3c7XG4gICAgICAgIHN0b3JlLiRvbkFjdGlvbigoeyBhZnRlciwgb25FcnJvciwgbmFtZSwgYXJncyB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBncm91cElkID0gcnVubmluZ0FjdGlvbklkKys7XG4gICAgICAgICAgICBhcGkuYWRkVGltZWxpbmVFdmVudCh7XG4gICAgICAgICAgICAgICAgbGF5ZXJJZDogTVVUQVRJT05TX0xBWUVSX0lELFxuICAgICAgICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5vdygpLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ/Cfm6sgJyArIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlOiAnc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZTogZm9ybWF0RGlzcGxheShzdG9yZS4kaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmb3JtYXREaXNwbGF5KG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhZnRlcigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlQWN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZDogTVVUQVRJT05TX0xBWUVSX0lELFxuICAgICAgICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogbm93KCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ/Cfm6wgJyArIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZTogJ2VuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmU6IGZvcm1hdERpc3BsYXkoc3RvcmUuJGlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGZvcm1hdERpc3BsYXkobmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb25FcnJvcigoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBhY3RpdmVBY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYXBpLmFkZFRpbWVsaW5lRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBsYXllcklkOiBNVVRBVElPTlNfTEFZRVJfSUQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBub3coKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ1R5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ/CfkqUgJyArIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZTogJ2VuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmU6IGZvcm1hdERpc3BsYXkoc3RvcmUuJGlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGZvcm1hdERpc3BsYXkobmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cElkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBzdG9yZS5fY3VzdG9tUHJvcGVydGllcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICB3YXRjaCgoKSA9PiB1bnJlZihzdG9yZVtuYW1lXSksIChuZXdWYWx1ZSwgb2xkVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBhcGkubm90aWZ5Q29tcG9uZW50VXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JTdGF0ZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICAgICAgICAgIGlmIChpc1RpbWVsaW5lQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVySWQ6IE1VVEFUSU9OU19MQVlFUl9JRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogbm93KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdDaGFuZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZDogYWN0aXZlQWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgeyBkZWVwOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RvcmUuJHN1YnNjcmliZSgoeyBldmVudHMsIHR5cGUgfSwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgIGFwaS5ub3RpZnlDb21wb25lbnRVcGRhdGUoKTtcbiAgICAgICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgICAgIGlmICghaXNUaW1lbGluZUFjdGl2ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyByb290U3RvcmUuc3RhdGVbc3RvcmUuaWRdID0gc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IHtcbiAgICAgICAgICAgICAgICB0aW1lOiBub3coKSxcbiAgICAgICAgICAgICAgICB0aXRsZTogZm9ybWF0TXV0YXRpb25UeXBlKHR5cGUpLFxuICAgICAgICAgICAgICAgIGRhdGE6IGFzc2lnbiQxKHsgc3RvcmU6IGZvcm1hdERpc3BsYXkoc3RvcmUuJGlkKSB9LCBmb3JtYXRFdmVudERhdGEoZXZlbnRzKSksXG4gICAgICAgICAgICAgICAgZ3JvdXBJZDogYWN0aXZlQWN0aW9uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBNdXRhdGlvblR5cGUucGF0Y2hGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGV2ZW50RGF0YS5zdWJ0aXRsZSA9ICfipLXvuI8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gTXV0YXRpb25UeXBlLnBhdGNoT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZXZlbnREYXRhLnN1YnRpdGxlID0gJ/Cfp6knO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRzICYmICFBcnJheS5pc0FycmF5KGV2ZW50cykpIHtcbiAgICAgICAgICAgICAgICBldmVudERhdGEuc3VidGl0bGUgPSBldmVudHMudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgICAgICAgICBldmVudERhdGEuZGF0YVsncmF3RXZlbnQocyknXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgX2N1c3RvbToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ0RlYnVnZ2VyRXZlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiAncmF3IERlYnVnZ2VyRXZlbnRbXScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcGkuYWRkVGltZWxpbmVFdmVudCh7XG4gICAgICAgICAgICAgICAgbGF5ZXJJZDogTVVUQVRJT05TX0xBWUVSX0lELFxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudERhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgeyBkZXRhY2hlZDogdHJ1ZSwgZmx1c2g6ICdzeW5jJyB9KTtcbiAgICAgICAgY29uc3QgaG90VXBkYXRlID0gc3RvcmUuX2hvdFVwZGF0ZTtcbiAgICAgICAgc3RvcmUuX2hvdFVwZGF0ZSA9IG1hcmtSYXcoKG5ld1N0b3JlKSA9PiB7XG4gICAgICAgICAgICBob3RVcGRhdGUobmV3U3RvcmUpO1xuICAgICAgICAgICAgYXBpLmFkZFRpbWVsaW5lRXZlbnQoe1xuICAgICAgICAgICAgICAgIGxheWVySWQ6IE1VVEFUSU9OU19MQVlFUl9JRCxcbiAgICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiBub3coKSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICfwn5SlICcgKyBzdG9yZS4kaWQsXG4gICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlOiAnSE1SIHVwZGF0ZScsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlOiBmb3JtYXREaXNwbGF5KHN0b3JlLiRpZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvOiBmb3JtYXREaXNwbGF5KGBITVIgdXBkYXRlYCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBkZXZ0b29scyB0b29cbiAgICAgICAgICAgIGFwaS5ub3RpZnlDb21wb25lbnRVcGRhdGUoKTtcbiAgICAgICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yVHJlZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JTdGF0ZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyAkZGlzcG9zZSB9ID0gc3RvcmU7XG4gICAgICAgIHN0b3JlLiRkaXNwb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgJGRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGFwaS5ub3RpZnlDb21wb25lbnRVcGRhdGUoKTtcbiAgICAgICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yVHJlZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JTdGF0ZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICAgICAgYXBpLmdldFNldHRpbmdzKCkubG9nU3RvcmVDaGFuZ2VzICYmXG4gICAgICAgICAgICAgICAgdG9hc3RNZXNzYWdlKGBEaXNwb3NlZCBcIiR7c3RvcmUuJGlkfVwiIHN0b3JlIPCfl5FgKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdHJpZ2dlciBhbiB1cGRhdGUgc28gaXQgY2FuIGRpc3BsYXkgbmV3IHJlZ2lzdGVyZWQgc3RvcmVzXG4gICAgICAgIGFwaS5ub3RpZnlDb21wb25lbnRVcGRhdGUoKTtcbiAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JUcmVlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgYXBpLmdldFNldHRpbmdzKCkubG9nU3RvcmVDaGFuZ2VzICYmXG4gICAgICAgICAgICB0b2FzdE1lc3NhZ2UoYFwiJHtzdG9yZS4kaWR9XCIgc3RvcmUgaW5zdGFsbGVkIPCfhpVgKTtcbiAgICB9KTtcbn1cbmxldCBydW5uaW5nQWN0aW9uSWQgPSAwO1xubGV0IGFjdGl2ZUFjdGlvbjtcbi8qKlxuICogUGF0Y2hlcyBhIHN0b3JlIHRvIGVuYWJsZSBhY3Rpb24gZ3JvdXBpbmcgaW4gZGV2dG9vbHMgYnkgd3JhcHBpbmcgdGhlIHN0b3JlIHdpdGggYSBQcm94eSB0aGF0IGlzIHBhc3NlZCBhcyB0aGVcbiAqIGNvbnRleHQgb2YgYWxsIGFjdGlvbnMsIGFsbG93aW5nIHVzIHRvIHNldCBgcnVubmluZ0FjdGlvbmAgb24gZWFjaCBhY2Nlc3MgYW5kIGVmZmVjdGl2ZWx5IGFzc29jaWF0aW5nIGFueSBzdGF0ZVxuICogbXV0YXRpb24gdG8gdGhlIGFjdGlvbi5cbiAqXG4gKiBAcGFyYW0gc3RvcmUgLSBzdG9yZSB0byBwYXRjaFxuICogQHBhcmFtIGFjdGlvbk5hbWVzIC0gbGlzdCBvZiBhY3Rpb25zdCB0byBwYXRjaFxuICovXG5mdW5jdGlvbiBwYXRjaEFjdGlvbkZvckdyb3VwaW5nKHN0b3JlLCBhY3Rpb25OYW1lcywgd3JhcFdpdGhQcm94eSkge1xuICAgIC8vIG9yaWdpbmFsIGFjdGlvbnMgb2YgdGhlIHN0b3JlIGFzIHRoZXkgYXJlIGdpdmVuIGJ5IHBpbmlhLiBXZSBhcmUgZ29pbmcgdG8gb3ZlcnJpZGUgdGhlbVxuICAgIGNvbnN0IGFjdGlvbnMgPSBhY3Rpb25OYW1lcy5yZWR1Y2UoKHN0b3JlQWN0aW9ucywgYWN0aW9uTmFtZSkgPT4ge1xuICAgICAgICAvLyB1c2UgdG9SYXcgdG8gYXZvaWQgdHJhY2tpbmcgIzU0MVxuICAgICAgICBzdG9yZUFjdGlvbnNbYWN0aW9uTmFtZV0gPSB0b1JhdyhzdG9yZSlbYWN0aW9uTmFtZV07XG4gICAgICAgIHJldHVybiBzdG9yZUFjdGlvbnM7XG4gICAgfSwge30pO1xuICAgIGZvciAoY29uc3QgYWN0aW9uTmFtZSBpbiBhY3Rpb25zKSB7XG4gICAgICAgIHN0b3JlW2FjdGlvbk5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gdGhlIHJ1bm5pbmcgYWN0aW9uIGlkIGlzIGluY3JlbWVudGVkIGluIGEgYmVmb3JlIGFjdGlvbiBob29rXG4gICAgICAgICAgICBjb25zdCBfYWN0aW9uSWQgPSBydW5uaW5nQWN0aW9uSWQ7XG4gICAgICAgICAgICBjb25zdCB0cmFja2VkU3RvcmUgPSB3cmFwV2l0aFByb3h5XG4gICAgICAgICAgICAgICAgPyBuZXcgUHJveHkoc3RvcmUsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0KC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUFjdGlvbiA9IF9hY3Rpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0KC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUFjdGlvbiA9IF9hY3Rpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LnNldCguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIDogc3RvcmU7XG4gICAgICAgICAgICAvLyBGb3IgU2V0dXAgU3RvcmVzIHdlIG5lZWQgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXN5bmMtY29udGV4dFxuICAgICAgICAgICAgYWN0aXZlQWN0aW9uID0gX2FjdGlvbklkO1xuICAgICAgICAgICAgY29uc3QgcmV0VmFsdWUgPSBhY3Rpb25zW2FjdGlvbk5hbWVdLmFwcGx5KHRyYWNrZWRTdG9yZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgc2FmZXIgYXMgYXN5bmMgYWN0aW9ucyBpbiBTZXR1cCBTdG9yZXMgd291bGQgYXNzb2NpYXRlIG11dGF0aW9ucyBkb25lIG91dHNpZGUgb2YgdGhlIGFjdGlvblxuICAgICAgICAgICAgYWN0aXZlQWN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIHJldFZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogcGluaWEudXNlKGRldnRvb2xzUGx1Z2luKVxuICovXG5mdW5jdGlvbiBkZXZ0b29sc1BsdWdpbih7IGFwcCwgc3RvcmUsIG9wdGlvbnMgfSkge1xuICAgIC8vIEhNUiBtb2R1bGVcbiAgICBpZiAoc3RvcmUuJGlkLnN0YXJ0c1dpdGgoJ19faG90OicpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZGV0ZWN0IG9wdGlvbiBhcGkgdnMgc2V0dXAgYXBpXG4gICAgc3RvcmUuX2lzT3B0aW9uc0FQSSA9ICEhb3B0aW9ucy5zdGF0ZTtcbiAgICAvLyBEbyBub3Qgb3ZlcndyaXRlIGFjdGlvbnMgbW9ja2VkIGJ5IEBwaW5pYS90ZXN0aW5nICgjMjI5OClcbiAgICBpZiAoIXN0b3JlLl9wLl90ZXN0aW5nKSB7XG4gICAgICAgIHBhdGNoQWN0aW9uRm9yR3JvdXBpbmcoc3RvcmUsIE9iamVjdC5rZXlzKG9wdGlvbnMuYWN0aW9ucyksIHN0b3JlLl9pc09wdGlvbnNBUEkpO1xuICAgICAgICAvLyBVcGdyYWRlIHRoZSBITVIgdG8gYWxzbyB1cGRhdGUgdGhlIG5ldyBhY3Rpb25zXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSG90VXBkYXRlID0gc3RvcmUuX2hvdFVwZGF0ZTtcbiAgICAgICAgdG9SYXcoc3RvcmUpLl9ob3RVcGRhdGUgPSBmdW5jdGlvbiAobmV3U3RvcmUpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsSG90VXBkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBwYXRjaEFjdGlvbkZvckdyb3VwaW5nKHN0b3JlLCBPYmplY3Qua2V5cyhuZXdTdG9yZS5faG1yUGF5bG9hZC5hY3Rpb25zKSwgISFzdG9yZS5faXNPcHRpb25zQVBJKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYWRkU3RvcmVUb0RldnRvb2xzKGFwcCwgXG4gICAgLy8gRklYTUU6IGlzIHRoZXJlIGEgd2F5IHRvIGFsbG93IHRoZSBhc3NpZ25tZW50IGZyb20gU3RvcmU8SWQsIFMsIEcsIEE+IHRvIFN0b3JlR2VuZXJpYz9cbiAgICBzdG9yZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFBpbmlhIGluc3RhbmNlIHRvIGJlIHVzZWQgYnkgdGhlIGFwcGxpY2F0aW9uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBpbmlhKCkge1xuICAgIGNvbnN0IHNjb3BlID0gZWZmZWN0U2NvcGUodHJ1ZSk7XG4gICAgLy8gTk9URTogaGVyZSB3ZSBjb3VsZCBjaGVjayB0aGUgd2luZG93IG9iamVjdCBmb3IgYSBzdGF0ZSBhbmQgZGlyZWN0bHkgc2V0IGl0XG4gICAgLy8gaWYgdGhlcmUgaXMgYW55dGhpbmcgbGlrZSBpdCB3aXRoIFZ1ZSAzIFNTUlxuICAgIGNvbnN0IHN0YXRlID0gc2NvcGUucnVuKCgpID0+IHJlZih7fSkpO1xuICAgIGxldCBfcCA9IFtdO1xuICAgIC8vIHBsdWdpbnMgYWRkZWQgYmVmb3JlIGNhbGxpbmcgYXBwLnVzZShwaW5pYSlcbiAgICBsZXQgdG9CZUluc3RhbGxlZCA9IFtdO1xuICAgIGNvbnN0IHBpbmlhID0gbWFya1Jhdyh7XG4gICAgICAgIGluc3RhbGwoYXBwKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGFsbG93cyBjYWxsaW5nIHVzZVN0b3JlKCkgb3V0c2lkZSBvZiBhIGNvbXBvbmVudCBzZXR1cCBhZnRlclxuICAgICAgICAgICAgLy8gaW5zdGFsbGluZyBwaW5pYSdzIHBsdWdpblxuICAgICAgICAgICAgc2V0QWN0aXZlUGluaWEocGluaWEpO1xuICAgICAgICAgICAgaWYgKCFpc1Z1ZTIpIHtcbiAgICAgICAgICAgICAgICBwaW5pYS5fYSA9IGFwcDtcbiAgICAgICAgICAgICAgICBhcHAucHJvdmlkZShwaW5pYVN5bWJvbCwgcGluaWEpO1xuICAgICAgICAgICAgICAgIGFwcC5jb25maWcuZ2xvYmFsUHJvcGVydGllcy4kcGluaWEgPSBwaW5pYTtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmICgoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgX19WVUVfUFJPRF9ERVZUT09MU19fKSkgJiYgIShwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSkgJiYgSVNfQ0xJRU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyUGluaWFEZXZ0b29scyhhcHAsIHBpbmlhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9CZUluc3RhbGxlZC5mb3JFYWNoKChwbHVnaW4pID0+IF9wLnB1c2gocGx1Z2luKSk7XG4gICAgICAgICAgICAgICAgdG9CZUluc3RhbGxlZCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1c2UocGx1Z2luKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2EgJiYgIWlzVnVlMikge1xuICAgICAgICAgICAgICAgIHRvQmVJbnN0YWxsZWQucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3AucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIF9wLFxuICAgICAgICAvLyBpdCdzIGFjdHVhbGx5IHVuZGVmaW5lZCBoZXJlXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgX2E6IG51bGwsXG4gICAgICAgIF9lOiBzY29wZSxcbiAgICAgICAgX3M6IG5ldyBNYXAoKSxcbiAgICAgICAgc3RhdGUsXG4gICAgfSk7XG4gICAgLy8gcGluaWEgZGV2dG9vbHMgcmVseSBvbiBkZXYgb25seSBmZWF0dXJlcyBzbyB0aGV5IGNhbm5vdCBiZSBmb3JjZWQgdW5sZXNzXG4gICAgLy8gdGhlIGRldiBidWlsZCBvZiBWdWUgaXMgdXNlZC4gQXZvaWQgb2xkIGJyb3dzZXJzIGxpa2UgSUUxMS5cbiAgICBpZiAoKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgKHR5cGVvZiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18gIT09ICd1bmRlZmluZWQnICYmIF9fVlVFX1BST0RfREVWVE9PTFNfXykpICYmICEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0JykpICYmIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGluaWEudXNlKGRldnRvb2xzUGx1Z2luKTtcbiAgICB9XG4gICAgcmV0dXJuIHBpbmlhO1xufVxuLyoqXG4gKiBEaXNwb3NlIGEgUGluaWEgaW5zdGFuY2UgYnkgc3RvcHBpbmcgaXRzIGVmZmVjdFNjb3BlIGFuZCByZW1vdmluZyB0aGUgc3RhdGUsIHBsdWdpbnMgYW5kIHN0b3Jlcy4gVGhpcyBpcyBtb3N0bHlcbiAqIHVzZWZ1bCBpbiB0ZXN0cywgd2l0aCBib3RoIGEgdGVzdGluZyBwaW5pYSBvciBhIHJlZ3VsYXIgcGluaWEgYW5kIGluIGFwcGxpY2F0aW9ucyB0aGF0IHVzZSBtdWx0aXBsZSBwaW5pYSBpbnN0YW5jZXMuXG4gKiBPbmNlIGRpc3Bvc2VkLCB0aGUgcGluaWEgaW5zdGFuY2UgY2Fubm90IGJlIHVzZWQgYW55bW9yZS5cbiAqXG4gKiBAcGFyYW0gcGluaWEgLSBwaW5pYSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBkaXNwb3NlUGluaWEocGluaWEpIHtcbiAgICBwaW5pYS5fZS5zdG9wKCk7XG4gICAgcGluaWEuX3MuY2xlYXIoKTtcbiAgICBwaW5pYS5fcC5zcGxpY2UoMCk7XG4gICAgcGluaWEuc3RhdGUudmFsdWUgPSB7fTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBub24gdmFsaWRcbiAgICBwaW5pYS5fYSA9IG51bGw7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZnVuY3Rpb24gaXMgYSBgU3RvcmVEZWZpbml0aW9uYC5cbiAqXG4gKiBAcGFyYW0gZm4gLSBvYmplY3QgdG8gdGVzdFxuICogQHJldHVybnMgdHJ1ZSBpZiBgZm5gIGlzIGEgU3RvcmVEZWZpbml0aW9uXG4gKi9cbmNvbnN0IGlzVXNlU3RvcmUgPSAoZm4pID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBmbi4kaWQgPT09ICdzdHJpbmcnO1xufTtcbi8qKlxuICogTXV0YXRlcyBpbiBwbGFjZSBgbmV3U3RhdGVgIHdpdGggYG9sZFN0YXRlYCB0byBfaG90IHVwZGF0ZV8gaXQuIEl0IHdpbGxcbiAqIHJlbW92ZSBhbnkga2V5IG5vdCBleGlzdGluZyBpbiBgbmV3U3RhdGVgIGFuZCByZWN1cnNpdmVseSBtZXJnZSBwbGFpblxuICogb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gbmV3U3RhdGUgLSBuZXcgc3RhdGUgb2JqZWN0IHRvIGJlIHBhdGNoZWRcbiAqIEBwYXJhbSBvbGRTdGF0ZSAtIG9sZCBzdGF0ZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHBhdGNoIG5ld1N0YXRlXG4gKiBAcmV0dXJucyAtIG5ld1N0YXRlXG4gKi9cbmZ1bmN0aW9uIHBhdGNoT2JqZWN0KG5ld1N0YXRlLCBvbGRTdGF0ZSkge1xuICAgIC8vIG5vIG5lZWQgdG8gZ28gdGhyb3VnaCBzeW1ib2xzIGJlY2F1c2UgdGhleSBjYW5ub3QgYmUgc2VyaWFsaXplZCBhbnl3YXlcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRTdGF0ZSkge1xuICAgICAgICBjb25zdCBzdWJQYXRjaCA9IG9sZFN0YXRlW2tleV07XG4gICAgICAgIC8vIHNraXAgdGhlIHdob2xlIHN1YiB0cmVlXG4gICAgICAgIGlmICghKGtleSBpbiBuZXdTdGF0ZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gbmV3U3RhdGVba2V5XTtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0VmFsdWUpICYmXG4gICAgICAgICAgICBpc1BsYWluT2JqZWN0KHN1YlBhdGNoKSAmJlxuICAgICAgICAgICAgIWlzUmVmKHN1YlBhdGNoKSAmJlxuICAgICAgICAgICAgIWlzUmVhY3RpdmUoc3ViUGF0Y2gpKSB7XG4gICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gcGF0Y2hPYmplY3QodGFyZ2V0VmFsdWUsIHN1YlBhdGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG9iamVjdHMgYXJlIGVpdGhlciBhIGJpdCBtb3JlIGNvbXBsZXggKGUuZy4gcmVmcykgb3IgcHJpbWl0aXZlcywgc28gd2VcbiAgICAgICAgICAgIC8vIGp1c3Qgc2V0IHRoZSB3aG9sZSB0aGluZ1xuICAgICAgICAgICAgaWYgKGlzVnVlMikge1xuICAgICAgICAgICAgICAgIHNldChuZXdTdGF0ZSwga2V5LCBzdWJQYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gc3ViUGF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIF9hY2NlcHRfIGZ1bmN0aW9uIHRvIHBhc3MgdG8gYGltcG9ydC5tZXRhLmhvdGAgaW4gVml0ZSBhcHBsaWNhdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCB1c2VVc2VyID0gZGVmaW5lU3RvcmUoLi4uKVxuICogaWYgKGltcG9ydC5tZXRhLmhvdCkge1xuICogICBpbXBvcnQubWV0YS5ob3QuYWNjZXB0KGFjY2VwdEhNUlVwZGF0ZSh1c2VVc2VyLCBpbXBvcnQubWV0YS5ob3QpKVxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGluaXRpYWxVc2VTdG9yZSAtIHJldHVybiBvZiB0aGUgZGVmaW5lU3RvcmUgdG8gaG90IHVwZGF0ZVxuICogQHBhcmFtIGhvdCAtIGBpbXBvcnQubWV0YS5ob3RgXG4gKi9cbmZ1bmN0aW9uIGFjY2VwdEhNUlVwZGF0ZShpbml0aWFsVXNlU3RvcmUsIGhvdCkge1xuICAgIC8vIHN0cmlwIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpaWZlLnByb2RcbiAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuICAgIH1cbiAgICByZXR1cm4gKG5ld01vZHVsZSkgPT4ge1xuICAgICAgICBjb25zdCBwaW5pYSA9IGhvdC5kYXRhLnBpbmlhIHx8IGluaXRpYWxVc2VTdG9yZS5fcGluaWE7XG4gICAgICAgIGlmICghcGluaWEpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgc3RvcmUgaXMgc3RpbGwgbm90IHVzZWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmVzZXJ2ZSB0aGUgcGluaWEgaW5zdGFuY2UgYWNyb3NzIGxvYWRzXG4gICAgICAgIGhvdC5kYXRhLnBpbmlhID0gcGluaWE7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdnb3QgZGF0YScsIG5ld1N0b3JlKVxuICAgICAgICBmb3IgKGNvbnN0IGV4cG9ydE5hbWUgaW4gbmV3TW9kdWxlKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VTdG9yZSA9IG5ld01vZHVsZVtleHBvcnROYW1lXTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjaGVja2luZyBmb3InLCBleHBvcnROYW1lKVxuICAgICAgICAgICAgaWYgKGlzVXNlU3RvcmUodXNlU3RvcmUpICYmIHBpbmlhLl9zLmhhcyh1c2VTdG9yZS4kaWQpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0FjY2VwdGluZyB1cGRhdGUgZm9yJywgdXNlU3RvcmUuJGlkKVxuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gdXNlU3RvcmUuJGlkO1xuICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gaW5pdGlhbFVzZVN0b3JlLiRpZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoZSBpZCBvZiB0aGUgc3RvcmUgY2hhbmdlZCBmcm9tIFwiJHtpbml0aWFsVXNlU3RvcmUuJGlkfVwiIHRvIFwiJHtpZH1cIi4gUmVsb2FkaW5nLmApO1xuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gaW1wb3J0Lm1ldGEuaG90LmludmFsaWRhdGUoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaG90LmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdTdG9yZSA9IHBpbmlhLl9zLmdldChpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZ1N0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUGluaWFdOiBza2lwcGluZyBobXIgYmVjYXVzZSBzdG9yZSBkb2Vzbid0IGV4aXN0IHlldGApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVzZVN0b3JlKHBpbmlhLCBleGlzdGluZ1N0b3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG5mdW5jdGlvbiBhZGRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9ucywgY2FsbGJhY2ssIGRldGFjaGVkLCBvbkNsZWFudXAgPSBub29wKSB7XG4gICAgc3Vic2NyaXB0aW9ucy5wdXNoKGNhbGxiYWNrKTtcbiAgICBjb25zdCByZW1vdmVTdWJzY3JpcHRpb24gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHN1YnNjcmlwdGlvbnMuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIG9uQ2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoIWRldGFjaGVkICYmIGdldEN1cnJlbnRTY29wZSgpKSB7XG4gICAgICAgIG9uU2NvcGVEaXNwb3NlKHJlbW92ZVN1YnNjcmlwdGlvbik7XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVTdWJzY3JpcHRpb247XG59XG5mdW5jdGlvbiB0cmlnZ2VyU3Vic2NyaXB0aW9ucyhzdWJzY3JpcHRpb25zLCAuLi5hcmdzKSB7XG4gICAgc3Vic2NyaXB0aW9ucy5zbGljZSgpLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgIH0pO1xufVxuXG5jb25zdCBmYWxsYmFja1J1bldpdGhDb250ZXh0ID0gKGZuKSA9PiBmbigpO1xuLyoqXG4gKiBNYXJrcyBhIGZ1bmN0aW9uIGFzIGFuIGFjdGlvbiBmb3IgYCRvbkFjdGlvbmBcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBBQ1RJT05fTUFSS0VSID0gU3ltYm9sKCk7XG4vKipcbiAqIEFjdGlvbiBuYW1lIHN5bWJvbC4gQWxsb3dzIHRvIGFkZCBhIG5hbWUgdG8gYW4gYWN0aW9uIGFmdGVyIGRlZmluaW5nIGl0XG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQUNUSU9OX05BTUUgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIG1lcmdlUmVhY3RpdmVPYmplY3RzKHRhcmdldCwgcGF0Y2hUb0FwcGx5KSB7XG4gICAgLy8gSGFuZGxlIE1hcCBpbnN0YW5jZXNcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWFwICYmIHBhdGNoVG9BcHBseSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBwYXRjaFRvQXBwbHkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdGFyZ2V0LnNldChrZXksIHZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFNldCAmJiBwYXRjaFRvQXBwbHkgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgLy8gSGFuZGxlIFNldCBpbnN0YW5jZXNcbiAgICAgICAgcGF0Y2hUb0FwcGx5LmZvckVhY2godGFyZ2V0LmFkZCwgdGFyZ2V0KTtcbiAgICB9XG4gICAgLy8gbm8gbmVlZCB0byBnbyB0aHJvdWdoIHN5bWJvbHMgYmVjYXVzZSB0aGV5IGNhbm5vdCBiZSBzZXJpYWxpemVkIGFueXdheVxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoVG9BcHBseSkge1xuICAgICAgICBpZiAoIXBhdGNoVG9BcHBseS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHN1YlBhdGNoID0gcGF0Y2hUb0FwcGx5W2tleV07XG4gICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldFZhbHVlKSAmJlxuICAgICAgICAgICAgaXNQbGFpbk9iamVjdChzdWJQYXRjaCkgJiZcbiAgICAgICAgICAgIHRhcmdldC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgICAgICAgICAhaXNSZWYoc3ViUGF0Y2gpICYmXG4gICAgICAgICAgICAhaXNSZWFjdGl2ZShzdWJQYXRjaCkpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IGhlcmUgSSB3YW50ZWQgdG8gd2FybiBhYm91dCBpbmNvbnNpc3RlbnQgdHlwZXMgYnV0IGl0J3Mgbm90IHBvc3NpYmxlIGJlY2F1c2UgaW4gc2V0dXAgc3RvcmVzIG9uZSBtaWdodFxuICAgICAgICAgICAgLy8gc3RhcnQgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgYXMgYSBjZXJ0YWluIHR5cGUgZS5nLiBhIE1hcCwgYW5kIHRoZW4gZm9yIHNvbWUgcmVhc29uLCBkdXJpbmcgU1NSLCBjaGFuZ2UgdGhhdFxuICAgICAgICAgICAgLy8gdG8gYHVuZGVmaW5lZGAuIFdoZW4gdHJ5aW5nIHRvIGh5ZHJhdGUsIHdlIHdhbnQgdG8gb3ZlcnJpZGUgdGhlIE1hcCB3aXRoIGB1bmRlZmluZWRgLlxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZVJlYWN0aXZlT2JqZWN0cyh0YXJnZXRWYWx1ZSwgc3ViUGF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogc3ViUGF0Y2ggaXMgYSB2YWxpZCB2YWx1ZVxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzdWJQYXRjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuY29uc3Qgc2tpcEh5ZHJhdGVTeW1ib2wgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICA/IFN5bWJvbCgncGluaWE6c2tpcEh5ZHJhdGlvbicpXG4gICAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBTeW1ib2woKTtcbmNvbnN0IHNraXBIeWRyYXRlTWFwID0gLyojX19QVVJFX18qLyBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBUZWxscyBQaW5pYSB0byBza2lwIHRoZSBoeWRyYXRpb24gcHJvY2VzcyBvZiBhIGdpdmVuIG9iamVjdC4gVGhpcyBpcyB1c2VmdWwgaW4gc2V0dXAgc3RvcmVzIChvbmx5KSB3aGVuIHlvdSByZXR1cm4gYVxuICogc3RhdGVmdWwgb2JqZWN0IGluIHRoZSBzdG9yZSBidXQgaXQgaXNuJ3QgcmVhbGx5IHN0YXRlLiBlLmcuIHJldHVybmluZyBhIHJvdXRlciBpbnN0YW5jZSBpbiBhIHNldHVwIHN0b3JlLlxuICpcbiAqIEBwYXJhbSBvYmogLSB0YXJnZXQgb2JqZWN0XG4gKiBAcmV0dXJucyBvYmpcbiAqL1xuZnVuY3Rpb24gc2tpcEh5ZHJhdGUob2JqKSB7XG4gICAgcmV0dXJuIGlzVnVlMlxuICAgICAgICA/IC8vIGluIEB2dWUvY29tcG9zaXRpb24tYXBpLCB0aGUgcmVmcyBhcmUgc2VhbGVkIHNvIGRlZmluZVByb3BlcnR5IGRvZXNuJ3Qgd29yay4uLlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gc2tpcEh5ZHJhdGVNYXAuc2V0KG9iaiwgMSkgJiYgb2JqXG4gICAgICAgIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgc2tpcEh5ZHJhdGVTeW1ib2wsIHt9KTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgdmFsdWUgc2hvdWxkIGJlIGh5ZHJhdGVkXG4gKlxuICogQHBhcmFtIG9iaiAtIHRhcmdldCB2YXJpYWJsZVxuICogQHJldHVybnMgdHJ1ZSBpZiBgb2JqYCBzaG91bGQgYmUgaHlkcmF0ZWRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkSHlkcmF0ZShvYmopIHtcbiAgICByZXR1cm4gaXNWdWUyXG4gICAgICAgID8gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gIXNraXBIeWRyYXRlTWFwLmhhcyhvYmopXG4gICAgICAgIDogIWlzUGxhaW5PYmplY3Qob2JqKSB8fCAhb2JqLmhhc093blByb3BlcnR5KHNraXBIeWRyYXRlU3ltYm9sKTtcbn1cbmNvbnN0IHsgYXNzaWduIH0gPSBPYmplY3Q7XG5mdW5jdGlvbiBpc0NvbXB1dGVkKG8pIHtcbiAgICByZXR1cm4gISEoaXNSZWYobykgJiYgby5lZmZlY3QpO1xufVxuZnVuY3Rpb24gY3JlYXRlT3B0aW9uc1N0b3JlKGlkLCBvcHRpb25zLCBwaW5pYSwgaG90KSB7XG4gICAgY29uc3QgeyBzdGF0ZSwgYWN0aW9ucywgZ2V0dGVycyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSBwaW5pYS5zdGF0ZS52YWx1ZVtpZF07XG4gICAgbGV0IHN0b3JlO1xuICAgIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgICAgICBpZiAoIWluaXRpYWxTdGF0ZSAmJiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAhaG90KSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoaXNWdWUyKSB7XG4gICAgICAgICAgICAgICAgc2V0KHBpbmlhLnN0YXRlLnZhbHVlLCBpZCwgc3RhdGUgPyBzdGF0ZSgpIDoge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGluaWEuc3RhdGUudmFsdWVbaWRdID0gc3RhdGUgPyBzdGF0ZSgpIDoge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXZvaWQgY3JlYXRpbmcgYSBzdGF0ZSBpbiBwaW5pYS5zdGF0ZS52YWx1ZVxuICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGhvdFxuICAgICAgICAgICAgPyAvLyB1c2UgcmVmKCkgdG8gdW53cmFwIHJlZnMgaW5zaWRlIHN0YXRlIFRPRE86IGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgdG9SZWZzKHJlZihzdGF0ZSA/IHN0YXRlKCkgOiB7fSkudmFsdWUpXG4gICAgICAgICAgICA6IHRvUmVmcyhwaW5pYS5zdGF0ZS52YWx1ZVtpZF0pO1xuICAgICAgICByZXR1cm4gYXNzaWduKGxvY2FsU3RhdGUsIGFjdGlvbnMsIE9iamVjdC5rZXlzKGdldHRlcnMgfHwge30pLnJlZHVjZSgoY29tcHV0ZWRHZXR0ZXJzLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5hbWUgaW4gbG9jYWxTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW/CfjY1dOiBBIGdldHRlciBjYW5ub3QgaGF2ZSB0aGUgc2FtZSBuYW1lIGFzIGFub3RoZXIgc3RhdGUgcHJvcGVydHkuIFJlbmFtZSBvbmUgb2YgdGhlbS4gRm91bmQgd2l0aCBcIiR7bmFtZX1cIiBpbiBzdG9yZSBcIiR7aWR9XCIuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wdXRlZEdldHRlcnNbbmFtZV0gPSBtYXJrUmF3KGNvbXB1dGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVQaW5pYShwaW5pYSk7XG4gICAgICAgICAgICAgICAgLy8gaXQgd2FzIGNyZWF0ZWQganVzdCBiZWZvcmVcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHBpbmlhLl9zLmdldChpZCk7XG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgY3Jvc3MgdXNpbmcgc3RvcmVzXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKGlzVnVlMiAmJiAhc3RvcmUuX3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGdldHRlcnMhW25hbWVdLmNhbGwoY29udGV4dCwgY29udGV4dClcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhdm9pZCByZWFkaW5nIHRoZSBnZXR0ZXIgd2hpbGUgYXNzaWduaW5nIHdpdGggYSBnbG9iYWwgdmFyaWFibGVcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyc1tuYW1lXS5jYWxsKHN0b3JlLCBzdG9yZSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZWRHZXR0ZXJzO1xuICAgICAgICB9LCB7fSkpO1xuICAgIH1cbiAgICBzdG9yZSA9IGNyZWF0ZVNldHVwU3RvcmUoaWQsIHNldHVwLCBvcHRpb25zLCBwaW5pYSwgaG90LCB0cnVlKTtcbiAgICByZXR1cm4gc3RvcmU7XG59XG5mdW5jdGlvbiBjcmVhdGVTZXR1cFN0b3JlKCRpZCwgc2V0dXAsIG9wdGlvbnMgPSB7fSwgcGluaWEsIGhvdCwgaXNPcHRpb25zU3RvcmUpIHtcbiAgICBsZXQgc2NvcGU7XG4gICAgY29uc3Qgb3B0aW9uc0ZvclBsdWdpbiA9IGFzc2lnbih7IGFjdGlvbnM6IHt9IH0sIG9wdGlvbnMpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXBpbmlhLl9lLmFjdGl2ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpbmlhIGRlc3Ryb3llZCcpO1xuICAgIH1cbiAgICAvLyB3YXRjaGVyIG9wdGlvbnMgZm9yICRzdWJzY3JpYmVcbiAgICBjb25zdCAkc3Vic2NyaWJlT3B0aW9ucyA9IHsgZGVlcDogdHJ1ZSB9O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNWdWUyKSB7XG4gICAgICAgICRzdWJzY3JpYmVPcHRpb25zLm9uVHJpZ2dlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChpc0xpc3RlbmluZykge1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyRXZlbnRzID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgLy8gYXZvaWQgdHJpZ2dlcmluZyB0aGlzIHdoaWxlIHRoZSBzdG9yZSBpcyBiZWluZyBidWlsdCBhbmQgdGhlIHN0YXRlIGlzIGJlaW5nIHNldCBpbiBwaW5pYVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNMaXN0ZW5pbmcgPT0gZmFsc2UgJiYgIXN0b3JlLl9ob3RVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIC8vIGxldCBwYXRjaCBzZW5kIGFsbCB0aGUgZXZlbnRzIHRvZ2V0aGVyIGxhdGVyXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZWJ1Z2dlckV2ZW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdnZXJFdmVudHMucHVzaChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfwn42NIGRlYnVnZ2VyRXZlbnRzIHNob3VsZCBiZSBhbiBhcnJheS4gVGhpcyBpcyBtb3N0IGxpa2VseSBhbiBpbnRlcm5hbCBQaW5pYSBidWcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBpbnRlcm5hbCBzdGF0ZVxuICAgIGxldCBpc0xpc3RlbmluZzsgLy8gc2V0IHRvIHRydWUgYXQgdGhlIGVuZFxuICAgIGxldCBpc1N5bmNMaXN0ZW5pbmc7IC8vIHNldCB0byB0cnVlIGF0IHRoZSBlbmRcbiAgICBsZXQgc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgIGxldCBhY3Rpb25TdWJzY3JpcHRpb25zID0gW107XG4gICAgbGV0IGRlYnVnZ2VyRXZlbnRzO1xuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHBpbmlhLnN0YXRlLnZhbHVlWyRpZF07XG4gICAgLy8gYXZvaWQgc2V0dGluZyB0aGUgc3RhdGUgZm9yIG9wdGlvbiBzdG9yZXMgaWYgaXQgaXMgc2V0XG4gICAgLy8gYnkgdGhlIHNldHVwXG4gICAgaWYgKCFpc09wdGlvbnNTdG9yZSAmJiAhaW5pdGlhbFN0YXRlICYmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICFob3QpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNWdWUyKSB7XG4gICAgICAgICAgICBzZXQocGluaWEuc3RhdGUudmFsdWUsICRpZCwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGluaWEuc3RhdGUudmFsdWVbJGlkXSA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhvdFN0YXRlID0gcmVmKHt9KTtcbiAgICAvLyBhdm9pZCB0cmlnZ2VyaW5nIHRvbyBtYW55IGxpc3RlbmVyc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9waW5pYS9pc3N1ZXMvMTEyOVxuICAgIGxldCBhY3RpdmVMaXN0ZW5lcjtcbiAgICBmdW5jdGlvbiAkcGF0Y2gocGFydGlhbFN0YXRlT3JNdXRhdG9yKSB7XG4gICAgICAgIGxldCBzdWJzY3JpcHRpb25NdXRhdGlvbjtcbiAgICAgICAgaXNMaXN0ZW5pbmcgPSBpc1N5bmNMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gcmVzZXQgdGhlIGRlYnVnZ2VyIGV2ZW50cyBzaW5jZSBwYXRjaGVzIGFyZSBzeW5jXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIGRlYnVnZ2VyRXZlbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJ0aWFsU3RhdGVPck11dGF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBhcnRpYWxTdGF0ZU9yTXV0YXRvcihwaW5pYS5zdGF0ZS52YWx1ZVskaWRdKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbk11dGF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IE11dGF0aW9uVHlwZS5wYXRjaEZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHN0b3JlSWQ6ICRpZCxcbiAgICAgICAgICAgICAgICBldmVudHM6IGRlYnVnZ2VyRXZlbnRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lcmdlUmVhY3RpdmVPYmplY3RzKHBpbmlhLnN0YXRlLnZhbHVlWyRpZF0sIHBhcnRpYWxTdGF0ZU9yTXV0YXRvcik7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25NdXRhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNdXRhdGlvblR5cGUucGF0Y2hPYmplY3QsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogcGFydGlhbFN0YXRlT3JNdXRhdG9yLFxuICAgICAgICAgICAgICAgIHN0b3JlSWQ6ICRpZCxcbiAgICAgICAgICAgICAgICBldmVudHM6IGRlYnVnZ2VyRXZlbnRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBteUxpc3RlbmVySWQgPSAoYWN0aXZlTGlzdGVuZXIgPSBTeW1ib2woKSk7XG4gICAgICAgIG5leHRUaWNrKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlTGlzdGVuZXIgPT09IG15TGlzdGVuZXJJZCkge1xuICAgICAgICAgICAgICAgIGlzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3luY0xpc3RlbmluZyA9IHRydWU7XG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgcGF1c2VkIHRoZSB3YXRjaGVyLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IGNhbGwgdGhlIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgdHJpZ2dlclN1YnNjcmlwdGlvbnMoc3Vic2NyaXB0aW9ucywgc3Vic2NyaXB0aW9uTXV0YXRpb24sIHBpbmlhLnN0YXRlLnZhbHVlWyRpZF0pO1xuICAgIH1cbiAgICBjb25zdCAkcmVzZXQgPSBpc09wdGlvbnNTdG9yZVxuICAgICAgICA/IGZ1bmN0aW9uICRyZXNldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlID8gc3RhdGUoKSA6IHt9O1xuICAgICAgICAgICAgLy8gd2UgdXNlIGEgcGF0Y2ggdG8gZ3JvdXAgYWxsIGNoYW5nZXMgaW50byBvbmUgc2luZ2xlIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgdGhpcy4kcGF0Y2goKCRzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEZJWE1FOiBzaG91bGRuJ3QgZXJyb3I/XG4gICAgICAgICAgICAgICAgYXNzaWduKCRzdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgICAgICAgICAgPyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihg8J+NjTogU3RvcmUgXCIkeyRpZH1cIiBpcyBidWlsdCB1c2luZyB0aGUgc2V0dXAgc3ludGF4IGFuZCBkb2VzIG5vdCBpbXBsZW1lbnQgJHJlc2V0KCkuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogbm9vcDtcbiAgICBmdW5jdGlvbiAkZGlzcG9zZSgpIHtcbiAgICAgICAgc2NvcGUuc3RvcCgpO1xuICAgICAgICBzdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIGFjdGlvblN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgcGluaWEuX3MuZGVsZXRlKCRpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciB0aGF0IHdyYXBzIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSB0cmFja2VkIHdpdGggJG9uQWN0aW9uXG4gICAgICogQHBhcmFtIGZuIC0gYWN0aW9uIHRvIHdyYXBcbiAgICAgKiBAcGFyYW0gbmFtZSAtIG5hbWUgb2YgdGhlIGFjdGlvblxuICAgICAqL1xuICAgIGNvbnN0IGFjdGlvbiA9IChmbiwgbmFtZSA9ICcnKSA9PiB7XG4gICAgICAgIGlmIChBQ1RJT05fTUFSS0VSIGluIGZuKSB7XG4gICAgICAgICAgICBmbltBQ1RJT05fTkFNRV0gPSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyYXBwZWRBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRBY3RpdmVQaW5pYShwaW5pYSk7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgICAgICAgICAgY29uc3QgYWZ0ZXJDYWxsYmFja0xpc3QgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3JDYWxsYmFja0xpc3QgPSBbXTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFmdGVyKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXJDYWxsYmFja0xpc3QucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBvbkVycm9yKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvckNhbGxiYWNrTGlzdC5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHRyaWdnZXJTdWJzY3JpcHRpb25zKGFjdGlvblN1YnNjcmlwdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgIG5hbWU6IHdyYXBwZWRBY3Rpb25bQUNUSU9OX05BTUVdLFxuICAgICAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgICAgIGFmdGVyLFxuICAgICAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCByZXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldCA9IGZuLmFwcGx5KHRoaXMgJiYgdGhpcy4kaWQgPT09ICRpZCA/IHRoaXMgOiBzdG9yZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHN5bmMgZXJyb3JzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyU3Vic2NyaXB0aW9ucyhvbkVycm9yQ2FsbGJhY2tMaXN0LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXRcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJTdWJzY3JpcHRpb25zKGFmdGVyQ2FsbGJhY2tMaXN0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJTdWJzY3JpcHRpb25zKG9uRXJyb3JDYWxsYmFja0xpc3QsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyaWdnZXIgYWZ0ZXIgY2FsbGJhY2tzXG4gICAgICAgICAgICB0cmlnZ2VyU3Vic2NyaXB0aW9ucyhhZnRlckNhbGxiYWNrTGlzdCwgcmV0KTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHdyYXBwZWRBY3Rpb25bQUNUSU9OX01BUktFUl0gPSB0cnVlO1xuICAgICAgICB3cmFwcGVkQWN0aW9uW0FDVElPTl9OQU1FXSA9IG5hbWU7IC8vIHdpbGwgYmUgc2V0IGxhdGVyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHdlIGFyZSBpbnRlbnRpb25hbGx5IGxpbWl0aW5nIHRoZSByZXR1cm5lZCB0eXBlIHRvIGp1c3QgRm5cbiAgICAgICAgLy8gYmVjYXVzZSBhbGwgdGhlIGFkZGVkIHByb3BlcnRpZXMgYXJlIGludGVybmFscyB0aGF0IGFyZSBleHBvc2VkIHRocm91Z2ggYCRvbkFjdGlvbigpYCBvbmx5XG4gICAgICAgIHJldHVybiB3cmFwcGVkQWN0aW9uO1xuICAgIH07XG4gICAgY29uc3QgX2htclBheWxvYWQgPSAvKiNfX1BVUkVfXyovIG1hcmtSYXcoe1xuICAgICAgICBhY3Rpb25zOiB7fSxcbiAgICAgICAgZ2V0dGVyczoge30sXG4gICAgICAgIHN0YXRlOiBbXSxcbiAgICAgICAgaG90U3RhdGUsXG4gICAgfSk7XG4gICAgY29uc3QgcGFydGlhbFN0b3JlID0ge1xuICAgICAgICBfcDogcGluaWEsXG4gICAgICAgIC8vIF9zOiBzY29wZSxcbiAgICAgICAgJGlkLFxuICAgICAgICAkb25BY3Rpb246IGFkZFN1YnNjcmlwdGlvbi5iaW5kKG51bGwsIGFjdGlvblN1YnNjcmlwdGlvbnMpLFxuICAgICAgICAkcGF0Y2gsXG4gICAgICAgICRyZXNldCxcbiAgICAgICAgJHN1YnNjcmliZShjYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVTdWJzY3JpcHRpb24gPSBhZGRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9ucywgY2FsbGJhY2ssIG9wdGlvbnMuZGV0YWNoZWQsICgpID0+IHN0b3BXYXRjaGVyKCkpO1xuICAgICAgICAgICAgY29uc3Qgc3RvcFdhdGNoZXIgPSBzY29wZS5ydW4oKCkgPT4gd2F0Y2goKCkgPT4gcGluaWEuc3RhdGUudmFsdWVbJGlkXSwgKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmx1c2ggPT09ICdzeW5jJyA/IGlzU3luY0xpc3RlbmluZyA6IGlzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlSWQ6ICRpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE11dGF0aW9uVHlwZS5kaXJlY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHM6IGRlYnVnZ2VyRXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICB9LCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgYXNzaWduKHt9LCAkc3Vic2NyaWJlT3B0aW9ucywgb3B0aW9ucykpKTtcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVTdWJzY3JpcHRpb247XG4gICAgICAgIH0sXG4gICAgICAgICRkaXNwb3NlLFxuICAgIH07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzVnVlMikge1xuICAgICAgICAvLyBzdGFydCBhcyBub24gcmVhZHlcbiAgICAgICAgcGFydGlhbFN0b3JlLl9yID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlID0gcmVhY3RpdmUoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICgoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgX19WVUVfUFJPRF9ERVZUT09MU19fKSkgJiYgIShwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSkgJiYgSVNfQ0xJRU5UKVxuICAgICAgICA/IGFzc2lnbih7XG4gICAgICAgICAgICBfaG1yUGF5bG9hZCxcbiAgICAgICAgICAgIF9jdXN0b21Qcm9wZXJ0aWVzOiBtYXJrUmF3KG5ldyBTZXQoKSksIC8vIGRldnRvb2xzIGN1c3RvbSBwcm9wZXJ0aWVzXG4gICAgICAgIH0sIHBhcnRpYWxTdG9yZVxuICAgICAgICAvLyBtdXN0IGJlIGFkZGVkIGxhdGVyXG4gICAgICAgIC8vIHNldHVwU3RvcmVcbiAgICAgICAgKVxuICAgICAgICA6IHBhcnRpYWxTdG9yZSk7XG4gICAgLy8gc3RvcmUgdGhlIHBhcnRpYWwgc3RvcmUgbm93IHNvIHRoZSBzZXR1cCBvZiBzdG9yZXMgY2FuIGluc3RhbnRpYXRlIGVhY2ggb3RoZXIgYmVmb3JlIHRoZXkgYXJlIGZpbmlzaGVkIHdpdGhvdXRcbiAgICAvLyBjcmVhdGluZyBpbmZpbml0ZSBsb29wcy5cbiAgICBwaW5pYS5fcy5zZXQoJGlkLCBzdG9yZSk7XG4gICAgY29uc3QgcnVuV2l0aENvbnRleHQgPSAocGluaWEuX2EgJiYgcGluaWEuX2EucnVuV2l0aENvbnRleHQpIHx8IGZhbGxiYWNrUnVuV2l0aENvbnRleHQ7XG4gICAgLy8gVE9ETzogaWRlYSBjcmVhdGUgc2tpcFNlcmlhbGl6ZSB0aGF0IG1hcmtzIHByb3BlcnRpZXMgYXMgbm9uIHNlcmlhbGl6YWJsZSBhbmQgdGhleSBhcmUgc2tpcHBlZFxuICAgIGNvbnN0IHNldHVwU3RvcmUgPSBydW5XaXRoQ29udGV4dCgoKSA9PiBwaW5pYS5fZS5ydW4oKCkgPT4gKHNjb3BlID0gZWZmZWN0U2NvcGUoKSkucnVuKCgpID0+IHNldHVwKHsgYWN0aW9uIH0pKSkpO1xuICAgIC8vIG92ZXJ3cml0ZSBleGlzdGluZyBhY3Rpb25zIHRvIHN1cHBvcnQgJG9uQWN0aW9uXG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2V0dXBTdG9yZSkge1xuICAgICAgICBjb25zdCBwcm9wID0gc2V0dXBTdG9yZVtrZXldO1xuICAgICAgICBpZiAoKGlzUmVmKHByb3ApICYmICFpc0NvbXB1dGVkKHByb3ApKSB8fCBpc1JlYWN0aXZlKHByb3ApKSB7XG4gICAgICAgICAgICAvLyBtYXJrIGl0IGFzIGEgcGllY2Ugb2Ygc3RhdGUgdG8gYmUgc2VyaWFsaXplZFxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBob3QpIHtcbiAgICAgICAgICAgICAgICBzZXQoaG90U3RhdGUudmFsdWUsIGtleSwgdG9SZWYoc2V0dXBTdG9yZSwga2V5KSk7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlT3B0aW9uU3RvcmUgZGlyZWN0bHkgc2V0cyB0aGUgc3RhdGUgaW4gcGluaWEuc3RhdGUudmFsdWUgc28gd2VcbiAgICAgICAgICAgICAgICAvLyBjYW4ganVzdCBza2lwIHRoYXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc09wdGlvbnNTdG9yZSkge1xuICAgICAgICAgICAgICAgIC8vIGluIHNldHVwIHN0b3JlcyB3ZSBtdXN0IGh5ZHJhdGUgdGhlIHN0YXRlIGFuZCBzeW5jIHBpbmlhIHN0YXRlIHRyZWUgd2l0aCB0aGUgcmVmcyB0aGUgdXNlciBqdXN0IGNyZWF0ZWRcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFN0YXRlICYmIHNob3VsZEh5ZHJhdGUocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVmKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLnZhbHVlID0gaW5pdGlhbFN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9iYWJseSBhIHJlYWN0aXZlIG9iamVjdCwgbGV0cyByZWN1cnNpdmVseSBhc3NpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByb3AgaXMgdW5rbm93blxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VSZWFjdGl2ZU9iamVjdHMocHJvcCwgaW5pdGlhbFN0YXRlW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRyYW5zZmVyIHRoZSByZWYgdG8gdGhlIHBpbmlhIHN0YXRlIHRvIGtlZXAgZXZlcnl0aGluZyBpbiBzeW5jXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKGlzVnVlMikge1xuICAgICAgICAgICAgICAgICAgICBzZXQocGluaWEuc3RhdGUudmFsdWVbJGlkXSwga2V5LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBpbmlhLnN0YXRlLnZhbHVlWyRpZF1ba2V5XSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBfaG1yUGF5bG9hZC5zdGF0ZS5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhY3Rpb25cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uVmFsdWUgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaG90ID8gcHJvcCA6IGFjdGlvbihwcm9wLCBrZXkpO1xuICAgICAgICAgICAgLy8gdGhpcyBhIGhvdCBtb2R1bGUgcmVwbGFjZW1lbnQgc3RvcmUgYmVjYXVzZSB0aGUgaG90VXBkYXRlIG1ldGhvZCBuZWVkc1xuICAgICAgICAgICAgLy8gdG8gZG8gaXQgd2l0aCB0aGUgcmlnaHQgY29udGV4dFxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoaXNWdWUyKSB7XG4gICAgICAgICAgICAgICAgc2V0KHNldHVwU3RvcmUsIGtleSwgYWN0aW9uVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHNldHVwU3RvcmVba2V5XSA9IGFjdGlvblZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBfaG1yUGF5bG9hZC5hY3Rpb25zW2tleV0gPSBwcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGlzdCBhY3Rpb25zIHNvIHRoZXkgY2FuIGJlIHVzZWQgaW4gcGx1Z2luc1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgb3B0aW9uc0ZvclBsdWdpbi5hY3Rpb25zW2tleV0gPSBwcm9wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgLy8gYWRkIGdldHRlcnMgZm9yIGRldnRvb2xzXG4gICAgICAgICAgICBpZiAoaXNDb21wdXRlZChwcm9wKSkge1xuICAgICAgICAgICAgICAgIF9obXJQYXlsb2FkLmdldHRlcnNba2V5XSA9IGlzT3B0aW9uc1N0b3JlXG4gICAgICAgICAgICAgICAgICAgID8gLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5nZXR0ZXJzW2tleV1cbiAgICAgICAgICAgICAgICAgICAgOiBwcm9wO1xuICAgICAgICAgICAgICAgIGlmIChJU19DTElFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2V0dGVycyA9IHNldHVwU3RvcmUuX2dldHRlcnMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHNhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXR1cFN0b3JlLl9nZXR0ZXJzID0gbWFya1JhdyhbXSkpO1xuICAgICAgICAgICAgICAgICAgICBnZXR0ZXJzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIHRoZSBzdGF0ZSwgZ2V0dGVycywgYW5kIGFjdGlvbiBwcm9wZXJ0aWVzXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzVnVlMikge1xuICAgICAgICBPYmplY3Qua2V5cyhzZXR1cFN0b3JlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIHNldChzdG9yZSwga2V5LCBzZXR1cFN0b3JlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2lnbihzdG9yZSwgc2V0dXBTdG9yZSk7XG4gICAgICAgIC8vIGFsbG93cyByZXRyaWV2aW5nIHJlYWN0aXZlIG9iamVjdHMgd2l0aCBgc3RvcmVUb1JlZnMoKWAuIE11c3QgYmUgY2FsbGVkIGFmdGVyIGFzc2lnbmluZyB0byB0aGUgcmVhY3RpdmUgb2JqZWN0LlxuICAgICAgICAvLyBNYWtlIGBzdG9yZVRvUmVmcygpYCB3b3JrIHdpdGggYHJlYWN0aXZlKClgICM3OTlcbiAgICAgICAgYXNzaWduKHRvUmF3KHN0b3JlKSwgc2V0dXBTdG9yZSk7XG4gICAgfVxuICAgIC8vIHVzZSB0aGlzIGluc3RlYWQgb2YgYSBjb21wdXRlZCB3aXRoIHNldHRlciB0byBiZSBhYmxlIHRvIGNyZWF0ZSBpdCBhbnl3aGVyZVxuICAgIC8vIHdpdGhvdXQgbGlua2luZyB0aGUgY29tcHV0ZWQgbGlmZXNwYW4gdG8gd2hlcmV2ZXIgdGhlIHN0b3JlIGlzIGZpcnN0XG4gICAgLy8gY3JlYXRlZC5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RvcmUsICckc3RhdGUnLCB7XG4gICAgICAgIGdldDogKCkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBob3QgPyBob3RTdGF0ZS52YWx1ZSA6IHBpbmlhLnN0YXRlLnZhbHVlWyRpZF0pLFxuICAgICAgICBzZXQ6IChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGhvdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNldCBob3RTdGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHBhdGNoKCgkc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBGSVhNRTogc2hvdWxkbid0IGVycm9yP1xuICAgICAgICAgICAgICAgIGFzc2lnbigkc3RhdGUsIHN0YXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIC8vIGFkZCB0aGUgaG90VXBkYXRlIGJlZm9yZSBwbHVnaW5zIHRvIGFsbG93IHRoZW0gdG8gb3ZlcnJpZGUgaXRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgc3RvcmUuX2hvdFVwZGF0ZSA9IG1hcmtSYXcoKG5ld1N0b3JlKSA9PiB7XG4gICAgICAgICAgICBzdG9yZS5faG90VXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgbmV3U3RvcmUuX2htclBheWxvYWQuc3RhdGUuZm9yRWFjaCgoc3RhdGVLZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVLZXkgaW4gc3RvcmUuJHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlVGFyZ2V0ID0gbmV3U3RvcmUuJHN0YXRlW3N0YXRlS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkU3RhdGVTb3VyY2UgPSBzdG9yZS4kc3RhdGVbc3RhdGVLZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld1N0YXRlVGFyZ2V0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQbGFpbk9iamVjdChuZXdTdGF0ZVRhcmdldCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGxhaW5PYmplY3Qob2xkU3RhdGVTb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaE9iamVjdChuZXdTdGF0ZVRhcmdldCwgb2xkU3RhdGVTb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmZXIgdGhlIHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RvcmUuJHN0YXRlW3N0YXRlS2V5XSA9IG9sZFN0YXRlU291cmNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHBhdGNoIGRpcmVjdCBhY2Nlc3MgcHJvcGVydGllcyB0byBhbGxvdyBzdG9yZS5zdGF0ZVByb3BlcnR5IHRvIHdvcmsgYXNcbiAgICAgICAgICAgICAgICAvLyBzdG9yZS4kc3RhdGUuc3RhdGVQcm9wZXJ0eVxuICAgICAgICAgICAgICAgIHNldChzdG9yZSwgc3RhdGVLZXksIHRvUmVmKG5ld1N0b3JlLiRzdGF0ZSwgc3RhdGVLZXkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGRlbGV0ZWQgc3RhdGUgcHJvcGVydGllc1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3RvcmUuJHN0YXRlKS5mb3JFYWNoKChzdGF0ZUtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghKHN0YXRlS2V5IGluIG5ld1N0b3JlLiRzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsKHN0b3JlLCBzdGF0ZUtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBhdm9pZCBkZXZ0b29scyBsb2dnaW5nIHRoaXMgYXMgYSBtdXRhdGlvblxuICAgICAgICAgICAgaXNMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlzU3luY0xpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcGluaWEuc3RhdGUudmFsdWVbJGlkXSA9IHRvUmVmKG5ld1N0b3JlLl9obXJQYXlsb2FkLCAnaG90U3RhdGUnKTtcbiAgICAgICAgICAgIGlzU3luY0xpc3RlbmluZyA9IHRydWU7XG4gICAgICAgICAgICBuZXh0VGljaygpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhY3Rpb25OYW1lIGluIG5ld1N0b3JlLl9obXJQYXlsb2FkLmFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb25GbiA9IG5ld1N0b3JlW2FjdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgIHNldChzdG9yZSwgYWN0aW9uTmFtZSwgYWN0aW9uKGFjdGlvbkZuLCBhY3Rpb25OYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBkb2VzIHRoaXMgd29yayBpbiBib3RoIHNldHVwIGFuZCBvcHRpb24gc3RvcmU/XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGdldHRlck5hbWUgaW4gbmV3U3RvcmUuX2htclBheWxvYWQuZ2V0dGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdldHRlciA9IG5ld1N0b3JlLl9obXJQYXlsb2FkLmdldHRlcnNbZ2V0dGVyTmFtZV07XG4gICAgICAgICAgICAgICAgY29uc3QgZ2V0dGVyVmFsdWUgPSBpc09wdGlvbnNTdG9yZVxuICAgICAgICAgICAgICAgICAgICA/IC8vIHNwZWNpYWwgaGFuZGxpbmcgb2Ygb3B0aW9ucyBhcGlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmVQaW5pYShwaW5pYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldHRlci5jYWxsKHN0b3JlLCBzdG9yZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICA6IGdldHRlcjtcbiAgICAgICAgICAgICAgICBzZXQoc3RvcmUsIGdldHRlck5hbWUsIGdldHRlclZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbW92ZSBkZWxldGVkIGdldHRlcnNcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0b3JlLl9obXJQYXlsb2FkLmdldHRlcnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBuZXdTdG9yZS5faG1yUGF5bG9hZC5nZXR0ZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWwoc3RvcmUsIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgb2xkIGFjdGlvbnNcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0b3JlLl9obXJQYXlsb2FkLmFjdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBuZXdTdG9yZS5faG1yUGF5bG9hZC5hY3Rpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWwoc3RvcmUsIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHZhbHVlcyB1c2VkIGluIGRldnRvb2xzIGFuZCB0byBhbGxvdyBkZWxldGluZyBuZXcgcHJvcGVydGllcyBsYXRlciBvblxuICAgICAgICAgICAgc3RvcmUuX2htclBheWxvYWQgPSBuZXdTdG9yZS5faG1yUGF5bG9hZDtcbiAgICAgICAgICAgIHN0b3JlLl9nZXR0ZXJzID0gbmV3U3RvcmUuX2dldHRlcnM7XG4gICAgICAgICAgICBzdG9yZS5faG90VXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICgoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgX19WVUVfUFJPRF9ERVZUT09MU19fKSkgJiYgIShwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSkgJiYgSVNfQ0xJRU5UKSB7XG4gICAgICAgIGNvbnN0IG5vbkVudW1lcmFibGUgPSB7XG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIC8vIGF2b2lkIHdhcm5pbmcgb24gZGV2dG9vbHMgdHJ5aW5nIHRvIGRpc3BsYXkgdGhpcyBwcm9wZXJ0eVxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIFsnX3AnLCAnX2htclBheWxvYWQnLCAnX2dldHRlcnMnLCAnX2N1c3RvbVByb3BlcnRpZXMnXS5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RvcmUsIHAsIGFzc2lnbih7IHZhbHVlOiBzdG9yZVtwXSB9LCBub25FbnVtZXJhYmxlKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNWdWUyKSB7XG4gICAgICAgIC8vIG1hcmsgdGhlIHN0b3JlIGFzIHJlYWR5IGJlZm9yZSBwbHVnaW5zXG4gICAgICAgIHN0b3JlLl9yID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gYXBwbHkgYWxsIHBsdWdpbnNcbiAgICBwaW5pYS5fcC5mb3JFYWNoKChleHRlbmRlcikgPT4ge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgKHR5cGVvZiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18gIT09ICd1bmRlZmluZWQnICYmIF9fVlVFX1BST0RfREVWVE9PTFNfXykpICYmICEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0JykpICYmIElTX0NMSUVOVCkge1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IHNjb3BlLnJ1bigoKSA9PiBleHRlbmRlcih7XG4gICAgICAgICAgICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgICAgICAgICAgIGFwcDogcGluaWEuX2EsXG4gICAgICAgICAgICAgICAgcGluaWEsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc0ZvclBsdWdpbixcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMgfHwge30pLmZvckVhY2goKGtleSkgPT4gc3RvcmUuX2N1c3RvbVByb3BlcnRpZXMuYWRkKGtleSkpO1xuICAgICAgICAgICAgYXNzaWduKHN0b3JlLCBleHRlbnNpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2lnbihzdG9yZSwgc2NvcGUucnVuKCgpID0+IGV4dGVuZGVyKHtcbiAgICAgICAgICAgICAgICBzdG9yZTogc3RvcmUsXG4gICAgICAgICAgICAgICAgYXBwOiBwaW5pYS5fYSxcbiAgICAgICAgICAgICAgICBwaW5pYSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zRm9yUGx1Z2luLFxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgc3RvcmUuJHN0YXRlICYmXG4gICAgICAgIHR5cGVvZiBzdG9yZS4kc3RhdGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR5cGVvZiBzdG9yZS4kc3RhdGUuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgIXN0b3JlLiRzdGF0ZS5jb25zdHJ1Y3Rvci50b1N0cmluZygpLmluY2x1ZGVzKCdbbmF0aXZlIGNvZGVdJykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBb8J+NjV06IFRoZSBcInN0YXRlXCIgbXVzdCBiZSBhIHBsYWluIG9iamVjdC4gSXQgY2Fubm90IGJlXFxuYCArXG4gICAgICAgICAgICBgXFx0c3RhdGU6ICgpID0+IG5ldyBNeUNsYXNzKClcXG5gICtcbiAgICAgICAgICAgIGBGb3VuZCBpbiBzdG9yZSBcIiR7c3RvcmUuJGlkfVwiLmApO1xuICAgIH1cbiAgICAvLyBvbmx5IGFwcGx5IGh5ZHJhdGUgdG8gb3B0aW9uIHN0b3JlcyB3aXRoIGFuIGluaXRpYWwgc3RhdGUgaW4gcGluaWFcbiAgICBpZiAoaW5pdGlhbFN0YXRlICYmXG4gICAgICAgIGlzT3B0aW9uc1N0b3JlICYmXG4gICAgICAgIG9wdGlvbnMuaHlkcmF0ZSkge1xuICAgICAgICBvcHRpb25zLmh5ZHJhdGUoc3RvcmUuJHN0YXRlLCBpbml0aWFsU3RhdGUpO1xuICAgIH1cbiAgICBpc0xpc3RlbmluZyA9IHRydWU7XG4gICAgaXNTeW5jTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RvcmU7XG59XG4vLyBpbXByb3ZlcyB0cmVlIHNoYWtpbmdcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gZGVmaW5lU3RvcmUoXG4vLyBUT0RPOiBhZGQgcHJvcGVyIHR5cGVzIGZyb20gYWJvdmVcbmlkT3JPcHRpb25zLCBzZXR1cCwgc2V0dXBPcHRpb25zKSB7XG4gICAgbGV0IGlkO1xuICAgIGxldCBvcHRpb25zO1xuICAgIGNvbnN0IGlzU2V0dXBTdG9yZSA9IHR5cGVvZiBzZXR1cCA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAodHlwZW9mIGlkT3JPcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZCA9IGlkT3JPcHRpb25zO1xuICAgICAgICAvLyB0aGUgb3B0aW9uIHN0b3JlIHNldHVwIHdpbGwgY29udGFpbiB0aGUgYWN0dWFsIG9wdGlvbnMgaW4gdGhpcyBjYXNlXG4gICAgICAgIG9wdGlvbnMgPSBpc1NldHVwU3RvcmUgPyBzZXR1cE9wdGlvbnMgOiBzZXR1cDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSBpZE9yT3B0aW9ucztcbiAgICAgICAgaWQgPSBpZE9yT3B0aW9ucy5pZDtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFvwn42NXTogXCJkZWZpbmVTdG9yZSgpXCIgbXVzdCBiZSBwYXNzZWQgYSBzdG9yZSBpZCBhcyBpdHMgZmlyc3QgYXJndW1lbnQuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlU3RvcmUocGluaWEsIGhvdCkge1xuICAgICAgICBjb25zdCBoYXNDb250ZXh0ID0gaGFzSW5qZWN0aW9uQ29udGV4dCgpO1xuICAgICAgICBwaW5pYSA9XG4gICAgICAgICAgICAvLyBpbiB0ZXN0IG1vZGUsIGlnbm9yZSB0aGUgYXJndW1lbnQgcHJvdmlkZWQgYXMgd2UgY2FuIGFsd2F5cyByZXRyaWV2ZSBhXG4gICAgICAgICAgICAvLyBwaW5pYSBpbnN0YW5jZSB3aXRoIGdldEFjdGl2ZVBpbmlhKClcbiAgICAgICAgICAgICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0JykgJiYgYWN0aXZlUGluaWEgJiYgYWN0aXZlUGluaWEuX3Rlc3RpbmcgPyBudWxsIDogcGluaWEpIHx8XG4gICAgICAgICAgICAgICAgKGhhc0NvbnRleHQgPyBpbmplY3QocGluaWFTeW1ib2wsIG51bGwpIDogbnVsbCk7XG4gICAgICAgIGlmIChwaW5pYSlcbiAgICAgICAgICAgIHNldEFjdGl2ZVBpbmlhKHBpbmlhKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhYWN0aXZlUGluaWEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW/CfjY1dOiBcImdldEFjdGl2ZVBpbmlhKClcIiB3YXMgY2FsbGVkIGJ1dCB0aGVyZSB3YXMgbm8gYWN0aXZlIFBpbmlhLiBBcmUgeW91IHRyeWluZyB0byB1c2UgYSBzdG9yZSBiZWZvcmUgY2FsbGluZyBcImFwcC51c2UocGluaWEpXCI/XFxuYCArXG4gICAgICAgICAgICAgICAgYFNlZSBodHRwczovL3BpbmlhLnZ1ZWpzLm9yZy9jb3JlLWNvbmNlcHRzL291dHNpZGUtY29tcG9uZW50LXVzYWdlLmh0bWwgZm9yIGhlbHAuXFxuYCArXG4gICAgICAgICAgICAgICAgYFRoaXMgd2lsbCBmYWlsIGluIHByb2R1Y3Rpb24uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcGluaWEgPSBhY3RpdmVQaW5pYTtcbiAgICAgICAgaWYgKCFwaW5pYS5fcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGluZyB0aGUgc3RvcmUgcmVnaXN0ZXJzIGl0IGluIGBwaW5pYS5fc2BcbiAgICAgICAgICAgIGlmIChpc1NldHVwU3RvcmUpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVTZXR1cFN0b3JlKGlkLCBzZXR1cCwgb3B0aW9ucywgcGluaWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlT3B0aW9uc1N0b3JlKGlkLCBvcHRpb25zLCBwaW5pYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG5vdCB0aGUgcmlnaHQgaW5mZXJyZWQgdHlwZVxuICAgICAgICAgICAgICAgIHVzZVN0b3JlLl9waW5pYSA9IHBpbmlhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0b3JlID0gcGluaWEuX3MuZ2V0KGlkKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBob3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvdElkID0gJ19faG90OicgKyBpZDtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0b3JlID0gaXNTZXR1cFN0b3JlXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVTZXR1cFN0b3JlKGhvdElkLCBzZXR1cCwgb3B0aW9ucywgcGluaWEsIHRydWUpXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVPcHRpb25zU3RvcmUoaG90SWQsIGFzc2lnbih7fSwgb3B0aW9ucyksIHBpbmlhLCB0cnVlKTtcbiAgICAgICAgICAgIGhvdC5faG90VXBkYXRlKG5ld1N0b3JlKTtcbiAgICAgICAgICAgIC8vIGNsZWFudXAgdGhlIHN0YXRlIHByb3BlcnRpZXMgYW5kIHRoZSBzdG9yZSBmcm9tIHRoZSBjYWNoZVxuICAgICAgICAgICAgZGVsZXRlIHBpbmlhLnN0YXRlLnZhbHVlW2hvdElkXTtcbiAgICAgICAgICAgIHBpbmlhLl9zLmRlbGV0ZShob3RJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBJU19DTElFTlQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgLy8gc2F2ZSBzdG9yZXMgaW4gaW5zdGFuY2VzIHRvIGFjY2VzcyB0aGVtIGRldnRvb2xzXG4gICAgICAgICAgICBpZiAoY3VycmVudEluc3RhbmNlICYmXG4gICAgICAgICAgICAgICAgY3VycmVudEluc3RhbmNlLnByb3h5ICYmXG4gICAgICAgICAgICAgICAgLy8gYXZvaWQgYWRkaW5nIHN0b3JlcyB0aGF0IGFyZSBqdXN0IGJ1aWx0IGZvciBob3QgbW9kdWxlIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgIWhvdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZtID0gY3VycmVudEluc3RhbmNlLnByb3h5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gJ19wU3RvcmVzJyBpbiB2bSA/IHZtLl9wU3RvcmVzIDogKHZtLl9wU3RvcmVzID0ge30pO1xuICAgICAgICAgICAgICAgIGNhY2hlW2lkXSA9IHN0b3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlR2VuZXJpYyBjYW5ub3QgYmUgY2FzdGVkIHRvd2FyZHMgU3RvcmVcbiAgICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH1cbiAgICB1c2VTdG9yZS4kaWQgPSBpZDtcbiAgICByZXR1cm4gdXNlU3RvcmU7XG59XG5cbmxldCBtYXBTdG9yZVN1ZmZpeCA9ICdTdG9yZSc7XG4vKipcbiAqIENoYW5nZXMgdGhlIHN1ZmZpeCBhZGRlZCBieSBgbWFwU3RvcmVzKClgLiBDYW4gYmUgc2V0IHRvIGFuIGVtcHR5IHN0cmluZy5cbiAqIERlZmF1bHRzIHRvIGBcIlN0b3JlXCJgLiBNYWtlIHN1cmUgdG8gZXh0ZW5kIHRoZSBNYXBTdG9yZXNDdXN0b21pemF0aW9uXG4gKiBpbnRlcmZhY2UgaWYgeW91IGFyZSB1c2luZyBUeXBlU2NyaXB0LlxuICpcbiAqIEBwYXJhbSBzdWZmaXggLSBuZXcgc3VmZml4XG4gKi9cbmZ1bmN0aW9uIHNldE1hcFN0b3JlU3VmZml4KHN1ZmZpeCAvLyBjb3VsZCBiZSAnU3RvcmUnIGJ1dCB0aGF0IHdvdWxkIGJlIGFubm95aW5nIGZvciBKU1xuKSB7XG4gICAgbWFwU3RvcmVTdWZmaXggPSBzdWZmaXg7XG59XG4vKipcbiAqIEFsbG93cyB1c2luZyBzdG9yZXMgd2l0aG91dCB0aGUgY29tcG9zaXRpb24gQVBJIChgc2V0dXAoKWApIGJ5IGdlbmVyYXRpbmcgYW5cbiAqIG9iamVjdCB0byBiZSBzcHJlYWQgaW4gdGhlIGBjb21wdXRlZGAgZmllbGQgb2YgYSBjb21wb25lbnQuIEl0IGFjY2VwdHMgYSBsaXN0XG4gKiBvZiBzdG9yZSBkZWZpbml0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGV4cG9ydCBkZWZhdWx0IHtcbiAqICAgY29tcHV0ZWQ6IHtcbiAqICAgICAvLyBvdGhlciBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gKiAgICAgLi4ubWFwU3RvcmVzKHVzZVVzZXJTdG9yZSwgdXNlQ2FydFN0b3JlKVxuICogICB9LFxuICpcbiAqICAgY3JlYXRlZCgpIHtcbiAqICAgICB0aGlzLnVzZXJTdG9yZSAvLyBzdG9yZSB3aXRoIGlkIFwidXNlclwiXG4gKiAgICAgdGhpcy5jYXJ0U3RvcmUgLy8gc3RvcmUgd2l0aCBpZCBcImNhcnRcIlxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc3RvcmVzIC0gbGlzdCBvZiBzdG9yZXMgdG8gbWFwIHRvIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiBtYXBTdG9yZXMoLi4uc3RvcmVzKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBBcnJheS5pc0FycmF5KHN0b3Jlc1swXSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBb8J+NjV06IERpcmVjdGx5IHBhc3MgYWxsIHN0b3JlcyB0byBcIm1hcFN0b3JlcygpXCIgd2l0aG91dCBwdXR0aW5nIHRoZW0gaW4gYW4gYXJyYXk6XFxuYCArXG4gICAgICAgICAgICBgUmVwbGFjZVxcbmAgK1xuICAgICAgICAgICAgYFxcdG1hcFN0b3JlcyhbdXNlQXV0aFN0b3JlLCB1c2VDYXJ0U3RvcmVdKVxcbmAgK1xuICAgICAgICAgICAgYHdpdGhcXG5gICtcbiAgICAgICAgICAgIGBcXHRtYXBTdG9yZXModXNlQXV0aFN0b3JlLCB1c2VDYXJ0U3RvcmUpXFxuYCArXG4gICAgICAgICAgICBgVGhpcyB3aWxsIGZhaWwgaW4gcHJvZHVjdGlvbiBpZiBub3QgZml4ZWQuYCk7XG4gICAgICAgIHN0b3JlcyA9IHN0b3Jlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3Jlcy5yZWR1Y2UoKHJlZHVjZWQsIHVzZVN0b3JlKSA9PiB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6ICRpZCBpcyBhZGRlZCBieSBkZWZpbmVTdG9yZVxuICAgICAgICByZWR1Y2VkW3VzZVN0b3JlLiRpZCArIG1hcFN0b3JlU3VmZml4XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VTdG9yZSh0aGlzLiRwaW5pYSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgIH0sIHt9KTtcbn1cbi8qKlxuICogQWxsb3dzIHVzaW5nIHN0YXRlIGFuZCBnZXR0ZXJzIGZyb20gb25lIHN0b3JlIHdpdGhvdXQgdXNpbmcgdGhlIGNvbXBvc2l0aW9uXG4gKiBBUEkgKGBzZXR1cCgpYCkgYnkgZ2VuZXJhdGluZyBhbiBvYmplY3QgdG8gYmUgc3ByZWFkIGluIHRoZSBgY29tcHV0ZWRgIGZpZWxkXG4gKiBvZiBhIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0gdXNlU3RvcmUgLSBzdG9yZSB0byBtYXAgZnJvbVxuICogQHBhcmFtIGtleXNPck1hcHBlciAtIGFycmF5IG9yIG9iamVjdFxuICovXG5mdW5jdGlvbiBtYXBTdGF0ZSh1c2VTdG9yZSwga2V5c09yTWFwcGVyKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoa2V5c09yTWFwcGVyKVxuICAgICAgICA/IGtleXNPck1hcHBlci5yZWR1Y2UoKHJlZHVjZWQsIGtleSkgPT4ge1xuICAgICAgICAgICAgcmVkdWNlZFtrZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEZJWE1FOiBzaG91bGQgd29yaz9cbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlU3RvcmUodGhpcy4kcGluaWEpW2tleV07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZWQ7XG4gICAgICAgIH0sIHt9KVxuICAgICAgICA6IE9iamVjdC5rZXlzKGtleXNPck1hcHBlcikucmVkdWNlKChyZWR1Y2VkLCBrZXkpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHJlZHVjZWRba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKHRoaXMuJHBpbmlhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZUtleSA9IGtleXNPck1hcHBlcltrZXldO1xuICAgICAgICAgICAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBUUyBpcyB1bmFibGUgdG8gaW5mZXIgdGhlIHR5cGUgb2Ygc3RvcmVLZXkgdG8gYmUgYVxuICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBzdG9yZUtleSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICA/IHN0b3JlS2V5LmNhbGwodGhpcywgc3RvcmUpXG4gICAgICAgICAgICAgICAgICAgIDogLy8gQHRzLWV4cGVjdC1lcnJvcjogRklYTUU6IHNob3VsZCB3b3JrP1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVbc3RvcmVLZXldO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgICAgICB9LCB7fSk7XG59XG4vKipcbiAqIEFsaWFzIGZvciBgbWFwU3RhdGUoKWAuIFlvdSBzaG91bGQgdXNlIGBtYXBTdGF0ZSgpYCBpbnN0ZWFkLlxuICogQGRlcHJlY2F0ZWQgdXNlIGBtYXBTdGF0ZSgpYCBpbnN0ZWFkLlxuICovXG5jb25zdCBtYXBHZXR0ZXJzID0gbWFwU3RhdGU7XG4vKipcbiAqIEFsbG93cyBkaXJlY3RseSB1c2luZyBhY3Rpb25zIGZyb20geW91ciBzdG9yZSB3aXRob3V0IHVzaW5nIHRoZSBjb21wb3NpdGlvblxuICogQVBJIChgc2V0dXAoKWApIGJ5IGdlbmVyYXRpbmcgYW4gb2JqZWN0IHRvIGJlIHNwcmVhZCBpbiB0aGUgYG1ldGhvZHNgIGZpZWxkXG4gKiBvZiBhIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0gdXNlU3RvcmUgLSBzdG9yZSB0byBtYXAgZnJvbVxuICogQHBhcmFtIGtleXNPck1hcHBlciAtIGFycmF5IG9yIG9iamVjdFxuICovXG5mdW5jdGlvbiBtYXBBY3Rpb25zKHVzZVN0b3JlLCBrZXlzT3JNYXBwZXIpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShrZXlzT3JNYXBwZXIpXG4gICAgICAgID8ga2V5c09yTWFwcGVyLnJlZHVjZSgocmVkdWNlZCwga2V5KSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICByZWR1Y2VkW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEZJWE1FOiBzaG91bGQgd29yaz9cbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlU3RvcmUodGhpcy4kcGluaWEpW2tleV0oLi4uYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZWQ7XG4gICAgICAgIH0sIHt9KVxuICAgICAgICA6IE9iamVjdC5rZXlzKGtleXNPck1hcHBlcikucmVkdWNlKChyZWR1Y2VkLCBrZXkpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHJlZHVjZWRba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogRklYTUU6IHNob3VsZCB3b3JrP1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VTdG9yZSh0aGlzLiRwaW5pYSlba2V5c09yTWFwcGVyW2tleV1dKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgICAgICB9LCB7fSk7XG59XG4vKipcbiAqIEFsbG93cyB1c2luZyBzdGF0ZSBhbmQgZ2V0dGVycyBmcm9tIG9uZSBzdG9yZSB3aXRob3V0IHVzaW5nIHRoZSBjb21wb3NpdGlvblxuICogQVBJIChgc2V0dXAoKWApIGJ5IGdlbmVyYXRpbmcgYW4gb2JqZWN0IHRvIGJlIHNwcmVhZCBpbiB0aGUgYGNvbXB1dGVkYCBmaWVsZFxuICogb2YgYSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHVzZVN0b3JlIC0gc3RvcmUgdG8gbWFwIGZyb21cbiAqIEBwYXJhbSBrZXlzT3JNYXBwZXIgLSBhcnJheSBvciBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbWFwV3JpdGFibGVTdGF0ZSh1c2VTdG9yZSwga2V5c09yTWFwcGVyKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoa2V5c09yTWFwcGVyKVxuICAgICAgICA/IGtleXNPck1hcHBlci5yZWR1Y2UoKHJlZHVjZWQsIGtleSkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmVkdWNlZFtrZXldID0ge1xuICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogRklYTUU6IHNob3VsZCB3b3JrP1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNlU3RvcmUodGhpcy4kcGluaWEpW2tleV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogRklYTUU6IHNob3VsZCB3b3JrP1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHVzZVN0b3JlKHRoaXMuJHBpbmlhKVtrZXldID0gdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZWQ7XG4gICAgICAgIH0sIHt9KVxuICAgICAgICA6IE9iamVjdC5rZXlzKGtleXNPck1hcHBlcikucmVkdWNlKChyZWR1Y2VkLCBrZXkpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHJlZHVjZWRba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEZJWE1FOiBzaG91bGQgd29yaz9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVzZVN0b3JlKHRoaXMuJHBpbmlhKVtrZXlzT3JNYXBwZXJba2V5XV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogRklYTUU6IHNob3VsZCB3b3JrP1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHVzZVN0b3JlKHRoaXMuJHBpbmlhKVtrZXlzT3JNYXBwZXJba2V5XV0gPSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVkdWNlZDtcbiAgICAgICAgfSwge30pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IG9mIHJlZmVyZW5jZXMgd2l0aCBhbGwgdGhlIHN0YXRlLCBnZXR0ZXJzLCBhbmQgcGx1Z2luLWFkZGVkXG4gKiBzdGF0ZSBwcm9wZXJ0aWVzIG9mIHRoZSBzdG9yZS4gU2ltaWxhciB0byBgdG9SZWZzKClgIGJ1dCBzcGVjaWZpY2FsbHlcbiAqIGRlc2lnbmVkIGZvciBQaW5pYSBzdG9yZXMgc28gbWV0aG9kcyBhbmQgbm9uIHJlYWN0aXZlIHByb3BlcnRpZXMgYXJlXG4gKiBjb21wbGV0ZWx5IGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHN0b3JlIC0gc3RvcmUgdG8gZXh0cmFjdCB0aGUgcmVmcyBmcm9tXG4gKi9cbmZ1bmN0aW9uIHN0b3JlVG9SZWZzKHN0b3JlKSB7XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9waW5pYS9pc3N1ZXMvODUyXG4gICAgLy8gSXQncyBlYXNpZXIgdG8ganVzdCB1c2UgdG9SZWZzKCkgZXZlbiBpZiBpdCBpbmNsdWRlcyBtb3JlIHN0dWZmXG4gICAgaWYgKGlzVnVlMikge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB0b1JlZnMgaW5jbHVkZSBtZXRob2RzIGFuZCBvdGhlcnNcbiAgICAgICAgcmV0dXJuIHRvUmVmcyhzdG9yZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdG9yZSA9IHRvUmF3KHN0b3JlKTtcbiAgICAgICAgY29uc3QgcmVmcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzdG9yZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzdG9yZVtrZXldO1xuICAgICAgICAgICAgaWYgKGlzUmVmKHZhbHVlKSB8fCBpc1JlYWN0aXZlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHRoZSBrZXkgaXMgc3RhdGUgb3IgZ2V0dGVyXG4gICAgICAgICAgICAgICAgcmVmc1trZXldID1cbiAgICAgICAgICAgICAgICAgICAgLy8gLS0tXG4gICAgICAgICAgICAgICAgICAgIHRvUmVmKHN0b3JlLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWZzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWdWUgMiBQbHVnaW4gdGhhdCBtdXN0IGJlIGluc3RhbGxlZCBmb3IgcGluaWEgdG8gd29yay4gTm90ZSAqKnlvdSBkb24ndCBuZWVkXG4gKiB0aGlzIHBsdWdpbiBpZiB5b3UgYXJlIHVzaW5nIE51eHQuanMqKi4gVXNlIHRoZSBgYnVpbGRNb2R1bGVgIGluc3RlYWQ6XG4gKiBodHRwczovL3BpbmlhLnZ1ZWpzLm9yZy9zc3IvbnV4dC5odG1sLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXG4gKiBpbXBvcnQgeyBQaW5pYVZ1ZVBsdWdpbiwgY3JlYXRlUGluaWEgfSBmcm9tICdwaW5pYSdcbiAqXG4gKiBWdWUudXNlKFBpbmlhVnVlUGx1Z2luKVxuICogY29uc3QgcGluaWEgPSBjcmVhdGVQaW5pYSgpXG4gKlxuICogbmV3IFZ1ZSh7XG4gKiAgIGVsOiAnI2FwcCcsXG4gKiAgIC8vIC4uLlxuICogICBwaW5pYSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gX1Z1ZSAtIGBWdWVgIGltcG9ydGVkIGZyb20gJ3Z1ZScuXG4gKi9cbmNvbnN0IFBpbmlhVnVlUGx1Z2luID0gZnVuY3Rpb24gKF9WdWUpIHtcbiAgICAvLyBFcXVpdmFsZW50IG9mXG4gICAgLy8gYXBwLmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLiRwaW5pYSA9IHBpbmlhXG4gICAgX1Z1ZS5taXhpbih7XG4gICAgICAgIGJlZm9yZUNyZWF0ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGluaWEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaW5pYSA9IG9wdGlvbnMucGluaWE7XG4gICAgICAgICAgICAgICAgLy8gSEFDSzogdGFrZW4gZnJvbSBwcm92aWRlKCk6IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9jb21wb3NpdGlvbi1hcGkvYmxvYi9tYWluL3NyYy9hcGlzL2luamVjdC50cyNMMzFcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcHJvdmlkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZUNhY2hlID0ge307XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX3Byb3ZpZGVkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBwcm92aWRlQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQ6ICh2KSA9PiBPYmplY3QuYXNzaWduKHByb3ZpZGVDYWNoZSwgdiksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9wcm92aWRlZFtwaW5pYVN5bWJvbF0gPSBwaW5pYTtcbiAgICAgICAgICAgICAgICAvLyBwcm9wYWdhdGUgdGhlIHBpbmlhIGluc3RhbmNlIGluIGFuIFNTUiBmcmllbmRseSB3YXlcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCBhZGRpbmcgaXQgdG8gbnV4dCB0d2ljZVxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLiRwaW5pYSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRwaW5pYSA9IHBpbmlhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwaW5pYS5fYSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKElTX0NMSUVOVCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGFsbG93cyBjYWxsaW5nIHVzZVN0b3JlKCkgb3V0c2lkZSBvZiBhIGNvbXBvbmVudCBzZXR1cCBhZnRlclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnN0YWxsaW5nIHBpbmlhJ3MgcGx1Z2luXG4gICAgICAgICAgICAgICAgICAgIHNldEFjdGl2ZVBpbmlhKHBpbmlhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSAndW5kZWZpbmVkJyAmJiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pKSAmJiAhKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpKSAmJiBJU19DTElFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJQaW5pYURldnRvb2xzKHBpbmlhLl9hLCBwaW5pYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuJHBpbmlhICYmIG9wdGlvbnMucGFyZW50ICYmIG9wdGlvbnMucGFyZW50LiRwaW5pYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHBpbmlhID0gb3B0aW9ucy5wYXJlbnQuJHBpbmlhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95ZWQoKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcFN0b3JlcztcbiAgICAgICAgfSxcbiAgICB9KTtcbn07XG5cbmV4cG9ydCB7IE11dGF0aW9uVHlwZSwgUGluaWFWdWVQbHVnaW4sIGFjY2VwdEhNUlVwZGF0ZSwgY3JlYXRlUGluaWEsIGRlZmluZVN0b3JlLCBkaXNwb3NlUGluaWEsIGdldEFjdGl2ZVBpbmlhLCBtYXBBY3Rpb25zLCBtYXBHZXR0ZXJzLCBtYXBTdGF0ZSwgbWFwU3RvcmVzLCBtYXBXcml0YWJsZVN0YXRlLCBzZXRBY3RpdmVQaW5pYSwgc2V0TWFwU3RvcmVTdWZmaXgsIHNraXBIeWRyYXRlLCBzdG9yZVRvUmVmcyB9O1xuIiwiLyoqXG4gKiByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHByb21pc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnQgdmFyIFBST01JU0VfUkVTT0xWRURfRkFMU0UgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuZXhwb3J0IHZhciBQUk9NSVNFX1JFU09MVkVEX1RSVUUgPSBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG5leHBvcnQgdmFyIFBST01JU0VfUkVTT0xWRURfVk9JRCA9IFByb21pc2UucmVzb2x2ZSgpO1xuZXhwb3J0IGZ1bmN0aW9uIHNsZWVwKHRpbWUsIHJlc29sdmVXaXRoKSB7XG4gIGlmICghdGltZSkgdGltZSA9IDA7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlcyhyZXNvbHZlV2l0aCk7XG4gICAgfSwgdGltZSk7XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUludChtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpICsgbWluKTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODA4NDI0OFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tVG9rZW4oKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMik7XG59XG52YXIgbGFzdE1zID0gMDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHVuaXggdGltZSBpbiBtaWNyby1zZWNvbmRzLFxuICogV0FSTklORzogVGhpcyBpcyBhIHBzZXVkby1mdW5jdGlvblxuICogUGVyZm9ybWFuY2Uubm93IGlzIG5vdCByZWxpYWJsZSBpbiB3ZWJ3b3JrZXJzLCBzbyB3ZSBqdXN0IG1ha2Ugc3VyZSB0byBuZXZlciByZXR1cm4gdGhlIHNhbWUgdGltZS5cbiAqIFRoaXMgaXMgZW5vdWdoIGluIGJyb3dzZXJzLCBhbmQgdGhpcyBmdW5jdGlvbiB3aWxsIG5vdCBiZSB1c2VkIGluIG5vZGVqcy5cbiAqIFRoZSBtYWluIHJlYXNvbiBmb3IgdGhpcyBoYWNrIGlzIHRvIGVuc3VyZSB0aGF0IEJyb2FkY2FzdENoYW5uZWwgYmVoYXZlcyBlcXVhbCB0byBwcm9kdWN0aW9uIHdoZW4gaXQgaXMgdXNlZCBpbiBmYXN0LXJ1bm5pbmcgdW5pdCB0ZXN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1pY3JvU2Vjb25kcygpIHtcbiAgdmFyIHJldCA9IERhdGUubm93KCkgKiAxMDAwOyAvLyBtaWxsaXNlY29uZHMgdG8gbWljcm9zZWNvbmRzXG4gIGlmIChyZXQgPD0gbGFzdE1zKSB7XG4gICAgcmV0ID0gbGFzdE1zICsgMTtcbiAgfVxuICBsYXN0TXMgPSByZXQ7XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgV2ViTG9jayBBUEkgaXMgc3VwcG9ydGVkLlxuICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9Mb2Nrc19BUElcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRzV2ViTG9ja0FQSSgpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IubG9ja3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IubG9ja3MucmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSIsImltcG9ydCB7IG1pY3JvU2Vjb25kcyBhcyBtaWNybywgUFJPTUlTRV9SRVNPTFZFRF9WT0lEIH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5leHBvcnQgdmFyIG1pY3JvU2Vjb25kcyA9IG1pY3JvO1xuZXhwb3J0IHZhciB0eXBlID0gJ25hdGl2ZSc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKGNoYW5uZWxOYW1lKSB7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICB0aW1lOiBtaWNybygpLFxuICAgIG1lc3NhZ2VzQ2FsbGJhY2s6IG51bGwsXG4gICAgYmM6IG5ldyBCcm9hZGNhc3RDaGFubmVsKGNoYW5uZWxOYW1lKSxcbiAgICBzdWJGbnM6IFtdIC8vIHN1YnNjcmliZXJGdW5jdGlvbnNcbiAgfTtcblxuICBzdGF0ZS5iYy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAobXNnRXZlbnQpIHtcbiAgICBpZiAoc3RhdGUubWVzc2FnZXNDYWxsYmFjaykge1xuICAgICAgc3RhdGUubWVzc2FnZXNDYWxsYmFjayhtc2dFdmVudC5kYXRhKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBzdGF0ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZShjaGFubmVsU3RhdGUpIHtcbiAgY2hhbm5lbFN0YXRlLmJjLmNsb3NlKCk7XG4gIGNoYW5uZWxTdGF0ZS5zdWJGbnMgPSBbXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3N0TWVzc2FnZShjaGFubmVsU3RhdGUsIG1lc3NhZ2VKc29uKSB7XG4gIHRyeSB7XG4gICAgY2hhbm5lbFN0YXRlLmJjLnBvc3RNZXNzYWdlKG1lc3NhZ2VKc29uLCBmYWxzZSk7XG4gICAgcmV0dXJuIFBST01JU0VfUkVTT0xWRURfVk9JRDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBvbk1lc3NhZ2UoY2hhbm5lbFN0YXRlLCBmbikge1xuICBjaGFubmVsU3RhdGUubWVzc2FnZXNDYWxsYmFjayA9IGZuO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNhbkJlVXNlZCgpIHtcbiAgLy8gRGVubyBydW50aW1lXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuRGVubyAmJiBnbG9iYWxUaGlzLkRlbm8uYXJncykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gQnJvd3NlciBydW50aW1lXG4gIGlmICgodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSAmJiB0eXBlb2YgQnJvYWRjYXN0Q2hhbm5lbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChCcm9hZGNhc3RDaGFubmVsLl9wdWJrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQnJvYWRjYXN0Q2hhbm5lbDogRG8gbm90IG92ZXJ3cml0ZSB3aW5kb3cuQnJvYWRjYXN0Q2hhbm5lbCB3aXRoIHRoaXMgbW9kdWxlLCB0aGlzIGlzIG5vdCBhIHBvbHlmaWxsJyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGF2ZXJhZ2VSZXNwb25zZVRpbWUoKSB7XG4gIHJldHVybiAxNTA7XG59XG5leHBvcnQgdmFyIE5hdGl2ZU1ldGhvZCA9IHtcbiAgY3JlYXRlOiBjcmVhdGUsXG4gIGNsb3NlOiBjbG9zZSxcbiAgb25NZXNzYWdlOiBvbk1lc3NhZ2UsXG4gIHBvc3RNZXNzYWdlOiBwb3N0TWVzc2FnZSxcbiAgY2FuQmVVc2VkOiBjYW5CZVVzZWQsXG4gIHR5cGU6IHR5cGUsXG4gIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IGF2ZXJhZ2VSZXNwb25zZVRpbWUsXG4gIG1pY3JvU2Vjb25kczogbWljcm9TZWNvbmRzXG59OyIsIi8qKlxuICogdGhpcyBpcyBhIHNldCB3aGljaCBhdXRvbWF0aWNhbGx5IGZvcmdldHNcbiAqIGEgZ2l2ZW4gZW50cnkgd2hlbiBhIG5ldyBlbnRyeSBpcyBzZXQgYW5kIHRoZSB0dGxcbiAqIG9mIHRoZSBvbGQgb25lIGlzIG92ZXJcbiAqL1xuZXhwb3J0IGNsYXNzIE9ibGl2aW91c1NldCB7XG4gICAgdHRsO1xuICAgIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGluZyBjYWxscyB0byBzZXRUaW1lb3V0KCkgaXMgZXhwZW5zaXZlLFxuICAgICAqIHNvIHdlIG9ubHkgZG8gdGhhdCBpZiB0aGVyZSBpcyBub3QgdGltZW91dCBhbHJlYWR5IG9wZW4uXG4gICAgICovXG4gICAgX3RvID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IodHRsKSB7XG4gICAgICAgIHRoaXMudHRsID0gdHRsO1xuICAgIH1cbiAgICBoYXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmhhcyh2YWx1ZSk7XG4gICAgfVxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1hcC5zZXQodmFsdWUsIG5vdygpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gYSBuZXcgdmFsdWUgaXMgYWRkZWQsXG4gICAgICAgICAqIHN0YXJ0IHRoZSBjbGVhbnVwIGF0IHRoZSBuZXh0IHRpY2tcbiAgICAgICAgICogdG8gbm90IGJsb2NrIHRoZSBjcHUgZm9yIG1vcmUgaW1wb3J0YW50IHN0dWZmXG4gICAgICAgICAqIHRoYXQgbWlnaHQgaGFwcGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCF0aGlzLl90bykge1xuICAgICAgICAgICAgdGhpcy5fdG8gPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG8gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZW1vdmVUb29PbGRWYWx1ZXModGhpcyk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5tYXAuY2xlYXIoKTtcbiAgICB9XG59XG4vKipcbiAqIFJlbW92ZXMgYWxsIGVudHJpZXMgZnJvbSB0aGUgc2V0XG4gKiB3aGVyZSB0aGUgVFRMIGhhcyBleHBpcmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVUb29PbGRWYWx1ZXMob2JsaXZpb3VzU2V0KSB7XG4gICAgY29uc3Qgb2xkZXJUaGVuID0gbm93KCkgLSBvYmxpdmlvdXNTZXQudHRsO1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gb2JsaXZpb3VzU2V0Lm1hcFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgLyoqXG4gICAgICogQmVjYXVzZSB3ZSBjYW4gYXNzdW1lIHRoZSBuZXcgdmFsdWVzIGFyZSBhZGRlZCBhdCB0aGUgYm90dG9tLFxuICAgICAqIHdlIHN0YXJ0IGZyb20gdGhlIHRvcCBhbmQgc3RvcCBhcyBzb29uIGFzIHdlIHJlYWNoIGEgbm9uLXRvby1vbGQgdmFsdWUuXG4gICAgICovXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIG5vIG1vcmUgZWxlbWVudHNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IG5leHRbMF07XG4gICAgICAgIGNvbnN0IHRpbWUgPSBuZXh0WzFdO1xuICAgICAgICBpZiAodGltZSA8IG9sZGVyVGhlbikge1xuICAgICAgICAgICAgb2JsaXZpb3VzU2V0Lm1hcC5kZWxldGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgcmVhY2hlZCBhIHZhbHVlIHRoYXQgaXMgbm90IG9sZCBlbm91Z2hcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gZmlsbE9wdGlvbnNXaXRoRGVmYXVsdHMoKSB7XG4gIHZhciBvcmlnaW5hbE9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgb3B0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3JpZ2luYWxPcHRpb25zKSk7XG5cbiAgLy8gbWFpblxuICBpZiAodHlwZW9mIG9wdGlvbnMud2ViV29ya2VyU3VwcG9ydCA9PT0gJ3VuZGVmaW5lZCcpIG9wdGlvbnMud2ViV29ya2VyU3VwcG9ydCA9IHRydWU7XG5cbiAgLy8gaW5kZXhlZC1kYlxuICBpZiAoIW9wdGlvbnMuaWRiKSBvcHRpb25zLmlkYiA9IHt9O1xuICAvLyAgYWZ0ZXIgdGhpcyB0aW1lIHRoZSBtZXNzYWdlcyBnZXQgZGVsZXRlZFxuICBpZiAoIW9wdGlvbnMuaWRiLnR0bCkgb3B0aW9ucy5pZGIudHRsID0gMTAwMCAqIDQ1O1xuICBpZiAoIW9wdGlvbnMuaWRiLmZhbGxiYWNrSW50ZXJ2YWwpIG9wdGlvbnMuaWRiLmZhbGxiYWNrSW50ZXJ2YWwgPSAxNTA7XG4gIC8vICBoYW5kbGVzIGFicnVwdCBkYiBvbmNsb3NlIGV2ZW50cy5cbiAgaWYgKG9yaWdpbmFsT3B0aW9ucy5pZGIgJiYgdHlwZW9mIG9yaWdpbmFsT3B0aW9ucy5pZGIub25jbG9zZSA9PT0gJ2Z1bmN0aW9uJykgb3B0aW9ucy5pZGIub25jbG9zZSA9IG9yaWdpbmFsT3B0aW9ucy5pZGIub25jbG9zZTtcblxuICAvLyBsb2NhbHN0b3JhZ2VcbiAgaWYgKCFvcHRpb25zLmxvY2Fsc3RvcmFnZSkgb3B0aW9ucy5sb2NhbHN0b3JhZ2UgPSB7fTtcbiAgaWYgKCFvcHRpb25zLmxvY2Fsc3RvcmFnZS5yZW1vdmVUaW1lb3V0KSBvcHRpb25zLmxvY2Fsc3RvcmFnZS5yZW1vdmVUaW1lb3V0ID0gMTAwMCAqIDYwO1xuXG4gIC8vIGN1c3RvbSBtZXRob2RzXG4gIGlmIChvcmlnaW5hbE9wdGlvbnMubWV0aG9kcykgb3B0aW9ucy5tZXRob2RzID0gb3JpZ2luYWxPcHRpb25zLm1ldGhvZHM7XG5cbiAgLy8gbm9kZVxuICBpZiAoIW9wdGlvbnMubm9kZSkgb3B0aW9ucy5ub2RlID0ge307XG4gIGlmICghb3B0aW9ucy5ub2RlLnR0bCkgb3B0aW9ucy5ub2RlLnR0bCA9IDEwMDAgKiA2MCAqIDI7IC8vIDIgbWludXRlcztcbiAgLyoqXG4gICAqIE9uIGxpbnV4IHVzZSAndWxpbWl0IC1IbicgdG8gZ2V0IHRoZSBsaW1pdCBvZiBvcGVuIGZpbGVzLlxuICAgKiBPbiB1YnVudHUgdGhpcyB3YXMgNDA5NiBmb3IgbWUsIHNvIHdlIHVzZSBoYWxmIG9mIHRoYXQgYXMgbWF4UGFyYWxsZWxXcml0ZXMgZGVmYXVsdC5cbiAgICovXG4gIGlmICghb3B0aW9ucy5ub2RlLm1heFBhcmFsbGVsV3JpdGVzKSBvcHRpb25zLm5vZGUubWF4UGFyYWxsZWxXcml0ZXMgPSAyMDQ4O1xuICBpZiAodHlwZW9mIG9wdGlvbnMubm9kZS51c2VGYXN0UGF0aCA9PT0gJ3VuZGVmaW5lZCcpIG9wdGlvbnMubm9kZS51c2VGYXN0UGF0aCA9IHRydWU7XG4gIHJldHVybiBvcHRpb25zO1xufSIsIi8qKlxuICogdGhpcyBtZXRob2QgdXNlcyBpbmRleGVkZGIgdG8gc3RvcmUgdGhlIG1lc3NhZ2VzXG4gKiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gb2JzZXJ2ZXJBUEkgZm9yIGlkYlxuICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3czYy9JbmRleGVkREIvaXNzdWVzLzUxXG4gKiBcbiAqIFdoZW4gd29ya2luZyBvbiB0aGlzLCBlbnN1cmUgdG8gdXNlIHRoZXNlIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiBAbGluayBodHRwczovL3J4ZGIuaW5mby9zbG93LWluZGV4ZWRkYi5odG1sXG4gKi9cblxuaW1wb3J0IHsgc2xlZXAsIHJhbmRvbUludCwgcmFuZG9tVG9rZW4sIG1pY3JvU2Vjb25kcyBhcyBtaWNybywgUFJPTUlTRV9SRVNPTFZFRF9WT0lEIH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5leHBvcnQgdmFyIG1pY3JvU2Vjb25kcyA9IG1pY3JvO1xuaW1wb3J0IHsgT2JsaXZpb3VzU2V0IH0gZnJvbSAnb2JsaXZpb3VzLXNldCc7XG5pbXBvcnQgeyBmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyB9IGZyb20gJy4uL29wdGlvbnMuanMnO1xudmFyIERCX1BSRUZJWCA9ICdwdWJrZXkuYnJvYWRjYXN0LWNoYW5uZWwtMC0nO1xudmFyIE9CSkVDVF9TVE9SRV9JRCA9ICdtZXNzYWdlcyc7XG5cbi8qKlxuICogVXNlIHJlbGF4ZWQgZHVyYWJpbGl0eSBmb3IgZmFzdGVyIHBlcmZvcm1hbmNlIG9uIGFsbCB0cmFuc2FjdGlvbnMuXG4gKiBAbGluayBodHRwczovL25vbGFubGF3c29uLmNvbS8yMDIxLzA4LzIyL3NwZWVkaW5nLXVwLWluZGV4ZWRkYi1yZWFkcy1hbmQtd3JpdGVzL1xuICovXG5leHBvcnQgdmFyIFRSQU5TQUNUSU9OX1NFVFRJTkdTID0ge1xuICBkdXJhYmlsaXR5OiAncmVsYXhlZCdcbn07XG5leHBvcnQgdmFyIHR5cGUgPSAnaWRiJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRJZGIoKSB7XG4gIGlmICh0eXBlb2YgaW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGluZGV4ZWREQjtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cubW96SW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHdpbmRvdy5tb3pJbmRleGVkREI7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cud2Via2l0SW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHdpbmRvdy53ZWJraXRJbmRleGVkREI7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cubXNJbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gd2luZG93Lm1zSW5kZXhlZERCO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBJZiBwb3NzaWJsZSwgd2Ugc2hvdWxkIGV4cGxpY2l0bHkgY29tbWl0IEluZGV4ZWREQiB0cmFuc2FjdGlvbnNcbiAqIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gKiBAbGluayBodHRwczovL25vbGFubGF3c29uLmNvbS8yMDIxLzA4LzIyL3NwZWVkaW5nLXVwLWluZGV4ZWRkYi1yZWFkcy1hbmQtd3JpdGVzL1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbWl0SW5kZXhlZERCVHJhbnNhY3Rpb24odHgpIHtcbiAgaWYgKHR4LmNvbW1pdCkge1xuICAgIHR4LmNvbW1pdCgpO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGF0YWJhc2UoY2hhbm5lbE5hbWUpIHtcbiAgdmFyIEluZGV4ZWREQiA9IGdldElkYigpO1xuXG4gIC8vIGNyZWF0ZSB0YWJsZVxuICB2YXIgZGJOYW1lID0gREJfUFJFRklYICsgY2hhbm5lbE5hbWU7XG5cbiAgLyoqXG4gICAqIEFsbCBJbmRleGVkREIgZGF0YWJhc2VzIGFyZSBvcGVuZWQgd2l0aG91dCB2ZXJzaW9uXG4gICAqIGJlY2F1c2UgaXQgaXMgYSBiaXQgZmFzdGVyLCBlc3BlY2lhbGx5IG9uIGZpcmVmb3hcbiAgICogQGxpbmsgaHR0cDovL25wYXJhc2h1cmFtLmNvbS9JbmRleGVkREIvcGVyZi8jT3BlbiUyMERhdGFiYXNlJTIwd2l0aCUyMHZlcnNpb25cbiAgICovXG4gIHZhciBvcGVuUmVxdWVzdCA9IEluZGV4ZWREQi5vcGVuKGRiTmFtZSk7XG4gIG9wZW5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IGZ1bmN0aW9uIChldikge1xuICAgIHZhciBkYiA9IGV2LnRhcmdldC5yZXN1bHQ7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lELCB7XG4gICAgICBrZXlQYXRoOiAnaWQnLFxuICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgb3BlblJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgcmV0dXJuIHJlaihldik7XG4gICAgfTtcbiAgICBvcGVuUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXMob3BlblJlcXVlc3QucmVzdWx0KTtcbiAgICB9O1xuICB9KTtcbn1cblxuLyoqXG4gKiB3cml0ZXMgdGhlIG5ldyBtZXNzYWdlIHRvIHRoZSBkYXRhYmFzZVxuICogc28gb3RoZXIgcmVhZGVycyBjYW4gZmluZCBpdFxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVNZXNzYWdlKGRiLCByZWFkZXJVdWlkLCBtZXNzYWdlSnNvbikge1xuICB2YXIgdGltZSA9IERhdGUubm93KCk7XG4gIHZhciB3cml0ZU9iamVjdCA9IHtcbiAgICB1dWlkOiByZWFkZXJVdWlkLFxuICAgIHRpbWU6IHRpbWUsXG4gICAgZGF0YTogbWVzc2FnZUpzb25cbiAgfTtcbiAgdmFyIHR4ID0gZGIudHJhbnNhY3Rpb24oW09CSkVDVF9TVE9SRV9JRF0sICdyZWFkd3JpdGUnLCBUUkFOU0FDVElPTl9TRVRUSU5HUyk7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcbiAgICB0eC5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlcygpO1xuICAgIH07XG4gICAgdHgub25lcnJvciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgcmV0dXJuIHJlaihldik7XG4gICAgfTtcbiAgICB2YXIgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfSUQpO1xuICAgIG9iamVjdFN0b3JlLmFkZCh3cml0ZU9iamVjdCk7XG4gICAgY29tbWl0SW5kZXhlZERCVHJhbnNhY3Rpb24odHgpO1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxNZXNzYWdlcyhkYikge1xuICB2YXIgdHggPSBkYi50cmFuc2FjdGlvbihPQkpFQ1RfU1RPUkVfSUQsICdyZWFkb25seScsIFRSQU5TQUNUSU9OX1NFVFRJTkdTKTtcbiAgdmFyIG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lEKTtcbiAgdmFyIHJldCA9IFtdO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcykge1xuICAgIG9iamVjdFN0b3JlLm9wZW5DdXJzb3IoKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHZhciBjdXJzb3IgPSBldi50YXJnZXQucmVzdWx0O1xuICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICByZXQucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICAvL2FsZXJ0KFwiTmFtZSBmb3IgU1NOIFwiICsgY3Vyc29yLmtleSArIFwiIGlzIFwiICsgY3Vyc29yLnZhbHVlLm5hbWUpO1xuICAgICAgICBjdXJzb3JbXCJjb250aW51ZVwiXSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWl0SW5kZXhlZERCVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXMocmV0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZXNzYWdlc0hpZ2hlclRoYW4oZGIsIGxhc3RDdXJzb3JJZCkge1xuICB2YXIgdHggPSBkYi50cmFuc2FjdGlvbihPQkpFQ1RfU1RPUkVfSUQsICdyZWFkb25seScsIFRSQU5TQUNUSU9OX1NFVFRJTkdTKTtcbiAgdmFyIG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lEKTtcbiAgdmFyIHJldCA9IFtdO1xuICB2YXIga2V5UmFuZ2VWYWx1ZSA9IElEQktleVJhbmdlLmJvdW5kKGxhc3RDdXJzb3JJZCArIDEsIEluZmluaXR5KTtcblxuICAvKipcbiAgICogT3B0aW1pemF0aW9uIHNob3J0Y3V0LFxuICAgKiBpZiBnZXRBbGwoKSBjYW4gYmUgdXNlZCwgZG8gbm90IHVzZSBhIGN1cnNvci5cbiAgICogQGxpbmsgaHR0cHM6Ly9yeGRiLmluZm8vc2xvdy1pbmRleGVkZGIuaHRtbFxuICAgKi9cbiAgaWYgKG9iamVjdFN0b3JlLmdldEFsbCkge1xuICAgIHZhciBnZXRBbGxSZXF1ZXN0ID0gb2JqZWN0U3RvcmUuZ2V0QWxsKGtleVJhbmdlVmFsdWUpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcbiAgICAgIGdldEFsbFJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlaihlcnIpO1xuICAgICAgfTtcbiAgICAgIGdldEFsbFJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmVzKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIG9wZW5DdXJzb3IoKSB7XG4gICAgLy8gT2NjYXNpb25hbGx5IFNhZmFyaSB3aWxsIGZhaWwgb24gSURCS2V5UmFuZ2UuYm91bmQsIHRoaXNcbiAgICAvLyBjYXRjaGVzIHRoYXQgZXJyb3IsIGhhdmluZyBpdCBvcGVuIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0XG4gICAgLy8gaXRlbS4gV2hlbiBpdCBnZXRzIGRhdGEgaXQgd2lsbCBhZHZhbmNlIHRvIHRoZSBkZXNpcmVkIGtleS5cbiAgICB0cnkge1xuICAgICAga2V5UmFuZ2VWYWx1ZSA9IElEQktleVJhbmdlLmJvdW5kKGxhc3RDdXJzb3JJZCArIDEsIEluZmluaXR5KTtcbiAgICAgIHJldHVybiBvYmplY3RTdG9yZS5vcGVuQ3Vyc29yKGtleVJhbmdlVmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RTdG9yZS5vcGVuQ3Vyc29yKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcbiAgICB2YXIgb3BlbkN1cnNvclJlcXVlc3QgPSBvcGVuQ3Vyc29yKCk7XG4gICAgb3BlbkN1cnNvclJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHJldHVybiByZWooZXJyKTtcbiAgICB9O1xuICAgIG9wZW5DdXJzb3JSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIGN1cnNvciA9IGV2LnRhcmdldC5yZXN1bHQ7XG4gICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgIGlmIChjdXJzb3IudmFsdWUuaWQgPCBsYXN0Q3Vyc29ySWQgKyAxKSB7XG4gICAgICAgICAgY3Vyc29yW1wiY29udGludWVcIl0obGFzdEN1cnNvcklkICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0LnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgICBjdXJzb3JbXCJjb250aW51ZVwiXSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21taXRJbmRleGVkREJUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIHJlcyhyZXQpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU1lc3NhZ2VzQnlJZChjaGFubmVsU3RhdGUsIGlkcykge1xuICBpZiAoY2hhbm5lbFN0YXRlLmNsb3NlZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICB9XG4gIHZhciB0eCA9IGNoYW5uZWxTdGF0ZS5kYi50cmFuc2FjdGlvbihPQkpFQ1RfU1RPUkVfSUQsICdyZWFkd3JpdGUnLCBUUkFOU0FDVElPTl9TRVRUSU5HUyk7XG4gIHZhciBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9JRCk7XG4gIHJldHVybiBQcm9taXNlLmFsbChpZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBkZWxldGVSZXF1ZXN0ID0gb2JqZWN0U3RvcmVbXCJkZWxldGVcIl0oaWQpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICBkZWxldGVSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcygpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE9sZE1lc3NhZ2VzKGRiLCB0dGwpIHtcbiAgdmFyIG9sZGVyVGhlbiA9IERhdGUubm93KCkgLSB0dGw7XG4gIHZhciB0eCA9IGRiLnRyYW5zYWN0aW9uKE9CSkVDVF9TVE9SRV9JRCwgJ3JlYWRvbmx5JywgVFJBTlNBQ1RJT05fU0VUVElOR1MpO1xuICB2YXIgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfSUQpO1xuICB2YXIgcmV0ID0gW107XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7XG4gICAgb2JqZWN0U3RvcmUub3BlbkN1cnNvcigpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIGN1cnNvciA9IGV2LnRhcmdldC5yZXN1bHQ7XG4gICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgIHZhciBtc2dPYmsgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgIGlmIChtc2dPYmsudGltZSA8IG9sZGVyVGhlbikge1xuICAgICAgICAgIHJldC5wdXNoKG1zZ09iayk7XG4gICAgICAgICAgLy9hbGVydChcIk5hbWUgZm9yIFNTTiBcIiArIGN1cnNvci5rZXkgKyBcIiBpcyBcIiArIGN1cnNvci52YWx1ZS5uYW1lKTtcbiAgICAgICAgICBjdXJzb3JbXCJjb250aW51ZVwiXSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIG1vcmUgb2xkIG1lc3NhZ2VzLFxuICAgICAgICAgIGNvbW1pdEluZGV4ZWREQlRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgICByZXMocmV0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzKHJldCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY2xlYW5PbGRNZXNzYWdlcyhjaGFubmVsU3RhdGUpIHtcbiAgcmV0dXJuIGdldE9sZE1lc3NhZ2VzKGNoYW5uZWxTdGF0ZS5kYiwgY2hhbm5lbFN0YXRlLm9wdGlvbnMuaWRiLnR0bCkudGhlbihmdW5jdGlvbiAodG9vT2xkKSB7XG4gICAgcmV0dXJuIHJlbW92ZU1lc3NhZ2VzQnlJZChjaGFubmVsU3RhdGUsIHRvb09sZC5tYXAoZnVuY3Rpb24gKG1zZykge1xuICAgICAgcmV0dXJuIG1zZy5pZDtcbiAgICB9KSk7XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShjaGFubmVsTmFtZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gZmlsbE9wdGlvbnNXaXRoRGVmYXVsdHMob3B0aW9ucyk7XG4gIHJldHVybiBjcmVhdGVEYXRhYmFzZShjaGFubmVsTmFtZSkudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBjbG9zZWQ6IGZhbHNlLFxuICAgICAgbGFzdEN1cnNvcklkOiAwLFxuICAgICAgY2hhbm5lbE5hbWU6IGNoYW5uZWxOYW1lLFxuICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgIHV1aWQ6IHJhbmRvbVRva2VuKCksXG4gICAgICAvKipcbiAgICAgICAqIGVtaXR0ZWRNZXNzYWdlc0lkc1xuICAgICAgICogY29udGFpbnMgYWxsIG1lc3NhZ2VzIHRoYXQgaGF2ZSBiZWVuIGVtaXR0ZWQgYmVmb3JlXG4gICAgICAgKiBAdHlwZSB7T2JsaXZpb3VzU2V0fVxuICAgICAgICovXG4gICAgICBlTUlzOiBuZXcgT2JsaXZpb3VzU2V0KG9wdGlvbnMuaWRiLnR0bCAqIDIpLFxuICAgICAgLy8gZW5zdXJlcyB3ZSBkbyBub3QgcmVhZCBtZXNzYWdlcyBpbiBwYXJhbGxlbFxuICAgICAgd3JpdGVCbG9ja1Byb21pc2U6IFBST01JU0VfUkVTT0xWRURfVk9JRCxcbiAgICAgIG1lc3NhZ2VzQ2FsbGJhY2s6IG51bGwsXG4gICAgICByZWFkUXVldWVQcm9taXNlczogW10sXG4gICAgICBkYjogZGJcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFicnVwdCBjbG9zZXMgdGhhdCBkbyBub3Qgb3JpZ2luYXRlIGZyb20gZGIuY2xvc2UoKS5cbiAgICAgKiBUaGlzIGNvdWxkIGhhcHBlbiwgZm9yIGV4YW1wbGUsIGlmIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UgaXNcbiAgICAgKiByZW1vdmVkIG9yIGlmIHRoZSB1c2VyIGNsZWFycyB0aGUgZGF0YWJhc2UgaW4gdGhlIGJyb3dzZXInc1xuICAgICAqIGhpc3RvcnkgcHJlZmVyZW5jZXMuXG4gICAgICovXG4gICAgZGIub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0YXRlLmNsb3NlZCA9IHRydWU7XG4gICAgICBpZiAob3B0aW9ucy5pZGIub25jbG9zZSkgb3B0aW9ucy5pZGIub25jbG9zZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBpZiBzZXJ2aWNlLXdvcmtlcnMgYXJlIHVzZWQsXG4gICAgICogd2UgaGF2ZSBubyAnc3RvcmFnZSctZXZlbnQgaWYgdGhleSBwb3N0IGEgbWVzc2FnZSxcbiAgICAgKiB0aGVyZWZvcmUgd2UgYWxzbyBoYXZlIHRvIHNldCBhbiBpbnRlcnZhbFxuICAgICAqL1xuICAgIF9yZWFkTG9vcChzdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIF9yZWFkTG9vcChzdGF0ZSkge1xuICBpZiAoc3RhdGUuY2xvc2VkKSByZXR1cm47XG4gIHJlYWROZXdNZXNzYWdlcyhzdGF0ZSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNsZWVwKHN0YXRlLm9wdGlvbnMuaWRiLmZhbGxiYWNrSW50ZXJ2YWwpO1xuICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3JlYWRMb29wKHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBfZmlsdGVyTWVzc2FnZShtc2dPYmosIHN0YXRlKSB7XG4gIGlmIChtc2dPYmoudXVpZCA9PT0gc3RhdGUudXVpZCkgcmV0dXJuIGZhbHNlOyAvLyBzZW5kIGJ5IG93blxuICBpZiAoc3RhdGUuZU1Jcy5oYXMobXNnT2JqLmlkKSkgcmV0dXJuIGZhbHNlOyAvLyBhbHJlYWR5IGVtaXR0ZWRcbiAgaWYgKG1zZ09iai5kYXRhLnRpbWUgPCBzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSkgcmV0dXJuIGZhbHNlOyAvLyBvbGRlciB0aGVuIG9uTWVzc2FnZUNhbGxiYWNrXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIHJlYWRzIGFsbCBuZXcgbWVzc2FnZXMgZnJvbSB0aGUgZGF0YWJhc2UgYW5kIGVtaXRzIHRoZW1cbiAqL1xuZnVuY3Rpb24gcmVhZE5ld01lc3NhZ2VzKHN0YXRlKSB7XG4gIC8vIGNoYW5uZWwgYWxyZWFkeSBjbG9zZWRcbiAgaWYgKHN0YXRlLmNsb3NlZCkgcmV0dXJuIFBST01JU0VfUkVTT0xWRURfVk9JRDtcblxuICAvLyBpZiBubyBvbmUgaXMgbGlzdGVuaW5nLCB3ZSBkbyBub3QgbmVlZCB0byBzY2FuIGZvciBuZXcgbWVzc2FnZXNcbiAgaWYgKCFzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKSByZXR1cm4gUFJPTUlTRV9SRVNPTFZFRF9WT0lEO1xuICByZXR1cm4gZ2V0TWVzc2FnZXNIaWdoZXJUaGFuKHN0YXRlLmRiLCBzdGF0ZS5sYXN0Q3Vyc29ySWQpLnRoZW4oZnVuY3Rpb24gKG5ld2VyTWVzc2FnZXMpIHtcbiAgICB2YXIgdXNlTWVzc2FnZXMgPSBuZXdlck1lc3NhZ2VzXG4gICAgLyoqXG4gICAgICogdGhlcmUgaXMgYSBidWcgaW4gaU9TIHdoZXJlIHRoZSBtc2dPYmogY2FuIGJlIHVuZGVmaW5lZCBzb21ldGltZXNcbiAgICAgKiBzbyB3ZSBmaWx0ZXIgdGhlbSBvdXRcbiAgICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vcHVia2V5L2Jyb2FkY2FzdC1jaGFubmVsL2lzc3Vlcy8xOVxuICAgICAqLy5maWx0ZXIoZnVuY3Rpb24gKG1zZ09iaikge1xuICAgICAgcmV0dXJuICEhbXNnT2JqO1xuICAgIH0pLm1hcChmdW5jdGlvbiAobXNnT2JqKSB7XG4gICAgICBpZiAobXNnT2JqLmlkID4gc3RhdGUubGFzdEN1cnNvcklkKSB7XG4gICAgICAgIHN0YXRlLmxhc3RDdXJzb3JJZCA9IG1zZ09iai5pZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtc2dPYmo7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChtc2dPYmopIHtcbiAgICAgIHJldHVybiBfZmlsdGVyTWVzc2FnZShtc2dPYmosIHN0YXRlKTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uIChtc2dPYmpBLCBtc2dPYmpCKSB7XG4gICAgICByZXR1cm4gbXNnT2JqQS50aW1lIC0gbXNnT2JqQi50aW1lO1xuICAgIH0pOyAvLyBzb3J0IGJ5IHRpbWVcbiAgICB1c2VNZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2dPYmopIHtcbiAgICAgIGlmIChzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKSB7XG4gICAgICAgIHN0YXRlLmVNSXMuYWRkKG1zZ09iai5pZCk7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sobXNnT2JqLmRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBQUk9NSVNFX1JFU09MVkVEX1ZPSUQ7XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsb3NlKGNoYW5uZWxTdGF0ZSkge1xuICBjaGFubmVsU3RhdGUuY2xvc2VkID0gdHJ1ZTtcbiAgY2hhbm5lbFN0YXRlLmRiLmNsb3NlKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcG9zdE1lc3NhZ2UoY2hhbm5lbFN0YXRlLCBtZXNzYWdlSnNvbikge1xuICBjaGFubmVsU3RhdGUud3JpdGVCbG9ja1Byb21pc2UgPSBjaGFubmVsU3RhdGUud3JpdGVCbG9ja1Byb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdyaXRlTWVzc2FnZShjaGFubmVsU3RhdGUuZGIsIGNoYW5uZWxTdGF0ZS51dWlkLCBtZXNzYWdlSnNvbik7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmIChyYW5kb21JbnQoMCwgMTApID09PSAwKSB7XG4gICAgICAvKiBhd2FpdCAoZG8gbm90IGF3YWl0KSAqL1xuICAgICAgY2xlYW5PbGRNZXNzYWdlcyhjaGFubmVsU3RhdGUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjaGFubmVsU3RhdGUud3JpdGVCbG9ja1Byb21pc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gb25NZXNzYWdlKGNoYW5uZWxTdGF0ZSwgZm4sIHRpbWUpIHtcbiAgY2hhbm5lbFN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2tUaW1lID0gdGltZTtcbiAgY2hhbm5lbFN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sgPSBmbjtcbiAgcmVhZE5ld01lc3NhZ2VzKGNoYW5uZWxTdGF0ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY2FuQmVVc2VkKCkge1xuICByZXR1cm4gISFnZXRJZGIoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhdmVyYWdlUmVzcG9uc2VUaW1lKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuaWRiLmZhbGxiYWNrSW50ZXJ2YWwgKiAyO1xufVxuZXhwb3J0IHZhciBJbmRleGVkREJNZXRob2QgPSB7XG4gIGNyZWF0ZTogY3JlYXRlLFxuICBjbG9zZTogY2xvc2UsXG4gIG9uTWVzc2FnZTogb25NZXNzYWdlLFxuICBwb3N0TWVzc2FnZTogcG9zdE1lc3NhZ2UsXG4gIGNhbkJlVXNlZDogY2FuQmVVc2VkLFxuICB0eXBlOiB0eXBlLFxuICBhdmVyYWdlUmVzcG9uc2VUaW1lOiBhdmVyYWdlUmVzcG9uc2VUaW1lLFxuICBtaWNyb1NlY29uZHM6IG1pY3JvU2Vjb25kc1xufTsiLCIvKipcbiAqIEEgbG9jYWxTdG9yYWdlLW9ubHkgbWV0aG9kIHdoaWNoIHVzZXMgbG9jYWxzdG9yYWdlIGFuZCBpdHMgJ3N0b3JhZ2UnLWV2ZW50XG4gKiBUaGlzIGRvZXMgbm90IHdvcmsgaW5zaWRlIHdlYndvcmtlcnMgYmVjYXVzZSB0aGV5IGhhdmUgbm8gYWNjZXNzIHRvIGxvY2Fsc3RvcmFnZVxuICogVGhpcyBpcyBiYXNpY2FsbHkgaW1wbGVtZW50ZWQgdG8gc3VwcG9ydCBJRTkgb3IgeW91ciBncmFuZG1vdGhlcidzIHRvYXN0ZXIuXG4gKiBAbGluayBodHRwczovL2Nhbml1c2UuY29tLyNmZWF0PW5hbWV2YWx1ZS1zdG9yYWdlXG4gKiBAbGluayBodHRwczovL2Nhbml1c2UuY29tLyNmZWF0PWluZGV4ZWRkYlxuICovXG5cbmltcG9ydCB7IE9ibGl2aW91c1NldCB9IGZyb20gJ29ibGl2aW91cy1zZXQnO1xuaW1wb3J0IHsgZmlsbE9wdGlvbnNXaXRoRGVmYXVsdHMgfSBmcm9tICcuLi9vcHRpb25zLmpzJztcbmltcG9ydCB7IHNsZWVwLCByYW5kb21Ub2tlbiwgbWljcm9TZWNvbmRzIGFzIG1pY3JvIH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5leHBvcnQgdmFyIG1pY3JvU2Vjb25kcyA9IG1pY3JvO1xudmFyIEtFWV9QUkVGSVggPSAncHVia2V5LmJyb2FkY2FzdENoYW5uZWwtJztcbmV4cG9ydCB2YXIgdHlwZSA9ICdsb2NhbHN0b3JhZ2UnO1xuXG4vKipcbiAqIGNvcGllZCBmcm9tIGNyb3NzdGFiXG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vdGVqYWNxdWVzL2Nyb3NzdGFiL2Jsb2IvbWFzdGVyL3NyYy9jcm9zc3RhYi5qcyNMMzJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2FsU3RvcmFnZSgpIHtcbiAgdmFyIGxvY2FsU3RvcmFnZTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbDtcbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgIGxvY2FsU3RvcmFnZSA9IHdpbmRvd1snaWU4LWV2ZW50bGlzdGVuZXIvc3RvcmFnZSddIHx8IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBOZXcgdmVyc2lvbnMgb2YgRmlyZWZveCB0aHJvdyBhIFNlY3VyaXR5IGV4Y2VwdGlvblxuICAgIC8vIGlmIGNvb2tpZXMgYXJlIGRpc2FibGVkLiBTZWVcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDI4MTUzXG4gIH1cbiAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdG9yYWdlS2V5KGNoYW5uZWxOYW1lKSB7XG4gIHJldHVybiBLRVlfUFJFRklYICsgY2hhbm5lbE5hbWU7XG59XG5cbi8qKlxuKiB3cml0ZXMgdGhlIG5ldyBtZXNzYWdlIHRvIHRoZSBzdG9yYWdlXG4qIGFuZCBmaXJlcyB0aGUgc3RvcmFnZS1ldmVudCBzbyBvdGhlciByZWFkZXJzIGNhbiBmaW5kIGl0XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKGNoYW5uZWxTdGF0ZSwgbWVzc2FnZUpzb24pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICBzbGVlcCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGtleSA9IHN0b3JhZ2VLZXkoY2hhbm5lbFN0YXRlLmNoYW5uZWxOYW1lKTtcbiAgICAgIHZhciB3cml0ZU9iaiA9IHtcbiAgICAgICAgdG9rZW46IHJhbmRvbVRva2VuKCksXG4gICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgIGRhdGE6IG1lc3NhZ2VKc29uLFxuICAgICAgICB1dWlkOiBjaGFubmVsU3RhdGUudXVpZFxuICAgICAgfTtcbiAgICAgIHZhciB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHdyaXRlT2JqKTtcbiAgICAgIGdldExvY2FsU3RvcmFnZSgpLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG5cbiAgICAgIC8qKlxuICAgICAgICogU3RvcmFnZUV2ZW50IGRvZXMgbm90IGZpcmUgdGhlICdzdG9yYWdlJyBldmVudFxuICAgICAgICogaW4gdGhlIHdpbmRvdyB0aGF0IGNoYW5nZXMgdGhlIHN0YXRlIG9mIHRoZSBsb2NhbCBzdG9yYWdlLlxuICAgICAgICogU28gd2UgZmlyZSBpdCBtYW51YWxseVxuICAgICAgICovXG4gICAgICB2YXIgZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2LmluaXRFdmVudCgnc3RvcmFnZScsIHRydWUsIHRydWUpO1xuICAgICAgZXYua2V5ID0ga2V5O1xuICAgICAgZXYubmV3VmFsdWUgPSB2YWx1ZTtcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2KTtcbiAgICAgIHJlcygpO1xuICAgIH0pO1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhZGRTdG9yYWdlRXZlbnRMaXN0ZW5lcihjaGFubmVsTmFtZSwgZm4pIHtcbiAgdmFyIGtleSA9IHN0b3JhZ2VLZXkoY2hhbm5lbE5hbWUpO1xuICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcihldikge1xuICAgIGlmIChldi5rZXkgPT09IGtleSkge1xuICAgICAgZm4oSlNPTi5wYXJzZShldi5uZXdWYWx1ZSkpO1xuICAgIH1cbiAgfTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCBsaXN0ZW5lcik7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVTdG9yYWdlRXZlbnRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIGxpc3RlbmVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoY2hhbm5lbE5hbWUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGZpbGxPcHRpb25zV2l0aERlZmF1bHRzKG9wdGlvbnMpO1xuICBpZiAoIWNhbkJlVXNlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCcm9hZGNhc3RDaGFubmVsOiBsb2NhbHN0b3JhZ2UgY2Fubm90IGJlIHVzZWQnKTtcbiAgfVxuICB2YXIgdXVpZCA9IHJhbmRvbVRva2VuKCk7XG5cbiAgLyoqXG4gICAqIGVNSXNcbiAgICogY29udGFpbnMgYWxsIG1lc3NhZ2VzIHRoYXQgaGF2ZSBiZWVuIGVtaXR0ZWQgYmVmb3JlXG4gICAqIEB0eXBlIHtPYmxpdmlvdXNTZXR9XG4gICAqL1xuICB2YXIgZU1JcyA9IG5ldyBPYmxpdmlvdXNTZXQob3B0aW9ucy5sb2NhbHN0b3JhZ2UucmVtb3ZlVGltZW91dCk7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICBjaGFubmVsTmFtZTogY2hhbm5lbE5hbWUsXG4gICAgdXVpZDogdXVpZCxcbiAgICBlTUlzOiBlTUlzIC8vIGVtaXR0ZWRNZXNzYWdlc0lkc1xuICB9O1xuXG4gIHN0YXRlLmxpc3RlbmVyID0gYWRkU3RvcmFnZUV2ZW50TGlzdGVuZXIoY2hhbm5lbE5hbWUsIGZ1bmN0aW9uIChtc2dPYmopIHtcbiAgICBpZiAoIXN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2spIHJldHVybjsgLy8gbm8gbGlzdGVuZXJcbiAgICBpZiAobXNnT2JqLnV1aWQgPT09IHV1aWQpIHJldHVybjsgLy8gb3duIG1lc3NhZ2VcbiAgICBpZiAoIW1zZ09iai50b2tlbiB8fCBlTUlzLmhhcyhtc2dPYmoudG9rZW4pKSByZXR1cm47IC8vIGFscmVhZHkgZW1pdHRlZFxuICAgIGlmIChtc2dPYmouZGF0YS50aW1lICYmIG1zZ09iai5kYXRhLnRpbWUgPCBzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSkgcmV0dXJuOyAvLyB0b28gb2xkXG5cbiAgICBlTUlzLmFkZChtc2dPYmoudG9rZW4pO1xuICAgIHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sobXNnT2JqLmRhdGEpO1xuICB9KTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsb3NlKGNoYW5uZWxTdGF0ZSkge1xuICByZW1vdmVTdG9yYWdlRXZlbnRMaXN0ZW5lcihjaGFubmVsU3RhdGUubGlzdGVuZXIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9uTWVzc2FnZShjaGFubmVsU3RhdGUsIGZuLCB0aW1lKSB7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSA9IHRpbWU7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrID0gZm47XG59XG5leHBvcnQgZnVuY3Rpb24gY2FuQmVVc2VkKCkge1xuICB2YXIgbHMgPSBnZXRMb2NhbFN0b3JhZ2UoKTtcbiAgaWYgKCFscykgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBrZXkgPSAnX19icm9hZGNhc3RjaGFubmVsX2NoZWNrJztcbiAgICBscy5zZXRJdGVtKGtleSwgJ3dvcmtzJyk7XG4gICAgbHMucmVtb3ZlSXRlbShrZXkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gU2FmYXJpIDEwIGluIHByaXZhdGUgbW9kZSB3aWxsIG5vdCBhbGxvdyB3cml0ZSBhY2Nlc3MgdG8gbG9jYWxcbiAgICAvLyBzdG9yYWdlIGFuZCBmYWlsIHdpdGggYSBRdW90YUV4Y2VlZGVkRXJyb3IuIFNlZVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfU3RvcmFnZV9BUEkjUHJpdmF0ZV9Ccm93c2luZ19JbmNvZ25pdG9fbW9kZXNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gYXZlcmFnZVJlc3BvbnNlVGltZSgpIHtcbiAgdmFyIGRlZmF1bHRUaW1lID0gMTIwO1xuICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICBpZiAodXNlckFnZW50LmluY2x1ZGVzKCdzYWZhcmknKSAmJiAhdXNlckFnZW50LmluY2x1ZGVzKCdjaHJvbWUnKSkge1xuICAgIC8vIHNhZmFyaSBpcyBtdWNoIHNsb3dlciBzbyB0aGlzIHRpbWUgaXMgaGlnaGVyXG4gICAgcmV0dXJuIGRlZmF1bHRUaW1lICogMjtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFRpbWU7XG59XG5leHBvcnQgdmFyIExvY2Fsc3RvcmFnZU1ldGhvZCA9IHtcbiAgY3JlYXRlOiBjcmVhdGUsXG4gIGNsb3NlOiBjbG9zZSxcbiAgb25NZXNzYWdlOiBvbk1lc3NhZ2UsXG4gIHBvc3RNZXNzYWdlOiBwb3N0TWVzc2FnZSxcbiAgY2FuQmVVc2VkOiBjYW5CZVVzZWQsXG4gIHR5cGU6IHR5cGUsXG4gIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IGF2ZXJhZ2VSZXNwb25zZVRpbWUsXG4gIG1pY3JvU2Vjb25kczogbWljcm9TZWNvbmRzXG59OyIsImltcG9ydCB7IG1pY3JvU2Vjb25kcyBhcyBtaWNybyB9IGZyb20gJy4uL3V0aWwuanMnO1xuZXhwb3J0IHZhciBtaWNyb1NlY29uZHMgPSBtaWNybztcbmV4cG9ydCB2YXIgdHlwZSA9ICdzaW11bGF0ZSc7XG52YXIgU0lNVUxBVEVfQ0hBTk5FTFMgPSBuZXcgU2V0KCk7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKGNoYW5uZWxOYW1lKSB7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICB0aW1lOiBtaWNyb1NlY29uZHMoKSxcbiAgICBuYW1lOiBjaGFubmVsTmFtZSxcbiAgICBtZXNzYWdlc0NhbGxiYWNrOiBudWxsXG4gIH07XG4gIFNJTVVMQVRFX0NIQU5ORUxTLmFkZChzdGF0ZSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZShjaGFubmVsU3RhdGUpIHtcbiAgU0lNVUxBVEVfQ0hBTk5FTFNbXCJkZWxldGVcIl0oY2hhbm5lbFN0YXRlKTtcbn1cbmV4cG9ydCB2YXIgU0lNVUxBVEVfREVMQVlfVElNRSA9IDU7XG5leHBvcnQgZnVuY3Rpb24gcG9zdE1lc3NhZ2UoY2hhbm5lbFN0YXRlLCBtZXNzYWdlSnNvbikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcykge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjaGFubmVsQXJyYXkgPSBBcnJheS5mcm9tKFNJTVVMQVRFX0NIQU5ORUxTKTtcbiAgICAgIGNoYW5uZWxBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIGlmIChjaGFubmVsLm5hbWUgPT09IGNoYW5uZWxTdGF0ZS5uYW1lICYmXG4gICAgICAgIC8vIGhhcyBzYW1lIG5hbWVcbiAgICAgICAgY2hhbm5lbCAhPT0gY2hhbm5lbFN0YXRlICYmXG4gICAgICAgIC8vIG5vdCBvd24gY2hhbm5lbFxuICAgICAgICAhIWNoYW5uZWwubWVzc2FnZXNDYWxsYmFjayAmJlxuICAgICAgICAvLyBoYXMgc3Vic2NyaWJlcnNcbiAgICAgICAgY2hhbm5lbC50aW1lIDwgbWVzc2FnZUpzb24udGltZSAvLyBjaGFubmVsIG5vdCBjcmVhdGVkIGFmdGVyIHBvc3RNZXNzYWdlKCkgY2FsbFxuICAgICAgICApIHtcbiAgICAgICAgICBjaGFubmVsLm1lc3NhZ2VzQ2FsbGJhY2sobWVzc2FnZUpzb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlcygpO1xuICAgIH0sIFNJTVVMQVRFX0RFTEFZX1RJTUUpO1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvbk1lc3NhZ2UoY2hhbm5lbFN0YXRlLCBmbikge1xuICBjaGFubmVsU3RhdGUubWVzc2FnZXNDYWxsYmFjayA9IGZuO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNhbkJlVXNlZCgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gYXZlcmFnZVJlc3BvbnNlVGltZSgpIHtcbiAgcmV0dXJuIFNJTVVMQVRFX0RFTEFZX1RJTUU7XG59XG5leHBvcnQgdmFyIFNpbXVsYXRlTWV0aG9kID0ge1xuICBjcmVhdGU6IGNyZWF0ZSxcbiAgY2xvc2U6IGNsb3NlLFxuICBvbk1lc3NhZ2U6IG9uTWVzc2FnZSxcbiAgcG9zdE1lc3NhZ2U6IHBvc3RNZXNzYWdlLFxuICBjYW5CZVVzZWQ6IGNhbkJlVXNlZCxcbiAgdHlwZTogdHlwZSxcbiAgYXZlcmFnZVJlc3BvbnNlVGltZTogYXZlcmFnZVJlc3BvbnNlVGltZSxcbiAgbWljcm9TZWNvbmRzOiBtaWNyb1NlY29uZHNcbn07IiwiaW1wb3J0IHsgTmF0aXZlTWV0aG9kIH0gZnJvbSAnLi9tZXRob2RzL25hdGl2ZS5qcyc7XG5pbXBvcnQgeyBJbmRleGVkREJNZXRob2QgfSBmcm9tICcuL21ldGhvZHMvaW5kZXhlZC1kYi5qcyc7XG5pbXBvcnQgeyBMb2NhbHN0b3JhZ2VNZXRob2QgfSBmcm9tICcuL21ldGhvZHMvbG9jYWxzdG9yYWdlLmpzJztcbmltcG9ydCB7IFNpbXVsYXRlTWV0aG9kIH0gZnJvbSAnLi9tZXRob2RzL3NpbXVsYXRlLmpzJztcbi8vIHRoZSBsaW5lIGJlbG93IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIGVzNS9icm93c2VyIGJ1aWxkc1xuXG4vLyBvcmRlciBpcyBpbXBvcnRhbnRcbnZhciBNRVRIT0RTID0gW05hdGl2ZU1ldGhvZCxcbi8vIGZhc3Rlc3RcbkluZGV4ZWREQk1ldGhvZCwgTG9jYWxzdG9yYWdlTWV0aG9kXTtcbmV4cG9ydCBmdW5jdGlvbiBjaG9vc2VNZXRob2Qob3B0aW9ucykge1xuICB2YXIgY2hvb3NlTWV0aG9kcyA9IFtdLmNvbmNhdChvcHRpb25zLm1ldGhvZHMsIE1FVEhPRFMpLmZpbHRlcihCb29sZWFuKTtcblxuICAvLyB0aGUgbGluZSBiZWxvdyB3aWxsIGJlIHJlbW92ZWQgZnJvbSBlczUvYnJvd3NlciBidWlsZHNcblxuICAvLyBkaXJlY3RseSBjaG9zZW5cbiAgaWYgKG9wdGlvbnMudHlwZSkge1xuICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdzaW11bGF0ZScpIHtcbiAgICAgIC8vIG9ubHkgdXNlIHNpbXVsYXRlLW1ldGhvZCBpZiBkaXJlY3RseSBjaG9zZW5cbiAgICAgIHJldHVybiBTaW11bGF0ZU1ldGhvZDtcbiAgICB9XG4gICAgdmFyIHJldCA9IGNob29zZU1ldGhvZHMuZmluZChmdW5jdGlvbiAobSkge1xuICAgICAgcmV0dXJuIG0udHlwZSA9PT0gb3B0aW9ucy50eXBlO1xuICAgIH0pO1xuICAgIGlmICghcmV0KSB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZC10eXBlICcgKyBvcHRpb25zLnR5cGUgKyAnIG5vdCBmb3VuZCcpO2Vsc2UgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBpZiBubyB3ZWJ3b3JrZXIgc3VwcG9ydCBpcyBuZWVkZWQsXG4gICAqIHJlbW92ZSBpZGIgZnJvbSB0aGUgbGlzdCBzbyB0aGF0IGxvY2Fsc3RvcmFnZSB3aWxsIGJlIGNob3NlblxuICAgKi9cbiAgaWYgKCFvcHRpb25zLndlYldvcmtlclN1cHBvcnQpIHtcbiAgICBjaG9vc2VNZXRob2RzID0gY2hvb3NlTWV0aG9kcy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgIHJldHVybiBtLnR5cGUgIT09ICdpZGInO1xuICAgIH0pO1xuICB9XG4gIHZhciB1c2VNZXRob2QgPSBjaG9vc2VNZXRob2RzLmZpbmQoZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIHJldHVybiBtZXRob2QuY2FuQmVVc2VkKCk7XG4gIH0pO1xuICBpZiAoIXVzZU1ldGhvZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHVzYWJsZSBtZXRob2QgZm91bmQgaW4gXCIgKyBKU09OLnN0cmluZ2lmeShNRVRIT0RTLm1hcChmdW5jdGlvbiAobSkge1xuICAgICAgcmV0dXJuIG0udHlwZTtcbiAgICB9KSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1c2VNZXRob2Q7XG4gIH1cbn0iLCJpbXBvcnQgeyBpc1Byb21pc2UsIFBST01JU0VfUkVTT0xWRURfRkFMU0UsIFBST01JU0VfUkVTT0xWRURfVk9JRCB9IGZyb20gJy4vdXRpbC5qcyc7XG5pbXBvcnQgeyBjaG9vc2VNZXRob2QgfSBmcm9tICcuL21ldGhvZC1jaG9vc2VyLmpzJztcbmltcG9ydCB7IGZpbGxPcHRpb25zV2l0aERlZmF1bHRzIH0gZnJvbSAnLi9vcHRpb25zLmpzJztcblxuLyoqXG4gKiBDb250YWlucyBhbGwgb3BlbiBjaGFubmVscyxcbiAqIHVzZWQgaW4gdGVzdHMgdG8gZW5zdXJlIGV2ZXJ5dGhpbmcgaXMgY2xvc2VkLlxuICovXG5leHBvcnQgdmFyIE9QRU5fQlJPQURDQVNUX0NIQU5ORUxTID0gbmV3IFNldCgpO1xudmFyIGxhc3RJZCA9IDA7XG5leHBvcnQgdmFyIEJyb2FkY2FzdENoYW5uZWwgPSBmdW5jdGlvbiBCcm9hZGNhc3RDaGFubmVsKG5hbWUsIG9wdGlvbnMpIHtcbiAgLy8gaWRlbnRpZmllciBvZiB0aGUgY2hhbm5lbCB0byBkZWJ1ZyBzdHVmZlxuICB0aGlzLmlkID0gbGFzdElkKys7XG4gIE9QRU5fQlJPQURDQVNUX0NIQU5ORUxTLmFkZCh0aGlzKTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgaWYgKEVORk9SQ0VEX09QVElPTlMpIHtcbiAgICBvcHRpb25zID0gRU5GT1JDRURfT1BUSU9OUztcbiAgfVxuICB0aGlzLm9wdGlvbnMgPSBmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyhvcHRpb25zKTtcbiAgdGhpcy5tZXRob2QgPSBjaG9vc2VNZXRob2QodGhpcy5vcHRpb25zKTtcblxuICAvLyBpc0xpc3RlbmluZ1xuICB0aGlzLl9pTCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBfb25NZXNzYWdlTGlzdGVuZXJcbiAgICogc2V0dGluZyBvbm1lc3NhZ2UgdHdpY2UsXG4gICAqIHdpbGwgb3ZlcndyaXRlIHRoZSBmaXJzdCBsaXN0ZW5lclxuICAgKi9cbiAgdGhpcy5fb25NTCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIF9hZGRFdmVudExpc3RlbmVyc1xuICAgKi9cbiAgdGhpcy5fYWRkRUwgPSB7XG4gICAgbWVzc2FnZTogW10sXG4gICAgaW50ZXJuYWw6IFtdXG4gIH07XG5cbiAgLyoqXG4gICAqIFVuc2VudCBtZXNzYWdlIHByb21pc2VzXG4gICAqIHdoZXJlIHRoZSBzZW5kaW5nIGlzIHN0aWxsIGluIHByb2dyZXNzXG4gICAqIEB0eXBlIHtTZXQ8UHJvbWlzZT59XG4gICAqL1xuICB0aGlzLl91TVAgPSBuZXcgU2V0KCk7XG5cbiAgLyoqXG4gICAqIF9iZWZvcmVDbG9zZVxuICAgKiBhcnJheSBvZiBwcm9taXNlcyB0aGF0IHdpbGwgYmUgYXdhaXRlZFxuICAgKiBiZWZvcmUgdGhlIGNoYW5uZWwgaXMgY2xvc2VkXG4gICAqL1xuICB0aGlzLl9iZWZDID0gW107XG5cbiAgLyoqXG4gICAqIF9wcmVwYXJlUHJvbWlzZVxuICAgKi9cbiAgdGhpcy5fcHJlcFAgPSBudWxsO1xuICBfcHJlcGFyZUNoYW5uZWwodGhpcyk7XG59O1xuXG4vLyBTVEFUSUNTXG5cbi8qKlxuICogdXNlZCB0byBpZGVudGlmeSBpZiBzb21lb25lIG92ZXJ3cml0ZXNcbiAqIHdpbmRvdy5Ccm9hZGNhc3RDaGFubmVsIHdpdGggdGhpc1xuICogU2VlIG1ldGhvZHMvbmF0aXZlLmpzXG4gKi9cbkJyb2FkY2FzdENoYW5uZWwuX3B1YmtleSA9IHRydWU7XG5cbi8qKlxuICogY2xlYXJzIHRoZSB0bXAtZm9sZGVyIGlmIGlzIG5vZGVcbiAqIEByZXR1cm4ge1Byb21pc2U8Ym9vbGVhbj59IHRydWUgaWYgaGFzIHJ1biwgZmFsc2UgaWYgbm90IG5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyTm9kZUZvbGRlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyhvcHRpb25zKTtcbiAgdmFyIG1ldGhvZCA9IGNob29zZU1ldGhvZChvcHRpb25zKTtcbiAgaWYgKG1ldGhvZC50eXBlID09PSAnbm9kZScpIHtcbiAgICByZXR1cm4gbWV0aG9kLmNsZWFyTm9kZUZvbGRlcigpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFBST01JU0VfUkVTT0xWRURfRkFMU0U7XG4gIH1cbn1cblxuLyoqXG4gKiBpZiBzZXQsIHRoaXMgbWV0aG9kIGlzIGVuZm9yY2VkLFxuICogbm8gbWF0aGVyIHdoYXQgdGhlIG9wdGlvbnMgYXJlXG4gKi9cbnZhciBFTkZPUkNFRF9PUFRJT05TO1xuZXhwb3J0IGZ1bmN0aW9uIGVuZm9yY2VPcHRpb25zKG9wdGlvbnMpIHtcbiAgRU5GT1JDRURfT1BUSU9OUyA9IG9wdGlvbnM7XG59XG5cbi8vIFBST1RPVFlQRVxuQnJvYWRjYXN0Q2hhbm5lbC5wcm90b3R5cGUgPSB7XG4gIHBvc3RNZXNzYWdlOiBmdW5jdGlvbiBwb3N0TWVzc2FnZShtc2cpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSgpOiAnICsgJ0Nhbm5vdCBwb3N0IG1lc3NhZ2UgYWZ0ZXIgY2hhbm5lbCBoYXMgY2xvc2VkICcgK1xuICAgICAgLyoqXG4gICAgICAgKiBJbiB0aGUgcGFzdCB3aGVuIHRoaXMgZXJyb3IgYXBwZWFyZWQsIGl0IHdhcyByZWFsbHkgaGFyZCB0byBkZWJ1Zy5cbiAgICAgICAqIFNvIG5vdyB3ZSBsb2cgdGhlIG1zZyB0b2dldGhlciB3aXRoIHRoZSBlcnJvciBzbyBpdCBhdCBsZWFzdFxuICAgICAgICogZ2l2ZXMgc29tZSBjbHVlIGFib3V0IHdoZXJlIGluIHlvdXIgYXBwbGljYXRpb24gdGhpcyBoYXBwZW5zLlxuICAgICAgICovXG4gICAgICBKU09OLnN0cmluZ2lmeShtc2cpKTtcbiAgICB9XG4gICAgcmV0dXJuIF9wb3N0KHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgfSxcbiAgcG9zdEludGVybmFsOiBmdW5jdGlvbiBwb3N0SW50ZXJuYWwobXNnKSB7XG4gICAgcmV0dXJuIF9wb3N0KHRoaXMsICdpbnRlcm5hbCcsIG1zZyk7XG4gIH0sXG4gIHNldCBvbm1lc3NhZ2UoZm4pIHtcbiAgICB2YXIgdGltZSA9IHRoaXMubWV0aG9kLm1pY3JvU2Vjb25kcygpO1xuICAgIHZhciBsaXN0ZW5PYmogPSB7XG4gICAgICB0aW1lOiB0aW1lLFxuICAgICAgZm46IGZuXG4gICAgfTtcbiAgICBfcmVtb3ZlTGlzdGVuZXJPYmplY3QodGhpcywgJ21lc3NhZ2UnLCB0aGlzLl9vbk1MKTtcbiAgICBpZiAoZm4gJiYgdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9vbk1MID0gbGlzdGVuT2JqO1xuICAgICAgX2FkZExpc3RlbmVyT2JqZWN0KHRoaXMsICdtZXNzYWdlJywgbGlzdGVuT2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb25NTCA9IG51bGw7XG4gICAgfVxuICB9LFxuICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuKSB7XG4gICAgdmFyIHRpbWUgPSB0aGlzLm1ldGhvZC5taWNyb1NlY29uZHMoKTtcbiAgICB2YXIgbGlzdGVuT2JqID0ge1xuICAgICAgdGltZTogdGltZSxcbiAgICAgIGZuOiBmblxuICAgIH07XG4gICAgX2FkZExpc3RlbmVyT2JqZWN0KHRoaXMsIHR5cGUsIGxpc3Rlbk9iaik7XG4gIH0sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4pIHtcbiAgICB2YXIgb2JqID0gdGhpcy5fYWRkRUxbdHlwZV0uZmluZChmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLmZuID09PSBmbjtcbiAgICB9KTtcbiAgICBfcmVtb3ZlTGlzdGVuZXJPYmplY3QodGhpcywgdHlwZSwgb2JqKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9QRU5fQlJPQURDQVNUX0NIQU5ORUxTW1wiZGVsZXRlXCJdKHRoaXMpO1xuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB2YXIgYXdhaXRQcmVwYXJlID0gdGhpcy5fcHJlcFAgPyB0aGlzLl9wcmVwUCA6IFBST01JU0VfUkVTT0xWRURfVk9JRDtcbiAgICB0aGlzLl9vbk1MID0gbnVsbDtcbiAgICB0aGlzLl9hZGRFTC5tZXNzYWdlID0gW107XG4gICAgcmV0dXJuIGF3YWl0UHJlcGFyZVxuICAgIC8vIHdhaXQgdW50aWwgYWxsIGN1cnJlbnQgc2VuZGluZyBhcmUgcHJvY2Vzc2VkXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKEFycmF5LmZyb20oX3RoaXMuX3VNUCkpO1xuICAgIH0pXG4gICAgLy8gcnVuIGJlZm9yZS1jbG9zZSBob29rc1xuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChfdGhpcy5fYmVmQy5tYXAoZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSkpO1xuICAgIH0pXG4gICAgLy8gY2xvc2UgdGhlIGNoYW5uZWxcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMubWV0aG9kLmNsb3NlKF90aGlzLl9zdGF0ZSk7XG4gICAgfSk7XG4gIH0sXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZC50eXBlO1xuICB9LFxuICBnZXQgaXNDbG9zZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VkO1xuICB9XG59O1xuXG4vKipcbiAqIFBvc3QgYSBtZXNzYWdlIG92ZXIgdGhlIGNoYW5uZWxcbiAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGF0IHJlc29sdmVkIHdoZW4gdGhlIG1lc3NhZ2Ugc2VuZGluZyBpcyBkb25lXG4gKi9cbmZ1bmN0aW9uIF9wb3N0KGJyb2FkY2FzdENoYW5uZWwsIHR5cGUsIG1zZykge1xuICB2YXIgdGltZSA9IGJyb2FkY2FzdENoYW5uZWwubWV0aG9kLm1pY3JvU2Vjb25kcygpO1xuICB2YXIgbXNnT2JqID0ge1xuICAgIHRpbWU6IHRpbWUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBkYXRhOiBtc2dcbiAgfTtcbiAgdmFyIGF3YWl0UHJlcGFyZSA9IGJyb2FkY2FzdENoYW5uZWwuX3ByZXBQID8gYnJvYWRjYXN0Q2hhbm5lbC5fcHJlcFAgOiBQUk9NSVNFX1JFU09MVkVEX1ZPSUQ7XG4gIHJldHVybiBhd2FpdFByZXBhcmUudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbmRQcm9taXNlID0gYnJvYWRjYXN0Q2hhbm5lbC5tZXRob2QucG9zdE1lc3NhZ2UoYnJvYWRjYXN0Q2hhbm5lbC5fc3RhdGUsIG1zZ09iaik7XG5cbiAgICAvLyBhZGQvcmVtb3ZlIHRvIHVuc2VudCBtZXNzYWdlcyBsaXN0XG4gICAgYnJvYWRjYXN0Q2hhbm5lbC5fdU1QLmFkZChzZW5kUHJvbWlzZSk7XG4gICAgc2VuZFByb21pc2VbXCJjYXRjaFwiXSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGJyb2FkY2FzdENoYW5uZWwuX3VNUFtcImRlbGV0ZVwiXShzZW5kUHJvbWlzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbmRQcm9taXNlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIF9wcmVwYXJlQ2hhbm5lbChjaGFubmVsKSB7XG4gIHZhciBtYXliZVByb21pc2UgPSBjaGFubmVsLm1ldGhvZC5jcmVhdGUoY2hhbm5lbC5uYW1lLCBjaGFubmVsLm9wdGlvbnMpO1xuICBpZiAoaXNQcm9taXNlKG1heWJlUHJvbWlzZSkpIHtcbiAgICBjaGFubmVsLl9wcmVwUCA9IG1heWJlUHJvbWlzZTtcbiAgICBtYXliZVByb21pc2UudGhlbihmdW5jdGlvbiAocykge1xuICAgICAgLy8gdXNlZCBpbiB0ZXN0cyB0byBzaW11bGF0ZSBzbG93IHJ1bnRpbWVcbiAgICAgIC8qaWYgKGNoYW5uZWwub3B0aW9ucy5wcmVwYXJlRGVsYXkpIHtcbiAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCB0aGlzLm9wdGlvbnMucHJlcGFyZURlbGF5KSk7XG4gICAgICB9Ki9cbiAgICAgIGNoYW5uZWwuX3N0YXRlID0gcztcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFubmVsLl9zdGF0ZSA9IG1heWJlUHJvbWlzZTtcbiAgfVxufVxuZnVuY3Rpb24gX2hhc01lc3NhZ2VMaXN0ZW5lcnMoY2hhbm5lbCkge1xuICBpZiAoY2hhbm5lbC5fYWRkRUwubWVzc2FnZS5sZW5ndGggPiAwKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNoYW5uZWwuX2FkZEVMLmludGVybmFsLmxlbmd0aCA+IDApIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBfYWRkTGlzdGVuZXJPYmplY3QoY2hhbm5lbCwgdHlwZSwgb2JqKSB7XG4gIGNoYW5uZWwuX2FkZEVMW3R5cGVdLnB1c2gob2JqKTtcbiAgX3N0YXJ0TGlzdGVuaW5nKGNoYW5uZWwpO1xufVxuZnVuY3Rpb24gX3JlbW92ZUxpc3RlbmVyT2JqZWN0KGNoYW5uZWwsIHR5cGUsIG9iaikge1xuICBjaGFubmVsLl9hZGRFTFt0eXBlXSA9IGNoYW5uZWwuX2FkZEVMW3R5cGVdLmZpbHRlcihmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICE9PSBvYmo7XG4gIH0pO1xuICBfc3RvcExpc3RlbmluZyhjaGFubmVsKTtcbn1cbmZ1bmN0aW9uIF9zdGFydExpc3RlbmluZyhjaGFubmVsKSB7XG4gIGlmICghY2hhbm5lbC5faUwgJiYgX2hhc01lc3NhZ2VMaXN0ZW5lcnMoY2hhbm5lbCkpIHtcbiAgICAvLyBzb21lb25lIGlzIGxpc3RlbmluZywgc3RhcnQgc3Vic2NyaWJpbmdcblxuICAgIHZhciBsaXN0ZW5lckZuID0gZnVuY3Rpb24gbGlzdGVuZXJGbihtc2dPYmopIHtcbiAgICAgIGNoYW5uZWwuX2FkZEVMW21zZ09iai50eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lck9iamVjdCkge1xuICAgICAgICBpZiAobXNnT2JqLnRpbWUgPj0gbGlzdGVuZXJPYmplY3QudGltZSkge1xuICAgICAgICAgIGxpc3RlbmVyT2JqZWN0LmZuKG1zZ09iai5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgdGltZSA9IGNoYW5uZWwubWV0aG9kLm1pY3JvU2Vjb25kcygpO1xuICAgIGlmIChjaGFubmVsLl9wcmVwUCkge1xuICAgICAgY2hhbm5lbC5fcHJlcFAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoYW5uZWwuX2lMID0gdHJ1ZTtcbiAgICAgICAgY2hhbm5lbC5tZXRob2Qub25NZXNzYWdlKGNoYW5uZWwuX3N0YXRlLCBsaXN0ZW5lckZuLCB0aW1lKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFubmVsLl9pTCA9IHRydWU7XG4gICAgICBjaGFubmVsLm1ldGhvZC5vbk1lc3NhZ2UoY2hhbm5lbC5fc3RhdGUsIGxpc3RlbmVyRm4sIHRpbWUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX3N0b3BMaXN0ZW5pbmcoY2hhbm5lbCkge1xuICBpZiAoY2hhbm5lbC5faUwgJiYgIV9oYXNNZXNzYWdlTGlzdGVuZXJzKGNoYW5uZWwpKSB7XG4gICAgLy8gbm8gb25lIGlzIGxpc3RlbmluZywgc3RvcCBzdWJzY3JpYmluZ1xuICAgIGNoYW5uZWwuX2lMID0gZmFsc2U7XG4gICAgdmFyIHRpbWUgPSBjaGFubmVsLm1ldGhvZC5taWNyb1NlY29uZHMoKTtcbiAgICBjaGFubmVsLm1ldGhvZC5vbk1lc3NhZ2UoY2hhbm5lbC5fc3RhdGUsIG51bGwsIHRpbWUpO1xuICB9XG59IiwiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBCcm9hZGNhc3RDaGFubmVsIGFzIEJyb2FkY2FzdENoYW5uZWxJbXBsMiB9IGZyb20gXCJicm9hZGNhc3QtY2hhbm5lbFwiO1xuXG4vLyBzcmMvdXRpbHMudHNcbmZ1bmN0aW9uIHNlcmlhbGl6ZShvYmosIHNlcmlhbGl6ZXIgPSB7IHNlcmlhbGl6ZTogSlNPTi5zdHJpbmdpZnksIGRlc2VyaWFsaXplOiBKU09OLnBhcnNlIH0pIHtcbiAgcmV0dXJuIHNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoc2VyaWFsaXplci5zZXJpYWxpemUob2JqKSk7XG59XG5cbi8vIHNyYy92YW5pbGxhLnRzXG5pbXBvcnQgeyBCcm9hZGNhc3RDaGFubmVsIGFzIEJyb2FkY2FzdENoYW5uZWxJbXBsIH0gZnJvbSBcImJyb2FkY2FzdC1jaGFubmVsXCI7XG5mdW5jdGlvbiBzaGFyZShrZXksIHN0b3JlLCB7IGluaXRpYWxpemUsIHNlcmlhbGl6ZXIsIHR5cGUgfSkge1xuICBjb25zdCBjaGFubmVsTmFtZSA9IGAke3N0b3JlLiRpZH0tJHtrZXkudG9TdHJpbmcoKX1gO1xuICBjb25zdCBjaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWxJbXBsKGNoYW5uZWxOYW1lLCB7XG4gICAgdHlwZVxuICB9KTtcbiAgbGV0IGV4dGVybmFsVXBkYXRlID0gZmFsc2U7XG4gIGxldCB0aW1lc3RhbXAgPSAwO1xuICBzdG9yZS4kc3Vic2NyaWJlKChfLCBzdGF0ZSkgPT4ge1xuICAgIGlmICghZXh0ZXJuYWxVcGRhdGUpIHtcbiAgICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICBjaGFubmVsLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICBuZXdWYWx1ZTogc2VyaWFsaXplKHN0YXRlLCBzZXJpYWxpemVyKVtrZXldXG4gICAgICB9KTtcbiAgICB9XG4gICAgZXh0ZXJuYWxVcGRhdGUgPSBmYWxzZTtcbiAgfSk7XG4gIGNoYW5uZWwub25tZXNzYWdlID0gKGV2dCkgPT4ge1xuICAgIGlmIChldnQgPT09IHZvaWQgMCkge1xuICAgICAgY2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogVE9ET1xuICAgICAgICBuZXdWYWx1ZTogc2VyaWFsaXplKHN0b3JlLiRzdGF0ZSwgc2VyaWFsaXplcilba2V5XVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldnQudGltZXN0YW1wIDw9IHRpbWVzdGFtcClcbiAgICAgIHJldHVybjtcbiAgICBleHRlcm5hbFVwZGF0ZSA9IHRydWU7XG4gICAgdGltZXN0YW1wID0gZXZ0LnRpbWVzdGFtcDtcbiAgICBzdG9yZVtrZXldID0gZXZ0Lm5ld1ZhbHVlO1xuICB9O1xuICBjb25zdCBzeW5jID0gKCkgPT4gY2hhbm5lbC5wb3N0TWVzc2FnZSh2b2lkIDApO1xuICBjb25zdCB1bnNoYXJlID0gKCkgPT4ge1xuICAgIHJldHVybiBjaGFubmVsLmNsb3NlKCk7XG4gIH07XG4gIGlmIChpbml0aWFsaXplKVxuICAgIHN5bmMoKTtcbiAgcmV0dXJuIHsgc3luYywgdW5zaGFyZSB9O1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIHN0YXRlSGFzS2V5KGtleSwgJHN0YXRlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cygkc3RhdGUpLmluY2x1ZGVzKGtleSk7XG59XG5mdW5jdGlvbiBQaW5pYVNoYXJlZFN0YXRlKHtcbiAgZW5hYmxlID0gdHJ1ZSxcbiAgaW5pdGlhbGl6ZSA9IHRydWUsXG4gIHR5cGUsXG4gIHNlcmlhbGl6ZXJcbn0pIHtcbiAgcmV0dXJuICh7IHN0b3JlLCBvcHRpb25zIH0pID0+IHtcbiAgICBjb25zdCBpc0VuYWJsZWQgPSBvcHRpb25zPy5zaGFyZT8uZW5hYmxlID8/IGVuYWJsZTtcbiAgICBjb25zdCBvbWl0dGVkS2V5cyA9IG9wdGlvbnM/LnNoYXJlPy5vbWl0ID8/IFtdO1xuICAgIGlmICghaXNFbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNoYW5uZWwgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbEltcGwyKHN0b3JlLiRpZCwge1xuICAgICAgdHlwZVxuICAgIH0pO1xuICAgIGxldCB0aW1lc3RhbXAgPSAwO1xuICAgIGxldCBleHRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIGNvbnN0IGtleXNUb1VwZGF0ZSA9IE9iamVjdC5rZXlzKHN0b3JlLiRzdGF0ZSkuZmlsdGVyKChrZXkpID0+ICFvbWl0dGVkS2V5cy5pbmNsdWRlcyhrZXkpICYmIHN0YXRlSGFzS2V5KGtleSwgc3RvcmUuJHN0YXRlKSk7XG4gICAgY2hhbm5lbC5vbm1lc3NhZ2UgPSAobmV3U3RhdGUpID0+IHtcbiAgICAgIGlmIChuZXdTdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNoYW5uZWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICBzdGF0ZTogc2VyaWFsaXplKHN0b3JlLiRzdGF0ZSwgc2VyaWFsaXplcilcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdTdGF0ZS50aW1lc3RhbXAgPD0gdGltZXN0YW1wKVxuICAgICAgICByZXR1cm47XG4gICAgICBleHRlcm5hbFVwZGF0ZSA9IHRydWU7XG4gICAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgc3RvcmUuJHBhdGNoKChzdGF0ZSkgPT4ge1xuICAgICAgICBrZXlzVG9VcGRhdGUuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgc3RhdGVba2V5XSA9IG5ld1N0YXRlLnN0YXRlW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRJbml0aWFsaXplID0gb3B0aW9ucz8uc2hhcmU/LmluaXRpYWxpemUgPz8gaW5pdGlhbGl6ZTtcbiAgICBpZiAoc2hvdWxkSW5pdGlhbGl6ZSlcbiAgICAgIGNoYW5uZWwucG9zdE1lc3NhZ2Uodm9pZCAwKTtcbiAgICBzdG9yZS4kc3Vic2NyaWJlKChfLCBzdGF0ZSkgPT4ge1xuICAgICAgaWYgKCFleHRlcm5hbFVwZGF0ZSkge1xuICAgICAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICBjaGFubmVsLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgc3RhdGU6IHNlcmlhbGl6ZShzdGF0ZSwgc2VyaWFsaXplcilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBleHRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIH0pO1xuICB9O1xufVxuZXhwb3J0IHtcbiAgUGluaWFTaGFyZWRTdGF0ZSxcbiAgc2hhcmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBpbmplY3QsIHR5cGUgQXBwIH0gZnJvbSBcInZ1ZVwiO1xuaW1wb3J0IHsgT3BlbkFJIH0gZnJvbSBcIm9wZW5haVwiO1xuaW1wb3J0IHsgY3JlYXRlUGluaWEgfSBmcm9tIFwicGluaWFcIjtcbmltcG9ydCB7IFBpbmlhU2hhcmVkU3RhdGUgfSBmcm9tIFwicGluaWEtc2hhcmVkLXN0YXRlXCI7XG5cbmNvbnN0IEFJX0NMSUVOVF9QUk9WSURFUiA9IFN5bWJvbChcImNsaWVudFwiKTtcblxudHlwZSBBSUNsaWVudFByb3ZpZGVyID0geyBjbGllbnQ6IE9wZW5BSTsgc3lzdGVtUHJvbXB0OiBzdHJpbmcgfTtcblxuZXhwb3J0IGNvbnN0IGNvbmZpZ3VyZUFwcFdpdGhQcm92aWRlcnMgPVxuICAoeyBjbGllbnQsIHN5c3RlbVByb21wdCB9OiBBSUNsaWVudFByb3ZpZGVyKSA9PlxuICAoYXBwOiBBcHApID0+IHtcbiAgICBjb25zdCBwaW5pYSA9IGNyZWF0ZVBpbmlhKCk7XG4gICAgcGluaWEudXNlKFBpbmlhU2hhcmVkU3RhdGUoeyBlbmFibGU6IHRydWUsIGluaXRpYWxpemU6IGZhbHNlLCB0eXBlOiBcImxvY2Fsc3RvcmFnZVwiIH0pKTtcblxuICAgIGFwcC51c2UocGluaWEpLnByb3ZpZGUoQUlfQ0xJRU5UX1BST1ZJREVSLCB7XG4gICAgICBjbGllbnQsXG4gICAgICBzeXN0ZW1Qcm9tcHQsXG4gICAgfSk7XG4gIH07XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBSSgpIHtcbiAgcmV0dXJuIGluamVjdDxBSUNsaWVudFByb3ZpZGVyPihBSV9DTElFTlRfUFJPVklERVIpITtcbn1cbiIsImltcG9ydCB7IGRlZmluZVN0b3JlIH0gZnJvbSBcInBpbmlhXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZSB7XG4gIHJvbGU6IFwidXNlclwiIHwgXCJhc3Npc3RhbnRcIiB8IFwic3lzdGVtXCI7XG4gIGNvbnRlbnQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGF0U2Vzc2lvbiB7XG4gIGlkOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogRGF0ZTtcbiAgbWVzc2FnZXM6IE1lc3NhZ2VbXTtcbn1cblxuZXhwb3J0IGNvbnN0IHVzZUNoYXRib3hTdG9yZSA9IGRlZmluZVN0b3JlKFwiY2hhdGJveFwiLCB7XG4gIHN0YXRlOiAoKSA9PiAoe1xuICAgIG1vZGVsczogW10gYXMgc3RyaW5nW10sXG4gICAgc2VsZWN0ZWRNb2RlbDogXCJcIixcbiAgICBzeXN0ZW1Qcm9tcHQ6IFwiXCIsXG4gICAgdXNlck1lc3NhZ2VzOiBbXSBhcyBNZXNzYWdlW10sXG4gICAgbmV3TWVzc2FnZTogXCJcIixcbiAgICBtYXhUb2tlbnM6IDUwMDAsXG4gICAgY2hhdEhpc3Rvcnk6IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJjaGF0SGlzdG9yeVwiKSB8fCBcIltdXCIpLm1hcCgoY2hhdDogYW55KSA9PiAoe1xuICAgICAgLi4uY2hhdCxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoY2hhdC50aW1lc3RhbXApLFxuICAgIH0pKSBhcyBDaGF0U2Vzc2lvbltdLFxuICAgIGN1cnJlbnRDaGF0SWQ6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiY3VycmVudENoYXRJZFwiKSB8fCBcIlwiLFxuICB9KSxcblxuICBhY3Rpb25zOiB7XG4gICAgc2V0U3lzdGVtUHJvbXB0KHByb21wdDogc3RyaW5nKSB7XG4gICAgICB0aGlzLnN5c3RlbVByb21wdCA9IHByb21wdDtcbiAgICB9LFxuXG4gICAgc2V0TW9kZWxzKG1vZGVsczogc3RyaW5nW10pIHtcbiAgICAgIHRoaXMubW9kZWxzID0gbW9kZWxzO1xuICAgIH0sXG5cbiAgICBzZXRTZWxlY3RlZE1vZGVsKG1vZGVsOiBzdHJpbmcpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRNb2RlbCA9IG1vZGVsO1xuICAgIH0sXG5cbiAgICBzZXRVc2VyTWVzc2FnZXMobWVzc2FnZXM6IE1lc3NhZ2VbXSkge1xuICAgICAgdGhpcy51c2VyTWVzc2FnZXMgPSBbLi4ubWVzc2FnZXNdO1xuICAgICAgdGhpcy5zYXZlVG9TdG9yYWdlKCk7XG4gICAgfSxcblxuICAgIGFkZE1lc3NhZ2UobWVzc2FnZTogTWVzc2FnZSkge1xuICAgICAgdGhpcy51c2VyTWVzc2FnZXMucHVzaChtZXNzYWdlKTtcblxuICAgICAgaWYgKCF0aGlzLmN1cnJlbnRDaGF0SWQgJiYgbWVzc2FnZS5yb2xlID09PSBcInVzZXJcIikge1xuICAgICAgICBjb25zdCBpZCA9IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICAgIHRoaXMuY3VycmVudENoYXRJZCA9IGlkO1xuICAgICAgICB0aGlzLmNoYXRIaXN0b3J5LnVuc2hpZnQoe1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHRpdGxlOiBtZXNzYWdlLmNvbnRlbnQuc2xpY2UoMCwgNTApICsgKG1lc3NhZ2UuY29udGVudC5sZW5ndGggPiA1MCA/IFwiLi4uXCIgOiBcIlwiKSxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgbWVzc2FnZXM6IFttZXNzYWdlXSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudENoYXRJZCkge1xuICAgICAgICBjb25zdCBjaGF0SW5kZXggPSB0aGlzLmNoYXRIaXN0b3J5LmZpbmRJbmRleCgoY2hhdCkgPT4gY2hhdC5pZCA9PT0gdGhpcy5jdXJyZW50Q2hhdElkKTtcbiAgICAgICAgaWYgKGNoYXRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLmNoYXRIaXN0b3J5W2NoYXRJbmRleF0gPSB7XG4gICAgICAgICAgICAuLi50aGlzLmNoYXRIaXN0b3J5W2NoYXRJbmRleF0sXG4gICAgICAgICAgICBtZXNzYWdlczogWy4uLnRoaXMudXNlck1lc3NhZ2VzXSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnNhdmVUb1N0b3JhZ2UoKTtcbiAgICB9LFxuXG4gICAgc2F2ZVRvU3RvcmFnZSgpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiY2hhdEhpc3RvcnlcIiwgSlNPTi5zdHJpbmdpZnkodGhpcy5jaGF0SGlzdG9yeSkpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJjdXJyZW50Q2hhdElkXCIsIHRoaXMuY3VycmVudENoYXRJZCk7XG4gICAgfSxcblxuICAgIGNsZWFyTWVzc2FnZXMoKSB7XG4gICAgICB0aGlzLnVzZXJNZXNzYWdlcyA9IFtdO1xuICAgICAgdGhpcy5jdXJyZW50Q2hhdElkID0gXCJcIjtcbiAgICAgIHRoaXMuc2F2ZVRvU3RvcmFnZSgpO1xuICAgIH0sXG5cbiAgICBsb2FkQ2hhdChjaGF0SWQ6IHN0cmluZykge1xuICAgICAgY29uc3QgY2hhdCA9IHRoaXMuY2hhdEhpc3RvcnkuZmluZCgoYykgPT4gYy5pZCA9PT0gY2hhdElkKTtcbiAgICAgIGlmIChjaGF0KSB7XG4gICAgICAgIHRoaXMuY3VycmVudENoYXRJZCA9IGNoYXRJZDtcbiAgICAgICAgdGhpcy51c2VyTWVzc2FnZXMgPSBbLi4uY2hhdC5tZXNzYWdlc107XG4gICAgICAgIHRoaXMuc2F2ZVRvU3RvcmFnZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGFydE5ld0NoYXQoKSB7XG4gICAgICB0aGlzLmNsZWFyTWVzc2FnZXMoKTtcbiAgICAgIHRoaXMuY2xlYXJOZXdNZXNzYWdlKCk7XG4gICAgfSxcblxuICAgIGNsZWFyTmV3TWVzc2FnZSgpIHtcbiAgICAgIHRoaXMubmV3TWVzc2FnZSA9IFwiXCI7XG4gICAgfSxcbiAgfSxcblxuICBnZXR0ZXJzOiB7XG4gICAgbWVzc2FnZXMoKTogTWVzc2FnZVtdIHtcbiAgICAgIGlmICh0aGlzLnN5c3RlbVByb21wdCkge1xuICAgICAgICByZXR1cm4gW3sgcm9sZTogXCJzeXN0ZW1cIiwgY29udGVudDogdGhpcy5zeXN0ZW1Qcm9tcHQgfSwgLi4udGhpcy51c2VyTWVzc2FnZXNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudXNlck1lc3NhZ2VzO1xuICAgIH0sXG4gIH0sXG59KTtcbiIsIi8qKlxuICogbWFya2VkIHYxNC4xLjEgLSBhIG1hcmtkb3duIHBhcnNlclxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMjQsIENocmlzdG9waGVyIEplZmZyZXkuIChNSVQgTGljZW5zZWQpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkXG4gKi9cblxuLyoqXG4gKiBETyBOT1QgRURJVCBUSElTIEZJTEVcbiAqIFRoZSBjb2RlIGluIHRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBmaWxlcyBpbiAuL3NyYy9cbiAqL1xuXG4vKipcbiAqIEdldHMgdGhlIG9yaWdpbmFsIG1hcmtlZCBkZWZhdWx0IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIF9nZXREZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgIGJyZWFrczogZmFsc2UsXG4gICAgICAgIGV4dGVuc2lvbnM6IG51bGwsXG4gICAgICAgIGdmbTogdHJ1ZSxcbiAgICAgICAgaG9va3M6IG51bGwsXG4gICAgICAgIHBlZGFudGljOiBmYWxzZSxcbiAgICAgICAgcmVuZGVyZXI6IG51bGwsXG4gICAgICAgIHNpbGVudDogZmFsc2UsXG4gICAgICAgIHRva2VuaXplcjogbnVsbCxcbiAgICAgICAgd2Fsa1Rva2VuczogbnVsbCxcbiAgICB9O1xufVxubGV0IF9kZWZhdWx0cyA9IF9nZXREZWZhdWx0cygpO1xuZnVuY3Rpb24gY2hhbmdlRGVmYXVsdHMobmV3RGVmYXVsdHMpIHtcbiAgICBfZGVmYXVsdHMgPSBuZXdEZWZhdWx0cztcbn1cblxuLyoqXG4gKiBIZWxwZXJzXG4gKi9cbmNvbnN0IGVzY2FwZVRlc3QgPSAvWyY8PlwiJ10vO1xuY29uc3QgZXNjYXBlUmVwbGFjZSA9IG5ldyBSZWdFeHAoZXNjYXBlVGVzdC5zb3VyY2UsICdnJyk7XG5jb25zdCBlc2NhcGVUZXN0Tm9FbmNvZGUgPSAvWzw+XCInXXwmKD8hKCNcXGR7MSw3fXwjW1h4XVthLWZBLUYwLTldezEsNn18XFx3Kyk7KS87XG5jb25zdCBlc2NhcGVSZXBsYWNlTm9FbmNvZGUgPSBuZXcgUmVnRXhwKGVzY2FwZVRlc3ROb0VuY29kZS5zb3VyY2UsICdnJyk7XG5jb25zdCBlc2NhcGVSZXBsYWNlbWVudHMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnLFxufTtcbmNvbnN0IGdldEVzY2FwZVJlcGxhY2VtZW50ID0gKGNoKSA9PiBlc2NhcGVSZXBsYWNlbWVudHNbY2hdO1xuZnVuY3Rpb24gZXNjYXBlJDEoaHRtbCwgZW5jb2RlKSB7XG4gICAgaWYgKGVuY29kZSkge1xuICAgICAgICBpZiAoZXNjYXBlVGVzdC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2UsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGVzY2FwZVRlc3ROb0VuY29kZS50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2VOb0VuY29kZSwgZ2V0RXNjYXBlUmVwbGFjZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xufVxuY29uc3QgY2FyZXQgPSAvKF58W15cXFtdKVxcXi9nO1xuZnVuY3Rpb24gZWRpdChyZWdleCwgb3B0KSB7XG4gICAgbGV0IHNvdXJjZSA9IHR5cGVvZiByZWdleCA9PT0gJ3N0cmluZycgPyByZWdleCA6IHJlZ2V4LnNvdXJjZTtcbiAgICBvcHQgPSBvcHQgfHwgJyc7XG4gICAgY29uc3Qgb2JqID0ge1xuICAgICAgICByZXBsYWNlOiAobmFtZSwgdmFsKSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsU291cmNlID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyB2YWwgOiB2YWwuc291cmNlO1xuICAgICAgICAgICAgdmFsU291cmNlID0gdmFsU291cmNlLnJlcGxhY2UoY2FyZXQsICckMScpO1xuICAgICAgICAgICAgc291cmNlID0gc291cmNlLnJlcGxhY2UobmFtZSwgdmFsU291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFJlZ2V4OiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChzb3VyY2UsIG9wdCk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gY2xlYW5VcmwoaHJlZikge1xuICAgIHRyeSB7XG4gICAgICAgIGhyZWYgPSBlbmNvZGVVUkkoaHJlZikucmVwbGFjZSgvJTI1L2csICclJyk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBocmVmO1xufVxuY29uc3Qgbm9vcFRlc3QgPSB7IGV4ZWM6ICgpID0+IG51bGwgfTtcbmZ1bmN0aW9uIHNwbGl0Q2VsbHModGFibGVSb3csIGNvdW50KSB7XG4gICAgLy8gZW5zdXJlIHRoYXQgZXZlcnkgY2VsbC1kZWxpbWl0aW5nIHBpcGUgaGFzIGEgc3BhY2VcbiAgICAvLyBiZWZvcmUgaXQgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbSBhbiBlc2NhcGVkIHBpcGVcbiAgICBjb25zdCByb3cgPSB0YWJsZVJvdy5yZXBsYWNlKC9cXHwvZywgKG1hdGNoLCBvZmZzZXQsIHN0cikgPT4ge1xuICAgICAgICBsZXQgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY3VyciA9IG9mZnNldDtcbiAgICAgICAgd2hpbGUgKC0tY3VyciA+PSAwICYmIHN0cltjdXJyXSA9PT0gJ1xcXFwnKVxuICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgICAgICAgLy8gb2RkIG51bWJlciBvZiBzbGFzaGVzIG1lYW5zIHwgaXMgZXNjYXBlZFxuICAgICAgICAgICAgLy8gc28gd2UgbGVhdmUgaXQgYWxvbmVcbiAgICAgICAgICAgIHJldHVybiAnfCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhZGQgc3BhY2UgYmVmb3JlIHVuZXNjYXBlZCB8XG4gICAgICAgICAgICByZXR1cm4gJyB8JztcbiAgICAgICAgfVxuICAgIH0pLCBjZWxscyA9IHJvdy5zcGxpdCgvIFxcfC8pO1xuICAgIGxldCBpID0gMDtcbiAgICAvLyBGaXJzdC9sYXN0IGNlbGwgaW4gYSByb3cgY2Fubm90IGJlIGVtcHR5IGlmIGl0IGhhcyBubyBsZWFkaW5nL3RyYWlsaW5nIHBpcGVcbiAgICBpZiAoIWNlbGxzWzBdLnRyaW0oKSkge1xuICAgICAgICBjZWxscy5zaGlmdCgpO1xuICAgIH1cbiAgICBpZiAoY2VsbHMubGVuZ3RoID4gMCAmJiAhY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV0udHJpbSgpKSB7XG4gICAgICAgIGNlbGxzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoY291bnQpIHtcbiAgICAgICAgaWYgKGNlbGxzLmxlbmd0aCA+IGNvdW50KSB7XG4gICAgICAgICAgICBjZWxscy5zcGxpY2UoY291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGNlbGxzLmxlbmd0aCA8IGNvdW50KVxuICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goJycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlIGlzIGlnbm9yZWQgcGVyIHRoZSBnZm0gc3BlY1xuICAgICAgICBjZWxsc1tpXSA9IGNlbGxzW2ldLnRyaW0oKS5yZXBsYWNlKC9cXFxcXFx8L2csICd8Jyk7XG4gICAgfVxuICAgIHJldHVybiBjZWxscztcbn1cbi8qKlxuICogUmVtb3ZlIHRyYWlsaW5nICdjJ3MuIEVxdWl2YWxlbnQgdG8gc3RyLnJlcGxhY2UoL2MqJC8sICcnKS5cbiAqIC9jKiQvIGlzIHZ1bG5lcmFibGUgdG8gUkVET1MuXG4gKlxuICogQHBhcmFtIHN0clxuICogQHBhcmFtIGNcbiAqIEBwYXJhbSBpbnZlcnQgUmVtb3ZlIHN1ZmZpeCBvZiBub24tYyBjaGFycyBpbnN0ZWFkLiBEZWZhdWx0IGZhbHNleS5cbiAqL1xuZnVuY3Rpb24gcnRyaW0oc3RyLCBjLCBpbnZlcnQpIHtcbiAgICBjb25zdCBsID0gc3RyLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8vIExlbmd0aCBvZiBzdWZmaXggbWF0Y2hpbmcgdGhlIGludmVydCBjb25kaXRpb24uXG4gICAgbGV0IHN1ZmZMZW4gPSAwO1xuICAgIC8vIFN0ZXAgbGVmdCB1bnRpbCB3ZSBmYWlsIHRvIG1hdGNoIHRoZSBpbnZlcnQgY29uZGl0aW9uLlxuICAgIHdoaWxlIChzdWZmTGVuIDwgbCkge1xuICAgICAgICBjb25zdCBjdXJyQ2hhciA9IHN0ci5jaGFyQXQobCAtIHN1ZmZMZW4gLSAxKTtcbiAgICAgICAgaWYgKGN1cnJDaGFyID09PSBjICYmICFpbnZlcnQpIHtcbiAgICAgICAgICAgIHN1ZmZMZW4rKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyQ2hhciAhPT0gYyAmJiBpbnZlcnQpIHtcbiAgICAgICAgICAgIHN1ZmZMZW4rKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHIuc2xpY2UoMCwgbCAtIHN1ZmZMZW4pO1xufVxuZnVuY3Rpb24gZmluZENsb3NpbmdCcmFja2V0KHN0ciwgYikge1xuICAgIGlmIChzdHIuaW5kZXhPZihiWzFdKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBsZXQgbGV2ZWwgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJbaV0gPT09ICdcXFxcJykge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0cltpXSA9PT0gYlswXSkge1xuICAgICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHJbaV0gPT09IGJbMV0pIHtcbiAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBvdXRwdXRMaW5rKGNhcCwgbGluaywgcmF3LCBsZXhlcikge1xuICAgIGNvbnN0IGhyZWYgPSBsaW5rLmhyZWY7XG4gICAgY29uc3QgdGl0bGUgPSBsaW5rLnRpdGxlID8gZXNjYXBlJDEobGluay50aXRsZSkgOiBudWxsO1xuICAgIGNvbnN0IHRleHQgPSBjYXBbMV0ucmVwbGFjZSgvXFxcXChbXFxbXFxdXSkvZywgJyQxJyk7XG4gICAgaWYgKGNhcFswXS5jaGFyQXQoMCkgIT09ICchJykge1xuICAgICAgICBsZXhlci5zdGF0ZS5pbkxpbmsgPSB0cnVlO1xuICAgICAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgICAgIHJhdyxcbiAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICB0b2tlbnM6IGxleGVyLmlubGluZVRva2Vucyh0ZXh0KSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgcmF3LFxuICAgICAgICBocmVmLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgdGV4dDogZXNjYXBlJDEodGV4dCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCB0ZXh0KSB7XG4gICAgY29uc3QgbWF0Y2hJbmRlbnRUb0NvZGUgPSByYXcubWF0Y2goL14oXFxzKykoPzpgYGApLyk7XG4gICAgaWYgKG1hdGNoSW5kZW50VG9Db2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBjb25zdCBpbmRlbnRUb0NvZGUgPSBtYXRjaEluZGVudFRvQ29kZVsxXTtcbiAgICByZXR1cm4gdGV4dFxuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC5tYXAobm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoSW5kZW50SW5Ob2RlID0gbm9kZS5tYXRjaCgvXlxccysvKTtcbiAgICAgICAgaWYgKG1hdGNoSW5kZW50SW5Ob2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbaW5kZW50SW5Ob2RlXSA9IG1hdGNoSW5kZW50SW5Ob2RlO1xuICAgICAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zbGljZShpbmRlbnRUb0NvZGUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9KVxuICAgICAgICAuam9pbignXFxuJyk7XG59XG4vKipcbiAqIFRva2VuaXplclxuICovXG5jbGFzcyBfVG9rZW5pemVyIHtcbiAgICBvcHRpb25zO1xuICAgIHJ1bGVzOyAvLyBzZXQgYnkgdGhlIGxleGVyXG4gICAgbGV4ZXI7IC8vIHNldCBieSB0aGUgbGV4ZXJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgIH1cbiAgICBzcGFjZShzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5uZXdsaW5lLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCAmJiBjYXBbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3BhY2UnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb2RlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmNvZGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gY2FwWzBdLnJlcGxhY2UoL14oPzogezEsNH18IHswLDN9XFx0KS9nbSwgJycpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgY29kZUJsb2NrU3R5bGU6ICdpbmRlbnRlZCcsXG4gICAgICAgICAgICAgICAgdGV4dDogIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgICAgICAgICAgICA/IHJ0cmltKHRleHQsICdcXG4nKVxuICAgICAgICAgICAgICAgICAgICA6IHRleHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZlbmNlcyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5mZW5jZXMuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCByYXcgPSBjYXBbMF07XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gaW5kZW50Q29kZUNvbXBlbnNhdGlvbihyYXcsIGNhcFszXSB8fCAnJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgbGFuZzogY2FwWzJdID8gY2FwWzJdLnRyaW0oKS5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLmFueVB1bmN0dWF0aW9uLCAnJDEnKSA6IGNhcFsyXSxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoZWFkaW5nKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmhlYWRpbmcuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IGNhcFsyXS50cmltKCk7XG4gICAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgI3NcbiAgICAgICAgICAgIGlmICgvIyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkID0gcnRyaW0odGV4dCwgJyMnKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0cmltbWVkLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRyaW1tZWQgfHwgLyAkLy50ZXN0KHRyaW1tZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbW1vbk1hcmsgcmVxdWlyZXMgc3BhY2UgYmVmb3JlIHRyYWlsaW5nICNzXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0cmltbWVkLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBkZXB0aDogY2FwWzFdLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUodGV4dCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGhyKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmhyLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHInLFxuICAgICAgICAgICAgICAgIHJhdzogcnRyaW0oY2FwWzBdLCAnXFxuJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGJsb2NrcXVvdGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suYmxvY2txdW90ZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHJ0cmltKGNhcFswXSwgJ1xcbicpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGxldCByYXcgPSAnJztcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgICAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChsaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluQmxvY2txdW90ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgbGluZXMgdXAgdG8gYSBjb250aW51YXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eIHswLDN9Pi8udGVzdChsaW5lc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lcy5wdXNoKGxpbmVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQmxvY2txdW90ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWluQmxvY2txdW90ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmVzLnB1c2gobGluZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZXMgPSBsaW5lcy5zbGljZShpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UmF3ID0gY3VycmVudExpbmVzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUZXh0ID0gY3VycmVudFJhd1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmVjZWRlIHNldGV4dCBjb250aW51YXRpb24gd2l0aCA0IHNwYWNlcyBzbyBpdCBpc24ndCBhIHNldGV4dFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxuIHswLDN9KCg/Oj0rfC0rKSAqKSg/PVxcbnwkKS9nLCAnXFxuICAgICQxJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL14gezAsM30+WyBcXHRdPy9nbSwgJycpO1xuICAgICAgICAgICAgICAgIHJhdyA9IHJhdyA/IGAke3Jhd31cXG4ke2N1cnJlbnRSYXd9YCA6IGN1cnJlbnRSYXc7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQgPyBgJHt0ZXh0fVxcbiR7Y3VycmVudFRleHR9YCA6IGN1cnJlbnRUZXh0O1xuICAgICAgICAgICAgICAgIC8vIHBhcnNlIGJsb2NrcXVvdGUgbGluZXMgYXMgdG9wIGxldmVsIHRva2Vuc1xuICAgICAgICAgICAgICAgIC8vIG1lcmdlIHBhcmFncmFwaHMgaWYgdGhpcyBpcyBhIGNvbnRpbnVhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHRvcCA9IHRoaXMubGV4ZXIuc3RhdGUudG9wO1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLmJsb2NrVG9rZW5zKGN1cnJlbnRUZXh0LCB0b2tlbnMsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gdG9wO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGNvbnRpbnVhdGlvbiB0aGVuIHdlIGFyZSBkb25lXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuPy50eXBlID09PSAnY29kZScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmxvY2txdW90ZSBjb250aW51YXRpb24gY2Fubm90IGJlIHByZWNlZGVkIGJ5IGEgY29kZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGFzdFRva2VuPy50eXBlID09PSAnYmxvY2txdW90ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jbHVkZSBjb250aW51YXRpb24gaW4gbmVzdGVkIGJsb2NrcXVvdGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkVG9rZW4gPSBsYXN0VG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RleHQgPSBvbGRUb2tlbi5yYXcgKyAnXFxuJyArIGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdUb2tlbiA9IHRoaXMuYmxvY2txdW90ZShuZXdUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSA9IG5ld1Rva2VuO1xuICAgICAgICAgICAgICAgICAgICByYXcgPSByYXcuc3Vic3RyaW5nKDAsIHJhdy5sZW5ndGggLSBvbGRUb2tlbi5yYXcubGVuZ3RoKSArIG5ld1Rva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHRleHQubGVuZ3RoIC0gb2xkVG9rZW4udGV4dC5sZW5ndGgpICsgbmV3VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxhc3RUb2tlbj8udHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluY2x1ZGUgY29udGludWF0aW9uIGluIG5lc3RlZCBsaXN0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFRva2VuID0gbGFzdFRva2VuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdUZXh0ID0gb2xkVG9rZW4ucmF3ICsgJ1xcbicgKyBsaW5lcy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VG9rZW4gPSB0aGlzLmxpc3QobmV3VGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0gPSBuZXdUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgcmF3ID0gcmF3LnN1YnN0cmluZygwLCByYXcubGVuZ3RoIC0gbGFzdFRva2VuLnJhdy5sZW5ndGgpICsgbmV3VG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgdGV4dC5sZW5ndGggLSBvbGRUb2tlbi5yYXcubGVuZ3RoKSArIG5ld1Rva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGluZXMgPSBuZXdUZXh0LnN1YnN0cmluZyh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnJhdy5sZW5ndGgpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2txdW90ZScsXG4gICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaXN0KHNyYykge1xuICAgICAgICBsZXQgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5saXN0LmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IGJ1bGwgPSBjYXBbMV0udHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgaXNvcmRlcmVkID0gYnVsbC5sZW5ndGggPiAxO1xuICAgICAgICAgICAgY29uc3QgbGlzdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgICAgICAgICAgcmF3OiAnJyxcbiAgICAgICAgICAgICAgICBvcmRlcmVkOiBpc29yZGVyZWQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGlzb3JkZXJlZCA/ICtidWxsLnNsaWNlKDAsIC0xKSA6ICcnLFxuICAgICAgICAgICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpdGVtczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnVsbCA9IGlzb3JkZXJlZCA/IGBcXFxcZHsxLDl9XFxcXCR7YnVsbC5zbGljZSgtMSl9YCA6IGBcXFxcJHtidWxsfWA7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICAgICAgYnVsbCA9IGlzb3JkZXJlZCA/IGJ1bGwgOiAnWyorLV0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IG5leHQgbGlzdCBpdGVtXG4gICAgICAgICAgICBjb25zdCBpdGVtUmVnZXggPSBuZXcgUmVnRXhwKGBeKCB7MCwzfSR7YnVsbH0pKCg/OltcXHQgXVteXFxcXG5dKik/KD86XFxcXG58JCkpYCk7XG4gICAgICAgICAgICBsZXQgZW5kc1dpdGhCbGFua0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgYnVsbGV0IHBvaW50IGNhbiBzdGFydCBhIG5ldyBMaXN0IEl0ZW1cbiAgICAgICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kRWFybHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgcmF3ID0gJyc7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1Db250ZW50cyA9ICcnO1xuICAgICAgICAgICAgICAgIGlmICghKGNhcCA9IGl0ZW1SZWdleC5leGVjKHNyYykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ydWxlcy5ibG9jay5oci50ZXN0KHNyYykpIHsgLy8gRW5kIGxpc3QgaWYgYnVsbGV0IHdhcyBhY3R1YWxseSBIUiAocG9zc2libHkgbW92ZSBpbnRvIGl0ZW1SZWdleD8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByYXcgPSBjYXBbMF07XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhyYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGNhcFsyXS5zcGxpdCgnXFxuJywgMSlbMF0ucmVwbGFjZSgvXlxcdCsvLCAodCkgPT4gJyAnLnJlcGVhdCgzICogdC5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dExpbmUgPSBzcmMuc3BsaXQoJ1xcbicsIDEpWzBdO1xuICAgICAgICAgICAgICAgIGxldCBibGFua0xpbmUgPSAhbGluZS50cmltKCk7XG4gICAgICAgICAgICAgICAgbGV0IGluZGVudCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICBpdGVtQ29udGVudHMgPSBsaW5lLnRyaW1TdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChibGFua0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gY2FwWzFdLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgPSBjYXBbMl0uc2VhcmNoKC9bXiBdLyk7IC8vIEZpbmQgZmlyc3Qgbm9uLXNwYWNlIGNoYXJcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gaW5kZW50ID4gNCA/IDEgOiBpbmRlbnQ7IC8vIFRyZWF0IGluZGVudGVkIGNvZGUgYmxvY2tzICg+IDQgc3BhY2VzKSBhcyBoYXZpbmcgb25seSAxIGluZGVudFxuICAgICAgICAgICAgICAgICAgICBpdGVtQ29udGVudHMgPSBsaW5lLnNsaWNlKGluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSBjYXBbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmxhbmtMaW5lICYmIC9eWyBcXHRdKiQvLnRlc3QobmV4dExpbmUpKSB7IC8vIEl0ZW1zIGJlZ2luIHdpdGggYXQgbW9zdCBvbmUgYmxhbmsgbGluZVxuICAgICAgICAgICAgICAgICAgICByYXcgKz0gbmV4dExpbmUgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhuZXh0TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kRWFybHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVuZEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRCdWxsZXRSZWdleCA9IG5ldyBSZWdFeHAoYF4gezAsJHtNYXRoLm1pbigzLCBpbmRlbnQgLSAxKX19KD86WyorLV18XFxcXGR7MSw5fVsuKV0pKCg/OlsgXFx0XVteXFxcXG5dKik/KD86XFxcXG58JCkpYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhyUmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSgoPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXFxcKiAqKXszLH0pKD86XFxcXG4rfCQpYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlbmNlc0JlZ2luUmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSg/OlxcYFxcYFxcYHx+fn4pYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRpbmdCZWdpblJlZ2V4ID0gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0jYCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGZvbGxvd2luZyBsaW5lcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gTGlzdCBJdGVtXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd0xpbmUgPSBzcmMuc3BsaXQoJ1xcbicsIDEpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRMaW5lV2l0aG91dFRhYnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0TGluZSA9IHJhd0xpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZS1hbGlnbiB0byBmb2xsb3cgY29tbW9ubWFyayBuZXN0aW5nIHJ1bGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUgPSBuZXh0TGluZS5yZXBsYWNlKC9eIHsxLDR9KD89KCB7NH0pKlteIF0pL2csICcgICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRMaW5lV2l0aG91dFRhYnMgPSBuZXh0TGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRMaW5lV2l0aG91dFRhYnMgPSBuZXh0TGluZS5yZXBsYWNlKC9cXHQvZywgJyAgICAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZCBsaXN0IGl0ZW0gaWYgZm91bmQgY29kZSBmZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZW5jZXNCZWdpblJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIG5ldyBoZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGluZ0JlZ2luUmVnZXgudGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZCBsaXN0IGl0ZW0gaWYgZm91bmQgc3RhcnQgb2YgbmV3IGJ1bGxldFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRCdWxsZXRSZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBydWxlIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHJSZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRMaW5lV2l0aG91dFRhYnMuc2VhcmNoKC9bXiBdLykgPj0gaW5kZW50IHx8ICFuZXh0TGluZS50cmltKCkpIHsgLy8gRGVkZW50IGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzICs9ICdcXG4nICsgbmV4dExpbmVXaXRob3V0VGFicy5zbGljZShpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGVub3VnaCBpbmRlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibGFua0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcmFncmFwaCBjb250aW51YXRpb24gdW5sZXNzIGxhc3QgbGluZSB3YXMgYSBkaWZmZXJlbnQgYmxvY2sgbGV2ZWwgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnJlcGxhY2UoL1xcdC9nLCAnICAgICcpLnNlYXJjaCgvW14gXS8pID49IDQpIHsgLy8gaW5kZW50ZWQgY29kZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlbmNlc0JlZ2luUmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRpbmdCZWdpblJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoclJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIG5leHRMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFibGFua0xpbmUgJiYgIW5leHRMaW5lLnRyaW0oKSkgeyAvLyBDaGVjayBpZiBjdXJyZW50IGxpbmUgaXMgYmxhbmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3ICs9IHJhd0xpbmUgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBuZXh0TGluZVdpdGhvdXRUYWJzLnNsaWNlKGluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBpdGVtIGVuZGVkIHdpdGggYSBibGFuayBsaW5lLCB0aGUgbGlzdCBpcyBsb29zZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kc1dpdGhCbGFua0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QubG9vc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9cXG5bIFxcdF0qXFxuWyBcXHRdKiQvLnRlc3QocmF3KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kc1dpdGhCbGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpc3Rhc2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBpc2NoZWNrZWQ7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRhc2sgbGlzdCBpdGVtc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzdGFzayA9IC9eXFxbWyB4WF1cXF0gLy5leGVjKGl0ZW1Db250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc3Rhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzY2hlY2tlZCA9IGlzdGFza1swXSAhPT0gJ1sgXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gaXRlbUNvbnRlbnRzLnJlcGxhY2UoL15cXFtbIHhYXVxcXSArLywgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3QuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXN0X2l0ZW0nLFxuICAgICAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgICAgIHRhc2s6ICEhaXN0YXNrLFxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBpc2NoZWNrZWQsXG4gICAgICAgICAgICAgICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogaXRlbUNvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IFtdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxpc3QucmF3ICs9IHJhdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvIG5vdCBjb25zdW1lIG5ld2xpbmVzIGF0IGVuZCBvZiBmaW5hbCBpdGVtLiBBbHRlcm5hdGl2ZWx5LCBtYWtlIGl0ZW1SZWdleCAqc3RhcnQqIHdpdGggYW55IG5ld2xpbmVzIHRvIHNpbXBsaWZ5L3NwZWVkIHVwIGVuZHNXaXRoQmxhbmtMaW5lIGxvZ2ljXG4gICAgICAgICAgICBsaXN0Lml0ZW1zW2xpc3QuaXRlbXMubGVuZ3RoIC0gMV0ucmF3ID0gbGlzdC5pdGVtc1tsaXN0Lml0ZW1zLmxlbmd0aCAtIDFdLnJhdy50cmltRW5kKCk7XG4gICAgICAgICAgICBsaXN0Lml0ZW1zW2xpc3QuaXRlbXMubGVuZ3RoIC0gMV0udGV4dCA9IGxpc3QuaXRlbXNbbGlzdC5pdGVtcy5sZW5ndGggLSAxXS50ZXh0LnRyaW1FbmQoKTtcbiAgICAgICAgICAgIGxpc3QucmF3ID0gbGlzdC5yYXcudHJpbUVuZCgpO1xuICAgICAgICAgICAgLy8gSXRlbSBjaGlsZCB0b2tlbnMgaGFuZGxlZCBoZXJlIGF0IGVuZCBiZWNhdXNlIHdlIG5lZWRlZCB0byBoYXZlIHRoZSBmaW5hbCBpdGVtIHRvIHRyaW0gaXQgZmlyc3RcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGlzdC5pdGVtc1tpXS50b2tlbnMgPSB0aGlzLmxleGVyLmJsb2NrVG9rZW5zKGxpc3QuaXRlbXNbaV0udGV4dCwgW10pO1xuICAgICAgICAgICAgICAgIGlmICghbGlzdC5sb29zZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBsaXN0IHNob3VsZCBiZSBsb29zZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGFjZXJzID0gbGlzdC5pdGVtc1tpXS50b2tlbnMuZmlsdGVyKHQgPT4gdC50eXBlID09PSAnc3BhY2UnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzTXVsdGlwbGVMaW5lQnJlYWtzID0gc3BhY2Vycy5sZW5ndGggPiAwICYmIHNwYWNlcnMuc29tZSh0ID0+IC9cXG4uKlxcbi8udGVzdCh0LnJhdykpO1xuICAgICAgICAgICAgICAgICAgICBsaXN0Lmxvb3NlID0gaGFzTXVsdGlwbGVMaW5lQnJlYWtzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCBhbGwgaXRlbXMgdG8gbG9vc2UgaWYgbGlzdCBpcyBsb29zZVxuICAgICAgICAgICAgaWYgKGxpc3QubG9vc2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5pdGVtc1tpXS5sb29zZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaHRtbChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5odG1sLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgICAgIGJsb2NrOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHByZTogY2FwWzFdID09PSAncHJlJyB8fCBjYXBbMV0gPT09ICdzY3JpcHQnIHx8IGNhcFsxXSA9PT0gJ3N0eWxlJyxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlZihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5kZWYuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBjYXBbMV0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICAgICAgICBjb25zdCBocmVmID0gY2FwWzJdID8gY2FwWzJdLnJlcGxhY2UoL148KC4qKT4kLywgJyQxJykucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnN1YnN0cmluZygxLCBjYXBbM10ubGVuZ3RoIC0gMSkucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiBjYXBbM107XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdkZWYnLFxuICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0YWJsZShzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay50YWJsZS5leGVjKHNyYyk7XG4gICAgICAgIGlmICghY2FwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEvWzp8XS8udGVzdChjYXBbMl0pKSB7XG4gICAgICAgICAgICAvLyBkZWxpbWl0ZXIgcm93IG11c3QgaGF2ZSBhIHBpcGUgKHwpIG9yIGNvbG9uICg6KSBvdGhlcndpc2UgaXQgaXMgYSBzZXRleHQgaGVhZGluZ1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBzcGxpdENlbGxzKGNhcFsxXSk7XG4gICAgICAgIGNvbnN0IGFsaWducyA9IGNhcFsyXS5yZXBsYWNlKC9eXFx8fFxcfCAqJC9nLCAnJykuc3BsaXQoJ3wnKTtcbiAgICAgICAgY29uc3Qgcm93cyA9IGNhcFszXSAmJiBjYXBbM10udHJpbSgpID8gY2FwWzNdLnJlcGxhY2UoL1xcblsgXFx0XSokLywgJycpLnNwbGl0KCdcXG4nKSA6IFtdO1xuICAgICAgICBjb25zdCBpdGVtID0ge1xuICAgICAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgaGVhZGVyOiBbXSxcbiAgICAgICAgICAgIGFsaWduOiBbXSxcbiAgICAgICAgICAgIHJvd3M6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGVhZGVycy5sZW5ndGggIT09IGFsaWducy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGhlYWRlciBhbmQgYWxpZ24gY29sdW1ucyBtdXN0IGJlIGVxdWFsLCByb3dzIGNhbiBiZSBkaWZmZXJlbnQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBhbGlnbiBvZiBhbGlnbnMpIHtcbiAgICAgICAgICAgIGlmICgvXiAqLSs6ICokLy50ZXN0KGFsaWduKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ24ucHVzaCgncmlnaHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGFsaWduKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ24ucHVzaCgnY2VudGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGFsaWduKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ24ucHVzaCgnbGVmdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbS5hbGlnbi5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaXRlbS5oZWFkZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgdGV4dDogaGVhZGVyc1tpXSxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGhlYWRlcnNbaV0pLFxuICAgICAgICAgICAgICAgIGhlYWRlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhbGlnbjogaXRlbS5hbGlnbltpXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgICAgIGl0ZW0ucm93cy5wdXNoKHNwbGl0Q2VsbHMocm93LCBpdGVtLmhlYWRlci5sZW5ndGgpLm1hcCgoY2VsbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGNlbGwsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUoY2VsbCksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFsaWduOiBpdGVtLmFsaWduW2ldLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgIGxoZWFkaW5nKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxoZWFkaW5nLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgZGVwdGg6IGNhcFsyXS5jaGFyQXQoMCkgPT09ICc9JyA/IDEgOiAyLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFsxXSxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNhcFsxXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcmFncmFwaChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5wYXJhZ3JhcGguZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gY2FwWzFdLmNoYXJBdChjYXBbMV0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nXG4gICAgICAgICAgICAgICAgPyBjYXBbMV0uc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAgICAgOiBjYXBbMV07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZSh0ZXh0KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGV4dChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay50ZXh0LmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dDogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUoY2FwWzBdKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXNjYXBlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5lc2NhcGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQ6IGVzY2FwZSQxKGNhcFsxXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRhZyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGFnLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxleGVyLnN0YXRlLmluTGluayAmJiAvXjxhIC9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rICYmIC9ePFxcL2E+L2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrICYmIC9ePChwcmV8Y29kZXxrYmR8c2NyaXB0KShcXHN8PikvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrICYmIC9ePFxcLyhwcmV8Y29kZXxrYmR8c2NyaXB0KShcXHN8PikvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGluTGluazogdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmssXG4gICAgICAgICAgICAgICAgaW5SYXdCbG9jazogdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrLFxuICAgICAgICAgICAgICAgIGJsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpbmsoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmxpbmsuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0cmltbWVkVXJsID0gY2FwWzJdLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLnBlZGFudGljICYmIC9ePC8udGVzdCh0cmltbWVkVXJsKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbW1vbm1hcmsgcmVxdWlyZXMgbWF0Y2hpbmcgYW5nbGUgYnJhY2tldHNcbiAgICAgICAgICAgICAgICBpZiAoISgvPiQvLnRlc3QodHJpbW1lZFVybCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZW5kaW5nIGFuZ2xlIGJyYWNrZXQgY2Fubm90IGJlIGVzY2FwZWRcbiAgICAgICAgICAgICAgICBjb25zdCBydHJpbVNsYXNoID0gcnRyaW0odHJpbW1lZFVybC5zbGljZSgwLCAtMSksICdcXFxcJyk7XG4gICAgICAgICAgICAgICAgaWYgKCh0cmltbWVkVXJsLmxlbmd0aCAtIHJ0cmltU2xhc2gubGVuZ3RoKSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgY2xvc2luZyBwYXJlbnRoZXNpc1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RQYXJlbkluZGV4ID0gZmluZENsb3NpbmdCcmFja2V0KGNhcFsyXSwgJygpJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQYXJlbkluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBjYXBbMF0uaW5kZXhPZignIScpID09PSAwID8gNSA6IDQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtMZW4gPSBzdGFydCArIGNhcFsxXS5sZW5ndGggKyBsYXN0UGFyZW5JbmRleDtcbiAgICAgICAgICAgICAgICAgICAgY2FwWzJdID0gY2FwWzJdLnN1YnN0cmluZygwLCBsYXN0UGFyZW5JbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGNhcFswXSA9IGNhcFswXS5zdWJzdHJpbmcoMCwgbGlua0xlbikudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBjYXBbM10gPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaHJlZiA9IGNhcFsyXTtcbiAgICAgICAgICAgIGxldCB0aXRsZSA9ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICAgIC8vIHNwbGl0IHBlZGFudGljIGhyZWYgYW5kIHRpdGxlXG4gICAgICAgICAgICAgICAgY29uc3QgbGluayA9IC9eKFteJ1wiXSpbXlxcc10pXFxzKyhbJ1wiXSkoLiopXFwyLy5leGVjKGhyZWYpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWYgPSBsaW5rWzFdO1xuICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IGxpbmtbM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGl0bGUgPSBjYXBbM10gPyBjYXBbM10uc2xpY2UoMSwgLTEpIDogJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBocmVmID0gaHJlZi50cmltKCk7XG4gICAgICAgICAgICBpZiAoL148Ly50ZXN0KGhyZWYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYyAmJiAhKC8+JC8udGVzdCh0cmltbWVkVXJsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGVkYW50aWMgYWxsb3dzIHN0YXJ0aW5nIGFuZ2xlIGJyYWNrZXQgd2l0aG91dCBlbmRpbmcgYW5nbGUgYnJhY2tldFxuICAgICAgICAgICAgICAgICAgICBocmVmID0gaHJlZi5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0TGluayhjYXAsIHtcbiAgICAgICAgICAgICAgICBocmVmOiBocmVmID8gaHJlZi5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLmFueVB1bmN0dWF0aW9uLCAnJDEnKSA6IGhyZWYsXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlID8gdGl0bGUucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiB0aXRsZSxcbiAgICAgICAgICAgIH0sIGNhcFswXSwgdGhpcy5sZXhlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmbGluayhzcmMsIGxpbmtzKSB7XG4gICAgICAgIGxldCBjYXA7XG4gICAgICAgIGlmICgoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgICAgICB8fCAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUubm9saW5rLmV4ZWMoc3JjKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtTdHJpbmcgPSAoY2FwWzJdIHx8IGNhcFsxXSkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgICAgICAgY29uc3QgbGluayA9IGxpbmtzW2xpbmtTdHJpbmcudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gY2FwWzBdLmNoYXJBdCgwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCBsaW5rLCBjYXBbMF0sIHRoaXMubGV4ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtU3Ryb25nKHNyYywgbWFza2VkU3JjLCBwcmV2Q2hhciA9ICcnKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nTERlbGltLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gXyBjYW4ndCBiZSBiZXR3ZWVuIHR3byBhbHBoYW51bWVyaWNzLiBcXHB7TH1cXHB7Tn0gaW5jbHVkZXMgbm9uLWVuZ2xpc2ggYWxwaGFiZXQvbnVtYmVycyBhcyB3ZWxsXG4gICAgICAgIGlmIChtYXRjaFszXSAmJiBwcmV2Q2hhci5tYXRjaCgvW1xccHtMfVxccHtOfV0vdSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG5leHRDaGFyID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgJyc7XG4gICAgICAgIGlmICghbmV4dENoYXIgfHwgIXByZXZDaGFyIHx8IHRoaXMucnVsZXMuaW5saW5lLnB1bmN0dWF0aW9uLmV4ZWMocHJldkNoYXIpKSB7XG4gICAgICAgICAgICAvLyB1bmljb2RlIFJlZ2V4IGNvdW50cyBlbW9qaSBhcyAxIGNoYXI7IHNwcmVhZCBpbnRvIGFycmF5IGZvciBwcm9wZXIgY291bnQgKHVzZWQgbXVsdGlwbGUgdGltZXMgYmVsb3cpXG4gICAgICAgICAgICBjb25zdCBsTGVuZ3RoID0gWy4uLm1hdGNoWzBdXS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgbGV0IHJEZWxpbSwgckxlbmd0aCwgZGVsaW1Ub3RhbCA9IGxMZW5ndGgsIG1pZERlbGltVG90YWwgPSAwO1xuICAgICAgICAgICAgY29uc3QgZW5kUmVnID0gbWF0Y2hbMF1bMF0gPT09ICcqJyA/IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nUkRlbGltQXN0IDogdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmdSRGVsaW1VbmQ7XG4gICAgICAgICAgICBlbmRSZWcubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIC8vIENsaXAgbWFza2VkU3JjIHRvIHNhbWUgc2VjdGlvbiBvZiBzdHJpbmcgYXMgc3JjIChtb3ZlIHRvIGxleGVyPylcbiAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgtMSAqIHNyYy5sZW5ndGggKyBsTGVuZ3RoKTtcbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBlbmRSZWcuZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgckRlbGltID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgbWF0Y2hbNl07XG4gICAgICAgICAgICAgICAgaWYgKCFyRGVsaW0pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBza2lwIHNpbmdsZSAqIGluIF9fYWJjKmFiY19fXG4gICAgICAgICAgICAgICAgckxlbmd0aCA9IFsuLi5yRGVsaW1dLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbM10gfHwgbWF0Y2hbNF0pIHsgLy8gZm91bmQgYW5vdGhlciBMZWZ0IERlbGltXG4gICAgICAgICAgICAgICAgICAgIGRlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoWzVdIHx8IG1hdGNoWzZdKSB7IC8vIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltXG4gICAgICAgICAgICAgICAgICAgIGlmIChsTGVuZ3RoICUgMyAmJiAhKChsTGVuZ3RoICsgckxlbmd0aCkgJSAzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlkRGVsaW1Ub3RhbCArPSByTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIENvbW1vbk1hcmsgRW1waGFzaXMgUnVsZXMgOS0xMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGltVG90YWwgLT0gckxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoZGVsaW1Ub3RhbCA+IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBIYXZlbid0IGZvdW5kIGVub3VnaCBjbG9zaW5nIGRlbGltaXRlcnNcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZXh0cmEgY2hhcmFjdGVycy4gKmEqKiogLT4gKmEqXG4gICAgICAgICAgICAgICAgckxlbmd0aCA9IE1hdGgubWluKHJMZW5ndGgsIHJMZW5ndGggKyBkZWxpbVRvdGFsICsgbWlkRGVsaW1Ub3RhbCk7XG4gICAgICAgICAgICAgICAgLy8gY2hhciBsZW5ndGggY2FuIGJlID4xIGZvciB1bmljb2RlIGNoYXJhY3RlcnM7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdENoYXJMZW5ndGggPSBbLi4ubWF0Y2hbMF1dWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCByYXcgPSBzcmMuc2xpY2UoMCwgbExlbmd0aCArIG1hdGNoLmluZGV4ICsgbGFzdENoYXJMZW5ndGggKyByTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYGVtYCBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIG9kZCBjaGFyIGNvdW50LiAqYSoqKlxuICAgICAgICAgICAgICAgIGlmIChNYXRoLm1pbihsTGVuZ3RoLCByTGVuZ3RoKSAlIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IHJhdy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSAnc3Ryb25nJyBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIGV2ZW4gY2hhciBjb3VudC4gKiphKioqXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IHJhdy5zbGljZSgyLCAtMik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cm9uZycsXG4gICAgICAgICAgICAgICAgICAgIHJhdyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZVRva2Vucyh0ZXh0KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvZGVzcGFuKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5jb2RlLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBjYXBbMl0ucmVwbGFjZSgvXFxuL2csICcgJyk7XG4gICAgICAgICAgICBjb25zdCBoYXNOb25TcGFjZUNoYXJzID0gL1teIF0vLnRlc3QodGV4dCk7XG4gICAgICAgICAgICBjb25zdCBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcyA9IC9eIC8udGVzdCh0ZXh0KSAmJiAvICQvLnRlc3QodGV4dCk7XG4gICAgICAgICAgICBpZiAoaGFzTm9uU3BhY2VDaGFycyAmJiBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcykge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygxLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dCA9IGVzY2FwZSQxKHRleHQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29kZXNwYW4nLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGJyKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5ici5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2JyJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5kZWwuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdkZWwnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFsyXSxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKGNhcFsyXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGF1dG9saW5rKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5hdXRvbGluay5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCB0ZXh0LCBocmVmO1xuICAgICAgICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZSQxKGNhcFsxXSk7XG4gICAgICAgICAgICAgICAgaHJlZiA9ICdtYWlsdG86JyArIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlJDEoY2FwWzFdKTtcbiAgICAgICAgICAgICAgICBocmVmID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICB0b2tlbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cmwoc3JjKSB7XG4gICAgICAgIGxldCBjYXA7XG4gICAgICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS51cmwuZXhlYyhzcmMpKSB7XG4gICAgICAgICAgICBsZXQgdGV4dCwgaHJlZjtcbiAgICAgICAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgIHRleHQgPSBlc2NhcGUkMShjYXBbMF0pO1xuICAgICAgICAgICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gZXh0ZW5kZWQgYXV0b2xpbmsgcGF0aCB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgbGV0IHByZXZDYXBaZXJvO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldkNhcFplcm8gPSBjYXBbMF07XG4gICAgICAgICAgICAgICAgICAgIGNhcFswXSA9IHRoaXMucnVsZXMuaW5saW5lLl9iYWNrcGVkYWwuZXhlYyhjYXBbMF0pPy5bMF0gPz8gJyc7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocHJldkNhcFplcm8gIT09IGNhcFswXSk7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZSQxKGNhcFswXSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWYgPSAnaHR0cDovLycgKyBjYXBbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gY2FwWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICB0b2tlbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmxpbmVUZXh0KHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS50ZXh0LmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGNhcFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBlc2NhcGUkMShjYXBbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQmxvY2stTGV2ZWwgR3JhbW1hclxuICovXG5jb25zdCBuZXdsaW5lID0gL14oPzpbIFxcdF0qKD86XFxufCQpKSsvO1xuY29uc3QgYmxvY2tDb2RlID0gL14oKD86IHs0fXwgezAsM31cXHQpW15cXG5dKyg/Olxcbig/OlsgXFx0XSooPzpcXG58JCkpKik/KSsvO1xuY29uc3QgZmVuY2VzID0gL14gezAsM30oYHszLH0oPz1bXmBcXG5dKig/OlxcbnwkKSl8fnszLH0pKFteXFxuXSopKD86XFxufCQpKD86fChbXFxzXFxTXSo/KSg/OlxcbnwkKSkoPzogezAsM31cXDFbfmBdKiAqKD89XFxufCQpfCQpLztcbmNvbnN0IGhyID0gL14gezAsM30oKD86LVtcXHQgXSopezMsfXwoPzpfWyBcXHRdKil7Myx9fCg/OlxcKlsgXFx0XSopezMsfSkoPzpcXG4rfCQpLztcbmNvbnN0IGhlYWRpbmcgPSAvXiB7MCwzfSgjezEsNn0pKD89XFxzfCQpKC4qKSg/Olxcbit8JCkvO1xuY29uc3QgYnVsbGV0ID0gLyg/OlsqKy1dfFxcZHsxLDl9Wy4pXSkvO1xuY29uc3QgbGhlYWRpbmcgPSBlZGl0KC9eKD8hYnVsbCB8YmxvY2tDb2RlfGZlbmNlc3xibG9ja3F1b3RlfGhlYWRpbmd8aHRtbCkoKD86LnxcXG4oPyFcXHMqP1xcbnxidWxsIHxibG9ja0NvZGV8ZmVuY2VzfGJsb2NrcXVvdGV8aGVhZGluZ3xodG1sKSkrPylcXG4gezAsM30oPSt8LSspICooPzpcXG4rfCQpLylcbiAgICAucmVwbGFjZSgvYnVsbC9nLCBidWxsZXQpIC8vIGxpc3RzIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgvYmxvY2tDb2RlL2csIC8oPzogezR9fCB7MCwzfVxcdCkvKSAvLyBpbmRlbnRlZCBjb2RlIGJsb2NrcyBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoL2ZlbmNlcy9nLCAvIHswLDN9KD86YHszLH18fnszLH0pLykgLy8gZmVuY2VkIGNvZGUgYmxvY2tzIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgvYmxvY2txdW90ZS9nLCAvIHswLDN9Pi8pIC8vIGJsb2NrcXVvdGUgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKC9oZWFkaW5nL2csIC8gezAsM30jezEsNn0vKSAvLyBBVFggaGVhZGluZyBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoL2h0bWwvZywgLyB7MCwzfTxbXlxcbj5dKz5cXG4vKSAvLyBibG9jayBodG1sIGNhbiBpbnRlcnJ1cHRcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IF9wYXJhZ3JhcGggPSAvXihbXlxcbl0rKD86XFxuKD8haHJ8aGVhZGluZ3xsaGVhZGluZ3xibG9ja3F1b3RlfGZlbmNlc3xsaXN0fGh0bWx8dGFibGV8ICtcXG4pW15cXG5dKykqKS87XG5jb25zdCBibG9ja1RleHQgPSAvXlteXFxuXSsvO1xuY29uc3QgX2Jsb2NrTGFiZWwgPSAvKD8hXFxzKlxcXSkoPzpcXFxcLnxbXlxcW1xcXVxcXFxdKSsvO1xuY29uc3QgZGVmID0gZWRpdCgvXiB7MCwzfVxcWyhsYWJlbClcXF06ICooPzpcXG5bIFxcdF0qKT8oW148XFxzXVteXFxzXSp8PC4qPz4pKD86KD86ICsoPzpcXG5bIFxcdF0qKT98ICpcXG5bIFxcdF0qKSh0aXRsZSkpPyAqKD86XFxuK3wkKS8pXG4gICAgLnJlcGxhY2UoJ2xhYmVsJywgX2Jsb2NrTGFiZWwpXG4gICAgLnJlcGxhY2UoJ3RpdGxlJywgLyg/OlwiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCdbXidcXG5dKig/OlxcblteJ1xcbl0rKSpcXG4/J3xcXChbXigpXSpcXCkpLylcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IGxpc3QgPSBlZGl0KC9eKCB7MCwzfWJ1bGwpKFsgXFx0XVteXFxuXSs/KT8oPzpcXG58JCkvKVxuICAgIC5yZXBsYWNlKC9idWxsL2csIGJ1bGxldClcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IF90YWcgPSAnYWRkcmVzc3xhcnRpY2xlfGFzaWRlfGJhc2V8YmFzZWZvbnR8YmxvY2txdW90ZXxib2R5fGNhcHRpb24nXG4gICAgKyAnfGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9uJ1xuICAgICsgJ3xmaWd1cmV8Zm9vdGVyfGZvcm18ZnJhbWV8ZnJhbWVzZXR8aFsxLTZdfGhlYWR8aGVhZGVyfGhyfGh0bWx8aWZyYW1lJ1xuICAgICsgJ3xsZWdlbmR8bGl8bGlua3xtYWlufG1lbnV8bWVudWl0ZW18bWV0YXxuYXZ8bm9mcmFtZXN8b2x8b3B0Z3JvdXB8b3B0aW9uJ1xuICAgICsgJ3xwfHBhcmFtfHNlYXJjaHxzZWN0aW9ufHN1bW1hcnl8dGFibGV8dGJvZHl8dGR8dGZvb3R8dGh8dGhlYWR8dGl0bGUnXG4gICAgKyAnfHRyfHRyYWNrfHVsJztcbmNvbnN0IF9jb21tZW50ID0gLzwhLS0oPzotPz58W1xcc1xcU10qPyg/Oi0tPnwkKSkvO1xuY29uc3QgaHRtbCA9IGVkaXQoJ14gezAsM30oPzonIC8vIG9wdGlvbmFsIGluZGVudGF0aW9uXG4gICAgKyAnPChzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVtcXFxccz5dW1xcXFxzXFxcXFNdKj8oPzo8L1xcXFwxPlteXFxcXG5dKlxcXFxuK3wkKScgLy8gKDEpXG4gICAgKyAnfGNvbW1lbnRbXlxcXFxuXSooXFxcXG4rfCQpJyAvLyAoMilcbiAgICArICd8PFxcXFw/W1xcXFxzXFxcXFNdKj8oPzpcXFxcPz5cXFxcbip8JCknIC8vICgzKVxuICAgICsgJ3w8IVtBLVpdW1xcXFxzXFxcXFNdKj8oPzo+XFxcXG4qfCQpJyAvLyAoNClcbiAgICArICd8PCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qPyg/OlxcXFxdXFxcXF0+XFxcXG4qfCQpJyAvLyAoNSlcbiAgICArICd8PC8/KHRhZykoPzogK3xcXFxcbnwvPz4pW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcblsgXFx0XSopK1xcXFxufCQpJyAvLyAoNilcbiAgICArICd8PCg/IXNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpKFthLXpdW1xcXFx3LV0qKSg/OmF0dHJpYnV0ZSkqPyAqLz8+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcblsgXFx0XSopK1xcXFxufCQpJyAvLyAoNykgb3BlbiB0YWdcbiAgICArICd8PC8oPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVthLXpdW1xcXFx3LV0qXFxcXHMqPig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG5bIFxcdF0qKStcXFxcbnwkKScgLy8gKDcpIGNsb3NpbmcgdGFnXG4gICAgKyAnKScsICdpJylcbiAgICAucmVwbGFjZSgnY29tbWVudCcsIF9jb21tZW50KVxuICAgIC5yZXBsYWNlKCd0YWcnLCBfdGFnKVxuICAgIC5yZXBsYWNlKCdhdHRyaWJ1dGUnLCAvICtbYS16QS1aOl9dW1xcdy46LV0qKD86ICo9ICpcIlteXCJcXG5dKlwifCAqPSAqJ1teJ1xcbl0qJ3wgKj0gKlteXFxzXCInPTw+YF0rKT8vKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgcGFyYWdyYXBoID0gZWRpdChfcGFyYWdyYXBoKVxuICAgIC5yZXBsYWNlKCdocicsIGhyKVxuICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSg/OlxcXFxzfCQpJylcbiAgICAucmVwbGFjZSgnfGxoZWFkaW5nJywgJycpIC8vIHNldGV4dCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gICAgLnJlcGxhY2UoJ3x0YWJsZScsICcnKVxuICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgIC5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJylcbiAgICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSknKVxuICAgIC5yZXBsYWNlKCd0YWcnLCBfdGFnKSAvLyBwYXJzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgYmxvY2txdW90ZSA9IGVkaXQoL14oIHswLDN9PiA/KHBhcmFncmFwaHxbXlxcbl0qKSg/OlxcbnwkKSkrLylcbiAgICAucmVwbGFjZSgncGFyYWdyYXBoJywgcGFyYWdyYXBoKVxuICAgIC5nZXRSZWdleCgpO1xuLyoqXG4gKiBOb3JtYWwgQmxvY2sgR3JhbW1hclxuICovXG5jb25zdCBibG9ja05vcm1hbCA9IHtcbiAgICBibG9ja3F1b3RlLFxuICAgIGNvZGU6IGJsb2NrQ29kZSxcbiAgICBkZWYsXG4gICAgZmVuY2VzLFxuICAgIGhlYWRpbmcsXG4gICAgaHIsXG4gICAgaHRtbCxcbiAgICBsaGVhZGluZyxcbiAgICBsaXN0LFxuICAgIG5ld2xpbmUsXG4gICAgcGFyYWdyYXBoLFxuICAgIHRhYmxlOiBub29wVGVzdCxcbiAgICB0ZXh0OiBibG9ja1RleHQsXG59O1xuLyoqXG4gKiBHRk0gQmxvY2sgR3JhbW1hclxuICovXG5jb25zdCBnZm1UYWJsZSA9IGVkaXQoJ14gKihbXlxcXFxuIF0uKilcXFxcbicgLy8gSGVhZGVyXG4gICAgKyAnIHswLDN9KCg/OlxcXFx8ICopPzo/LSs6PyAqKD86XFxcXHwgKjo/LSs6PyAqKSooPzpcXFxcfCAqKT8pJyAvLyBBbGlnblxuICAgICsgJyg/OlxcXFxuKCg/Oig/ISAqXFxcXG58aHJ8aGVhZGluZ3xibG9ja3F1b3RlfGNvZGV8ZmVuY2VzfGxpc3R8aHRtbCkuKig/OlxcXFxufCQpKSopXFxcXG4qfCQpJykgLy8gQ2VsbHNcbiAgICAucmVwbGFjZSgnaHInLCBocilcbiAgICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0oPzpcXFxcc3wkKScpXG4gICAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gICAgLnJlcGxhY2UoJ2NvZGUnLCAnKD86IHs0fXwgezAsM31cXHQpW15cXFxcbl0nKVxuICAgIC5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJylcbiAgICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSknKVxuICAgIC5yZXBsYWNlKCd0YWcnLCBfdGFnKSAvLyB0YWJsZXMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBibG9ja0dmbSA9IHtcbiAgICAuLi5ibG9ja05vcm1hbCxcbiAgICB0YWJsZTogZ2ZtVGFibGUsXG4gICAgcGFyYWdyYXBoOiBlZGl0KF9wYXJhZ3JhcGgpXG4gICAgICAgIC5yZXBsYWNlKCdocicsIGhyKVxuICAgICAgICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0oPzpcXFxcc3wkKScpXG4gICAgICAgIC5yZXBsYWNlKCd8bGhlYWRpbmcnLCAnJykgLy8gc2V0ZXh0IGhlYWRpbmdzIGRvbid0IGludGVycnVwdCBjb21tb25tYXJrIHBhcmFncmFwaHNcbiAgICAgICAgLnJlcGxhY2UoJ3RhYmxlJywgZ2ZtVGFibGUpIC8vIGludGVycnVwdCBwYXJhZ3JhcGhzIHdpdGggdGFibGVcbiAgICAgICAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gICAgICAgIC5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJylcbiAgICAgICAgLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgICAgICAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpXG4gICAgICAgIC5yZXBsYWNlKCd0YWcnLCBfdGFnKSAvLyBwYXJzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAgICAgICAuZ2V0UmVnZXgoKSxcbn07XG4vKipcbiAqIFBlZGFudGljIGdyYW1tYXIgKG9yaWdpbmFsIEpvaG4gR3J1YmVyJ3MgbG9vc2UgbWFya2Rvd24gc3BlY2lmaWNhdGlvbilcbiAqL1xuY29uc3QgYmxvY2tQZWRhbnRpYyA9IHtcbiAgICAuLi5ibG9ja05vcm1hbCxcbiAgICBodG1sOiBlZGl0KCdeICooPzpjb21tZW50ICooPzpcXFxcbnxcXFxccyokKSdcbiAgICAgICAgKyAnfDwodGFnKVtcXFxcc1xcXFxTXSs/PC9cXFxcMT4gKig/OlxcXFxuezIsfXxcXFxccyokKScgLy8gY2xvc2VkIHRhZ1xuICAgICAgICArICd8PHRhZyg/OlwiW15cIl0qXCJ8XFwnW15cXCddKlxcJ3xcXFxcc1teXFwnXCIvPlxcXFxzXSopKj8vPz4gKig/OlxcXFxuezIsfXxcXFxccyokKSknKVxuICAgICAgICAucmVwbGFjZSgnY29tbWVudCcsIF9jb21tZW50KVxuICAgICAgICAucmVwbGFjZSgvdGFnL2csICcoPyEoPzonXG4gICAgICAgICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlfHZhcnxzYW1wfGtiZHxzdWInXG4gICAgICAgICsgJ3xzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG98c3Bhbnxicnx3YnJ8aW5zfGRlbHxpbWcpJ1xuICAgICAgICArICdcXFxcYilcXFxcdysoPyE6fFteXFxcXHdcXFxcc0BdKkApXFxcXGInKVxuICAgICAgICAuZ2V0UmVnZXgoKSxcbiAgICBkZWY6IC9eICpcXFsoW15cXF1dKylcXF06ICo8PyhbXlxccz5dKyk+Pyg/OiArKFtcIihdW15cXG5dK1tcIildKSk/ICooPzpcXG4rfCQpLyxcbiAgICBoZWFkaW5nOiAvXigjezEsNn0pKC4qKSg/Olxcbit8JCkvLFxuICAgIGZlbmNlczogbm9vcFRlc3QsIC8vIGZlbmNlcyBub3Qgc3VwcG9ydGVkXG4gICAgbGhlYWRpbmc6IC9eKC4rPylcXG4gezAsM30oPSt8LSspICooPzpcXG4rfCQpLyxcbiAgICBwYXJhZ3JhcGg6IGVkaXQoX3BhcmFncmFwaClcbiAgICAgICAgLnJlcGxhY2UoJ2hyJywgaHIpXG4gICAgICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyAqI3sxLDZ9ICpbXlxcbl0nKVxuICAgICAgICAucmVwbGFjZSgnbGhlYWRpbmcnLCBsaGVhZGluZylcbiAgICAgICAgLnJlcGxhY2UoJ3x0YWJsZScsICcnKVxuICAgICAgICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgICAgICAgLnJlcGxhY2UoJ3xmZW5jZXMnLCAnJylcbiAgICAgICAgLnJlcGxhY2UoJ3xsaXN0JywgJycpXG4gICAgICAgIC5yZXBsYWNlKCd8aHRtbCcsICcnKVxuICAgICAgICAucmVwbGFjZSgnfHRhZycsICcnKVxuICAgICAgICAuZ2V0UmVnZXgoKSxcbn07XG4vKipcbiAqIElubGluZS1MZXZlbCBHcmFtbWFyXG4gKi9cbmNvbnN0IGVzY2FwZSA9IC9eXFxcXChbIVwiIyQlJicoKSorLFxcLS4vOjs8PT4/QFxcW1xcXVxcXFxeX2B7fH1+XSkvO1xuY29uc3QgaW5saW5lQ29kZSA9IC9eKGArKShbXmBdfFteYF1bXFxzXFxTXSo/W15gXSlcXDEoPyFgKS87XG5jb25zdCBiciA9IC9eKCB7Mix9fFxcXFwpXFxuKD8hXFxzKiQpLztcbmNvbnN0IGlubGluZVRleHQgPSAvXihgK3xbXmBdKSg/Oig/PSB7Mix9XFxuKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2AqX118XFxiX3wkKXxbXiBdKD89IHsyLH1cXG4pKSkvO1xuLy8gbGlzdCBvZiB1bmljb2RlIHB1bmN0dWF0aW9uIG1hcmtzLCBwbHVzIGFueSBtaXNzaW5nIGNoYXJhY3RlcnMgZnJvbSBDb21tb25NYXJrIHNwZWNcbmNvbnN0IF9wdW5jdHVhdGlvbiA9ICdcXFxccHtQfVxcXFxwe1N9JztcbmNvbnN0IHB1bmN0dWF0aW9uID0gZWRpdCgvXigoPyFbKl9dKVtcXHNwdW5jdHVhdGlvbl0pLywgJ3UnKVxuICAgIC5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBfcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4vLyBzZXF1ZW5jZXMgZW0gc2hvdWxkIHNraXAgb3ZlciBbdGl0bGVdKGxpbmspLCBgY29kZWAsIDxodG1sPlxuY29uc3QgYmxvY2tTa2lwID0gL1xcW1teW1xcXV0qP1xcXVxcKFteXFwoXFwpXSo/XFwpfGBbXmBdKj9gfDxbXjw+XSo/Pi9nO1xuY29uc3QgZW1TdHJvbmdMRGVsaW0gPSBlZGl0KC9eKD86XFwqKyg/OigoPyFcXCopW3B1bmN0XSl8W15cXHMqXSkpfF5fKyg/OigoPyFfKVtwdW5jdF0pfChbXlxcc19dKSkvLCAndScpXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIF9wdW5jdHVhdGlvbilcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IGVtU3Ryb25nUkRlbGltQXN0ID0gZWRpdCgnXlteXypdKj9fX1teXypdKj9cXFxcKlteXypdKj8oPz1fXyknIC8vIFNraXAgb3JwaGFuIGluc2lkZSBzdHJvbmdcbiAgICArICd8W14qXSsoPz1bXipdKScgLy8gQ29uc3VtZSB0byBkZWxpbVxuICAgICsgJ3woPyFcXFxcKilbcHVuY3RdKFxcXFwqKykoPz1bXFxcXHNdfCQpJyAvLyAoMSkgIyoqKiBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlclxuICAgICsgJ3xbXnB1bmN0XFxcXHNdKFxcXFwqKykoPyFcXFxcKikoPz1bcHVuY3RcXFxcc118JCknIC8vICgyKSBhKioqIywgYSoqKiBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlclxuICAgICsgJ3woPyFcXFxcKilbcHVuY3RcXFxcc10oXFxcXCorKSg/PVtecHVuY3RcXFxcc10pJyAvLyAoMykgIyoqKmEsICoqKmEgY2FuIG9ubHkgYmUgTGVmdCBEZWxpbWl0ZXJcbiAgICArICd8W1xcXFxzXShcXFxcKispKD8hXFxcXCopKD89W3B1bmN0XSknIC8vICg0KSAqKiojIGNhbiBvbmx5IGJlIExlZnQgRGVsaW1pdGVyXG4gICAgKyAnfCg/IVxcXFwqKVtwdW5jdF0oXFxcXCorKSg/IVxcXFwqKSg/PVtwdW5jdF0pJyAvLyAoNSkgIyoqKiMgY2FuIGJlIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltaXRlclxuICAgICsgJ3xbXnB1bmN0XFxcXHNdKFxcXFwqKykoPz1bXnB1bmN0XFxcXHNdKScsICdndScpIC8vICg2KSBhKioqYSBjYW4gYmUgZWl0aGVyIExlZnQgb3IgUmlnaHQgRGVsaW1pdGVyXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIF9wdW5jdHVhdGlvbilcbiAgICAuZ2V0UmVnZXgoKTtcbi8vICg2KSBOb3QgYWxsb3dlZCBmb3IgX1xuY29uc3QgZW1TdHJvbmdSRGVsaW1VbmQgPSBlZGl0KCdeW15fKl0qP1xcXFwqXFxcXCpbXl8qXSo/X1teXypdKj8oPz1cXFxcKlxcXFwqKScgLy8gU2tpcCBvcnBoYW4gaW5zaWRlIHN0cm9uZ1xuICAgICsgJ3xbXl9dKyg/PVteX10pJyAvLyBDb25zdW1lIHRvIGRlbGltXG4gICAgKyAnfCg/IV8pW3B1bmN0XShfKykoPz1bXFxcXHNdfCQpJyAvLyAoMSkgI19fXyBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlclxuICAgICsgJ3xbXnB1bmN0XFxcXHNdKF8rKSg/IV8pKD89W3B1bmN0XFxcXHNdfCQpJyAvLyAoMikgYV9fXyMsIGFfX18gY2FuIG9ubHkgYmUgYSBSaWdodCBEZWxpbWl0ZXJcbiAgICArICd8KD8hXylbcHVuY3RcXFxcc10oXyspKD89W15wdW5jdFxcXFxzXSknIC8vICgzKSAjX19fYSwgX19fYSBjYW4gb25seSBiZSBMZWZ0IERlbGltaXRlclxuICAgICsgJ3xbXFxcXHNdKF8rKSg/IV8pKD89W3B1bmN0XSknIC8vICg0KSBfX18jIGNhbiBvbmx5IGJlIExlZnQgRGVsaW1pdGVyXG4gICAgKyAnfCg/IV8pW3B1bmN0XShfKykoPyFfKSg/PVtwdW5jdF0pJywgJ2d1JykgLy8gKDUpICNfX18jIGNhbiBiZSBlaXRoZXIgTGVmdCBvciBSaWdodCBEZWxpbWl0ZXJcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgYW55UHVuY3R1YXRpb24gPSBlZGl0KC9cXFxcKFtwdW5jdF0pLywgJ2d1JylcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgYXV0b2xpbmsgPSBlZGl0KC9ePChzY2hlbWU6W15cXHNcXHgwMC1cXHgxZjw+XSp8ZW1haWwpPi8pXG4gICAgLnJlcGxhY2UoJ3NjaGVtZScsIC9bYS16QS1aXVthLXpBLVowLTkrLi1dezEsMzF9LylcbiAgICAucmVwbGFjZSgnZW1haWwnLCAvW2EtekEtWjAtOS4hIyQlJicqKy89P15fYHt8fX4tXSsoQClbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKyg/IVstX10pLylcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IF9pbmxpbmVDb21tZW50ID0gZWRpdChfY29tbWVudCkucmVwbGFjZSgnKD86LS0+fCQpJywgJy0tPicpLmdldFJlZ2V4KCk7XG5jb25zdCB0YWcgPSBlZGl0KCdeY29tbWVudCdcbiAgICArICd8XjwvW2EtekEtWl1bXFxcXHc6LV0qXFxcXHMqPicgLy8gc2VsZi1jbG9zaW5nIHRhZ1xuICAgICsgJ3xePFthLXpBLVpdW1xcXFx3LV0qKD86YXR0cmlidXRlKSo/XFxcXHMqLz8+JyAvLyBvcGVuIHRhZ1xuICAgICsgJ3xePFxcXFw/W1xcXFxzXFxcXFNdKj9cXFxcPz4nIC8vIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24sIGUuZy4gPD9waHAgPz5cbiAgICArICd8XjwhW2EtekEtWl0rXFxcXHNbXFxcXHNcXFxcU10qPz4nIC8vIGRlY2xhcmF0aW9uLCBlLmcuIDwhRE9DVFlQRSBodG1sPlxuICAgICsgJ3xePCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JykgLy8gQ0RBVEEgc2VjdGlvblxuICAgIC5yZXBsYWNlKCdjb21tZW50JywgX2lubGluZUNvbW1lbnQpXG4gICAgLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIC9cXHMrW2EtekEtWjpfXVtcXHcuOi1dKig/Olxccyo9XFxzKlwiW15cIl0qXCJ8XFxzKj1cXHMqJ1teJ10qJ3xcXHMqPVxccypbXlxcc1wiJz08PmBdKyk/LylcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IF9pbmxpbmVMYWJlbCA9IC8oPzpcXFsoPzpcXFxcLnxbXlxcW1xcXVxcXFxdKSpcXF18XFxcXC58YFteYF0qYHxbXlxcW1xcXVxcXFxgXSkqPy87XG5jb25zdCBsaW5rID0gZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcKFxccyooaHJlZikoPzpcXHMrKHRpdGxlKSk/XFxzKlxcKS8pXG4gICAgLnJlcGxhY2UoJ2xhYmVsJywgX2lubGluZUxhYmVsKVxuICAgIC5yZXBsYWNlKCdocmVmJywgLzwoPzpcXFxcLnxbXlxcbjw+XFxcXF0pKz58W15cXHNcXHgwMC1cXHgxZl0qLylcbiAgICAucmVwbGFjZSgndGl0bGUnLCAvXCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8Jyg/OlxcXFwnP3xbXidcXFxcXSkqJ3xcXCgoPzpcXFxcXFwpP3xbXilcXFxcXSkqXFwpLylcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IHJlZmxpbmsgPSBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFxbKHJlZilcXF0vKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIF9pbmxpbmVMYWJlbClcbiAgICAucmVwbGFjZSgncmVmJywgX2Jsb2NrTGFiZWwpXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBub2xpbmsgPSBlZGl0KC9eIT9cXFsocmVmKVxcXSg/OlxcW1xcXSk/LylcbiAgICAucmVwbGFjZSgncmVmJywgX2Jsb2NrTGFiZWwpXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCByZWZsaW5rU2VhcmNoID0gZWRpdCgncmVmbGlua3xub2xpbmsoPyFcXFxcKCknLCAnZycpXG4gICAgLnJlcGxhY2UoJ3JlZmxpbmsnLCByZWZsaW5rKVxuICAgIC5yZXBsYWNlKCdub2xpbmsnLCBub2xpbmspXG4gICAgLmdldFJlZ2V4KCk7XG4vKipcbiAqIE5vcm1hbCBJbmxpbmUgR3JhbW1hclxuICovXG5jb25zdCBpbmxpbmVOb3JtYWwgPSB7XG4gICAgX2JhY2twZWRhbDogbm9vcFRlc3QsIC8vIG9ubHkgdXNlZCBmb3IgR0ZNIHVybFxuICAgIGFueVB1bmN0dWF0aW9uLFxuICAgIGF1dG9saW5rLFxuICAgIGJsb2NrU2tpcCxcbiAgICBicixcbiAgICBjb2RlOiBpbmxpbmVDb2RlLFxuICAgIGRlbDogbm9vcFRlc3QsXG4gICAgZW1TdHJvbmdMRGVsaW0sXG4gICAgZW1TdHJvbmdSRGVsaW1Bc3QsXG4gICAgZW1TdHJvbmdSRGVsaW1VbmQsXG4gICAgZXNjYXBlLFxuICAgIGxpbmssXG4gICAgbm9saW5rLFxuICAgIHB1bmN0dWF0aW9uLFxuICAgIHJlZmxpbmssXG4gICAgcmVmbGlua1NlYXJjaCxcbiAgICB0YWcsXG4gICAgdGV4dDogaW5saW5lVGV4dCxcbiAgICB1cmw6IG5vb3BUZXN0LFxufTtcbi8qKlxuICogUGVkYW50aWMgSW5saW5lIEdyYW1tYXJcbiAqL1xuY29uc3QgaW5saW5lUGVkYW50aWMgPSB7XG4gICAgLi4uaW5saW5lTm9ybWFsLFxuICAgIGxpbms6IGVkaXQoL14hP1xcWyhsYWJlbClcXF1cXCgoLio/KVxcKS8pXG4gICAgICAgIC5yZXBsYWNlKCdsYWJlbCcsIF9pbmxpbmVMYWJlbClcbiAgICAgICAgLmdldFJlZ2V4KCksXG4gICAgcmVmbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxccypcXFsoW15cXF1dKilcXF0vKVxuICAgICAgICAucmVwbGFjZSgnbGFiZWwnLCBfaW5saW5lTGFiZWwpXG4gICAgICAgIC5nZXRSZWdleCgpLFxufTtcbi8qKlxuICogR0ZNIElubGluZSBHcmFtbWFyXG4gKi9cbmNvbnN0IGlubGluZUdmbSA9IHtcbiAgICAuLi5pbmxpbmVOb3JtYWwsXG4gICAgZXNjYXBlOiBlZGl0KGVzY2FwZSkucmVwbGFjZSgnXSknLCAnfnxdKScpLmdldFJlZ2V4KCksXG4gICAgdXJsOiBlZGl0KC9eKCg/OmZ0cHxodHRwcz8pOlxcL1xcL3x3d3dcXC4pKD86W2EtekEtWjAtOVxcLV0rXFwuPykrW15cXHM8XSp8XmVtYWlsLywgJ2knKVxuICAgICAgICAucmVwbGFjZSgnZW1haWwnLCAvW0EtWmEtejAtOS5fKy1dKyhAKVthLXpBLVowLTktX10rKD86XFwuW2EtekEtWjAtOS1fXSpbYS16QS1aMC05XSkrKD8hWy1fXSkvKVxuICAgICAgICAuZ2V0UmVnZXgoKSxcbiAgICBfYmFja3BlZGFsOiAvKD86W14/IS4sOjsqXydcIn4oKSZdK3xcXChbXildKlxcKXwmKD8hW2EtekEtWjAtOV0rOyQpfFs/IS4sOjsqXydcIn4pXSsoPyEkKSkrLyxcbiAgICBkZWw6IC9eKH5+PykoPz1bXlxcc35dKShbXFxzXFxTXSo/W15cXHN+XSlcXDEoPz1bXn5dfCQpLyxcbiAgICB0ZXh0OiAvXihbYH5dK3xbXmB+XSkoPzooPz0gezIsfVxcbil8KD89W2EtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXStAKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2Aqfl9dfFxcYl98aHR0cHM/OlxcL1xcL3xmdHA6XFwvXFwvfHd3d1xcLnwkKXxbXiBdKD89IHsyLH1cXG4pfFteYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dKD89W2EtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXStAKSkpLyxcbn07XG4vKipcbiAqIEdGTSArIExpbmUgQnJlYWtzIElubGluZSBHcmFtbWFyXG4gKi9cbmNvbnN0IGlubGluZUJyZWFrcyA9IHtcbiAgICAuLi5pbmxpbmVHZm0sXG4gICAgYnI6IGVkaXQoYnIpLnJlcGxhY2UoJ3syLH0nLCAnKicpLmdldFJlZ2V4KCksXG4gICAgdGV4dDogZWRpdChpbmxpbmVHZm0udGV4dClcbiAgICAgICAgLnJlcGxhY2UoJ1xcXFxiXycsICdcXFxcYl98IHsyLH1cXFxcbicpXG4gICAgICAgIC5yZXBsYWNlKC9cXHsyLFxcfS9nLCAnKicpXG4gICAgICAgIC5nZXRSZWdleCgpLFxufTtcbi8qKlxuICogZXhwb3J0c1xuICovXG5jb25zdCBibG9jayA9IHtcbiAgICBub3JtYWw6IGJsb2NrTm9ybWFsLFxuICAgIGdmbTogYmxvY2tHZm0sXG4gICAgcGVkYW50aWM6IGJsb2NrUGVkYW50aWMsXG59O1xuY29uc3QgaW5saW5lID0ge1xuICAgIG5vcm1hbDogaW5saW5lTm9ybWFsLFxuICAgIGdmbTogaW5saW5lR2ZtLFxuICAgIGJyZWFrczogaW5saW5lQnJlYWtzLFxuICAgIHBlZGFudGljOiBpbmxpbmVQZWRhbnRpYyxcbn07XG5cbi8qKlxuICogQmxvY2sgTGV4ZXJcbiAqL1xuY2xhc3MgX0xleGVyIHtcbiAgICB0b2tlbnM7XG4gICAgb3B0aW9ucztcbiAgICBzdGF0ZTtcbiAgICB0b2tlbml6ZXI7XG4gICAgaW5saW5lUXVldWU7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAvLyBUb2tlbkxpc3QgY2Fubm90IGJlIGNyZWF0ZWQgaW4gb25lIGdvXG4gICAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICAgIHRoaXMudG9rZW5zLmxpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBfZGVmYXVsdHM7XG4gICAgICAgIHRoaXMub3B0aW9ucy50b2tlbml6ZXIgPSB0aGlzLm9wdGlvbnMudG9rZW5pemVyIHx8IG5ldyBfVG9rZW5pemVyKCk7XG4gICAgICAgIHRoaXMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplcjtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdGhpcy50b2tlbml6ZXIubGV4ZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLmlubGluZVF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpbkxpbms6IGZhbHNlLFxuICAgICAgICAgICAgaW5SYXdCbG9jazogZmFsc2UsXG4gICAgICAgICAgICB0b3A6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJ1bGVzID0ge1xuICAgICAgICAgICAgYmxvY2s6IGJsb2NrLm5vcm1hbCxcbiAgICAgICAgICAgIGlubGluZTogaW5saW5lLm5vcm1hbCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgcnVsZXMuYmxvY2sgPSBibG9jay5wZWRhbnRpYztcbiAgICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5wZWRhbnRpYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICAgICAgICBydWxlcy5ibG9jayA9IGJsb2NrLmdmbTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnJlYWtzKSB7XG4gICAgICAgICAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lLmJyZWFrcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5nZm07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b2tlbml6ZXIucnVsZXMgPSBydWxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3NlIFJ1bGVzXG4gICAgICovXG4gICAgc3RhdGljIGdldCBydWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgaW5saW5lLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgTGV4IE1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyBsZXgoc3JjLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxleGVyID0gbmV3IF9MZXhlcihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGxleGVyLmxleChzcmMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgTGV4IElubGluZSBNZXRob2RcbiAgICAgKi9cbiAgICBzdGF0aWMgbGV4SW5saW5lKHNyYywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBsZXhlciA9IG5ldyBfTGV4ZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBsZXhlci5pbmxpbmVUb2tlbnMoc3JjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcHJvY2Vzc2luZ1xuICAgICAqL1xuICAgIGxleChzcmMpIHtcbiAgICAgICAgc3JjID0gc3JjXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJyk7XG4gICAgICAgIHRoaXMuYmxvY2tUb2tlbnMoc3JjLCB0aGlzLnRva2Vucyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuaW5saW5lUXVldWVbaV07XG4gICAgICAgICAgICB0aGlzLmlubGluZVRva2VucyhuZXh0LnNyYywgbmV4dC50b2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5saW5lUXVldWUgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zO1xuICAgIH1cbiAgICBibG9ja1Rva2VucyhzcmMsIHRva2VucyA9IFtdLCBsYXN0UGFyYWdyYXBoQ2xpcHBlZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9cXHQvZywgJyAgICAnKS5yZXBsYWNlKC9eICskL2dtLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICBsZXQgbGFzdFRva2VuO1xuICAgICAgICBsZXQgY3V0U3JjO1xuICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5ibG9ja1xuICAgICAgICAgICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmJsb2NrLnNvbWUoKGV4dFRva2VuaXplcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPSBleHRUb2tlbml6ZXIuY2FsbCh7IGxleGVyOiB0aGlzIH0sIHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbmV3bGluZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuc3BhY2Uoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnJhdy5sZW5ndGggPT09IDEgJiYgdG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBhIHNpbmdsZSBcXG4gYXMgYSBzcGFjZXIsIGl0J3MgdGVybWluYXRpbmcgdGhlIGxhc3QgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gbW92ZSBpdCB0aGVyZSBzbyB0aGF0IHdlIGRvbid0IGdldCB1bm5lY2Vzc2FyeSBwYXJhZ3JhcGggdGFnc1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnJhdyArPSAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb2RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2RlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgLy8gQW4gaW5kZW50ZWQgY29kZSBibG9jayBjYW5ub3QgaW50ZXJydXB0IGEgcGFyYWdyYXBoLlxuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgKGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmZW5jZXNcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmZlbmNlcyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoZWFkaW5nXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5oZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhyXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ocihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBibG9ja3F1b3RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ibG9ja3F1b3RlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxpc3RcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxpc3Qoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaHRtbFxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaHRtbChzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZWZcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmRlZihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgKGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogdG9rZW4uaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0b2tlbi50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0YWJsZSAoZ2ZtKVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGFibGUoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGhlYWRpbmdcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxoZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRvcC1sZXZlbCBwYXJhZ3JhcGhcbiAgICAgICAgICAgIC8vIHByZXZlbnQgcGFyYWdyYXBoIGNvbnN1bWluZyBleHRlbnNpb25zIGJ5IGNsaXBwaW5nICdzcmMnIHRvIGV4dGVuc2lvbiBzdGFydFxuICAgICAgICAgICAgY3V0U3JjID0gc3JjO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBTcmMgPSBzcmMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXBTdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydEJsb2NrLmZvckVhY2goKGdldFN0YXJ0SW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN0YXJ0ID0gZ2V0U3RhcnRJbmRleC5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgdGVtcFNyYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcFN0YXJ0ID09PSAnbnVtYmVyJyAmJiB0ZW1wU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IE1hdGgubWluKHN0YXJ0SW5kZXgsIHRlbXBTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA8IEluZmluaXR5ICYmIHN0YXJ0SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdXRTcmMgPSBzcmMuc3Vic3RyaW5nKDAsIHN0YXJ0SW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS50b3AgJiYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucGFyYWdyYXBoKGN1dFNyYykpKSB7XG4gICAgICAgICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFBhcmFncmFwaENsaXBwZWQgJiYgbGFzdFRva2VuPy50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFBhcmFncmFwaENsaXBwZWQgPSAoY3V0U3JjLmxlbmd0aCAhPT0gc3JjLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRleHRcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRleHQoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9ICdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUudG9wID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgaW5saW5lKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wdXNoKHsgc3JjLCB0b2tlbnMgfSk7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExleGluZy9Db21waWxpbmdcbiAgICAgKi9cbiAgICBpbmxpbmVUb2tlbnMoc3JjLCB0b2tlbnMgPSBbXSkge1xuICAgICAgICBsZXQgdG9rZW4sIGxhc3RUb2tlbiwgY3V0U3JjO1xuICAgICAgICAvLyBTdHJpbmcgd2l0aCBsaW5rcyBtYXNrZWQgdG8gYXZvaWQgaW50ZXJmZXJlbmNlIHdpdGggZW0gYW5kIHN0cm9uZ1xuICAgICAgICBsZXQgbWFza2VkU3JjID0gc3JjO1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIGxldCBrZWVwUHJldkNoYXIsIHByZXZDaGFyO1xuICAgICAgICAvLyBNYXNrIG91dCByZWZsaW5rc1xuICAgICAgICBpZiAodGhpcy50b2tlbnMubGlua3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gT2JqZWN0LmtleXModGhpcy50b2tlbnMubGlua3MpO1xuICAgICAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLnJlZmxpbmtTZWFyY2guZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5rcy5pbmNsdWRlcyhtYXRjaFswXS5zbGljZShtYXRjaFswXS5sYXN0SW5kZXhPZignWycpICsgMSwgLTEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdbJyArICdhJy5yZXBlYXQobWF0Y2hbMF0ubGVuZ3RoIC0gMikgKyAnXScgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLnJlZmxpbmtTZWFyY2gubGFzdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYXNrIG91dCBvdGhlciBibG9ja3NcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5ibG9ja1NraXAuZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJ1snICsgJ2EnLnJlcGVhdChtYXRjaFswXS5sZW5ndGggLSAyKSArICddJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmxhc3RJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFzayBvdXQgZXNjYXBlZCBjaGFyYWN0ZXJzXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24uZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJysrJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24ubGFzdEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICBpZiAoIWtlZXBQcmV2Q2hhcikge1xuICAgICAgICAgICAgICAgIHByZXZDaGFyID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZWVwUHJldkNoYXIgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGV4dGVuc2lvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmlubGluZVxuICAgICAgICAgICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmlubGluZS5zb21lKChleHRUb2tlbml6ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID0gZXh0VG9rZW5pemVyLmNhbGwoeyBsZXhlcjogdGhpcyB9LCBzcmMsIHRva2VucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzY2FwZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZXNjYXBlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRhZ1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGFnKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsaW5rXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saW5rKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlZmxpbmssIG5vbGlua1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucmVmbGluayhzcmMsIHRoaXMudG9rZW5zLmxpbmtzKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuICYmIHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVtICYgc3Ryb25nXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5lbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb2RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2Rlc3BhbihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiclxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYnIoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVsIChnZm0pXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5kZWwoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXV0b2xpbmtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmF1dG9saW5rKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVybCAoZ2ZtKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmluTGluayAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci51cmwoc3JjKSkpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRleHRcbiAgICAgICAgICAgIC8vIHByZXZlbnQgaW5saW5lVGV4dCBjb25zdW1pbmcgZXh0ZW5zaW9ucyBieSBjbGlwcGluZyAnc3JjJyB0byBleHRlbnNpb24gc3RhcnRcbiAgICAgICAgICAgIGN1dFNyYyA9IHNyYztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydElubGluZSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcFN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0SW5saW5lLmZvckVhY2goKGdldFN0YXJ0SW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN0YXJ0ID0gZ2V0U3RhcnRJbmRleC5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgdGVtcFNyYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcFN0YXJ0ID09PSAnbnVtYmVyJyAmJiB0ZW1wU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IE1hdGgubWluKHN0YXJ0SW5kZXgsIHRlbXBTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA8IEluZmluaXR5ICYmIHN0YXJ0SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdXRTcmMgPSBzcmMuc3Vic3RyaW5nKDAsIHN0YXJ0SW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5pbmxpbmVUZXh0KGN1dFNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5yYXcuc2xpY2UoLTEpICE9PSAnXycpIHsgLy8gVHJhY2sgcHJldkNoYXIgYmVmb3JlIHN0cmluZyBvZiBfX19fIHN0YXJ0ZWRcbiAgICAgICAgICAgICAgICAgICAgcHJldkNoYXIgPSB0b2tlbi5yYXcuc2xpY2UoLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZWVwUHJldkNoYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZW5kZXJlclxuICovXG5jbGFzcyBfUmVuZGVyZXIge1xuICAgIG9wdGlvbnM7XG4gICAgcGFyc2VyOyAvLyBzZXQgYnkgdGhlIHBhcnNlclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBfZGVmYXVsdHM7XG4gICAgfVxuICAgIHNwYWNlKHRva2VuKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY29kZSh7IHRleHQsIGxhbmcsIGVzY2FwZWQgfSkge1xuICAgICAgICBjb25zdCBsYW5nU3RyaW5nID0gKGxhbmcgfHwgJycpLm1hdGNoKC9eXFxTKi8pPy5bMF07XG4gICAgICAgIGNvbnN0IGNvZGUgPSB0ZXh0LnJlcGxhY2UoL1xcbiQvLCAnJykgKyAnXFxuJztcbiAgICAgICAgaWYgKCFsYW5nU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxwcmU+PGNvZGU+J1xuICAgICAgICAgICAgICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlJDEoY29kZSwgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICc8cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtJ1xuICAgICAgICAgICAgKyBlc2NhcGUkMShsYW5nU3RyaW5nKVxuICAgICAgICAgICAgKyAnXCI+J1xuICAgICAgICAgICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUkMShjb2RlLCB0cnVlKSlcbiAgICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgIH1cbiAgICBibG9ja3F1b3RlKHsgdG9rZW5zIH0pIHtcbiAgICAgICAgY29uc3QgYm9keSA9IHRoaXMucGFyc2VyLnBhcnNlKHRva2Vucyk7XG4gICAgICAgIHJldHVybiBgPGJsb2NrcXVvdGU+XFxuJHtib2R5fTwvYmxvY2txdW90ZT5cXG5gO1xuICAgIH1cbiAgICBodG1sKHsgdGV4dCB9KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBoZWFkaW5nKHsgdG9rZW5zLCBkZXB0aCB9KSB7XG4gICAgICAgIHJldHVybiBgPGgke2RlcHRofT4ke3RoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyl9PC9oJHtkZXB0aH0+XFxuYDtcbiAgICB9XG4gICAgaHIodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuICc8aHI+XFxuJztcbiAgICB9XG4gICAgbGlzdCh0b2tlbikge1xuICAgICAgICBjb25zdCBvcmRlcmVkID0gdG9rZW4ub3JkZXJlZDtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0b2tlbi5zdGFydDtcbiAgICAgICAgbGV0IGJvZHkgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0b2tlbi5pdGVtcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRva2VuLml0ZW1zW2pdO1xuICAgICAgICAgICAgYm9keSArPSB0aGlzLmxpc3RpdGVtKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBvcmRlcmVkID8gJ29sJyA6ICd1bCc7XG4gICAgICAgIGNvbnN0IHN0YXJ0QXR0ciA9IChvcmRlcmVkICYmIHN0YXJ0ICE9PSAxKSA/ICgnIHN0YXJ0PVwiJyArIHN0YXJ0ICsgJ1wiJykgOiAnJztcbiAgICAgICAgcmV0dXJuICc8JyArIHR5cGUgKyBzdGFydEF0dHIgKyAnPlxcbicgKyBib2R5ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG4gICAgfVxuICAgIGxpc3RpdGVtKGl0ZW0pIHtcbiAgICAgICAgbGV0IGl0ZW1Cb2R5ID0gJyc7XG4gICAgICAgIGlmIChpdGVtLnRhc2spIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrYm94ID0gdGhpcy5jaGVja2JveCh7IGNoZWNrZWQ6ICEhaXRlbS5jaGVja2VkIH0pO1xuICAgICAgICAgICAgaWYgKGl0ZW0ubG9vc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnMubGVuZ3RoID4gMCAmJiBpdGVtLnRva2Vuc1swXS50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vuc1swXS50ZXh0ID0gY2hlY2tib3ggKyAnICcgKyBpdGVtLnRva2Vuc1swXS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnNbMF0udG9rZW5zICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vucy5sZW5ndGggPiAwICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50ZXh0ID0gY2hlY2tib3ggKyAnICcgKyBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnMudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXc6IGNoZWNrYm94ICsgJyAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2hlY2tib3ggKyAnICcsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IGNoZWNrYm94ICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGl0ZW1Cb2R5ICs9IHRoaXMucGFyc2VyLnBhcnNlKGl0ZW0udG9rZW5zLCAhIWl0ZW0ubG9vc2UpO1xuICAgICAgICByZXR1cm4gYDxsaT4ke2l0ZW1Cb2R5fTwvbGk+XFxuYDtcbiAgICB9XG4gICAgY2hlY2tib3goeyBjaGVja2VkIH0pIHtcbiAgICAgICAgcmV0dXJuICc8aW5wdXQgJ1xuICAgICAgICAgICAgKyAoY2hlY2tlZCA/ICdjaGVja2VkPVwiXCIgJyA6ICcnKVxuICAgICAgICAgICAgKyAnZGlzYWJsZWQ9XCJcIiB0eXBlPVwiY2hlY2tib3hcIj4nO1xuICAgIH1cbiAgICBwYXJhZ3JhcGgoeyB0b2tlbnMgfSkge1xuICAgICAgICByZXR1cm4gYDxwPiR7dGhpcy5wYXJzZXIucGFyc2VJbmxpbmUodG9rZW5zKX08L3A+XFxuYDtcbiAgICB9XG4gICAgdGFibGUodG9rZW4pIHtcbiAgICAgICAgbGV0IGhlYWRlciA9ICcnO1xuICAgICAgICAvLyBoZWFkZXJcbiAgICAgICAgbGV0IGNlbGwgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0b2tlbi5oZWFkZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNlbGwgKz0gdGhpcy50YWJsZWNlbGwodG9rZW4uaGVhZGVyW2pdKTtcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXIgKz0gdGhpcy50YWJsZXJvdyh7IHRleHQ6IGNlbGwgfSk7XG4gICAgICAgIGxldCBib2R5ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdG9rZW4ucm93cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gdG9rZW4ucm93c1tqXTtcbiAgICAgICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcm93Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgY2VsbCArPSB0aGlzLnRhYmxlY2VsbChyb3dba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keSArPSB0aGlzLnRhYmxlcm93KHsgdGV4dDogY2VsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9keSlcbiAgICAgICAgICAgIGJvZHkgPSBgPHRib2R5PiR7Ym9keX08L3Rib2R5PmA7XG4gICAgICAgIHJldHVybiAnPHRhYmxlPlxcbidcbiAgICAgICAgICAgICsgJzx0aGVhZD5cXG4nXG4gICAgICAgICAgICArIGhlYWRlclxuICAgICAgICAgICAgKyAnPC90aGVhZD5cXG4nXG4gICAgICAgICAgICArIGJvZHlcbiAgICAgICAgICAgICsgJzwvdGFibGU+XFxuJztcbiAgICB9XG4gICAgdGFibGVyb3coeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIGA8dHI+XFxuJHt0ZXh0fTwvdHI+XFxuYDtcbiAgICB9XG4gICAgdGFibGVjZWxsKHRva2VuKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLnBhcnNlci5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpO1xuICAgICAgICBjb25zdCB0eXBlID0gdG9rZW4uaGVhZGVyID8gJ3RoJyA6ICd0ZCc7XG4gICAgICAgIGNvbnN0IHRhZyA9IHRva2VuLmFsaWduXG4gICAgICAgICAgICA/IGA8JHt0eXBlfSBhbGlnbj1cIiR7dG9rZW4uYWxpZ259XCI+YFxuICAgICAgICAgICAgOiBgPCR7dHlwZX0+YDtcbiAgICAgICAgcmV0dXJuIHRhZyArIGNvbnRlbnQgKyBgPC8ke3R5cGV9PlxcbmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNwYW4gbGV2ZWwgcmVuZGVyZXJcbiAgICAgKi9cbiAgICBzdHJvbmcoeyB0b2tlbnMgfSkge1xuICAgICAgICByZXR1cm4gYDxzdHJvbmc+JHt0aGlzLnBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMpfTwvc3Ryb25nPmA7XG4gICAgfVxuICAgIGVtKHsgdG9rZW5zIH0pIHtcbiAgICAgICAgcmV0dXJuIGA8ZW0+JHt0aGlzLnBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMpfTwvZW0+YDtcbiAgICB9XG4gICAgY29kZXNwYW4oeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIGA8Y29kZT4ke3RleHR9PC9jb2RlPmA7XG4gICAgfVxuICAgIGJyKHRva2VuKSB7XG4gICAgICAgIHJldHVybiAnPGJyPic7XG4gICAgfVxuICAgIGRlbCh7IHRva2VucyB9KSB7XG4gICAgICAgIHJldHVybiBgPGRlbD4ke3RoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyl9PC9kZWw+YDtcbiAgICB9XG4gICAgbGluayh7IGhyZWYsIHRpdGxlLCB0b2tlbnMgfSkge1xuICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5wYXJzZXIucGFyc2VJbmxpbmUodG9rZW5zKTtcbiAgICAgICAgY29uc3QgY2xlYW5IcmVmID0gY2xlYW5VcmwoaHJlZik7XG4gICAgICAgIGlmIChjbGVhbkhyZWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGhyZWYgPSBjbGVhbkhyZWY7XG4gICAgICAgIGxldCBvdXQgPSAnPGEgaHJlZj1cIicgKyBocmVmICsgJ1wiJztcbiAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICc+JyArIHRleHQgKyAnPC9hPic7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGltYWdlKHsgaHJlZiwgdGl0bGUsIHRleHQgfSkge1xuICAgICAgICBjb25zdCBjbGVhbkhyZWYgPSBjbGVhblVybChocmVmKTtcbiAgICAgICAgaWYgKGNsZWFuSHJlZiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaHJlZiA9IGNsZWFuSHJlZjtcbiAgICAgICAgbGV0IG91dCA9IGA8aW1nIHNyYz1cIiR7aHJlZn1cIiBhbHQ9XCIke3RleHR9XCJgO1xuICAgICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgICAgIG91dCArPSBgIHRpdGxlPVwiJHt0aXRsZX1cImA7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICc+JztcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgdGV4dCh0b2tlbikge1xuICAgICAgICByZXR1cm4gJ3Rva2VucycgaW4gdG9rZW4gJiYgdG9rZW4udG9rZW5zID8gdGhpcy5wYXJzZXIucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKSA6IHRva2VuLnRleHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIFRleHRSZW5kZXJlclxuICogcmV0dXJucyBvbmx5IHRoZSB0ZXh0dWFsIHBhcnQgb2YgdGhlIHRva2VuXG4gKi9cbmNsYXNzIF9UZXh0UmVuZGVyZXIge1xuICAgIC8vIG5vIG5lZWQgZm9yIGJsb2NrIGxldmVsIHJlbmRlcmVyc1xuICAgIHN0cm9uZyh7IHRleHQgfSkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgZW0oeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGNvZGVzcGFuKHsgdGV4dCB9KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBkZWwoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGh0bWwoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIHRleHQoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGxpbmsoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9XG4gICAgaW1hZ2UoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9XG4gICAgYnIoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5cbi8qKlxuICogUGFyc2luZyAmIENvbXBpbGluZ1xuICovXG5jbGFzcyBfUGFyc2VyIHtcbiAgICBvcHRpb25zO1xuICAgIHJlbmRlcmVyO1xuICAgIHRleHRSZW5kZXJlcjtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgICAgICB0aGlzLm9wdGlvbnMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IF9SZW5kZXJlcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucGFyc2VyID0gdGhpcztcbiAgICAgICAgdGhpcy50ZXh0UmVuZGVyZXIgPSBuZXcgX1RleHRSZW5kZXJlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgUGFyc2UgTWV0aG9kXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlKHRva2Vucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgX1BhcnNlcihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZSh0b2tlbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgUGFyc2UgSW5saW5lIE1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZUlubGluZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IF9QYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VJbmxpbmUodG9rZW5zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgTG9vcFxuICAgICAqL1xuICAgIHBhcnNlKHRva2VucywgdG9wID0gdHJ1ZSkge1xuICAgICAgICBsZXQgb3V0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhbnlUb2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIC8vIFJ1biBhbnkgcmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVycyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbYW55VG9rZW4udHlwZV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmljVG9rZW4gPSBhbnlUb2tlbjtcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZ2VuZXJpY1Rva2VuLnR5cGVdLmNhbGwoeyBwYXJzZXI6IHRoaXMgfSwgZ2VuZXJpY1Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSBmYWxzZSB8fCAhWydzcGFjZScsICdocicsICdoZWFkaW5nJywgJ2NvZGUnLCAndGFibGUnLCAnYmxvY2txdW90ZScsICdsaXN0JywgJ2h0bWwnLCAncGFyYWdyYXBoJywgJ3RleHQnXS5pbmNsdWRlcyhnZW5lcmljVG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJldCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBhbnlUb2tlbjtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5zcGFjZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdocic6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHIodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaGVhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaGVhZGluZyh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdjb2RlJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2RlKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3RhYmxlJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci50YWJsZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdibG9ja3F1b3RlJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5ibG9ja3F1b3RlKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2xpc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpc3QodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHRtbCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdwYXJhZ3JhcGgnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGxldCBib2R5ID0gdGhpcy5yZW5kZXJlci50ZXh0KHRleHRUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpICsgMSA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2kgKyAxXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRUb2tlbiA9IHRva2Vuc1srK2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSArPSAnXFxuJyArIHRoaXMucmVuZGVyZXIudGV4dCh0ZXh0VG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiBib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiBbeyB0eXBlOiAndGV4dCcsIHJhdzogYm9keSwgdGV4dDogYm9keSB9XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gJ1Rva2VuIHdpdGggXCInICsgdG9rZW4udHlwZSArICdcIiB0eXBlIHdhcyBub3QgZm91bmQuJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIElubGluZSBUb2tlbnNcbiAgICAgKi9cbiAgICBwYXJzZUlubGluZSh0b2tlbnMsIHJlbmRlcmVyKSB7XG4gICAgICAgIHJlbmRlcmVyID0gcmVuZGVyZXIgfHwgdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYW55VG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICAvLyBSdW4gYW55IHJlbmRlcmVyIGV4dGVuc2lvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW2FueVRva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW2FueVRva2VuLnR5cGVdLmNhbGwoeyBwYXJzZXI6IHRoaXMgfSwgYW55VG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ2VzY2FwZScsICdodG1sJywgJ2xpbmsnLCAnaW1hZ2UnLCAnc3Ryb25nJywgJ2VtJywgJ2NvZGVzcGFuJywgJ2JyJywgJ2RlbCcsICd0ZXh0J10uaW5jbHVkZXMoYW55VG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJldCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBhbnlUb2tlbjtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VzY2FwZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnRleHQodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmh0bWwodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbGluayc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmxpbmsodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaW1hZ2UnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5pbWFnZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdzdHJvbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5zdHJvbmcodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZW0nOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5lbSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdjb2Rlc3Bhbic6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmNvZGVzcGFuKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2JyJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuYnIodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZGVsJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuZGVsKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci50ZXh0KHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gJ1Rva2VuIHdpdGggXCInICsgdG9rZW4udHlwZSArICdcIiB0eXBlIHdhcyBub3QgZm91bmQuJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxufVxuXG5jbGFzcyBfSG9va3Mge1xuICAgIG9wdGlvbnM7XG4gICAgYmxvY2s7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IF9kZWZhdWx0cztcbiAgICB9XG4gICAgc3RhdGljIHBhc3NUaHJvdWdoSG9va3MgPSBuZXcgU2V0KFtcbiAgICAgICAgJ3ByZXByb2Nlc3MnLFxuICAgICAgICAncG9zdHByb2Nlc3MnLFxuICAgICAgICAncHJvY2Vzc0FsbFRva2VucycsXG4gICAgXSk7XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBtYXJrZG93biBiZWZvcmUgbWFya2VkXG4gICAgICovXG4gICAgcHJlcHJvY2VzcyhtYXJrZG93bikge1xuICAgICAgICByZXR1cm4gbWFya2Rvd247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgSFRNTCBhZnRlciBtYXJrZWQgaXMgZmluaXNoZWRcbiAgICAgKi9cbiAgICBwb3N0cHJvY2VzcyhodG1sKSB7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGFsbCB0b2tlbnMgYmVmb3JlIHdhbGsgdG9rZW5zXG4gICAgICovXG4gICAgcHJvY2Vzc0FsbFRva2Vucyh0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZSBmdW5jdGlvbiB0byB0b2tlbml6ZSBtYXJrZG93blxuICAgICAqL1xuICAgIHByb3ZpZGVMZXhlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2sgPyBfTGV4ZXIubGV4IDogX0xleGVyLmxleElubGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZSBmdW5jdGlvbiB0byBwYXJzZSB0b2tlbnNcbiAgICAgKi9cbiAgICBwcm92aWRlUGFyc2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9jayA/IF9QYXJzZXIucGFyc2UgOiBfUGFyc2VyLnBhcnNlSW5saW5lO1xuICAgIH1cbn1cblxuY2xhc3MgTWFya2VkIHtcbiAgICBkZWZhdWx0cyA9IF9nZXREZWZhdWx0cygpO1xuICAgIG9wdGlvbnMgPSB0aGlzLnNldE9wdGlvbnM7XG4gICAgcGFyc2UgPSB0aGlzLnBhcnNlTWFya2Rvd24odHJ1ZSk7XG4gICAgcGFyc2VJbmxpbmUgPSB0aGlzLnBhcnNlTWFya2Rvd24oZmFsc2UpO1xuICAgIFBhcnNlciA9IF9QYXJzZXI7XG4gICAgUmVuZGVyZXIgPSBfUmVuZGVyZXI7XG4gICAgVGV4dFJlbmRlcmVyID0gX1RleHRSZW5kZXJlcjtcbiAgICBMZXhlciA9IF9MZXhlcjtcbiAgICBUb2tlbml6ZXIgPSBfVG9rZW5pemVyO1xuICAgIEhvb2tzID0gX0hvb2tzO1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy51c2UoLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biBjYWxsYmFjayBmb3IgZXZlcnkgdG9rZW5cbiAgICAgKi9cbiAgICB3YWxrVG9rZW5zKHRva2VucywgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChjYWxsYmFjay5jYWxsKHRoaXMsIHRva2VuKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdGFibGVUb2tlbi5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlVG9rZW4ucm93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdsaXN0Jzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnMobGlzdFRva2VuLml0ZW1zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmljVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdHMuZXh0ZW5zaW9ucz8uY2hpbGRUb2tlbnM/LltnZW5lcmljVG9rZW4udHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdHMuZXh0ZW5zaW9ucy5jaGlsZFRva2Vuc1tnZW5lcmljVG9rZW4udHlwZV0uZm9yRWFjaCgoY2hpbGRUb2tlbnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbnMgPSBnZW5lcmljVG9rZW5bY2hpbGRUb2tlbnNdLmZsYXQoSW5maW5pdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKHRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGdlbmVyaWNUb2tlbi50b2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGdlbmVyaWNUb2tlbi50b2tlbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgdXNlKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZGVmYXVsdHMuZXh0ZW5zaW9ucyB8fCB7IHJlbmRlcmVyczoge30sIGNoaWxkVG9rZW5zOiB7fSB9O1xuICAgICAgICBhcmdzLmZvckVhY2goKHBhY2spID0+IHtcbiAgICAgICAgICAgIC8vIGNvcHkgb3B0aW9ucyB0byBuZXcgb2JqZWN0XG4gICAgICAgICAgICBjb25zdCBvcHRzID0geyAuLi5wYWNrIH07XG4gICAgICAgICAgICAvLyBzZXQgYXN5bmMgdG8gdHJ1ZSBpZiBpdCB3YXMgc2V0IHRvIHRydWUgYmVmb3JlXG4gICAgICAgICAgICBvcHRzLmFzeW5jID0gdGhpcy5kZWZhdWx0cy5hc3luYyB8fCBvcHRzLmFzeW5jIHx8IGZhbHNlO1xuICAgICAgICAgICAgLy8gPT0tLSBQYXJzZSBcImFkZG9uXCIgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICAgICAgICBpZiAocGFjay5leHRlbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgcGFjay5leHRlbnNpb25zLmZvckVhY2goKGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4dC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuc2lvbiBuYW1lIHJlcXVpcmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCdyZW5kZXJlcicgaW4gZXh0KSB7IC8vIFJlbmRlcmVyIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZSZW5kZXJlciA9IGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2UmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGV4dGVuc2lvbiB3aXRoIGZ1bmMgdG8gcnVuIG5ldyBleHRlbnNpb24gYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSBleHQucmVuZGVyZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBwcmV2UmVuZGVyZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdID0gZXh0LnJlbmRlcmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgndG9rZW5pemVyJyBpbiBleHQpIHsgLy8gVG9rZW5pemVyIEV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXh0LmxldmVsIHx8IChleHQubGV2ZWwgIT09ICdibG9jaycgJiYgZXh0LmxldmVsICE9PSAnaW5saW5lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHRlbnNpb24gbGV2ZWwgbXVzdCBiZSAnYmxvY2snIG9yICdpbmxpbmUnXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0TGV2ZWwgPSBleHRlbnNpb25zW2V4dC5sZXZlbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0TGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRMZXZlbC51bnNoaWZ0KGV4dC50b2tlbml6ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHQubGV2ZWxdID0gW2V4dC50b2tlbml6ZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dC5zdGFydCkgeyAvLyBGdW5jdGlvbiB0byBjaGVjayBmb3Igc3RhcnQgb2YgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0LmxldmVsID09PSAnYmxvY2snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25zLnN0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRCbG9jay5wdXNoKGV4dC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sgPSBbZXh0LnN0YXJ0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChleHQubGV2ZWwgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25zLnN0YXJ0SW5saW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0SW5saW5lLnB1c2goZXh0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUgPSBbZXh0LnN0YXJ0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ2NoaWxkVG9rZW5zJyBpbiBleHQgJiYgZXh0LmNoaWxkVG9rZW5zKSB7IC8vIENoaWxkIHRva2VucyB0byBiZSB2aXNpdGVkIGJ5IHdhbGtUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbZXh0Lm5hbWVdID0gZXh0LmNoaWxkVG9rZW5zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3B0cy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vID09LS0gUGFyc2UgXCJvdmVyd3JpdGVcIiBleHRlbnNpb25zIC0tPT0gLy9cbiAgICAgICAgICAgIGlmIChwYWNrLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLmRlZmF1bHRzLnJlbmRlcmVyIHx8IG5ldyBfUmVuZGVyZXIodGhpcy5kZWZhdWx0cyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHBhY2sucmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocHJvcCBpbiByZW5kZXJlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVuZGVyZXIgJyR7cHJvcH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFsnb3B0aW9ucycsICdwYXJzZXInXS5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG9wdGlvbnMgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyUHJvcCA9IHByb3A7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyRnVuYyA9IHBhY2sucmVuZGVyZXJbcmVuZGVyZXJQcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldlJlbmRlcmVyID0gcmVuZGVyZXJbcmVuZGVyZXJQcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSByZW5kZXJlciB3aXRoIGZ1bmMgdG8gcnVuIGV4dGVuc2lvbiwgYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlcltyZW5kZXJlclByb3BdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSByZW5kZXJlckZ1bmMuYXBwbHkocmVuZGVyZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBwcmV2UmVuZGVyZXIuYXBwbHkocmVuZGVyZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0cy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhY2sudG9rZW5pemVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5pemVyID0gdGhpcy5kZWZhdWx0cy50b2tlbml6ZXIgfHwgbmV3IF9Ub2tlbml6ZXIodGhpcy5kZWZhdWx0cyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHBhY2sudG9rZW5pemVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHByb3AgaW4gdG9rZW5pemVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0b2tlbml6ZXIgJyR7cHJvcH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFsnb3B0aW9ucycsICdydWxlcycsICdsZXhlciddLmluY2x1ZGVzKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgb3B0aW9ucywgcnVsZXMsIGFuZCBsZXhlciBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbml6ZXJQcm9wID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5pemVyRnVuYyA9IHBhY2sudG9rZW5pemVyW3Rva2VuaXplclByb3BdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2VG9rZW5pemVyID0gdG9rZW5pemVyW3Rva2VuaXplclByb3BdO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRva2VuaXplciB3aXRoIGZ1bmMgdG8gcnVuIGV4dGVuc2lvbiwgYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNhbm5vdCB0eXBlIHRva2VuaXplciBmdW5jdGlvbiBkeW5hbWljYWxseVxuICAgICAgICAgICAgICAgICAgICB0b2tlbml6ZXJbdG9rZW5pemVyUHJvcF0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IHRva2VuaXplckZ1bmMuYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHJldlRva2VuaXplci5hcHBseSh0b2tlbml6ZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA9PS0tIFBhcnNlIEhvb2tzIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgICAgICAgICAgaWYgKHBhY2suaG9va3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBob29rcyA9IHRoaXMuZGVmYXVsdHMuaG9va3MgfHwgbmV3IF9Ib29rcygpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYWNrLmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHByb3AgaW4gaG9va3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhvb2sgJyR7cHJvcH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFsnb3B0aW9ucycsICdibG9jayddLmluY2x1ZGVzKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgb3B0aW9ucyBhbmQgYmxvY2sgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9va3NQcm9wID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9va3NGdW5jID0gcGFjay5ob29rc1tob29rc1Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2SG9vayA9IGhvb2tzW2hvb2tzUHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChfSG9va3MucGFzc1Rocm91Z2hIb29rcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2Fubm90IHR5cGUgaG9vayBmdW5jdGlvbiBkeW5hbWljYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3NbaG9va3NQcm9wXSA9IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0cy5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhvb2tzRnVuYy5jYWxsKGhvb2tzLCBhcmcpKS50aGVuKHJldCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldkhvb2suY2FsbChob29rcywgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IGhvb2tzRnVuYy5jYWxsKGhvb2tzLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2SG9vay5jYWxsKGhvb2tzLCByZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2Fubm90IHR5cGUgaG9vayBmdW5jdGlvbiBkeW5hbWljYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3NbaG9va3NQcm9wXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IGhvb2tzRnVuYy5hcHBseShob29rcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHJldkhvb2suYXBwbHkoaG9va3MsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLmhvb2tzID0gaG9va3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA9PS0tIFBhcnNlIFdhbGtUb2tlbnMgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICAgICAgICBpZiAocGFjay53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2Fsa1Rva2VucyA9IHRoaXMuZGVmYXVsdHMud2Fsa1Rva2VucztcbiAgICAgICAgICAgICAgICBjb25zdCBwYWNrV2Fsa3Rva2VucyA9IHBhY2sud2Fsa1Rva2VucztcbiAgICAgICAgICAgICAgICBvcHRzLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChwYWNrV2Fsa3Rva2Vucy5jYWxsKHRoaXMsIHRva2VuKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHdhbGtUb2tlbnMuY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdHMgPSB7IC4uLnRoaXMuZGVmYXVsdHMsIC4uLm9wdHMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdCkge1xuICAgICAgICB0aGlzLmRlZmF1bHRzID0geyAuLi50aGlzLmRlZmF1bHRzLCAuLi5vcHQgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxleGVyKHNyYywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX0xleGVyLmxleChzcmMsIG9wdGlvbnMgPz8gdGhpcy5kZWZhdWx0cyk7XG4gICAgfVxuICAgIHBhcnNlcih0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9QYXJzZXIucGFyc2UodG9rZW5zLCBvcHRpb25zID8/IHRoaXMuZGVmYXVsdHMpO1xuICAgIH1cbiAgICBwYXJzZU1hcmtkb3duKGJsb2NrVHlwZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBwYXJzZSA9IChzcmMsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdPcHQgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IHsgLi4udGhpcy5kZWZhdWx0cywgLi4ub3JpZ09wdCB9O1xuICAgICAgICAgICAgY29uc3QgdGhyb3dFcnJvciA9IHRoaXMub25FcnJvcighIW9wdC5zaWxlbnQsICEhb3B0LmFzeW5jKTtcbiAgICAgICAgICAgIC8vIHRocm93IGVycm9yIGlmIGFuIGV4dGVuc2lvbiBzZXQgYXN5bmMgdG8gdHJ1ZSBidXQgcGFyc2Ugd2FzIGNhbGxlZCB3aXRoIGFzeW5jOiBmYWxzZVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdHMuYXN5bmMgPT09IHRydWUgJiYgb3JpZ09wdC5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBUaGUgYXN5bmMgb3B0aW9uIHdhcyBzZXQgdG8gdHJ1ZSBieSBhbiBleHRlbnNpb24uIFJlbW92ZSBhc3luYzogZmFsc2UgZnJvbSB0aGUgcGFyc2Ugb3B0aW9ucyBvYmplY3QgdG8gcmV0dXJuIGEgUHJvbWlzZS4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aHJvdyBlcnJvciBpbiBjYXNlIG9mIG5vbiBzdHJpbmcgaW5wdXRcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgb2YgdHlwZSAnXG4gICAgICAgICAgICAgICAgICAgICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNyYykgKyAnLCBzdHJpbmcgZXhwZWN0ZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgb3B0Lmhvb2tzLm9wdGlvbnMgPSBvcHQ7XG4gICAgICAgICAgICAgICAgb3B0Lmhvb2tzLmJsb2NrID0gYmxvY2tUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGV4ZXIgPSBvcHQuaG9va3MgPyBvcHQuaG9va3MucHJvdmlkZUxleGVyKCkgOiAoYmxvY2tUeXBlID8gX0xleGVyLmxleCA6IF9MZXhlci5sZXhJbmxpbmUpO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VyID0gb3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnByb3ZpZGVQYXJzZXIoKSA6IChibG9ja1R5cGUgPyBfUGFyc2VyLnBhcnNlIDogX1BhcnNlci5wYXJzZUlubGluZSk7XG4gICAgICAgICAgICBpZiAob3B0LmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvcHQuaG9va3MgPyBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpIDogc3JjKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihzcmMgPT4gbGV4ZXIoc3JjLCBvcHQpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbih0b2tlbnMgPT4gb3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnByb2Nlc3NBbGxUb2tlbnModG9rZW5zKSA6IHRva2VucylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odG9rZW5zID0+IG9wdC53YWxrVG9rZW5zID8gUHJvbWlzZS5hbGwodGhpcy53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpKS50aGVuKCgpID0+IHRva2VucykgOiB0b2tlbnMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHRva2VucyA9PiBwYXJzZXIodG9rZW5zLCBvcHQpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihodG1sID0+IG9wdC5ob29rcyA/IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKSA6IGh0bWwpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCh0aHJvd0Vycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgICAgICAgICAgICBzcmMgPSBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdG9rZW5zID0gbGV4ZXIoc3JjLCBvcHQpO1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gb3B0Lmhvb2tzLnByb2Nlc3NBbGxUb2tlbnModG9rZW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGh0bWwgPSBwYXJzZXIodG9rZW5zLCBvcHQpO1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbCA9IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFyc2U7XG4gICAgfVxuICAgIG9uRXJyb3Ioc2lsZW50LCBhc3luYykge1xuICAgICAgICByZXR1cm4gKGUpID0+IHtcbiAgICAgICAgICAgIGUubWVzc2FnZSArPSAnXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWQuJztcbiAgICAgICAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnPHA+QW4gZXJyb3Igb2NjdXJyZWQ6PC9wPjxwcmU+J1xuICAgICAgICAgICAgICAgICAgICArIGVzY2FwZSQxKGUubWVzc2FnZSArICcnLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICArICc8L3ByZT4nO1xuICAgICAgICAgICAgICAgIGlmIChhc3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuY29uc3QgbWFya2VkSW5zdGFuY2UgPSBuZXcgTWFya2VkKCk7XG5mdW5jdGlvbiBtYXJrZWQoc3JjLCBvcHQpIHtcbiAgICByZXR1cm4gbWFya2VkSW5zdGFuY2UucGFyc2Uoc3JjLCBvcHQpO1xufVxuLyoqXG4gKiBTZXRzIHRoZSBkZWZhdWx0IG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgSGFzaCBvZiBvcHRpb25zXG4gKi9cbm1hcmtlZC5vcHRpb25zID1cbiAgICBtYXJrZWQuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG1hcmtlZEluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIG1hcmtlZC5kZWZhdWx0cyA9IG1hcmtlZEluc3RhbmNlLmRlZmF1bHRzO1xuICAgICAgICBjaGFuZ2VEZWZhdWx0cyhtYXJrZWQuZGVmYXVsdHMpO1xuICAgICAgICByZXR1cm4gbWFya2VkO1xuICAgIH07XG4vKipcbiAqIEdldHMgdGhlIG9yaWdpbmFsIG1hcmtlZCBkZWZhdWx0IG9wdGlvbnMuXG4gKi9cbm1hcmtlZC5nZXREZWZhdWx0cyA9IF9nZXREZWZhdWx0cztcbm1hcmtlZC5kZWZhdWx0cyA9IF9kZWZhdWx0cztcbi8qKlxuICogVXNlIEV4dGVuc2lvblxuICovXG5tYXJrZWQudXNlID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBtYXJrZWRJbnN0YW5jZS51c2UoLi4uYXJncyk7XG4gICAgbWFya2VkLmRlZmF1bHRzID0gbWFya2VkSW5zdGFuY2UuZGVmYXVsdHM7XG4gICAgY2hhbmdlRGVmYXVsdHMobWFya2VkLmRlZmF1bHRzKTtcbiAgICByZXR1cm4gbWFya2VkO1xufTtcbi8qKlxuICogUnVuIGNhbGxiYWNrIGZvciBldmVyeSB0b2tlblxuICovXG5tYXJrZWQud2Fsa1Rva2VucyA9IGZ1bmN0aW9uICh0b2tlbnMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG1hcmtlZEluc3RhbmNlLndhbGtUb2tlbnModG9rZW5zLCBjYWxsYmFjayk7XG59O1xuLyoqXG4gKiBDb21waWxlcyBtYXJrZG93biB0byBIVE1MIHdpdGhvdXQgZW5jbG9zaW5nIGBwYCB0YWcuXG4gKlxuICogQHBhcmFtIHNyYyBTdHJpbmcgb2YgbWFya2Rvd24gc291cmNlIHRvIGJlIGNvbXBpbGVkXG4gKiBAcGFyYW0gb3B0aW9ucyBIYXNoIG9mIG9wdGlvbnNcbiAqIEByZXR1cm4gU3RyaW5nIG9mIGNvbXBpbGVkIEhUTUxcbiAqL1xubWFya2VkLnBhcnNlSW5saW5lID0gbWFya2VkSW5zdGFuY2UucGFyc2VJbmxpbmU7XG4vKipcbiAqIEV4cG9zZVxuICovXG5tYXJrZWQuUGFyc2VyID0gX1BhcnNlcjtcbm1hcmtlZC5wYXJzZXIgPSBfUGFyc2VyLnBhcnNlO1xubWFya2VkLlJlbmRlcmVyID0gX1JlbmRlcmVyO1xubWFya2VkLlRleHRSZW5kZXJlciA9IF9UZXh0UmVuZGVyZXI7XG5tYXJrZWQuTGV4ZXIgPSBfTGV4ZXI7XG5tYXJrZWQubGV4ZXIgPSBfTGV4ZXIubGV4O1xubWFya2VkLlRva2VuaXplciA9IF9Ub2tlbml6ZXI7XG5tYXJrZWQuSG9va3MgPSBfSG9va3M7XG5tYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG5jb25zdCBvcHRpb25zID0gbWFya2VkLm9wdGlvbnM7XG5jb25zdCBzZXRPcHRpb25zID0gbWFya2VkLnNldE9wdGlvbnM7XG5jb25zdCB1c2UgPSBtYXJrZWQudXNlO1xuY29uc3Qgd2Fsa1Rva2VucyA9IG1hcmtlZC53YWxrVG9rZW5zO1xuY29uc3QgcGFyc2VJbmxpbmUgPSBtYXJrZWQucGFyc2VJbmxpbmU7XG5jb25zdCBwYXJzZSA9IG1hcmtlZDtcbmNvbnN0IHBhcnNlciA9IF9QYXJzZXIucGFyc2U7XG5jb25zdCBsZXhlciA9IF9MZXhlci5sZXg7XG5cbmV4cG9ydCB7IF9Ib29rcyBhcyBIb29rcywgX0xleGVyIGFzIExleGVyLCBNYXJrZWQsIF9QYXJzZXIgYXMgUGFyc2VyLCBfUmVuZGVyZXIgYXMgUmVuZGVyZXIsIF9UZXh0UmVuZGVyZXIgYXMgVGV4dFJlbmRlcmVyLCBfVG9rZW5pemVyIGFzIFRva2VuaXplciwgX2RlZmF1bHRzIGFzIGRlZmF1bHRzLCBfZ2V0RGVmYXVsdHMgYXMgZ2V0RGVmYXVsdHMsIGxleGVyLCBtYXJrZWQsIG9wdGlvbnMsIHBhcnNlLCBwYXJzZUlubGluZSwgcGFyc2VyLCBzZXRPcHRpb25zLCB1c2UsIHdhbGtUb2tlbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcmtlZC5lc20uanMubWFwXG4iLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM2M/eG1sJTIwdmVyc2lvbj0nMS4wJyUyMGVuY29kaW5nPSd1dGYtOCc/JTNlJTNjIS0tJTIwVXBsb2FkZWQlMjB0bzolMjBTVkclMjBSZXBvLCUyMHd3dy5zdmdyZXBvLmNvbSwlMjBHZW5lcmF0b3I6JTIwU1ZHJTIwUmVwbyUyME1peGVyJTIwVG9vbHMlMjAtLSUzZSUzY3N2ZyUyMHdpZHRoPSc4MDBweCclMjBoZWlnaHQ9JzgwMHB4JyUyMHZpZXdCb3g9JzAlMjAwJTIwMjQlMjAyNCclMjBmaWxsPSdub25lJyUyMHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyclM2UlM2NnJTIwaWQ9J0VkaXQlMjAvJTIwRWRpdF9QZW5jaWxfMDEnJTNlJTNjcGF0aCUyMGlkPSdWZWN0b3InJTIwZD0nTTEyJTIwOC4wMDAxMkw0JTIwMTYuMDAwMVYyMC4wMDAxTDglMjAyMC4wMDAxTDE2JTIwMTIuMDAwMU0xMiUyMDguMDAwMTJMMTQuODY4NiUyMDUuMTMxNDZMMTQuODcwNCUyMDUuMTI5NzZDMTUuMjY1MiUyMDQuNzM0ODglMjAxNS40NjMlMjA0LjUzNzA5JTIwMTUuNjkxJTIwNC40NjMwMUMxNS44OTE5JTIwNC4zOTc3NSUyMDE2LjEwODIlMjA0LjM5Nzc1JTIwMTYuMzA5MSUyMDQuNDYzMDFDMTYuNTM2OSUyMDQuNTM3MDQlMjAxNi43MzQ1JTIwNC43MzQ2JTIwMTcuMTI4OCUyMDUuMTI4OTJMMTguODY4NiUyMDYuODY4NzJDMTkuMjY0NiUyMDcuMjY0NzQlMjAxOS40NjI3JTIwNy40NjI4NCUyMDE5LjUzNjklMjA3LjY5MTE3QzE5LjYwMjIlMjA3Ljg5MjAxJTIwMTkuNjAyMSUyMDguMTA4MzUlMjAxOS41MzY5JTIwOC4zMDkyQzE5LjQ2MjglMjA4LjUzNzM2JTIwMTkuMjY1JTIwOC43MzUxNiUyMDE4Ljg2OTUlMjA5LjEzMDYxTDE4Ljg2ODYlMjA5LjEzMTQ2TDE2JTIwMTIuMDAwMU0xMiUyMDguMDAwMTJMMTYlMjAxMi4wMDAxJyUyMHN0cm9rZT0nJTIzMDAwMDAwJyUyMHN0cm9rZS13aWR0aD0nMiclMjBzdHJva2UtbGluZWNhcD0ncm91bmQnJTIwc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCcvJTNlJTNjL2clM2UlM2Mvc3ZnJTNlXCIiLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM2M/eG1sJTIwdmVyc2lvbj0nMS4wJyUyMGVuY29kaW5nPSd1dGYtOCc/JTNlJTNjIS0tJTIwVXBsb2FkZWQlMjB0bzolMjBTVkclMjBSZXBvLCUyMHd3dy5zdmdyZXBvLmNvbSwlMjBHZW5lcmF0b3I6JTIwU1ZHJTIwUmVwbyUyME1peGVyJTIwVG9vbHMlMjAtLSUzZSUzY3N2ZyUyMHdpZHRoPSc4MDBweCclMjBoZWlnaHQ9JzgwMHB4JyUyMHZpZXdCb3g9JzAlMjAwJTIwMjQlMjAyNCclMjBmaWxsPSdub25lJyUyMHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyclM2UlM2NnJTIwaWQ9J0ludGVyZmFjZSUyMC8lMjBUcmFzaF9GdWxsJyUzZSUzY3BhdGglMjBpZD0nVmVjdG9yJyUyMGQ9J00xNCUyMDEwVjE3TTEwJTIwMTBWMTdNNiUyMDZWMTcuOEM2JTIwMTguOTIwMSUyMDYlMjAxOS40Nzk4JTIwNi4yMTc5OSUyMDE5LjkwNzZDNi40MDk3MyUyMDIwLjI4MzklMjA2LjcxNTQ3JTIwMjAuNTkwNSUyMDcuMDkxOCUyMDIwLjc4MjJDNy41MTkyJTIwMjElMjA4LjA3ODk5JTIwMjElMjA5LjE5NjkxJTIwMjFIMTQuODAzMUMxNS45MjElMjAyMSUyMDE2LjQ4JTIwMjElMjAxNi45MDc0JTIwMjAuNzgyMkMxNy4yODM3JTIwMjAuNTkwNSUyMDE3LjU5MDUlMjAyMC4yODM5JTIwMTcuNzgyMiUyMDE5LjkwNzZDMTglMjAxOS40ODAyJTIwMTglMjAxOC45MjElMjAxOCUyMDE3LjgwMzFWNk02JTIwNkg4TTYlMjA2SDRNOCUyMDZIMTZNOCUyMDZDOCUyMDUuMDY4MTIlMjA4JTIwNC42MDI0MSUyMDguMTUyMjQlMjA0LjIzNDg2QzguMzU1MjMlMjAzLjc0NDgxJTIwOC43NDQzMiUyMDMuMzU1MjMlMjA5LjIzNDM4JTIwMy4xNTIyNEM5LjYwMTkyJTIwMyUyMDEwLjA2ODElMjAzJTIwMTElMjAzSDEzQzEzLjkzMTklMjAzJTIwMTQuMzk3OCUyMDMlMjAxNC43NjU0JTIwMy4xNTIyNEMxNS4yNTU0JTIwMy4zNTUyMyUyMDE1LjY0NDclMjAzLjc0NDgxJTIwMTUuODQ3NyUyMDQuMjM0ODZDMTUuOTk5OSUyMDQuNjAyNCUyMDE2JTIwNS4wNjgxMiUyMDE2JTIwNk0xNiUyMDZIMThNMTglMjA2SDIwJyUyMHN0cm9rZT0nJTIzMDAwMDAwJyUyMHN0cm9rZS13aWR0aD0nMiclMjBzdHJva2UtbGluZWNhcD0ncm91bmQnJTIwc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCcvJTNlJTNjL2clM2UlM2Mvc3ZnJTNlXCIiLCI8c2NyaXB0IHNldHVwIGxhbmc9XCJ0c1wiPlxuaW1wb3J0IHsgcmVmLCBjb21wdXRlZCB9IGZyb20gXCJ2dWVcIjtcbmltcG9ydCB7IHVzZUNoYXRib3hTdG9yZSB9IGZyb20gXCJAL3N0b3JlL2NoYXRib3hcIjtcblxuaW50ZXJmYWNlIE1lc3NhZ2Uge1xuICByb2xlOiBcInVzZXJcIiB8IFwiYXNzaXN0YW50XCIgfCBcInN5c3RlbVwiO1xuICBjb250ZW50OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBDaGF0U2Vzc2lvbiB7XG4gIGlkOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogRGF0ZTtcbiAgbWVzc2FnZXM6IE1lc3NhZ2VbXTtcbn1cblxuY29uc3QgZW1pdCA9IGRlZmluZUVtaXRzPHtcbiAgKGU6IFwibG9hZENoYXRcIiwgY2hhdDogQ2hhdFNlc3Npb24pOiB2b2lkO1xufT4oKTtcblxuY29uc3QgY2hhdGJveCA9IHVzZUNoYXRib3hTdG9yZSgpO1xuY29uc3QgaXNWaXNpYmxlID0gcmVmKGZhbHNlKTtcbmNvbnN0IHNlYXJjaFF1ZXJ5ID0gcmVmKFwiXCIpO1xuY29uc3QgaG92ZXJlZENoYXRJZCA9IHJlZjxzdHJpbmcgfCBudWxsPihudWxsKTtcbmNvbnN0IGVkaXRpbmdDaGF0SWQgPSByZWY8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5jb25zdCBlZGl0VGl0bGUgPSByZWYoXCJcIik7XG5cbmNvbnN0IGZpbHRlcmVkQ2hhdHMgPSBjb21wdXRlZCgoKSA9PiB7XG4gIGlmICghc2VhcmNoUXVlcnkudmFsdWUpIHJldHVybiBjaGF0Ym94LmNoYXRIaXN0b3J5O1xuICBjb25zdCBxdWVyeSA9IHNlYXJjaFF1ZXJ5LnZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBjaGF0Ym94LmNoYXRIaXN0b3J5LmZpbHRlcihcbiAgICAoY2hhdCkgPT5cbiAgICAgIGNoYXQudGl0bGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeSkgfHxcbiAgICAgIGNoYXQubWVzc2FnZXMuc29tZSgobXNnKSA9PiBtc2cuY29udGVudC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5KSksXG4gICk7XG59KTtcblxuY29uc3QgZm9ybWF0RGF0ZSA9IChkYXRlOiBEYXRlKSA9PiB7XG4gIGlmICghZGF0ZSkgcmV0dXJuIFwiXCI7XG4gIHJldHVybiBuZXcgRGF0ZShkYXRlKS50b0xvY2FsZVN0cmluZyhcImVuLVVTXCIsIHtcbiAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICBob3VyOiBcIjItZGlnaXRcIixcbiAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICB9KTtcbn07XG5cbmNvbnN0IHNlbGVjdENoYXQgPSAoY2hhdElkOiBzdHJpbmcpID0+IHtcbiAgaWYgKGVkaXRpbmdDaGF0SWQudmFsdWUgPT09IG51bGwpIHtcbiAgICBjaGF0Ym94LmxvYWRDaGF0KGNoYXRJZCk7XG4gICAgaGlkZSgpO1xuICB9XG59O1xuXG5jb25zdCBzdGFydEVkaXQgPSAoZXZlbnQ6IEV2ZW50LCBjaGF0OiBDaGF0U2Vzc2lvbikgPT4ge1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgZWRpdGluZ0NoYXRJZC52YWx1ZSA9IGNoYXQuaWQ7XG4gIGVkaXRUaXRsZS52YWx1ZSA9IGNoYXQudGl0bGU7XG59O1xuXG5jb25zdCBzYXZlRWRpdCA9IChldmVudDogRXZlbnQsIGNoYXRJZDogc3RyaW5nKSA9PiB7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICBpZiAoZWRpdFRpdGxlLnZhbHVlLnRyaW0oKSkge1xuICAgIGNvbnN0IGNoYXRJbmRleCA9IGNoYXRib3guY2hhdEhpc3RvcnkuZmluZEluZGV4KChjaGF0KSA9PiBjaGF0LmlkID09PSBjaGF0SWQpO1xuICAgIGlmIChjaGF0SW5kZXggIT09IC0xKSB7XG4gICAgICBjaGF0Ym94LmNoYXRIaXN0b3J5W2NoYXRJbmRleF0udGl0bGUgPSBlZGl0VGl0bGUudmFsdWUudHJpbSgpO1xuICAgICAgY2hhdGJveC5zYXZlVG9TdG9yYWdlKCk7XG4gICAgfVxuICB9XG4gIGVkaXRpbmdDaGF0SWQudmFsdWUgPSBudWxsO1xuICBlZGl0VGl0bGUudmFsdWUgPSBcIlwiO1xufTtcblxuY29uc3QgZGVsZXRlQ2hhdCA9IChjaGF0SWQ6IHN0cmluZykgPT4ge1xuICBpZiAoY29uZmlybShcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgdGhpcyBjaGF0P1wiKSkge1xuICAgIGNvbnN0IGNoYXRJbmRleCA9IGNoYXRib3guY2hhdEhpc3RvcnkuZmluZEluZGV4KChjaGF0KSA9PiBjaGF0LmlkID09PSBjaGF0SWQpO1xuICAgIGlmIChjaGF0SW5kZXggIT09IC0xKSB7XG4gICAgICBjaGF0Ym94LmNoYXRIaXN0b3J5LnNwbGljZShjaGF0SW5kZXgsIDEpO1xuICAgICAgaWYgKGNoYXRib3guY3VycmVudENoYXRJZCA9PT0gY2hhdElkKSB7XG4gICAgICAgIGNoYXRib3guY2xlYXJNZXNzYWdlcygpO1xuICAgICAgICBjaGF0Ym94LmN1cnJlbnRDaGF0SWQgPSBcIlwiO1xuICAgICAgfVxuICAgICAgY2hhdGJveC5zYXZlVG9TdG9yYWdlKCk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBoYW5kbGVLZXlEb3duID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBjaGF0SWQ6IHN0cmluZykgPT4ge1xuICBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICBzYXZlRWRpdChldmVudCwgY2hhdElkKTtcbiAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICBlZGl0aW5nQ2hhdElkLnZhbHVlID0gbnVsbDtcbiAgICBlZGl0VGl0bGUudmFsdWUgPSBcIlwiO1xuICB9XG59O1xuXG5jb25zdCBzaG93ID0gKCkgPT4ge1xuICBpc1Zpc2libGUudmFsdWUgPSB0cnVlO1xufTtcblxuY29uc3QgaGlkZSA9ICgpID0+IHtcbiAgaXNWaXNpYmxlLnZhbHVlID0gZmFsc2U7XG4gIGhvdmVyZWRDaGF0SWQudmFsdWUgPSBudWxsO1xuICBlZGl0aW5nQ2hhdElkLnZhbHVlID0gbnVsbDtcbiAgZWRpdFRpdGxlLnZhbHVlID0gXCJcIjtcbn07XG5cbmRlZmluZUV4cG9zZSh7IHNob3csIGhpZGUgfSk7XG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8ZGl2IHYtaWY9XCJpc1Zpc2libGVcIiBjbGFzcz1cImNoYXQtaGlzdG9yeS1vdmVybGF5XCI+XG4gICAgPGRpdiBjbGFzcz1cImNoYXQtaGlzdG9yeS1tb2RhbFwiPlxuICAgICAgPGRpdiBjbGFzcz1cImNoYXQtaGlzdG9yeS1oZWFkZXJcIj5cbiAgICAgICAgPGgyIGNsYXNzPVwiY2hhdC1oaXN0b3J5LXRpdGxlXCI+VGVhY2hlckFJZGU8L2gyPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2hhdC1oaXN0b3J5LXN1YnRpdGxlXCI+Q2hhdCBIaXN0b3J5PC9kaXY+XG4gICAgICAgIDxpbWcgQGNsaWNrPVwiaGlkZVwiIHNyYz1cIi4uL2Fzc2V0cy9jbG9zZV9pY29uLnN2Z1wiIGFsdD1cImNsb3NlXCIgY2xhc3M9XCJjaGF0LWhpc3RvcnktY2xvc2VcIiAvPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJjaGF0LWhpc3Rvcnktc2VhcmNoLWNvbnRhaW5lclwiPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICB2LW1vZGVsPVwic2VhcmNoUXVlcnlcIlxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIlNlYXJjaCB5b3VyIGNoYXRzLi4uXCJcbiAgICAgICAgICBjbGFzcz1cImNoYXQtaGlzdG9yeS1zZWFyY2gtaW5wdXRcIlxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJjaGF0LWhpc3RvcnktY29udGVudFwiPlxuICAgICAgICA8dGVtcGxhdGUgdi1pZj1cImZpbHRlcmVkQ2hhdHMubGVuZ3RoID09PSAwXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNoYXQtaGlzdG9yeS1lbXB0eS1jb250YWluZXJcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGF0LWhpc3RvcnktZW1wdHlcIj5cbiAgICAgICAgICAgICAgPHA+WW91ciBjaGF0IGhpc3RvcnkgaXMgY3VycmVudGx5IGVtcHR5LjwvcD5cbiAgICAgICAgICAgICAgPHA+UmV0dXJuIHRvIEhvbWUgc2NyZWVuIGFuZCBzdGFydCBhIG5ldyBjb252ZXJzYXRpb24hPC9wPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvdGVtcGxhdGU+XG5cbiAgICAgICAgPHRlbXBsYXRlIHYtZWxzZT5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2hhdC1oaXN0b3J5LWxpc3RcIj5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgdi1mb3I9XCJjaGF0IGluIGZpbHRlcmVkQ2hhdHNcIlxuICAgICAgICAgICAgICA6a2V5PVwiY2hhdC5pZFwiXG4gICAgICAgICAgICAgIGNsYXNzPVwiY2hhdC1oaXN0b3J5LWl0ZW1cIlxuICAgICAgICAgICAgICA6Y2xhc3M9XCJ7IGFjdGl2ZTogaG92ZXJlZENoYXRJZCA9PT0gY2hhdC5pZCB9XCJcbiAgICAgICAgICAgICAgQG1vdXNlZW50ZXI9XCJob3ZlcmVkQ2hhdElkID0gY2hhdC5pZFwiXG4gICAgICAgICAgICAgIEBtb3VzZWxlYXZlPVwiaG92ZXJlZENoYXRJZCA9IG51bGxcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2hhdC1pdGVtLWFjdGlvbnNcIj5cbiAgICAgICAgICAgICAgICA8aW1nXG4gICAgICAgICAgICAgICAgICBAY2xpY2suc3RvcD1cInN0YXJ0RWRpdCgkZXZlbnQsIGNoYXQpXCJcbiAgICAgICAgICAgICAgICAgIHNyYz1cIi4uL2Fzc2V0cy9lZGl0X2ljb24uc3ZnXCJcbiAgICAgICAgICAgICAgICAgIGFsdD1cImVkaXRcIlxuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJhY3Rpb24taWNvblwiXG4gICAgICAgICAgICAgICAgICB0aXRsZT1cIkVkaXQgdGl0bGVcIlxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgICAgQGNsaWNrLnN0b3A9XCJkZWxldGVDaGF0KGNoYXQuaWQpXCJcbiAgICAgICAgICAgICAgICAgIHNyYz1cIi4uL2Fzc2V0cy90cmFzaF9pY29uLnN2Z1wiXG4gICAgICAgICAgICAgICAgICBhbHQ9XCJkZWxldGVcIlxuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJhY3Rpb24taWNvblwiXG4gICAgICAgICAgICAgICAgICB0aXRsZT1cIkRlbGV0ZSBjaGF0XCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNoYXQtaXRlbS1jb250ZW50XCIgQGNsaWNrPVwic2VsZWN0Q2hhdChjaGF0LmlkKVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgdi1pZj1cImVkaXRpbmdDaGF0SWQgPT09IGNoYXQuaWRcIiBjbGFzcz1cImNoYXQtdGl0bGUtZWRpdFwiPlxuICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgIHYtbW9kZWw9XCJlZGl0VGl0bGVcIlxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgIEBjbGljay5zdG9wXG4gICAgICAgICAgICAgICAgICAgIEBrZXlkb3duPVwiKGUpID0+IGhhbmRsZUtleURvd24oZSwgY2hhdC5pZClcIlxuICAgICAgICAgICAgICAgICAgICBAYmx1cj1cInNhdmVFZGl0KCRldmVudCwgY2hhdC5pZClcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImNoYXQtdGl0bGUtaW5wdXRcIlxuICAgICAgICAgICAgICAgICAgICByZWY9XCJlZGl0SW5wdXRcIlxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IHYtZWxzZT5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGF0LXRpdGxlXCI+e3sgY2hhdC50aXRsZSB9fTwvZGl2PlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNoYXQtZGF0ZVwiPnt7IGZvcm1hdERhdGUoY2hhdC50aW1lc3RhbXApIH19PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c3R5bGUgc2NvcGVkPlxuLmNoYXQtaGlzdG9yeS1vdmVybGF5IHtcbiAgcG9zaXRpb246IGZpeGVkO1xuICB0b3A6IDA7XG4gIGxlZnQ6IDA7XG4gIHJpZ2h0OiAwO1xuICBib3R0b206IDA7XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC41KTtcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIHotaW5kZXg6IDEwMDA7XG59XG5cbi5jaGF0LWhpc3RvcnktbW9kYWwge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgd2lkdGg6IDkwJTtcbiAgbWF4LXdpZHRoOiA1MDBweDtcbiAgaGVpZ2h0OiA5MHZoO1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBvdmVyZmxvdzogaGlkZGVuO1xufVxuXG4uY2hhdC1oaXN0b3J5LWhlYWRlciB7XG4gIHBhZGRpbmc6IDIwcHg7XG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZTVlN2ViO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG5cbi5jaGF0LWhpc3RvcnktdGl0bGUge1xuICBjb2xvcjogIzAwMzI3NDtcbiAgZm9udC1zaXplOiAyNHB4O1xuICBmb250LXdlaWdodDogNjAwO1xuICBtYXJnaW46IDA7XG59XG5cbi5jaGF0LWhpc3Rvcnktc3VidGl0bGUge1xuICBjb2xvcjogIzkzYTNiYztcbiAgZm9udC1zaXplOiAxOHB4O1xuICBtYXJnaW4tdG9wOiA0cHg7XG59XG5cbi5jaGF0LWhpc3RvcnktY2xvc2Uge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMjBweDtcbiAgcmlnaHQ6IDIwcHg7XG4gIHdpZHRoOiAxNXB4O1xuICBoZWlnaHQ6IDE1cHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cblxuLmNoYXQtaGlzdG9yeS1zZWFyY2gtY29udGFpbmVyIHtcbiAgcGFkZGluZzogMTJweCAyMHB4O1xuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2U1ZTdlYjtcbn1cblxuLmNoYXQtaGlzdG9yeS1zZWFyY2gtaW5wdXQge1xuICB3aWR0aDogMTAwJTtcbiAgcGFkZGluZzogOHB4IDEycHg7XG4gIGJvcmRlcjogMXB4IHNvbGlkICNlNWU3ZWI7XG4gIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgZm9udC1zaXplOiAxNHB4O1xuICBvdXRsaW5lOiBub25lO1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xufVxuXG4uY2hhdC1oaXN0b3J5LXNlYXJjaC1pbnB1dDpmb2N1cyB7XG4gIGJvcmRlci1jb2xvcjogIzAwMzI3NDtcbn1cblxuLmNoYXQtaGlzdG9yeS1jb250ZW50IHtcbiAgZmxleDogMTtcbiAgb3ZlcmZsb3cteTogYXV0bztcbiAgcGFkZGluZzogMjBweDtcbn1cblxuLmNoYXQtaGlzdG9yeS1lbXB0eS1jb250YWluZXIge1xuICBoZWlnaHQ6IDEwMCU7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIGNvbG9yOiAjNmI3MjgwO1xufVxuXG4uY2hhdC1oaXN0b3J5LWVtcHR5IHtcbiAgcGFkZGluZzogMjBweDtcbn1cblxuLmNoYXQtaGlzdG9yeS1lbXB0eSBwIHtcbiAgbWFyZ2luOiA0cHggMDtcbn1cblxuLmNoYXQtaGlzdG9yeS1saXN0IHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgZ2FwOiAxMnB4O1xufVxuXG4uY2hhdC1oaXN0b3J5LWl0ZW0ge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGJhY2tncm91bmQtY29sb3I6ICNlN2VlZjc7XG4gIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgcGFkZGluZzogMTZweDtcbiAgcGFkZGluZy1yaWdodDogMzJweDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICB0cmFuc2l0aW9uOiBhbGwgMC4ycyBlYXNlO1xufVxuXG4uY2hhdC1oaXN0b3J5LWl0ZW0uYWN0aXZlIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2I4Y2NlODtcbn1cblxuLmNoYXQtaXRlbS1hY3Rpb25zIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDhweDtcbiAgcmlnaHQ6IDhweDtcbiAgei1pbmRleDogMTtcbiAgZGlzcGxheTogZmxleDtcbiAgZ2FwOiA4cHg7XG59XG5cbi5hY3Rpb24taWNvbiB7XG4gIHdpZHRoOiAxNnB4O1xuICBoZWlnaHQ6IDE2cHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgb3BhY2l0eTogMDtcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGVhc2U7XG59XG5cbi5jaGF0LWhpc3RvcnktaXRlbTpob3ZlciAuYWN0aW9uLWljb24ge1xuICBvcGFjaXR5OiAwLjY7XG59XG5cbi5hY3Rpb24taWNvbjpob3ZlciB7XG4gIG9wYWNpdHk6IDEgIWltcG9ydGFudDtcbn1cblxuLmNoYXQtdGl0bGUtZWRpdCB7XG4gIG1hcmdpbi1yaWdodDogNDBweDtcbn1cblxuLmNoYXQtdGl0bGUtaW5wdXQge1xuICB3aWR0aDogMTAwJTtcbiAgcGFkZGluZzogNHB4IDhweDtcbiAgYm9yZGVyOiAxcHggc29saWQgIzAwMzI3NDtcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xuICBmb250LXNpemU6IDE0cHg7XG4gIGJhY2tncm91bmQ6IHdoaXRlO1xuICBjb2xvcjogIzAwMzI3NDtcbn1cblxuLmNoYXQtdGl0bGUtaW5wdXQ6Zm9jdXMge1xuICBvdXRsaW5lOiBub25lO1xuICBib3JkZXItY29sb3I6ICMwMDMyNzQ7XG4gIGJveC1zaGFkb3c6IDAgMCAwIDJweCByZ2JhKDAsIDUwLCAxMTYsIDAuMSk7XG59XG5cbi5jaGF0LXRpdGxlIHtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBjb2xvcjogIzFmMjkzNztcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgbWFyZ2luLWJvdHRvbTogNHB4O1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbn1cblxuLmNoYXQtZGF0ZSB7XG4gIGZvbnQtc2l6ZTogMTJweDtcbiAgY29sb3I6ICM2YjcyODA7XG59XG5cbi8qIFNjcm9sbGJhciBzdHlsaW5nICovXG4uY2hhdC1oaXN0b3J5LWNvbnRlbnQ6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcbiAgd2lkdGg6IDZweDtcbn1cblxuLmNoYXQtaGlzdG9yeS1jb250ZW50Ojotd2Via2l0LXNjcm9sbGJhci10cmFjayB7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xufVxuXG4uY2hhdC1oaXN0b3J5LWNvbnRlbnQ6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iIHtcbiAgYmFja2dyb3VuZDogI2RkZDtcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xufVxuXG4uY2hhdC1oaXN0b3J5LWNvbnRlbnQ6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iOmhvdmVyIHtcbiAgYmFja2dyb3VuZDogI2M0YzRjNDtcbn1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0IHNldHVwIGxhbmc9XCJ0c1wiPlxuaW1wb3J0IHsgcmVmLCByZWFjdGl2ZSB9IGZyb20gXCJ2dWVcIjtcblxuY29uc3QgaXNWaXNpYmxlID0gcmVmKGZhbHNlKTtcblxuY29uc3Qgc2hvdyA9ICgpID0+IHtcbiAgaXNWaXNpYmxlLnZhbHVlID0gdHJ1ZTtcbn07XG5cbmNvbnN0IGhpZGUgPSAoKSA9PiB7XG4gIGlzVmlzaWJsZS52YWx1ZSA9IGZhbHNlO1xuICAvLyBSZXNldCBhbGwgZXhwYW5kZWQgc3RhdGVzIHdoZW4gY2xvc2luZ1xuICBoZWxwSXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4gKGl0ZW0uaXNFeHBhbmRlZCA9IGZhbHNlKSk7XG59O1xuXG5pbnRlcmZhY2UgSGVscEl0ZW0ge1xuICBpZDogbnVtYmVyO1xuICBxdWVzdGlvbjogc3RyaW5nO1xuICBhbnN3ZXI6IHN0cmluZztcbiAgaXNFeHBhbmRlZDogYm9vbGVhbjtcbiAgaXNIb3ZlcmVkOiBib29sZWFuO1xufVxuXG5jb25zdCBoZWxwSXRlbXMgPSByZWFjdGl2ZTxIZWxwSXRlbVtdPihbXG4gIHtcbiAgICBpZDogMSxcbiAgICBxdWVzdGlvbjogXCJXaG8gaXMgVGVhY2hlckFJZGU/XCIsXG4gICAgYW5zd2VyOiBcIlRlYWNoZXJBSWRlIGlzIGEgaGVscGZ1bCBhc3Npc3RhbnQgZGVzaWduZWQgdG8gc3VwcG9ydCB0ZWFjaGVycyBpbiB0aGVpciBkYWlseSB0YXNrcy5cIixcbiAgICBpc0V4cGFuZGVkOiBmYWxzZSxcbiAgICBpc0hvdmVyZWQ6IGZhbHNlLFxuICB9LFxuICB7XG4gICAgaWQ6IDIsXG4gICAgcXVlc3Rpb246IFwiSG93IHRvIGNvcHkgYW5zd2VyP1wiLFxuICAgIGFuc3dlcjogXCJDbGljayB0aGUgY29weSBpY29uIChjbGlwYm9hcmQgc3ltYm9sKSBiZWxvdyBhbnkgbWVzc2FnZSB0byBjb3B5IGl0cyBjb250ZW50LlwiLFxuICAgIGlzRXhwYW5kZWQ6IGZhbHNlLFxuICAgIGlzSG92ZXJlZDogZmFsc2UsXG4gIH0sXG4gIHtcbiAgICBpZDogMyxcbiAgICBxdWVzdGlvbjogXCJIb3cgdG8gcmVnZW5lcmF0ZSBhbnN3ZXI/XCIsXG4gICAgYW5zd2VyOiBcIkNsaWNrIHRoZSByZWZyZXNoIGljb24gYmVsb3cgYW55IG1lc3NhZ2UgdG8gZ2VuZXJhdGUgYSBuZXcgcmVzcG9uc2UuXCIsXG4gICAgaXNFeHBhbmRlZDogZmFsc2UsXG4gICAgaXNIb3ZlcmVkOiBmYWxzZSxcbiAgfSxcbiAge1xuICAgIGlkOiA0LFxuICAgIHF1ZXN0aW9uOiBcIkhvdyB0byBpbnNlcnQgYW5zd2VyIHRvIGVkaXRvcj9cIixcbiAgICBhbnN3ZXI6IFwiQ2xpY2sgdGhlIHNoYXJlIGljb24gYmVsb3cgYW55IG1lc3NhZ2UgdG8gaW5zZXJ0IGl0IGludG8geW91ciBjdXJyZW50IGRvY3VtZW50LlwiLFxuICAgIGlzRXhwYW5kZWQ6IGZhbHNlLFxuICAgIGlzSG92ZXJlZDogZmFsc2UsXG4gIH0sXG4gIHtcbiAgICBpZDogNSxcbiAgICBxdWVzdGlvbjogXCJIb3cgdG8gcmV0cmlldmUgY2hhdCBoaXN0b3J5P1wiLFxuICAgIGFuc3dlcjogXCJDbGljayB0aGUgbGlzdCBpY29uIGF0IHRoZSBib3R0b20gbGVmdCBvZiB0aGUgc2NyZWVuIHRvIHZpZXcgeW91ciBjaGF0IGhpc3RvcnkuXCIsXG4gICAgaXNFeHBhbmRlZDogZmFsc2UsXG4gICAgaXNIb3ZlcmVkOiBmYWxzZSxcbiAgfSxcbiAge1xuICAgIGlkOiA2LFxuICAgIHF1ZXN0aW9uOiBcIkhvdyB0byBlZGl0IG9yIGRlbGV0ZSBjaGF0IGhpc3Rvcnk/XCIsXG4gICAgYW5zd2VyOlxuICAgICAgXCJJbiB0aGUgY2hhdCBoaXN0b3J5IHZpZXcsIHlvdSBjYW4gY2xpY2sgdGhlIHBlbiBpY29uIHRvIGVkaXQgY2hhdCBzZXNzaW9uIG5hbWUgb3IgY2xpY2sgdGhlIGJpbiBpY29uIHRvIGRlbGV0ZSB0aGUgY2hhdCBzZXNzaW9uIGZyb20gdGhlIGNoYXQgaGlzdG9yeS5cIixcbiAgICBpc0V4cGFuZGVkOiBmYWxzZSxcbiAgICBpc0hvdmVyZWQ6IGZhbHNlLFxuICB9LFxuXSk7XG5cbmNvbnN0IHRvZ2dsZUl0ZW0gPSAoaXRlbTogSGVscEl0ZW0pID0+IHtcbiAgaXRlbS5pc0V4cGFuZGVkID0gIWl0ZW0uaXNFeHBhbmRlZDtcbn07XG5cbmRlZmluZUV4cG9zZSh7IHNob3csIGhpZGUgfSk7XG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8ZGl2IHYtaWY9XCJpc1Zpc2libGVcIiBjbGFzcz1cImhlbHAtb3ZlcmxheVwiPlxuICAgIDxkaXYgY2xhc3M9XCJoZWxwLW1vZGFsXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiaGVscC1oZWFkZXJcIj5cbiAgICAgICAgPGgyIGNsYXNzPVwiaGVscC10aXRsZVwiPlRlYWNoZXJBSWRlPC9oMj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImhlbHAtc3VidGl0bGVcIj5IZWxwPC9kaXY+XG4gICAgICAgIDxpbWcgQGNsaWNrPVwiaGlkZVwiIHNyYz1cIi4uL2Fzc2V0cy9jbG9zZV9pY29uLnN2Z1wiIGFsdD1cImNsb3NlXCIgY2xhc3M9XCJoZWxwLWNsb3NlXCIgLz5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzPVwiaGVscC1jb250ZW50XCI+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICB2LWZvcj1cIml0ZW0gaW4gaGVscEl0ZW1zXCJcbiAgICAgICAgICA6a2V5PVwiaXRlbS5pZFwiXG4gICAgICAgICAgY2xhc3M9XCJoZWxwLWl0ZW1cIlxuICAgICAgICAgIDpjbGFzcz1cIntcbiAgICAgICAgICAgIGFjdGl2ZTogaXRlbS5pc0hvdmVyZWQsXG4gICAgICAgICAgICBleHBhbmRlZDogaXRlbS5pc0V4cGFuZGVkLFxuICAgICAgICAgIH1cIlxuICAgICAgICAgIEBtb3VzZWVudGVyPVwiaXRlbS5pc0hvdmVyZWQgPSB0cnVlXCJcbiAgICAgICAgICBAbW91c2VsZWF2ZT1cIml0ZW0uaXNIb3ZlcmVkID0gZmFsc2VcIlxuICAgICAgICAgIEBjbGljaz1cInRvZ2dsZUl0ZW0oaXRlbSlcIlxuICAgICAgICA+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImhlbHAtcXVlc3Rpb25cIj57eyBpdGVtLmlkIH19LiB7eyBpdGVtLnF1ZXN0aW9uIH19PC9kaXY+XG4gICAgICAgICAgPGRpdiB2LWlmPVwiaXRlbS5pc0V4cGFuZGVkXCIgY2xhc3M9XCJoZWxwLWFuc3dlclwiPlxuICAgICAgICAgICAge3sgaXRlbS5hbnN3ZXIgfX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c3R5bGUgc2NvcGVkPlxuLmhlbHAtb3ZlcmxheSB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgdG9wOiAwO1xuICBsZWZ0OiAwO1xuICByaWdodDogMDtcbiAgYm90dG9tOiAwO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNSk7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB6LWluZGV4OiAxMDAwO1xufVxuXG4uaGVscC1tb2RhbCB7XG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICB3aWR0aDogOTAlO1xuICBtYXgtd2lkdGg6IDUwMHB4O1xuICBoZWlnaHQ6IDkwdmg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbi5oZWxwLWhlYWRlciB7XG4gIHBhZGRpbmc6IDIwcHg7XG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZTVlN2ViO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG5cbi5oZWxwLXRpdGxlIHtcbiAgY29sb3I6ICMwMDMyNzQ7XG4gIGZvbnQtc2l6ZTogMjRweDtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgbWFyZ2luOiAwO1xufVxuXG4uaGVscC1zdWJ0aXRsZSB7XG4gIGNvbG9yOiAjOTNhM2JjO1xuICBmb250LXNpemU6IDE4cHg7XG4gIG1hcmdpbi10b3A6IDRweDtcbn1cblxuLmhlbHAtY2xvc2Uge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMjBweDtcbiAgcmlnaHQ6IDIwcHg7XG4gIHdpZHRoOiAxNXB4O1xuICBoZWlnaHQ6IDE1cHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cblxuLmhlbHAtY29udGVudCB7XG4gIGZsZXg6IDE7XG4gIG92ZXJmbG93LXk6IGF1dG87XG4gIHBhZGRpbmc6IDIwcHg7XG59XG5cbi5oZWxwLWl0ZW0ge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTdlZWY3O1xuICBib3JkZXItcmFkaXVzOiA4cHg7XG4gIHBhZGRpbmc6IDE2cHg7XG4gIG1hcmdpbi1ib3R0b206IDEycHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgdHJhbnNpdGlvbjogYWxsIDAuMnMgZWFzZTtcbn1cblxuLmhlbHAtaXRlbS5hY3RpdmUge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYjhjY2U4O1xufVxuXG4uaGVscC1pdGVtLmV4cGFuZGVkIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2I4Y2NlODtcbn1cblxuLmhlbHAtcXVlc3Rpb24ge1xuICBmb250LXNpemU6IDE2cHg7XG4gIGNvbG9yOiAjMDAzMjc0O1xuICBmb250LXdlaWdodDogNTAwO1xufVxuXG4uaGVscC1hbnN3ZXIge1xuICBtYXJnaW4tdG9wOiAxMnB4O1xuICBwYWRkaW5nLXRvcDogMTJweDtcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHJnYmEoMCwgNTAsIDExNiwgMC4xKTtcbiAgY29sb3I6ICM0YTU1Njg7XG4gIGZvbnQtc2l6ZTogMTRweDtcbiAgbGluZS1oZWlnaHQ6IDEuNDtcbn1cblxuLyogSG92ZXIgZWZmZWN0cyAqL1xuLmhlbHAtY2xvc2U6aG92ZXIge1xuICBvcGFjaXR5OiAwLjg7XG59XG48L3N0eWxlPlxuIiwiPHNjcmlwdCBzZXR1cCBsYW5nPVwidHNcIj5cbmltcG9ydCB7IHVzZUFJIH0gZnJvbSBcIkAvcHJvdmlkZXJcIjtcbmltcG9ydCB7IG9uTW91bnRlZCwgcmVmIH0gZnJvbSBcInZ1ZVwiO1xuaW1wb3J0IHsgdXNlQ2hhdGJveFN0b3JlIH0gZnJvbSBcIkAvc3RvcmUvY2hhdGJveFwiO1xuaW1wb3J0IHsgbWFya2VkIH0gZnJvbSBcIm1hcmtlZFwiO1xuaW1wb3J0IENoYXRIaXN0b3J5IGZyb20gXCIuL0NoYXRIaXN0b3J5LnZ1ZVwiO1xuaW1wb3J0IEhlbHBEaWFsb2cgZnJvbSBcIi4vSGVscERpYWxvZy52dWVcIjtcbmltcG9ydCB0eXBlIHsgQ2hhdENvbXBsZXRpb25NZXNzYWdlUGFyYW0gfSBmcm9tIFwib3BlbmFpL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zXCI7XG5pbXBvcnQgdHlwZSB7IENoYXRTZXNzaW9uIH0gZnJvbSBcIkAvc3RvcmUvY2hhdGJveFwiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICB0ZXh0TWVzc2FnZTogc3RyaW5nO1xufVxuXG5jb25zdCBwcm9wcyA9IGRlZmluZVByb3BzPFByb3BzPigpO1xuXG5jb25zdCBlbWl0ID0gZGVmaW5lRW1pdHM8e1xuICAoZTogXCJiYWNrLXRvLWhvbWVcIik6IHZvaWQ7XG59PigpO1xuXG5jb25zdCBjaGF0Ym94ID0gdXNlQ2hhdGJveFN0b3JlKCk7XG5jb25zdCB7IGNsaWVudCwgc3lzdGVtUHJvbXB0IH0gPSB1c2VBSSgpO1xuXG5jb25zdCBjaGF0SGlzdG9yeVJlZiA9IHJlZjxJbnN0YW5jZVR5cGU8dHlwZW9mIENoYXRIaXN0b3J5PiB8IG51bGw+KG51bGwpO1xuY29uc3QgaGVscERpYWxvZ1JlZiA9IHJlZjxJbnN0YW5jZVR5cGU8dHlwZW9mIEhlbHBEaWFsb2c+IHwgbnVsbD4obnVsbCk7XG5cbmNvbnN0IGZldGNoTW9kZWxzID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50Lm1vZGVscy5saXN0KCk7XG4gICAgY2hhdGJveC5zZXRNb2RlbHMocmVzcG9uc2UuZGF0YS5tYXAoKG1vZGVsKSA9PiBtb2RlbC5pZCkpO1xuICAgIGNoYXRib3guc2V0U2VsZWN0ZWRNb2RlbChjaGF0Ym94Lm1vZGVsc1swXSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBtb2RlbHM6XCIsIGVycm9yKTtcbiAgfVxufTtcblxuY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblxuY29uc3Qgc2VuZE1lc3NhZ2UgPSBhc3luYyAoKSA9PiB7XG4gIGlmICghY2hhdGJveC5uZXdNZXNzYWdlKSByZXR1cm47XG5cbiAgLy8gQWRkIHVzZXIgbWVzc2FnZSBpbW1lZGlhdGVseVxuICBjb25zdCB1c2VyTWVzc2FnZSA9IGNoYXRib3gubmV3TWVzc2FnZTtcbiAgY2hhdGJveC5hZGRNZXNzYWdlKHtcbiAgICBjb250ZW50OiB1c2VyTWVzc2FnZSxcbiAgICByb2xlOiBcInVzZXJcIixcbiAgfSk7XG5cbiAgY2hhdGJveC5jbGVhck5ld01lc3NhZ2UoKTtcblxuICB0cnkge1xuICAgIGNvbnN0IG1lc3NhZ2VzOiBDaGF0Q29tcGxldGlvbk1lc3NhZ2VQYXJhbVtdID0gY2hhdGJveC5tZXNzYWdlcztcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICAgIG1vZGVsOiBjaGF0Ym94LnNlbGVjdGVkTW9kZWwsXG4gICAgICBtZXNzYWdlcyxcbiAgICAgIG1heF90b2tlbnM6IGNoYXRib3gubWF4VG9rZW5zLFxuICAgIH0pO1xuXG4gICAgaWYgKHJlc3BvbnNlLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50KSB7XG4gICAgICBjaGF0Ym94LmFkZE1lc3NhZ2Uoe1xuICAgICAgICBjb250ZW50OiByZXNwb25zZS5jaG9pY2VzWzBdLm1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNlbmQgbWVzc2FnZTpcIiwgZXJyb3IpO1xuICB9XG59O1xuXG5jb25zdCBnb0hvbWUgPSBhc3luYyAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgdHJ5IHtcbiAgICBjaGF0Ym94LmNsZWFyTWVzc2FnZXMoKTtcbiAgICBjaGF0Ym94LmNsZWFyTmV3TWVzc2FnZSgpO1xuICAgIGNoYXRib3guY3VycmVudENoYXRJZCA9IFwiXCI7IC8vIENsZWFyIGN1cnJlbnQgY2hhdCBJRFxuICAgIGVtaXQoXCJiYWNrLXRvLWhvbWVcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcmV0dXJuIHRvIGhvbWU6XCIsIGVycik7XG4gIH1cbn07XG5cbmNvbnN0IG9uTG9hZENoYXQgPSAoY2hhdDogQ2hhdFNlc3Npb24pID0+IHtcbiAgY2hhdGJveC5jdXJyZW50Q2hhdElkID0gY2hhdC5pZDtcbiAgY2hhdGJveC5zZXRVc2VyTWVzc2FnZXMoY2hhdC5tZXNzYWdlcyk7XG4gIGNoYXRib3guY2xlYXJOZXdNZXNzYWdlKCk7XG59O1xuXG5jb25zdCBjb3B5VGV4dCA9IGFzeW5jIChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG1lc3NhZ2VFbGVtZW50ID0gKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudClcbiAgICAgIC5jbG9zZXN0KFwiLmFzc2lzdGFudC1tZXNzYWdlXCIpXG4gICAgICA/LnF1ZXJ5U2VsZWN0b3IoXCIubWVzc2FnZS1jb250ZW50XCIpO1xuXG4gICAgaWYgKG1lc3NhZ2VFbGVtZW50KSB7XG4gICAgICBjb25zdCB0ZXh0Q29udGVudCA9IG1lc3NhZ2VFbGVtZW50LnRleHRDb250ZW50IHx8IFwiXCI7XG5cbiAgICAgIGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHRDb250ZW50KTtcbiAgICAgIGFsZXJ0KFwiTWVzc2FnZSBjb3BpZWQgdG8gY2xpcGJvYXJkIVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiTWVzc2FnZSBjb250ZW50IG5vdCBmb3VuZFwiKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY29weTpcIiwgZXJyKTtcbiAgICBhbGVydChcIkZhaWxlZCB0byBjb3B5IG1lc3NhZ2UuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xuICB9XG59O1xuXG5jb25zdCByZWZyZXNoVGV4dCA9IGFzeW5jIChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAvLyBUT0RPOiBUaGlzIGZ1bmN0aW9uIG5lZWQgdG8gYmUgcmVmYWN0b3JlZCwgaXQgaXMgbm90IHdvcmtpbmcgYXMgZXhwZWN0ZWRcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhcIlJlZnJlc2hpbmcgcmVzcG9uc2UuLi5cIik7XG5cbiAgICBjb25zdCBtZXNzYWdlV3JhcHBlcnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm1lc3NhZ2Utd3JhcHBlclwiKTtcbiAgICBjb25zdCBjdXJyZW50V3JhcHBlciA9IChldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpLmNsb3Nlc3QoXCIubWVzc2FnZS13cmFwcGVyXCIpO1xuXG4gICAgaWYgKCFjdXJyZW50V3JhcHBlcikge1xuICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGZpbmQgbWVzc2FnZSB3cmFwcGVyXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2VJbmRleCA9IEFycmF5LmZyb20obWVzc2FnZVdyYXBwZXJzKS5pbmRleE9mKGN1cnJlbnRXcmFwcGVyKTtcbiAgICBjb25zb2xlLmxvZyhcIk1lc3NhZ2Ugd3JhcHBlciBpbmRleDpcIiwgbWVzc2FnZUluZGV4KTtcblxuICAgIGlmIChtZXNzYWdlSW5kZXggPT09IC0xKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCBtZXNzYWdlIGluZGV4XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2VzVXBUb1RoaXMgPSBjaGF0Ym94Lm1lc3NhZ2VzLnNsaWNlKDAsIG1lc3NhZ2VJbmRleCk7XG4gICAgY29uc29sZS5sb2coXCJNZXNzYWdlcyB1cCB0byB0aGlzOlwiLCBtZXNzYWdlc1VwVG9UaGlzKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICAgIG1vZGVsOiBjaGF0Ym94LnNlbGVjdGVkTW9kZWwsXG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICAuLi4oY2hhdGJveC5zeXN0ZW1Qcm9tcHRcbiAgICAgICAgICA/IFt7IHJvbGU6IFwic3lzdGVtXCIgYXMgY29uc3QsIGNvbnRlbnQ6IGNoYXRib3guc3lzdGVtUHJvbXB0IH1dXG4gICAgICAgICAgOiBbXSksXG4gICAgICAgIC4uLm1lc3NhZ2VzVXBUb1RoaXMsXG4gICAgICBdLFxuICAgICAgbWF4X3Rva2VuczogY2hhdGJveC5tYXhUb2tlbnMsXG4gICAgICB0ZW1wZXJhdHVyZTogMS4wLFxuICAgICAgcHJlc2VuY2VfcGVuYWx0eTogMC42LFxuICAgICAgZnJlcXVlbmN5X3BlbmFsdHk6IDAuNixcbiAgICAgIHRvcF9wOiAwLjksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXNwb25zZSBjb250ZW50IHJlY2VpdmVkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHVwZGF0ZWRNZXNzYWdlcyA9IGNoYXRib3gudXNlck1lc3NhZ2VzLm1hcCgobXNnLCBpZHgpID0+IHtcbiAgICAgIGlmIChpZHggPT09IG1lc3NhZ2VJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbnRlbnQ6IHJlc3BvbnNlLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50ISxcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiIGFzIGNvbnN0LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1zZztcbiAgICB9KTtcblxuICAgIGNoYXRib3guY2xlYXJNZXNzYWdlcygpO1xuICAgIHVwZGF0ZWRNZXNzYWdlcy5mb3JFYWNoKChtc2cpID0+IGNoYXRib3guYWRkTWVzc2FnZShtc2cpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byByZWZyZXNoIHJlc3BvbnNlOlwiLCBlcnIpO1xuICAgIGFsZXJ0KFwiRmFpbGVkIHRvIGdlbmVyYXRlIG5ldyByZXNwb25zZS4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gIH1cbn07XG5cbmNvbnN0IHNoYXJlVGV4dCA9IGFzeW5jIChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAvLyBUT0RPOiBzaGFyZSB0ZXh0IGRpcmVjdGx5IHRvIHRoZSB0aW55TUNFIGVkaXRvclxufTtcblxuY29uc3QgZGlzcGxheUNoYXRIaXN0b3J5ID0gYXN5bmMgKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCFjaGF0SGlzdG9yeVJlZi52YWx1ZSkge1xuICAgICAgY29uc29sZS53YXJuKFwiQ2hhdCBoaXN0b3J5IGNvbXBvbmVudCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IGNoYXRIaXN0b3J5UmVmLnZhbHVlLnNob3coKTtcbiAgICBjb25zb2xlLmxvZyhcIkNoYXQgaGlzdG9yeSBkaXNwbGF5ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGRpc3BsYXkgY2hhdCBoaXN0b3J5OlwiLCBlcnIpO1xuICAgIGFsZXJ0KFwiRmFpbGVkIHRvIG9wZW4gY2hhdCBoaXN0b3J5LiBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcbiAgfVxufTtcblxuY29uc3QgZGlzcGxheUhlbHAgPSBhc3luYyAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIWhlbHBEaWFsb2dSZWYudmFsdWUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkhlbHAgZGlhbG9nIGNvbXBvbmVudCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IGhlbHBEaWFsb2dSZWYudmFsdWUuc2hvdygpO1xuICAgIGNvbnNvbGUubG9nKFwiSGVscCBkaWFsb2cgZGlzcGxheWVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBkaXNwbGF5IGhlbHAgZGlhbG9nOlwiLCBlcnIpO1xuICAgIGFsZXJ0KFwiRmFpbGVkIHRvIG9wZW4gaGVscC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gIH1cbn07XG5cbm9uTW91bnRlZCgoKSA9PiB7XG4gIGlmIChwcm9wcy50ZXh0TWVzc2FnZSkge1xuICAgIGNoYXRib3gubmV3TWVzc2FnZSA9IHByb3BzLnRleHRNZXNzYWdlO1xuICAgIHNlbmRNZXNzYWdlKCk7XG4gIH1cbn0pO1xuXG5jb25zdCBoYW5kbGVDbG9zZSA9ICgpID0+IHtcbiAgY29uc29sZS5sb2coYGNsb3NlIHdpbmRvd2ApO1xuICBsZXQgY2hhdHdpbmRvdyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2hhdC1zY3JlZW5cIik7XG4gIGlmIChjaGF0d2luZG93KSB7XG4gICAgY2hhdHdpbmRvdy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIH1cbn07XG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwiY2hhdC1jb250YWluZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwiaGVhZGVyXCI+XG4gICAgICA8aDIgY2xhc3M9XCJ0aXRsZVwiPlRlYWNoZXJBSWRlPC9oMj5cbiAgICAgIDxpbWdcbiAgICAgICAgQGNsaWNrPVwiaGFuZGxlQ2xvc2VcIlxuICAgICAgICBzcmM9XCIuLi9hc3NldHMvY2xvc2VfaWNvbi5zdmdcIlxuICAgICAgICBhbHQ9XCJjbG9zZVwiXG4gICAgICAgIGNsYXNzPVwiY2xvc2UtaWNvblwiXG4gICAgICAgIHRpdGxlPVwiY2xvc2VcIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJtZXNzYWdlcy1jb250YWluZXJcIj5cbiAgICAgIDxkaXYgdi1pZj1cImNoYXRib3gubWVzc2FnZXMubGVuZ3RoID09PSAwXCIgY2xhc3M9XCJlbXB0eS1zdGF0ZVwiPlxuICAgICAgICA8cD5Zb3UgYXJlIGEgaGVscGZ1bCBhc3Npc3RhbnQgdGhhdCBhaWRzIHRlYWNoZXJzLjwvcD5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IHYtZm9yPVwiKG1lc3NhZ2UsIGluZGV4KSBpbiBjaGF0Ym94Lm1lc3NhZ2VzXCIgOmtleT1cImluZGV4XCIgY2xhc3M9XCJtZXNzYWdlLXdyYXBwZXJcIj5cbiAgICAgICAgPGRpdiB2LWlmPVwibWVzc2FnZS5yb2xlID09PSAndXNlcidcIiBjbGFzcz1cInVzZXItbWVzc2FnZVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJtZXNzYWdlLWNvbnRlbnRcIj5cbiAgICAgICAgICAgIHt7IG1lc3NhZ2UuY29udGVudCB9fVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IHYtaWY9XCJtZXNzYWdlLnJvbGUgPT09ICdhc3Npc3RhbnQnXCIgY2xhc3M9XCJhc3Npc3RhbnQtbWVzc2FnZVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJhc3Npc3RhbnQtbGFiZWxcIj5UZWFjaGVyQUlkZTo8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibWVzc2FnZS1jb250ZW50XCIgdi1odG1sPVwibWFya2VkLnBhcnNlKG1lc3NhZ2UuY29udGVudCBhcyBzdHJpbmcpXCI+PC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm1lc3NhZ2UtYWN0aW9uc1wiIEBjbGljay5zdG9wPlxuICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICBAY2xpY2s9XCJjb3B5VGV4dFwiXG4gICAgICAgICAgICAgIHNyYz1cIi4uL2Fzc2V0cy9jb3B5X2ljb24uc3ZnXCJcbiAgICAgICAgICAgICAgYWx0PVwiY29weVwiXG4gICAgICAgICAgICAgIGNsYXNzPVwiYWN0aW9uLWljb25cIlxuICAgICAgICAgICAgICB0aXRsZT1cIkNvcHkgdG8gY2xpcGJvYXJkXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8aW1nXG4gICAgICAgICAgICAgIEBjbGljaz1cInJlZnJlc2hUZXh0XCJcbiAgICAgICAgICAgICAgc3JjPVwiLi4vYXNzZXRzL3JlZnJlc2hfaWNvbi5zdmdcIlxuICAgICAgICAgICAgICBhbHQ9XCJyZWZyZXNoXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJhY3Rpb24taWNvblwiXG4gICAgICAgICAgICAgIHRpdGxlPVwiUmVnZW5lcmF0ZSByZXNwb25zZVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICBAY2xpY2s9XCJzaGFyZVRleHRcIlxuICAgICAgICAgICAgICBzcmM9XCIuLi9hc3NldHMvc2hhcmVfaWNvbi5zdmdcIlxuICAgICAgICAgICAgICBhbHQ9XCJzaGFyZVwiXG4gICAgICAgICAgICAgIGNsYXNzPVwiYWN0aW9uLWljb25cIlxuICAgICAgICAgICAgICB0aXRsZT1cIkNvcHkgdG8gZWRpdG9yXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiYm90dG9tLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBjbGFzcz1cImlucHV0LXdyYXBwZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWFyZWFcIj5cbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHYtbW9kZWw9XCJjaGF0Ym94Lm5ld01lc3NhZ2VcIlxuICAgICAgICAgICAgQGtleXVwLmVudGVyPVwic2VuZE1lc3NhZ2VcIlxuICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJBc2sgVGVhY2hlckFJZGUuLi5cIlxuICAgICAgICAgICAgY2xhc3M9XCJtZXNzYWdlLWlucHV0XCJcbiAgICAgICAgICAvPlxuICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgIEBjbGljaz1cInNlbmRNZXNzYWdlXCJcbiAgICAgICAgICAgIHNyYz1cIi4uL2Fzc2V0cy9zZW5kX2ljb25fMy5zdmdcIlxuICAgICAgICAgICAgYWx0PVwic2VuZFwiXG4gICAgICAgICAgICBjbGFzcz1cInNlbmQtaWNvblwiXG4gICAgICAgICAgICB0aXRsZT1cInNlbmRcIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJuYXZpZ2F0aW9uXCI+XG4gICAgICAgIDxpbWdcbiAgICAgICAgICBAY2xpY2s9XCJkaXNwbGF5Q2hhdEhpc3RvcnlcIlxuICAgICAgICAgIHNyYz1cIi4uL2Fzc2V0cy9saXN0X2ljb24uc3ZnXCJcbiAgICAgICAgICBhbHQ9XCJjaGF0IGhpc3RvcnlcIlxuICAgICAgICAgIGNsYXNzPVwibmF2LWljb25cIlxuICAgICAgICAgIHRpdGxlPVwiQ2hhdCBoaXN0b3J5XCJcbiAgICAgICAgLz5cbiAgICAgICAgPGltZ1xuICAgICAgICAgIEBjbGljaz1cImdvSG9tZVwiXG4gICAgICAgICAgc3JjPVwiLi4vYXNzZXRzL2hvbWVfaWNvbi5zdmdcIlxuICAgICAgICAgIGFsdD1cImhvbWVcIlxuICAgICAgICAgIGNsYXNzPVwibmF2LWljb25cIlxuICAgICAgICAgIHRpdGxlPVwiU3RhcnQgbmV3IGNoYXRcIlxuICAgICAgICAvPlxuICAgICAgICA8aW1nXG4gICAgICAgICAgQGNsaWNrPVwiZGlzcGxheUhlbHBcIlxuICAgICAgICAgIHNyYz1cIi4uL2Fzc2V0cy9oZWxwX2ljb24uc3ZnXCJcbiAgICAgICAgICBhbHQ9XCJoZWxwXCJcbiAgICAgICAgICBjbGFzcz1cIm5hdi1pY29uXCJcbiAgICAgICAgICB0aXRsZT1cIkhlbHBcIlxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8Q2hhdEhpc3RvcnkgcmVmPVwiY2hhdEhpc3RvcnlSZWZcIiBAbG9hZC1jaGF0PVwib25Mb2FkQ2hhdFwiIC8+XG4gICAgPEhlbHBEaWFsb2cgcmVmPVwiaGVscERpYWxvZ1JlZlwiIC8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHN0eWxlIHNjb3BlZD5cbi5jaGF0LWNvbnRhaW5lciB7XG4gIHdpZHRoOiA5MCU7XG4gIG1heC13aWR0aDogNTAwcHg7XG4gIGhlaWdodDogOTB2aDtcbiAgbWFyZ2luOiAyMHB4IGF1dG87XG4gIGJhY2tncm91bmQ6IHdoaXRlO1xuICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBib3JkZXI6IDFweCBzb2xpZCAjZTVlN2ViO1xuICBib3gtc2hhZG93OiAwIDJweCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4xKTtcbn1cblxuLmhlYWRlciB7XG4gIHBhZGRpbmc6IDE2cHggMjBweDtcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlNWU3ZWI7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cblxuLnRpdGxlIHtcbiAgY29sb3I6ICMwMDMyNzQ7XG4gIGZvbnQtc2l6ZTogMjRweDtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgbWFyZ2luOiAwO1xufVxuXG4uY2xvc2UtaWNvbiB7XG4gIHdpZHRoOiAxNXB4O1xuICBoZWlnaHQ6IDE1cHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cblxuLm1lc3NhZ2VzLWNvbnRhaW5lciB7XG4gIGZsZXg6IDE7XG4gIG92ZXJmbG93LXk6IGF1dG87XG4gIHBhZGRpbmc6IDE2cHggMjBweDtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgZ2FwOiAxNnB4O1xufVxuXG4ubWVzc2FnZS13cmFwcGVyIHtcbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xuICB3aWR0aDogMTAwJTtcbn1cblxuLnVzZXItbWVzc2FnZSB7XG4gIG1hcmdpbi1ib3R0b206IDRweDtcbn1cblxuLnVzZXItbWVzc2FnZSAubWVzc2FnZS1jb250ZW50IHtcbiAgY29sb3I6ICMwMDMyNzQ7XG4gIHRleHQtYWxpZ246IGxlZnQ7XG4gIGZvbnQtd2VpZ2h0OiA4MDA7XG59XG5cbi5hc3Npc3RhbnQtbWVzc2FnZSB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmOGY5ZmE7XG4gIHBhZGRpbmc6IDE2cHggMjBweDtcbiAgbWFyZ2luOiAwIC0yMHB4O1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG5cbi5hc3Npc3RhbnQtbGFiZWwge1xuICBjb2xvcjogIzAwMzI3NDtcbiAgZm9udC13ZWlnaHQ6IDgwMDtcbiAgbWFyZ2luLWJvdHRvbTogNHB4O1xufVxuXG4uYXNzaXN0YW50LW1lc3NhZ2UgLm1lc3NhZ2UtY29udGVudCB7XG4gIGNvbG9yOiAjMDAwMDAwO1xuICB0ZXh0LWFsaWduOiBsZWZ0O1xuICBtYXJnaW4tYm90dG9tOiAyNHB4O1xufVxuXG4ubWVzc2FnZS1jb250ZW50IHtcbiAgbGluZS1oZWlnaHQ6IDEuNDtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG4ubWVzc2FnZS1hY3Rpb25zIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBib3R0b206IDhweDtcbiAgbGVmdDogMjBweDtcbiAgZGlzcGxheTogZmxleDtcbiAgZ2FwOiAxNnB4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxuXG4uYWN0aW9uLWljb24ge1xuICB3aWR0aDogMTZweDtcbiAgaGVpZ2h0OiAxNnB4O1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGZpbHRlcjogYnJpZ2h0bmVzcygwKTtcbiAgb3BhY2l0eTogMC44O1xuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgZWFzZTtcbiAgcGFkZGluZzogMnB4O1xufVxuXG4uYm90dG9tLWNvbnRhaW5lciB7XG4gIG1hcmdpbi10b3A6IGF1dG87XG59XG5cbi5pbnB1dC13cmFwcGVyIHtcbiAgcGFkZGluZzogMCAyMHB4O1xuICBtYXJnaW4tYm90dG9tOiA4cHg7XG59XG5cbi5pbnB1dC1hcmVhIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzAwMzI3NDtcbiAgYm9yZGVyLXJhZGl1czogMjVweDtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgcGFkZGluZzogOHB4IDE2cHg7XG59XG5cbi5tZXNzYWdlLWlucHV0IHtcbiAgZmxleDogMTtcbiAgcGFkZGluZzogOHB4O1xuICBib3JkZXI6IG5vbmU7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICBjb2xvcjogd2hpdGU7XG4gIG91dGxpbmU6IG5vbmU7XG4gIGZvbnQtc2l6ZTogMTRweDtcbn1cblxuLm1lc3NhZ2UtaW5wdXQ6OnBsYWNlaG9sZGVyIHtcbiAgY29sb3I6ICNmZmZmZmY7XG4gIG9wYWNpdHk6IDAuODtcbn1cblxuLnNlbmQtaWNvbiB7XG4gIHdpZHRoOiAyMHB4O1xuICBoZWlnaHQ6IDIwcHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgbWFyZ2luLWxlZnQ6IDhweDtcbn1cblxuLm5hdmlnYXRpb24ge1xuICBiYWNrZ3JvdW5kOiAjZjhmOWZhO1xuICBwYWRkaW5nOiAxMnB4IDIwcHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNlNWU3ZWI7XG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDEycHg7XG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAxMnB4O1xufVxuXG4ubmF2LWljb24ge1xuICB3aWR0aDogMjRweDtcbiAgaGVpZ2h0OiAyNHB4O1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBlYXNlO1xufVxuXG4ubmF2LWljb246aG92ZXIsXG4uc2VuZC1pY29uOmhvdmVyLFxuLmNsb3NlLWljb246aG92ZXIge1xuICBvcGFjaXR5OiAwLjg7XG59XG5cbi5tZXNzYWdlcy1jb250YWluZXI6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcbiAgd2lkdGg6IDZweDtcbn1cblxuLm1lc3NhZ2VzLWNvbnRhaW5lcjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2sge1xuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbn1cblxuLm1lc3NhZ2VzLWNvbnRhaW5lcjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWIge1xuICBiYWNrZ3JvdW5kOiAjZGRkO1xuICBib3JkZXItcmFkaXVzOiAzcHg7XG59XG48L3N0eWxlPlxuIiwiPHNjcmlwdCBzZXR1cCBsYW5nPVwidHNcIj5cbmltcG9ydCB7IHJlZiB9IGZyb20gXCJ2dWVcIjtcbmltcG9ydCBTaW1wbGVDaGF0IGZyb20gXCIuL1NpbXBsZUNoYXQudnVlXCI7XG5pbXBvcnQgQ2hhdEhpc3RvcnkgZnJvbSBcIi4vQ2hhdEhpc3RvcnkudnVlXCI7XG5pbXBvcnQgSGVscERpYWxvZyBmcm9tIFwiLi9IZWxwRGlhbG9nLnZ1ZVwiO1xuXG5jb25zdCBzaG93Q2hhdCA9IHJlZihmYWxzZSk7XG5jb25zdCBpbnB1dE1lc3NhZ2UgPSByZWYoXCJcIik7XG5jb25zdCBjaGF0SGlzdG9yeVJlZiA9IHJlZjxJbnN0YW5jZVR5cGU8dHlwZW9mIENoYXRIaXN0b3J5PiB8IG51bGw+KG51bGwpO1xuY29uc3QgaGVscERpYWxvZ1JlZiA9IHJlZjxJbnN0YW5jZVR5cGU8dHlwZW9mIEhlbHBEaWFsb2c+IHwgbnVsbD4obnVsbCk7XG5cbi8vIEFkZCBoYW5kbGVycyBmb3IgY2hhdCBoaXN0b3J5IGFuZCBoZWxwXG5jb25zdCBkaXNwbGF5Q2hhdEhpc3RvcnkgPSBhc3luYyAoKSA9PiB7XG4gIGNoYXRIaXN0b3J5UmVmLnZhbHVlPy5zaG93KCk7XG59O1xuXG5jb25zdCBkaXNwbGF5SGVscCA9IGFzeW5jICgpID0+IHtcbiAgaGVscERpYWxvZ1JlZi52YWx1ZT8uc2hvdygpO1xufTtcblxuY29uc3QgaGFuZGxlQXNrVGVhY2hlciA9ICgpID0+IHtcbiAgaWYgKGlucHV0TWVzc2FnZS52YWx1ZS50cmltKCkpIHtcbiAgICBzaG93Q2hhdC52YWx1ZSA9IHRydWU7XG4gIH1cbn07XG5cbmNvbnN0IGhhbmRsZUNsb3NlID0gKCkgPT4ge1xuICBzaG93Q2hhdC52YWx1ZSA9IGZhbHNlO1xuICBpbnB1dE1lc3NhZ2UudmFsdWUgPSBcIlwiOyAvLyBSZXNldCBpbnB1dCB3aGVuIGNsb3Npbmdcbn07XG5cbmNvbnN0IGJhY2tUb0hvbWUgPSAoKSA9PiB7XG4gIHNob3dDaGF0LnZhbHVlID0gZmFsc2U7XG4gIGlucHV0TWVzc2FnZS52YWx1ZSA9IFwiXCI7IC8vIFJlc2V0IGlucHV0IHdoZW4gcmV0dXJuaW5nIHRvIGhvbWVcbn07XG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8ZGl2IHYtaWY9XCIhc2hvd0NoYXRcIiBjbGFzcz1cImhvbWUtY29udGFpbmVyXCI+XG4gICAgPGltZyBAY2xpY2s9XCJoYW5kbGVDbG9zZVwiIHNyYz1cIi4uL2Fzc2V0cy9jbG9zZV9pY29uLnN2Z1wiIGFsdD1cImNsb3NlXCIgY2xhc3M9XCJjbG9zZS1pY29uXCIgLz5cblxuICAgIDxkaXYgY2xhc3M9XCJjb250ZW50LWNvbnRhaW5lclwiPlxuICAgICAgPGgxIGNsYXNzPVwidGl0bGVcIj5UZWFjaGVyQUlkZTwvaDE+XG4gICAgICA8cCBjbGFzcz1cInN1YnRpdGxlXCI+WW91ciBwZXJzb25hbCB0ZWFjaGluZyBhc3Npc3RhbnQ8L3A+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1jb250YWluZXJcIj5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgdi1tb2RlbD1cImlucHV0TWVzc2FnZVwiXG4gICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiQXNrIFRlYWNoZXJBSWRlLi4uXCJcbiAgICAgICAgICBjbGFzcz1cImFzay1pbnB1dFwiXG4gICAgICAgICAgQGtleXVwLmVudGVyPVwiaGFuZGxlQXNrVGVhY2hlclwiXG4gICAgICAgIC8+XG4gICAgICAgIDxpbWdcbiAgICAgICAgICBAY2xpY2s9XCJoYW5kbGVBc2tUZWFjaGVyXCJcbiAgICAgICAgICBzcmM9XCIuLi9hc3NldHMvc2VuZF9pY29uXzMuc3ZnXCJcbiAgICAgICAgICBhbHQ9XCJzZW5kXCJcbiAgICAgICAgICBjbGFzcz1cInNlbmQtaWNvblwiXG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJuYXZpZ2F0aW9uXCI+XG4gICAgICA8aW1nXG4gICAgICAgIEBjbGljaz1cImRpc3BsYXlDaGF0SGlzdG9yeVwiXG4gICAgICAgIHNyYz1cIi4uL2Fzc2V0cy9saXN0X2ljb24uc3ZnXCJcbiAgICAgICAgYWx0PVwiY2hhdCBoaXN0b3J5XCJcbiAgICAgICAgY2xhc3M9XCJuYXYtaWNvblwiXG4gICAgICAgIHRpdGxlPVwiQ2hhdCBoaXN0b3J5XCJcbiAgICAgIC8+XG4gICAgICA8aW1nIHNyYz1cIi4uL2Fzc2V0cy9ob21lX2ljb24uc3ZnXCIgYWx0PVwiaG9tZVwiIGNsYXNzPVwibmF2LWljb24gYWN0aXZlXCIgdGl0bGU9XCJIb21lXCIgLz5cbiAgICAgIDxpbWdcbiAgICAgICAgQGNsaWNrPVwiZGlzcGxheUhlbHBcIlxuICAgICAgICBzcmM9XCIuLi9hc3NldHMvaGVscF9pY29uLnN2Z1wiXG4gICAgICAgIGFsdD1cImhlbHBcIlxuICAgICAgICBjbGFzcz1cIm5hdi1pY29uXCJcbiAgICAgICAgdGl0bGU9XCJIZWxwXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIEFkZCBkaWFsb2cgY29tcG9uZW50cyAtLT5cbiAgICA8Q2hhdEhpc3RvcnkgcmVmPVwiY2hhdEhpc3RvcnlSZWZcIiAvPlxuICAgIDxIZWxwRGlhbG9nIHJlZj1cImhlbHBEaWFsb2dSZWZcIiAvPlxuICA8L2Rpdj5cblxuICA8U2ltcGxlQ2hhdCB2LWVsc2UgOnRleHQtbWVzc2FnZT1cImlucHV0TWVzc2FnZVwiIEBiYWNrLXRvLWhvbWU9XCJiYWNrVG9Ib21lXCIgLz5cbjwvdGVtcGxhdGU+XG5cbjxzdHlsZSBzY29wZWQ+XG4uaG9tZS1jb250YWluZXIge1xuICB3aWR0aDogOTAlO1xuICBtYXgtd2lkdGg6IDUwMHB4O1xuICBoZWlnaHQ6IDkwdmg7XG4gIG1hcmdpbjogMjBweCBhdXRvO1xuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBib3JkZXI6IDFweCBzb2xpZCAjZTVlN2ViO1xuICBib3gtc2hhZG93OiAwIDJweCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4xKTtcbn1cblxuLmNsb3NlLWljb24ge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMjBweDtcbiAgcmlnaHQ6IDIwcHg7XG4gIHdpZHRoOiAxNXB4O1xuICBoZWlnaHQ6IDE1cHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cblxuLmNvbnRlbnQtY29udGFpbmVyIHtcbiAgZmxleDogMTtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIHBhZGRpbmc6IDIwcHg7XG59XG5cbi50aXRsZSB7XG4gIGNvbG9yOiAjMDAzMjc0O1xuICBmb250LXNpemU6IDMycHg7XG4gIGZvbnQtd2VpZ2h0OiA2MDA7XG4gIG1hcmdpbjogMDtcbn1cblxuLnN1YnRpdGxlIHtcbiAgY29sb3I6ICM2NjY7XG4gIG1hcmdpbi10b3A6IDhweDtcbn1cblxuLmlucHV0LWNvbnRhaW5lciB7XG4gIG1hcmdpbi10b3A6IDI0cHg7XG4gIHdpZHRoOiBjYWxjKDEwMCUgLSA0MHB4KTtcbiAgbWF4LXdpZHRoOiA0MDBweDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuXG4uYXNrLWlucHV0IHtcbiAgd2lkdGg6IGNhbGMoMTAwJSAtIDQwcHgpO1xuICBwYWRkaW5nOiAxMnB4IDIwcHggMTJweCAyMHB4O1xuICBib3JkZXItcmFkaXVzOiAyNXB4O1xuICBib3JkZXI6IG5vbmU7XG4gIGJhY2tncm91bmQtY29sb3I6ICMwMDMyNzQ7XG4gIGNvbG9yOiB3aGl0ZTtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBvdXRsaW5lOiBub25lO1xufVxuXG4uYXNrLWlucHV0OjpwbGFjZWhvbGRlciB7XG4gIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG59XG5cbi5zZW5kLWljb24ge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHJpZ2h0OiAxMnB4O1xuICB0b3A6IDUwJTtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xuICB3aWR0aDogMjRweDtcbiAgaGVpZ2h0OiAyNHB4O1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG5cbi5uYXZpZ2F0aW9uIHtcbiAgcGFkZGluZzogMTJweCAyMHB4O1xuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCAjZTVlN2ViO1xufVxuXG4ubmF2LWljb24ge1xuICB3aWR0aDogMjRweDtcbiAgaGVpZ2h0OiAyNHB4O1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIG9wYWNpdHk6IDAuNTtcbn1cblxuLm5hdi1pY29uLmFjdGl2ZSB7XG4gIG9wYWNpdHk6IDE7XG59XG48L3N0eWxlPlxuIiwiaW1wb3J0IHsgY2FsbCBhcyBmZXRjaE1hbnkgfSBmcm9tIFwiY29yZS9hamF4XCI7XG5cbmludGVyZmFjZSBSZXF1ZXN0SW5pdCB7XG4gIGVuZHBvaW50OiBzdHJpbmc7XG4gIG1ldGhvZDogc3RyaW5nO1xuICBwYXJhbXM6IHN0cmluZztcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hUaHJvdWdobG9jYWxUZWFjaGVyYWlkZU9wZW5BSUdhdGV3YXkoe1xuICBlbmRwb2ludCxcbiAgbWV0aG9kLFxuICBwYXJhbXMsXG59OiBSZXF1ZXN0SW5pdCkge1xuICByZXR1cm4gZmV0Y2hNYW55KFtcbiAgICB7XG4gICAgICBtZXRob2RuYW1lOiBcImxvY2FsX3RlYWNoZXJhaWRlX29wZW5haV9nYXRld2F5XCIsXG4gICAgICBhcmdzOiB7XG4gICAgICAgIGVuZHBvaW50LFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgIH0sXG4gICAgfSxcbiAgXSlbMF07XG59XG5cbmNvbnN0IHd3d3Jvb3QgPSBNLmNmZy53d3dyb290O1xuXG5leHBvcnQgY29uc3Qgd2Vic2VydmljZUJhc2VVcmwgPSBgJHt3d3dyb290fS93ZWJzZXJ2aWNlL3Jlc3RmdWwvc2VydmVyLnBocC9sb2NhbF90ZWFjaGVyYWlkZV9vcGVuYWlfZ2F0ZXdheWA7XG5cbmV4cG9ydCBjb25zdCB3ZWJzZXJ2aWNlRmV0Y2g6IHR5cGVvZiBmZXRjaCA9IGFzeW5jICh1cmwsIGluaXQpID0+IHtcbiAgY29uc3QgZW5kcG9pbnQgPSBgJHt1cmx9YC5yZXBsYWNlKHdlYnNlcnZpY2VCYXNlVXJsLCBcIlwiKTtcbiAgY29uc3QgbWV0aG9kID0gaW5pdD8ubWV0aG9kIGFzIHN0cmluZztcbiAgY29uc3QgYm9keSA9IGluaXQ/LmJvZHkgYXMgc3RyaW5nO1xuXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoVGhyb3VnaGxvY2FsVGVhY2hlcmFpZGVPcGVuQUlHYXRld2F5KHtcbiAgICBlbmRwb2ludCxcbiAgICBtZXRob2QsXG4gICAgcGFyYW1zOiBib2R5LFxuICB9KTtcblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKHJlcy5kYXRhLCB7XG4gICAgLy8gY3JlYXRlIHN0YW5kYXJkIFJlc3BvbnNlIG9iamVjdFxuICAgIHN0YXR1czogMjAwLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIH0sXG4gIH0pO1xufTtcbiIsImltcG9ydCBIb21lU2NyZWVuIGZyb20gXCIuL2NvbXBvbmVudHMvSG9tZVNjcmVlbi52dWVcIjtcbmltcG9ydCB7IGNvbmZpZ3VyZUFwcFdpdGhQcm92aWRlcnMgfSBmcm9tIFwiLi9wcm92aWRlclwiO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCB9IGZyb20gXCJ2dWVcIjtcbmltcG9ydCB7IE9wZW5BSSB9IGZyb20gXCJvcGVuYWlcIjtcbmltcG9ydCB7IHdlYnNlcnZpY2VCYXNlVXJsLCB3ZWJzZXJ2aWNlRmV0Y2ggfSBmcm9tIFwiLi93ZWJzZXJ2aWNlXCI7XG5cbmludGVyZmFjZSBJbml0T3B0aW9ucyB7XG4gIHN5c3RlbVByb21wdDogc3RyaW5nO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpbml0KHsgc3lzdGVtUHJvbXB0IH06IEluaXRPcHRpb25zKSB7XG4gIC8vIENyZWF0ZSBPcGVuQUkgY2xpZW50XG4gIGNvbnN0IGNsaWVudCA9IG5ldyBPcGVuQUkoe1xuICAgIGJhc2VVUkw6IHdlYnNlcnZpY2VCYXNlVXJsLFxuICAgIGFwaUtleTogXCJkdW1teVwiLCAvLyBUaGlzIGlzIGEgZHVtbXkgQVBJIGtleSwgYXMgdGhlIEFQSSBrZXkgaXMgbm90IG5lZWRlZCBmb3IgdXNpbmcgdGhlIHdlYnNlcnZpY2VcbiAgICBkYW5nZXJvdXNseUFsbG93QnJvd3NlcjogdHJ1ZSxcbiAgICBmZXRjaDogd2Vic2VydmljZUZldGNoLFxuICB9KTtcblxuICAvLyBDb25maWd1cmUgdGhlIGFwcCB3aXRoIHByb3ZpZGVyc1xuICBjb25zdCBjb25maWd1cmVBcHAgPSBjb25maWd1cmVBcHBXaXRoUHJvdmlkZXJzKHsgY2xpZW50LCBzeXN0ZW1Qcm9tcHQgfSk7XG5cbiAgLy8gUmVnaXN0ZXIgdGhlIGN1c3RvbSBlbGVtZW50XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShcbiAgICBcInRlYWNoZXJhaWRlLXNpbXBsZS1jaGF0XCIsXG4gICAgZGVmaW5lQ3VzdG9tRWxlbWVudChIb21lU2NyZWVuLCB7IGNvbmZpZ3VyZUFwcCB9KSxcbiAgKTtcbn1cblxuZXhwb3J0IHsgaW5pdCB9O1xuIl0sIm5hbWVzIjpbIm1ha2VNYXAiLCJzdHIiLCJzZXQiLCJFTVBUWV9PQkoiLCJOT09QIiwiZXh0ZW5kIiwicmVtb3ZlIiwiaGFzT3duUHJvcGVydHkiLCJoYXNPd24iLCJpc0FycmF5IiwiaXNNYXAiLCJ0b1R5cGVTdHJpbmciLCJpc1NldCIsImlzRnVuY3Rpb24iLCJpc1N0cmluZyIsImlzU3ltYm9sIiwiaXNPYmplY3QiLCJvYmplY3RUb1N0cmluZyIsImlzUGxhaW5PYmplY3QiLCJkZWYiLCJsaW5rIiwiY29tcHV0ZWQiLCJ0eXBlIiwiX2EiLCJzZWxmIiwiaXNSZWYiLCJ3YXRjaCIsImVmZmVjdCIsImlzT24iLCJpc01vZGVsTGlzdGVuZXIiLCJpc1Byb21pc2UiLCJjYWNoZVN0cmluZ0Z1bmN0aW9uIiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwiaHlwaGVuYXRlUkUiLCJoeXBoZW5hdGUiLCJjYXBpdGFsaXplIiwiaW52b2tlQXJyYXlGbnMiLCJsb29zZVRvTnVtYmVyIiwiY2xvc2UiLCJwIiwicmVmIiwicmVuZGVyIiwiZ2V0IiwiaCIsImNyZWF0ZUFwcCIsInJlbW92ZTIiLCJpc0ZsdXNoaW5nIiwiZW1pdCIsInJlbmRlcjIiLCJ0YWciLCJjYW1lbGl6ZSQxIiwiaGFzIiwiZmV0Y2giLCJGb3JtRGF0YSIsIkZpbGUiLCJSZWFkYWJsZVN0cmVhbSIsInNoaW1zLmtpbmQiLCJzaGltcy5zZXRTaGltcyIsImF1dG8uZ2V0UnVudGltZSIsIml0ZXJhdG9yIiwicXVldWUiLCJuZXdsaW5lIiwiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsImtpbmQiLCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0Iiwib3B0cyIsIlBhZ2UiLCJzaGltc0tpbmQiLCJyZXRyeU1lc3NhZ2UiLCJpbml0Iiwic2xlZXAiLCJDb21wbGV0aW9ucyIsIkNvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25zIiwiQ2hhdCIsIlNwZWVjaCIsIkNvcmUubXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zIiwiVHJhbnNjcmlwdGlvbnMiLCJUcmFuc2xhdGlvbnMiLCJUcmFuc2NyaXB0aW9uc0FQSS5UcmFuc2NyaXB0aW9ucyIsIlRyYW5zbGF0aW9uc0FQSS5UcmFuc2xhdGlvbnMiLCJTcGVlY2hBUEkuU3BlZWNoIiwiQXVkaW8iLCJCYXRjaGVzIiwiQmF0Y2hlc0FQSS5CYXRjaGVzUGFnZSIsIkFzc2lzdGFudHMiLCJBc3Npc3RhbnRzQVBJLkFzc2lzdGFudHNQYWdlIiwiX0V2ZW50U3RyZWFtX2hhbmRsZUVycm9yIiwiaW5wdXRUb29sIiwiY29udGVudCIsIm5hbWUiLCJfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbENvbnRlbnQiLCJfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbE1lc3NhZ2UiLCJfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbEZ1bmN0aW9uQ2FsbCIsIl9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0IiwiX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfY2FsY3VsYXRlVG90YWxVc2FnZSIsIl9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX3ZhbGlkYXRlUGFyYW1zIiwiX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfc3RyaW5naWZ5RnVuY3Rpb25DYWxsUmVzdWx0IiwiX0NoYXRDb21wbGV0aW9uU3RyZWFtX2JlZ2luUmVxdWVzdCIsIl9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRDaG9pY2VFdmVudFN0YXRlIiwiX0NoYXRDb21wbGV0aW9uU3RyZWFtX2FkZENodW5rIiwiX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRUb29sQ2FsbERvbmVFdmVudCIsIl9DaGF0Q29tcGxldGlvblN0cmVhbV9lbWl0Q29udGVudERvbmVFdmVudHMiLCJfQ2hhdENvbXBsZXRpb25TdHJlYW1fZW5kUmVxdWVzdCIsIl9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQiLCJfQ2hhdENvbXBsZXRpb25TdHJlYW1fYWNjdW11bGF0ZUNoYXRDb21wbGV0aW9uIiwicmVmdXNhbCIsInJlc3QiLCJpbmRleCIsImNodW5rIiwiaWQiLCJDb3JlLmlzT2JqIiwiX0Fzc2lzdGFudFN0cmVhbV9hZGRFdmVudCIsIl9Bc3Npc3RhbnRTdHJlYW1fZW5kUmVxdWVzdCIsIl9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlTWVzc2FnZSIsIl9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlUnVuU3RlcCIsIl9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlRXZlbnQiLCJfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVSdW5TdGVwIiwiX0Fzc2lzdGFudFN0cmVhbV9hY2N1bXVsYXRlTWVzc2FnZSIsIl9Bc3Npc3RhbnRTdHJlYW1fYWNjdW11bGF0ZUNvbnRlbnQiLCJfQXNzaXN0YW50U3RyZWFtX2hhbmRsZVJ1biIsIk1lc3NhZ2VzIiwiTWVzc2FnZXNBUEkuTWVzc2FnZXNQYWdlIiwiU3RlcHMiLCJTdGVwc0FQSS5SdW5TdGVwc1BhZ2UiLCJTdGVwc0FQSS5TdGVwcyIsIlJ1bnMiLCJSdW5zQVBJLlJ1bnNQYWdlIiwiUnVuc0FQSS5SdW5zIiwiTWVzc2FnZXNBUEkuTWVzc2FnZXMiLCJUaHJlYWRzIiwiRmlsZXMiLCJGaWxlc0FQSS5WZWN0b3JTdG9yZUZpbGVzUGFnZSIsIkZpbGVCYXRjaGVzIiwiRmlsZXNBUEkuRmlsZXMiLCJGaWxlQmF0Y2hlc0FQSS5GaWxlQmF0Y2hlcyIsIlZlY3RvclN0b3JlcyIsIlZlY3RvclN0b3Jlc0FQSS5WZWN0b3JTdG9yZXNQYWdlIiwiVmVjdG9yU3RvcmVzQVBJLlZlY3RvclN0b3JlcyIsIkNoYXRBUEkuQ2hhdCIsIkFzc2lzdGFudHNBUEkuQXNzaXN0YW50cyIsIlRocmVhZHNBUEkuVGhyZWFkcyIsIkJldGEiLCJFbWJlZGRpbmdzIiwiRmlsZXNBUEkuRmlsZU9iamVjdHNQYWdlIiwiQ2hlY2twb2ludHMiLCJDaGVja3BvaW50c0FQSS5GaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlIiwiQ2hlY2twb2ludHNBUEkuQ2hlY2twb2ludHMiLCJKb2JzIiwiSm9ic0FQSS5GaW5lVHVuaW5nSm9ic1BhZ2UiLCJKb2JzQVBJLkZpbmVUdW5pbmdKb2JFdmVudHNQYWdlIiwiSm9ic0FQSS5Kb2JzIiwiRmluZVR1bmluZyIsIkltYWdlcyIsIk1vZGVscyIsIk1vZGVsc0FQSS5Nb2RlbHNQYWdlIiwiTW9kZXJhdGlvbnMiLCJQYXJ0cyIsIlBhcnRzQVBJLlBhcnRzIiwiVXBsb2FkcyIsIkNvcmUuQVBJQ2xpZW50IiwiQ29yZS5yZWFkRW52IiwiRXJyb3JzLk9wZW5BSUVycm9yIiwiQ29yZS5pc1J1bm5pbmdJbkJyb3dzZXIiLCJBUEkuQ29tcGxldGlvbnMiLCJBUEkuQ2hhdCIsIkFQSS5FbWJlZGRpbmdzIiwiQVBJLkZpbGVzIiwiQVBJLkltYWdlcyIsIkFQSS5BdWRpbyIsIkFQSS5Nb2RlcmF0aW9ucyIsIkFQSS5Nb2RlbHMiLCJBUEkuRmluZVR1bmluZyIsIkFQSS5CZXRhIiwiQVBJLkJhdGNoZXMiLCJBUEkuVXBsb2FkcyIsIkVycm9ycy5BUElFcnJvciIsIkVycm9ycy5BUElDb25uZWN0aW9uRXJyb3IiLCJFcnJvcnMuQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvciIsIkVycm9ycy5BUElVc2VyQWJvcnRFcnJvciIsIkVycm9ycy5Ob3RGb3VuZEVycm9yIiwiRXJyb3JzLkNvbmZsaWN0RXJyb3IiLCJFcnJvcnMuUmF0ZUxpbWl0RXJyb3IiLCJFcnJvcnMuQmFkUmVxdWVzdEVycm9yIiwiRXJyb3JzLkF1dGhlbnRpY2F0aW9uRXJyb3IiLCJFcnJvcnMuSW50ZXJuYWxTZXJ2ZXJFcnJvciIsIkVycm9ycy5QZXJtaXNzaW9uRGVuaWVkRXJyb3IiLCJFcnJvcnMuVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yIiwiVXBsb2Fkcy50b0ZpbGUiLCJVcGxvYWRzLmZpbGVGcm9tUGF0aCIsIk9wZW5BSSIsIlBhZ2luYXRpb24uUGFnZSIsIlBhZ2luYXRpb24uQ3Vyc29yUGFnZSIsIkFQSS5GaWxlT2JqZWN0c1BhZ2UiLCJBUEkuTW9kZWxzUGFnZSIsIkFQSS5CYXRjaGVzUGFnZSIsIk11dGF0aW9uVHlwZSIsInN0b3JlIiwiJHJlc2V0Iiwib3B0aW9ucyIsIm1pY3JvU2Vjb25kcyIsIm1pY3JvIiwiY3JlYXRlIiwicG9zdE1lc3NhZ2UiLCJvbk1lc3NhZ2UiLCJjYW5CZVVzZWQiLCJhdmVyYWdlUmVzcG9uc2VUaW1lIiwibG9jYWxTdG9yYWdlIiwibGlzdGVuZXIiLCJCcm9hZGNhc3RDaGFubmVsIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvYmoiLCJsaXN0ZW5lckZuIiwiQnJvYWRjYXN0Q2hhbm5lbEltcGwyIiwiaHRtbCIsImxpc3QiLCJ0ZXh0IiwicmVuZGVyZXIiLCJ0b2tlbnMiLCJhcmdzIiwicmV0Iiwic3JjIiwiZmV0Y2hNYW55Il0sIm1hcHBpbmdzIjoiOzs7OztFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBO0FBQUE7QUFFQSxXQUFTQSxVQUFRQyxNQUFLLGtCQUFrQjtBQUN0QyxVQUFNQyxPQUFNLElBQUksSUFBSUQsS0FBSSxNQUFNLEdBQUcsQ0FBQztBQUNsQyxXQUFnRSxDQUFDLFFBQVFDLEtBQUksSUFBSSxHQUFHO0FBQUEsRUFDdEY7QUFFQSxRQUFNQyxjQUE0RSxDQUFBO0FBRWxGLFFBQU1DLFNBQU8sTUFBTTtBQUFBLEVBQ25CO0FBS0EsUUFBTUMsV0FBUyxPQUFPO0FBQ3RCLFFBQU1DLFdBQVMsQ0FBQyxLQUFLLE9BQU87QUFDcEIsVUFBQSxJQUFJLElBQUksUUFBUSxFQUFFO0FBQ3hCLFFBQUksSUFBSSxJQUFJO0FBQ04sVUFBQSxPQUFPLEdBQUcsQ0FBQztBQUFBLElBQ2pCO0FBQUEsRUFDRjtBQUNBLFFBQU1DLG1CQUFpQixPQUFPLFVBQVU7QUFDeEMsUUFBTUMsV0FBUyxDQUFDLEtBQUssUUFBUUQsaUJB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TSxVQUFVO0FBQUEsTUFDZjtBQUFBLFFBQ0UsWUFBWTtBQUFBLFFBQ1osTUFBTTtBQUFBLFVBQ0o7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsSUFBQSxDQUNELEVBQUUsQ0FBQztBQUFBLEVBQ047QUFFQSxRQUFNLFVBQVUsRUFBRSxJQUFJO0FBRVQsUUFBQSxvQkFBb0IsR0FBRyxPQUFPO0FBRTlCLFFBQUEsa0JBQWdDLE9BQU8sS0FBS3pKLFVBQVM7QUFDaEUsVUFBTSxXQUFXLEdBQUcsR0FBRyxHQUFHLFFBQVEsbUJBQW1CLEVBQUU7QUFDdkQsVUFBTSxTQUFTQSxTQUFBLGdCQUFBQSxNQUFNO0FBQ3JCLFVBQU0sT0FBT0EsU0FBQSxnQkFBQUEsTUFBTTtBQUViLFVBQUEsTUFBTSxNQUFNLDBDQUEwQztBQUFBLE1BQzFEO0FBQUEsTUFDQTtBQUFBLE1BQ0EsUUFBUTtBQUFBLElBQUEsQ0FDVDtBQUVNLFdBQUEsSUFBSSxTQUFTLElBQUksTUFBTTtBQUFBO0FBQUEsTUFFNUIsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLFFBQ1AsZ0JBQWdCO0FBQUEsTUFDbEI7QUFBQSxJQUFBLENBQ0Q7QUFBQSxFQUNIO0FDckNBLGlCQUFlLEtBQUssRUFBRSxnQkFBNkI7QUFFM0MsVUFBQSxTQUFTLElBQUksT0FBTztBQUFBLE1BQ3hCLFNBQVM7QUFBQSxNQUNULFFBQVE7QUFBQTtBQUFBLE1BQ1IseUJBQXlCO0FBQUEsTUFDekIsT0FBTztBQUFBLElBQUEsQ0FDUjtBQUdELFVBQU0sZUFBZSwwQkFBMEIsRUFBRSxRQUFRLGFBQWMsQ0FBQTtBQUd4RCxtQkFBQTtBQUFBLE1BQ2I7QUFBQSxNQUNBLG9DQUFvQixZQUFZLEVBQUUsY0FBYztBQUFBLElBQUE7QUFBQSxFQUVwRDs7OzsiLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMCwxLDIsMyw0LDUsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDEsNDIsNDMsNDQsNDUsNDYsNDcsNDgsNDksNTAsNTEsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNTksNjAsNjEsNjIsNjMsNjQsNjUsNjYsNjcsNjgsNjksNzAsNzEsNzIsNzMsNzQsNzUsNzYsNzcsODBdfQ==
