var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
define(["exports", "core/ajax"], function(exports, ajax) {
  "use strict";
  /**
  * @vue/shared v3.5.0-beta.3
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function makeMap$2(str2, expectsLowerCase) {
    const set2 = new Set(str2.split(","));
    return (val) => set2.has(val);
  }
  const EMPTY_OBJ$1 = {};
  const NOOP$1 = () => {
  };
  const extend$2 = Object.assign;
  const remove$1 = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  const hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  const hasOwn$3 = (val, key) => hasOwnProperty$3.call(val, key);
  const isArray$2 = Array.isArray;
  const isMap$1 = (val) => toTypeString$2(val) === "[object Map]";
  const isSet$2 = (val) => toTypeString$2(val) === "[object Set]";
  const isFunction$2 = (val) => typeof val === "function";
  const isString$2 = (val) => typeof val === "string";
  const isSymbol$2 = (val) => typeof val === "symbol";
  const isObject$2 = (val) => val !== null && typeof val === "object";
  const objectToString$2 = Object.prototype.toString;
  const toTypeString$2 = (value) => objectToString$2.call(value);
  const toRawType = (value) => {
    return toTypeString$2(value).slice(8, -1);
  };
  const isPlainObject$3 = (val) => toTypeString$2(val) === "[object Object]";
  const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  const def$2 = (obj, key, value, writable = false) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      writable,
      value
    });
  };
  /**
  * @vue/reactivity v3.5.0-beta.3
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  let activeEffectScope;
  class EffectScope {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this.effects = [];
      this.cleanups = [];
      this._isPaused = false;
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
      }
    }
    get active() {
      return this._active;
    }
    pause() {
      if (this._active) {
        this._isPaused = true;
        if (this.scopes) {
          for (let i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].pause();
          }
        }
        for (let i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].pause();
        }
      }
    }
    /**
     * Resumes the effect scope, including all child scopes and effects.
     */
    resume() {
      if (this._active) {
        if (this._isPaused) {
          this._isPaused = false;
          if (this.scopes) {
            for (let i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].resume();
            }
          }
          for (let i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].resume();
          }
        }
      }
    }
    run(fn) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
      activeEffectScope = this;
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
      activeEffectScope = this.parent;
    }
    stop(fromParent) {
      if (this._active) {
        let i, l;
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].stop();
        }
        for (i = 0, l = this.cleanups.length; i < l; i++) {
          this.cleanups[i]();
        }
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].stop(true);
          }
        }
        if (!this.detached && this.parent && !fromParent) {
          const last = this.parent.scopes.pop();
          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }
        this.parent = void 0;
        this._active = false;
      }
    }
  }
  function effectScope(detached) {
    return new EffectScope(detached);
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  function onScopeDispose(fn, failSilently = false) {
    if (activeEffectScope) {
      activeEffectScope.cleanups.push(fn);
    }
  }
  let activeSub;
  const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
  class ReactiveEffect {
    constructor(fn) {
      this.fn = fn;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 1 | 4;
      this.nextEffect = void 0;
      this.cleanup = void 0;
      this.scheduler = void 0;
      if (activeEffectScope && activeEffectScope.active) {
        activeEffectScope.effects.push(this);
      }
    }
    pause() {
      this.flags |= 64;
    }
    resume() {
      if (this.flags & 64) {
        this.flags &= ~64;
        if (pausedQueueEffects.has(this)) {
          pausedQueueEffects.delete(this);
          this.trigger();
        }
      }
    }
    /**
     * @internal
     */
    notify() {
      if (this.flags & 2 && !(this.flags & 32)) {
        return;
      }
      if (!(this.flags & 8)) {
        this.flags |= 8;
        this.nextEffect = batchedEffect;
        batchedEffect = this;
      }
    }
    run() {
      if (!(this.flags & 1)) {
        return this.fn();
      }
      this.flags |= 2;
      cleanupEffect(this);
      prepareDeps(this);
      const prevEffect = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = this;
      shouldTrack = true;
      try {
        return this.fn();
      } finally {
        cleanupDeps(this);
        activeSub = prevEffect;
        shouldTrack = prevShouldTrack;
        this.flags &= ~2;
      }
    }
    stop() {
      if (this.flags & 1) {
        for (let link2 = this.deps; link2; link2 = link2.nextDep) {
          removeSub(link2);
        }
        this.deps = this.depsTail = void 0;
        cleanupEffect(this);
        this.onStop && this.onStop();
        this.flags &= ~1;
      }
    }
    trigger() {
      if (this.flags & 64) {
        pausedQueueEffects.add(this);
      } else if (this.scheduler) {
        this.scheduler();
      } else {
        this.runIfDirty();
      }
    }
    /**
     * @internal
     */
    runIfDirty() {
      if (isDirty(this)) {
        this.run();
      }
    }
    get dirty() {
      return isDirty(this);
    }
  }
  let batchDepth = 0;
  let batchedEffect;
  function startBatch() {
    batchDepth++;
  }
  function endBatch() {
    if (batchDepth > 1) {
      batchDepth--;
      return;
    }
    batchDepth--;
    let error;
    while (batchedEffect) {
      let e = batchedEffect;
      batchedEffect = void 0;
      while (e) {
        const next = e.nextEffect;
        e.nextEffect = void 0;
        e.flags &= ~8;
        if (e.flags & 1) {
          try {
            e.trigger();
          } catch (err) {
            if (!error) error = err;
          }
        }
        e = next;
      }
    }
    if (error) throw error;
  }
  function prepareDeps(sub) {
    for (let link2 = sub.deps; link2; link2 = link2.nextDep) {
      link2.version = -1;
      link2.prevActiveLink = link2.dep.activeLink;
      link2.dep.activeLink = link2;
    }
  }
  function cleanupDeps(sub) {
    let head;
    let tail = sub.depsTail;
    for (let link2 = tail; link2; link2 = link2.prevDep) {
      if (link2.version === -1) {
        if (link2 === tail) tail = link2.prevDep;
        removeSub(link2);
        removeDep(link2);
      } else {
        head = link2;
      }
      link2.dep.activeLink = link2.prevActiveLink;
      link2.prevActiveLink = void 0;
    }
    sub.deps = head;
    sub.depsTail = tail;
  }
  function isDirty(sub) {
    for (let link2 = sub.deps; link2; link2 = link2.nextDep) {
      if (link2.dep.version !== link2.version || link2.dep.computed && refreshComputed(link2.dep.computed) === false || link2.dep.version !== link2.version) {
        return true;
      }
    }
    if (sub._dirty) {
      return true;
    }
    return false;
  }
  function refreshComputed(computed2) {
    if (computed2.flags & 2) {
      return false;
    }
    if (computed2.flags & 4 && !(computed2.flags & 16)) {
      return;
    }
    computed2.flags &= ~16;
    if (computed2.globalVersion === globalVersion) {
      return;
    }
    computed2.globalVersion = globalVersion;
    const dep = computed2.dep;
    computed2.flags |= 2;
    if (dep.version > 0 && !computed2.isSSR && !isDirty(computed2)) {
      computed2.flags &= ~2;
      return;
    }
    const prevSub = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = computed2;
    shouldTrack = true;
    try {
      prepareDeps(computed2);
      const value = computed2.fn();
      if (dep.version === 0 || hasChanged(value, computed2._value)) {
        computed2._value = value;
        dep.version++;
      }
    } catch (err) {
      dep.version++;
      throw err;
    } finally {
      activeSub = prevSub;
      shouldTrack = prevShouldTrack;
      cleanupDeps(computed2);
      computed2.flags &= ~2;
    }
  }
  function removeSub(link2) {
    const { dep, prevSub, nextSub } = link2;
    if (prevSub) {
      prevSub.nextSub = nextSub;
      link2.prevSub = void 0;
    }
    if (nextSub) {
      nextSub.prevSub = prevSub;
      link2.nextSub = void 0;
    }
    if (dep.subs === link2) {
      dep.subs = prevSub;
    }
    if (!dep.subs && dep.computed) {
      dep.computed.flags &= ~4;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l);
      }
    }
  }
  function removeDep(link2) {
    const { prevDep, nextDep } = link2;
    if (prevDep) {
      prevDep.nextDep = nextDep;
      link2.prevDep = void 0;
    }
    if (nextDep) {
      nextDep.prevDep = prevDep;
      link2.nextDep = void 0;
    }
  }
  let shouldTrack = true;
  const trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function cleanupEffect(e) {
    const { cleanup } = e;
    e.cleanup = void 0;
    if (cleanup) {
      const prevSub = activeSub;
      activeSub = void 0;
      try {
        cleanup();
      } finally {
        activeSub = prevSub;
      }
    }
  }
  let globalVersion = 0;
  class Dep {
    constructor(computed2) {
      this.computed = computed2;
      this.version = 0;
      this.activeLink = void 0;
      this.subs = void 0;
    }
    track(debugInfo) {
      if (!activeSub || !shouldTrack) {
        return;
      }
      let link2 = this.activeLink;
      if (link2 === void 0 || link2.sub !== activeSub) {
        link2 = this.activeLink = {
          dep: this,
          sub: activeSub,
          version: this.version,
          nextDep: void 0,
          prevDep: void 0,
          nextSub: void 0,
          prevSub: void 0,
          prevActiveLink: void 0
        };
        if (!activeSub.deps) {
          activeSub.deps = activeSub.depsTail = link2;
        } else {
          link2.prevDep = activeSub.depsTail;
          activeSub.depsTail.nextDep = link2;
          activeSub.depsTail = link2;
        }
        if (activeSub.flags & 4) {
          addSub(link2);
        }
      } else if (link2.version === -1) {
        link2.version = this.version;
        if (link2.nextDep) {
          const next = link2.nextDep;
          next.prevDep = link2.prevDep;
          if (link2.prevDep) {
            link2.prevDep.nextDep = next;
          }
          link2.prevDep = activeSub.depsTail;
          link2.nextDep = void 0;
          activeSub.depsTail.nextDep = link2;
          activeSub.depsTail = link2;
          if (activeSub.deps === link2) {
            activeSub.deps = next;
          }
        }
      }
      return link2;
    }
    trigger(debugInfo) {
      this.version++;
      globalVersion++;
      this.notify(debugInfo);
    }
    notify(debugInfo) {
      startBatch();
      try {
        if (false) ;
        for (let link2 = this.subs; link2; link2 = link2.prevSub) {
          link2.sub.notify();
        }
      } finally {
        endBatch();
      }
    }
  }
  function addSub(link2) {
    const computed2 = link2.dep.computed;
    if (computed2 && !link2.dep.subs) {
      computed2.flags |= 4 | 16;
      for (let l = computed2.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link2.dep.subs;
    if (currentTail !== link2) {
      link2.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link2;
    }
    link2.dep.subs = link2;
  }
  const targetMap = /* @__PURE__ */ new WeakMap();
  const ITERATE_KEY = Symbol(
    ""
  );
  const MAP_KEY_ITERATE_KEY = Symbol(
    ""
  );
  const ARRAY_ITERATE_KEY = Symbol(
    ""
  );
  function track(target, type2, key) {
    if (shouldTrack && activeSub) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = new Dep());
      }
      {
        dep.track();
      }
    }
  }
  function trigger(target, type2, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      globalVersion++;
      return;
    }
    let deps = [];
    if (type2 === "clear") {
      deps = [...depsMap.values()];
    } else {
      const targetIsArray = isArray$2(target);
      const isArrayIndex = targetIsArray && isIntegerKey(key);
      if (targetIsArray && key === "length") {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol$2(key2) && key2 >= newLength) {
            deps.push(dep);
          }
        });
      } else {
        const push = (dep) => dep && deps.push(dep);
        if (key !== void 0) {
          push(depsMap.get(key));
        }
        if (isArrayIndex) {
          push(depsMap.get(ARRAY_ITERATE_KEY));
        }
        switch (type2) {
          case "add":
            if (!targetIsArray) {
              push(depsMap.get(ITERATE_KEY));
              if (isMap$1(target)) {
                push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isArrayIndex) {
              push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!targetIsArray) {
              push(depsMap.get(ITERATE_KEY));
              if (isMap$1(target)) {
                push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap$1(target)) {
              push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
    }
    startBatch();
    for (const dep of deps) {
      {
        dep.trigger();
      }
    }
    endBatch();
  }
  function getDepFromReactive(object, key) {
    var _a2;
    return (_a2 = targetMap.get(object)) == null ? void 0 : _a2.get(key);
  }
  function reactiveReadArray(array) {
    const raw = toRaw(array);
    if (raw === array) return raw;
    track(raw, "iterate", ARRAY_ITERATE_KEY);
    return isShallow(array) ? raw : raw.map(toReactive);
  }
  function shallowReadArray(arr) {
    track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
    return arr;
  }
  const arrayInstrumentations = {
    __proto__: null,
    [Symbol.iterator]() {
      return iterator(this, Symbol.iterator, toReactive);
    },
    concat(...args) {
      return reactiveReadArray(this).concat(
        ...args.map((x) => reactiveReadArray(x))
      );
    },
    entries() {
      return iterator(this, "entries", (value) => {
        value[1] = toReactive(value[1]);
        return value;
      });
    },
    every(fn, thisArg) {
      return apply(this, "every", fn, thisArg, void 0, arguments);
    },
    filter(fn, thisArg) {
      return apply(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
    },
    find(fn, thisArg) {
      return apply(this, "find", fn, thisArg, toReactive, arguments);
    },
    findIndex(fn, thisArg) {
      return apply(this, "findIndex", fn, thisArg, void 0, arguments);
    },
    findLast(fn, thisArg) {
      return apply(this, "findLast", fn, thisArg, toReactive, arguments);
    },
    findLastIndex(fn, thisArg) {
      return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
    },
    // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
    forEach(fn, thisArg) {
      return apply(this, "forEach", fn, thisArg, void 0, arguments);
    },
    includes(...args) {
      return searchProxy(this, "includes", args);
    },
    indexOf(...args) {
      return searchProxy(this, "indexOf", args);
    },
    join(separator) {
      return reactiveReadArray(this).join(separator);
    },
    // keys() iterator only reads `length`, no optimisation required
    lastIndexOf(...args) {
      return searchProxy(this, "lastIndexOf", args);
    },
    map(fn, thisArg) {
      return apply(this, "map", fn, thisArg, void 0, arguments);
    },
    pop() {
      return noTracking(this, "pop");
    },
    push(...args) {
      return noTracking(this, "push", args);
    },
    reduce(fn, ...args) {
      return reduce(this, "reduce", fn, args);
    },
    reduceRight(fn, ...args) {
      return reduce(this, "reduceRight", fn, args);
    },
    shift() {
      return noTracking(this, "shift");
    },
    // slice could use ARRAY_ITERATE but also seems to beg for range tracking
    some(fn, thisArg) {
      return apply(this, "some", fn, thisArg, void 0, arguments);
    },
    splice(...args) {
      return noTracking(this, "splice", args);
    },
    toReversed() {
      return reactiveReadArray(this).toReversed();
    },
    toSorted(comparer) {
      return reactiveReadArray(this).toSorted(comparer);
    },
    toSpliced(...args) {
      return reactiveReadArray(this).toSpliced(...args);
    },
    unshift(...args) {
      return noTracking(this, "unshift", args);
    },
    values() {
      return iterator(this, "values", toReactive);
    }
  };
  function iterator(self2, method, wrapValue) {
    const arr = shallowReadArray(self2);
    const iter = arr[method]();
    if (arr !== self2 && !isShallow(self2)) {
      iter._next = iter.next;
      iter.next = () => {
        const result = iter._next();
        if (result.value) {
          result.value = wrapValue(result.value);
        }
        return result;
      };
    }
    return iter;
  }
  const arrayProto = Array.prototype;
  function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
    const arr = shallowReadArray(self2);
    const needsWrap = arr !== self2 && !isShallow(self2);
    const methodFn = arr[method];
    if (methodFn !== arrayProto[method]) {
      const result2 = methodFn.apply(arr, args);
      return needsWrap ? toReactive(result2) : result2;
    }
    let wrappedFn = fn;
    if (arr !== self2) {
      if (needsWrap) {
        wrappedFn = function(item, index) {
          return fn.call(this, toReactive(item), index, self2);
        };
      } else if (fn.length > 2) {
        wrappedFn = function(item, index) {
          return fn.call(this, item, index, self2);
        };
      }
    }
    const result = methodFn.call(arr, wrappedFn, thisArg);
    return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
  }
  function reduce(self2, method, fn, args) {
    const arr = shallowReadArray(self2);
    let wrappedFn = fn;
    if (arr !== self2) {
      if (!isShallow(self2)) {
        wrappedFn = function(acc, item, index) {
          return fn.call(this, acc, toReactive(item), index, self2);
        };
      } else if (fn.length > 3) {
        wrappedFn = function(acc, item, index) {
          return fn.call(this, acc, item, index, self2);
        };
      }
    }
    return arr[method](wrappedFn, ...args);
  }
  function searchProxy(self2, method, args) {
    const arr = toRaw(self2);
    track(arr, "iterate", ARRAY_ITERATE_KEY);
    const res = arr[method](...args);
    if ((res === -1 || res === false) && isProxy(args[0])) {
      args[0] = toRaw(args[0]);
      return arr[method](...args);
    }
    return res;
  }
  function noTracking(self2, method, args = []) {
    pauseTracking();
    startBatch();
    const res = toRaw(self2)[method].apply(self2, args);
    endBatch();
    resetTracking();
    return res;
  }
  const isNonTrackableKeys = /* @__PURE__ */ makeMap$2(`__proto__,__v_isRef,__isVue`);
  const builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$2)
  );
  function hasOwnProperty$2(key) {
    if (!isSymbol$2(key)) key = String(key);
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  class BaseReactiveHandler {
    constructor(_isReadonly = false, _isShallow = false) {
      this._isReadonly = _isReadonly;
      this._isShallow = _isShallow;
    }
    get(target, key, receiver) {
      const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return isShallow2;
      } else if (key === "__v_raw") {
        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
        // this means the receiver is a user proxy of the reactive proxy
        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
          return target;
        }
        return;
      }
      const targetIsArray = isArray$2(target);
      if (!isReadonly2) {
        let fn;
        if (targetIsArray && (fn = arrayInstrumentations[key])) {
          return fn;
        }
        if (key === "hasOwnProperty") {
          return hasOwnProperty$2;
        }
      }
      const res = Reflect.get(
        target,
        key,
        // if this is a proxy wrapping a ref, return methods using the raw ref
        // as receiver so that we don't have to call `toRaw` on the ref in all
        // its class methods
        isRef$1(target) ? target : receiver
      );
      if (isSymbol$2(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (isShallow2) {
        return res;
      }
      if (isRef$1(res)) {
        return targetIsArray && isIntegerKey(key) ? res : res.value;
      }
      if (isObject$2(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    }
  }
  class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(false, isShallow2);
    }
    set(target, key, value, receiver) {
      let oldValue = target[key];
      if (!this._isShallow) {
        const isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray$2(target) && isRef$1(oldValue) && !isRef$1(value)) {
          if (isOldValueReadonly) {
            return false;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$3(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
      }
      return result;
    }
    deleteProperty(target, key) {
      const hadKey = hasOwn$3(target, key);
      target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    has(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol$2(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    ownKeys(target) {
      track(
        target,
        "iterate",
        isArray$2(target) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target);
    }
  }
  class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(true, isShallow2);
    }
    set(target, key) {
      return true;
    }
    deleteProperty(target, key) {
      return true;
    }
  }
  const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
  const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
  const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
  const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
  const toShallow = (value) => value;
  const getProto = (v) => Reflect.getPrototypeOf(v);
  function get(target, key, isReadonly2 = false, isShallow2 = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
      if (hasChanged(key, rawKey)) {
        track(rawTarget, "get", key);
      }
      track(rawTarget, "get", rawKey);
    }
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has(key, isReadonly2 = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
      if (hasChanged(key, rawKey)) {
        track(rawTarget, "has", key);
      }
      track(rawTarget, "has", rawKey);
    }
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly2 = false) {
    target = target["__v_raw"];
    !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value, _isShallow = false) {
    if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
      value = toRaw(value);
    }
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set(key, value, _isShallow = false) {
    if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
      value = toRaw(value);
    }
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    }
    const oldValue = get2.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    }
    get2 ? get2.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0);
    }
    return result;
  }
  function createForEach(isReadonly2, isShallow2) {
    return function forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap$1(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type2) {
    return function(...args) {
      return type2 === "delete" ? false : type2 === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key) {
        return get(this, key);
      },
      get size() {
        return size(this);
      },
      has,
      add,
      set,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key) {
        return get(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has,
      add(value) {
        return add.call(this, value, true);
      },
      set(key, value) {
        return set.call(this, key, value, true);
      },
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key) {
        return get(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key) {
        return get(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = [
      "keys",
      "values",
      "entries",
      Symbol.iterator
    ];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
      shallowInstrumentations2[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations2[method] = createIterableMethod(
        method,
        true,
        true
      );
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  const [
    mutableInstrumentations,
    readonlyInstrumentations,
    shallowInstrumentations,
    shallowReadonlyInstrumentations
  ] = /* @__PURE__ */ createInstrumentations();
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(
        hasOwn$3(instrumentations, key) && key in target ? instrumentations : target,
        key,
        receiver
      );
    };
  }
  const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  const reactiveMap = /* @__PURE__ */ new WeakMap();
  const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  const readonlyMap = /* @__PURE__ */ new WeakMap();
  const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function shallowReactive(target) {
    return createReactiveObject(
      target,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
    );
  }
  function readonly(target) {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function shallowReadonly(target) {
    return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    );
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject$2(target)) {
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(
      target,
      targetType === 2 ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    if (Object.isExtensible(value)) {
      def$2(value, "__v_skip", true);
    }
    return value;
  }
  const toReactive = (value) => isObject$2(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject$2(value) ? readonly(value) : value;
  function isRef$1(r) {
    return r ? r["__v_isRef"] === true : false;
  }
  function ref(value) {
    return createRef(value, false);
  }
  function createRef(rawValue, shallow) {
    if (isRef$1(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  class RefImpl {
    constructor(value, isShallow2) {
      this.dep = new Dep();
      this["__v_isRef"] = true;
      this["__v_isShallow"] = false;
      this._rawValue = isShallow2 ? value : toRaw(value);
      this._value = isShallow2 ? value : toReactive(value);
      this["__v_isShallow"] = isShallow2;
    }
    get value() {
      {
        this.dep.track();
      }
      return this._value;
    }
    set value(newValue) {
      const oldValue = this._rawValue;
      const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
      newValue = useDirectValue ? newValue : toRaw(newValue);
      if (hasChanged(newValue, oldValue)) {
        this._rawValue = newValue;
        this._value = useDirectValue ? newValue : toReactive(newValue);
        {
          this.dep.trigger();
        }
      }
    }
  }
  function unref(ref2) {
    return isRef$1(ref2) ? ref2.value : ref2;
  }
  const shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef$1(oldValue) && !isRef$1(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  function toRefs(object) {
    const ret = isArray$2(object) ? new Array(object.length) : {};
    for (const key in object) {
      ret[key] = propertyToRef(object, key);
    }
    return ret;
  }
  class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
      this._object = _object;
      this._key = _key;
      this._defaultValue = _defaultValue;
      this["__v_isRef"] = true;
      this._value = void 0;
    }
    get value() {
      const val = this._object[this._key];
      return this._value = val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
      this._object[this._key] = newVal;
    }
    get dep() {
      return getDepFromReactive(toRaw(this._object), this._key);
    }
  }
  function propertyToRef(source, key, defaultValue) {
    const val = source[key];
    return isRef$1(val) ? val : new ObjectRefImpl(source, key, defaultValue);
  }
  class ComputedRefImpl {
    constructor(fn, setter, isSSR) {
      this.fn = fn;
      this.setter = setter;
      this._value = void 0;
      this.dep = new Dep(this);
      this.__v_isRef = true;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 16;
      this.globalVersion = globalVersion - 1;
      this.effect = this;
      this["__v_isReadonly"] = !setter;
      this.isSSR = isSSR;
    }
    /**
     * @internal
     */
    notify() {
      if (activeSub !== this) {
        this.flags |= 16;
        this.dep.notify();
      }
    }
    get value() {
      const link2 = this.dep.track();
      refreshComputed(this);
      if (link2) {
        link2.version = this.dep.version;
      }
      return this._value;
    }
    set value(newValue) {
      if (this.setter) {
        this.setter(newValue);
      }
    }
  }
  function computed$1(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    if (isFunction$2(getterOrOptions)) {
      getter = getterOrOptions;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, isSSR);
    return cRef;
  }
  const INITIAL_WATCHER_VALUE = {};
  const cleanupMap = /* @__PURE__ */ new WeakMap();
  let activeWatcher = void 0;
  function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
    if (owner) {
      let cleanups = cleanupMap.get(owner);
      if (!cleanups) cleanupMap.set(owner, cleanups = []);
      cleanups.push(cleanupFn);
    }
  }
  function watch$1(source, cb, options = EMPTY_OBJ$1) {
    const { immediate, deep, once, scheduler, augmentJob, call } = options;
    const reactiveGetter = (source2) => {
      if (deep) return source2;
      if (isShallow(source2) || deep === false || deep === 0)
        return traverse(source2, 1);
      return traverse(source2);
    };
    let effect2;
    let getter;
    let cleanup;
    let boundCleanup;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef$1(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => reactiveGetter(source);
      forceTrigger = true;
    } else if (isArray$2(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
      getter = () => source.map((s) => {
        if (isRef$1(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return reactiveGetter(s);
        } else if (isFunction$2(s)) {
          return call ? call(s, 2) : s();
        } else ;
      });
    } else if (isFunction$2(source)) {
      if (cb) {
        getter = call ? () => call(source, 2) : source;
      } else {
        getter = () => {
          if (cleanup) {
            pauseTracking();
            try {
              cleanup();
            } finally {
              resetTracking();
            }
          }
          const currentEffect = activeWatcher;
          activeWatcher = effect2;
          try {
            return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
          } finally {
            activeWatcher = currentEffect;
          }
        };
      }
    } else {
      getter = NOOP$1;
    }
    if (cb && deep) {
      const baseGetter = getter;
      const depth = deep === true ? Infinity : deep;
      getter = () => traverse(baseGetter(), depth);
    }
    if (once) {
      if (cb) {
        const _cb = cb;
        cb = (...args) => {
          _cb(...args);
          effect2.stop();
        };
      } else {
        const _getter = getter;
        getter = () => {
          _getter();
          effect2.stop();
        };
      }
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = (immediateFirstRun) => {
      if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
          if (cleanup) {
            cleanup();
          }
          const currentWatcher = activeWatcher;
          activeWatcher = effect2;
          try {
            const args = [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              boundCleanup
            ];
            call ? call(cb, 3, args) : (
              // @ts-expect-error
              cb(...args)
            );
            oldValue = newValue;
          } finally {
            activeWatcher = currentWatcher;
          }
        }
      } else {
        effect2.run();
      }
    };
    if (augmentJob) {
      augmentJob(job);
    }
    effect2 = new ReactiveEffect(getter);
    effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
    boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
    cleanup = effect2.onStop = () => {
      const cleanups = cleanupMap.get(effect2);
      if (cleanups) {
        if (call) {
          call(cleanups, 4);
        } else {
          for (const cleanup2 of cleanups) cleanup2();
        }
        cleanupMap.delete(effect2);
      }
    };
    if (cb) {
      if (immediate) {
        job(true);
      } else {
        oldValue = effect2.run();
      }
    } else if (scheduler) {
      scheduler(job.bind(null, true), true);
    } else {
      effect2.run();
    }
    const scope = getCurrentScope();
    const watchHandle = () => {
      effect2.stop();
      if (scope) {
        remove$1(scope.effects, effect2);
      }
    };
    watchHandle.pause = effect2.pause.bind(effect2);
    watchHandle.resume = effect2.resume.bind(effect2);
    watchHandle.stop = watchHandle;
    return watchHandle;
  }
  function traverse(value, depth = Infinity, seen) {
    if (depth <= 0 || !isObject$2(value) || value["__v_skip"]) {
      return value;
    }
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    depth--;
    if (isRef$1(value)) {
      traverse(value.value, depth, seen);
    } else if (isArray$2(value)) {
      for (let i = 0; i < value.length; i++) {
        traverse(value[i], depth, seen);
      }
    } else if (isSet$2(value) || isMap$1(value)) {
      value.forEach((v) => {
        traverse(v, depth, seen);
      });
    } else if (isPlainObject$3(value)) {
      for (const key in value) {
        traverse(value[key], depth, seen);
      }
      for (const key of Object.getOwnPropertySymbols(value)) {
        if (Object.prototype.propertyIsEnumerable.call(value, key)) {
          traverse(value[key], depth, seen);
        }
      }
    }
    return value;
  }
  /**
  * @vue/shared v3.5.0-beta.3
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function makeMap$1(str2, expectsLowerCase) {
    const set2 = new Set(str2.split(","));
    return (val) => set2.has(val);
  }
  const EMPTY_OBJ = {};
  const EMPTY_ARR = [];
  const NOOP = () => {
  };
  const NO = () => false;
  const isOn$1 = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  const isModelListener$1 = (key) => key.startsWith("onUpdate:");
  const extend$1 = Object.assign;
  const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  const hasOwn$2 = (val, key) => hasOwnProperty$1.call(val, key);
  const isArray$1 = Array.isArray;
  const isMap = (val) => toTypeString$1(val) === "[object Map]";
  const isSet$1 = (val) => toTypeString$1(val) === "[object Set]";
  const isFunction$1 = (val) => typeof val === "function";
  const isString$1 = (val) => typeof val === "string";
  const isSymbol$1 = (val) => typeof val === "symbol";
  const isObject$1 = (val) => val !== null && typeof val === "object";
  const isPromise$1 = (val) => {
    return (isObject$1(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
  };
  const objectToString$1 = Object.prototype.toString;
  const toTypeString$1 = (value) => objectToString$1.call(value);
  const isPlainObject$2 = (val) => toTypeString$1(val) === "[object Object]";
  const isReservedProp = /* @__PURE__ */ makeMap$1(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  const cacheStringFunction$1 = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str2) => {
      const hit = cache[str2];
      return hit || (cache[str2] = fn(str2));
    };
  };
  const camelizeRE$1 = /-(\w)/g;
  const camelize$1 = cacheStringFunction$1(
    (str2) => {
      return str2.replace(camelizeRE$1, (_, c) => c ? c.toUpperCase() : "");
    }
  );
  const hyphenateRE$1 = /\B([A-Z])/g;
  const hyphenate$1 = cacheStringFunction$1(
    (str2) => str2.replace(hyphenateRE$1, "-$1").toLowerCase()
  );
  const capitalize$1 = cacheStringFunction$1((str2) => {
    return str2.charAt(0).toUpperCase() + str2.slice(1);
  });
  const toHandlerKey = cacheStringFunction$1(
    (str2) => {
      const s = str2 ? `on${capitalize$1(str2)}` : ``;
      return s;
    }
  );
  const invokeArrayFns$1 = (fns, ...arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](...arg);
    }
  };
  const def$1 = (obj, key, value, writable = false) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      writable,
      value
    });
  };
  const looseToNumber$1 = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function normalizeStyle(value) {
    if (isArray$1(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString$1(value) || isObject$1(value)) {
      return value;
    }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString$1(value)) {
      res = value;
    } else if (isArray$1(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject$1(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  const isRef = (val) => {
    return !!(val && val["__v_isRef"] === true);
  };
  const toDisplayString = (val) => {
    return isString$1(val) ? val : val == null ? "" : isArray$1(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
  };
  const replacer = (_key, val) => {
    if (isRef(val)) {
      return replacer(_key, val.value);
    } else if (isMap(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce(
          (entries, [key, val2], i) => {
            entries[stringifySymbol(key, i) + " =>"] = val2;
            return entries;
          },
          {}
        )
      };
    } else if (isSet$1(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
      };
    } else if (isSymbol$1(val)) {
      return stringifySymbol(val);
    } else if (isObject$1(val) && !isArray$1(val) && !isPlainObject$2(val)) {
      return String(val);
    }
    return val;
  };
  const stringifySymbol = (v, i = "") => {
    var _a2;
    return (
      // Symbol.description in es2019+ so we need to cast here to pass
      // the lib: es2016 check
      isSymbol$1(v) ? `Symbol(${(_a2 = v.description) != null ? _a2 : i})` : v
    );
  };
  /**
  * @vue/runtime-core v3.5.0-beta.3
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const stack = [];
  let isWarning = false;
  function warn$1(msg, ...args) {
    if (isWarning) return;
    isWarning = true;
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
          // eslint-disable-next-line no-restricted-syntax
          msg + args.map((a) => {
            var _a2, _b;
            return (_b = (_a2 = a.toString) == null ? void 0 : _a2.call(a)) != null ? _b : JSON.stringify(a);
          }).join(""),
          instance && instance.proxy,
          trace.map(
            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
          ).join("\n"),
          trace
        ]
      );
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && // avoid spamming console during tests
      true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
    isWarning = false;
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last = normalizedStack[0];
      if (last && last.vnode === currentVNode) {
        last.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
      logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(
      vnode.component,
      vnode.type,
      isRoot
    )}`;
    const close2 = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close2] : [open + close2];
  }
  function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString$1(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key}=${value}`];
    } else if (isRef$1(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction$1(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key}=`, value];
    }
  }
  function callWithErrorHandling(fn, instance, type2, args) {
    try {
      return args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type2);
    }
  }
  function callWithAsyncErrorHandling(fn, instance, type2, args) {
    if (isFunction$1(fn)) {
      const res = callWithErrorHandling(fn, instance, type2, args);
      if (res && isPromise$1(res)) {
        res.catch((err) => {
          handleError(err, instance, type2);
        });
      }
      return res;
    }
    if (isArray$1(fn)) {
      const values = [];
      for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type2, args));
      }
      return values;
    }
  }
  function handleError(err, instance, type2, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = `https://vuejs.org/error-reference/#runtime-${type2}`;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i = 0; i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      if (errorHandler) {
        pauseTracking();
        callWithErrorHandling(errorHandler, null, 10, [
          err,
          exposedInstance,
          errorInfo
        ]);
        resetTracking();
        return;
      }
    }
    logError(err, type2, contextVNode, throwInDev, throwUnhandledErrorInProduction);
  }
  function logError(err, type2, contextVNode, throwInDev = true, throwInProd = false) {
    if (throwInProd) {
      throw err;
    } else {
      console.error(err);
    }
  }
  let isFlushing = false;
  let isFlushPending = false;
  const queue = [];
  let flushIndex = 0;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = /* @__PURE__ */ Promise.resolve();
  let currentFlushPromise = null;
  function nextTick(fn) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
  }
  function findInsertionIndex(id) {
    let start = isFlushing ? flushIndex + 1 : 0;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJob = queue[middle];
      const middleJobId = getId(middleJob);
      if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
        start = middle + 1;
      } else {
        end = middle;
      }
    }
    return start;
  }
  function queueJob(job) {
    if (!(job.flags & 1)) {
      const jobId = getId(job);
      const lastJob = queue[queue.length - 1];
      if (!lastJob || // fast path when the job id is larger than the tail
      !(job.flags & 2) && jobId >= getId(lastJob)) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(jobId), 0, job);
      }
      if (!(job.flags & 4)) {
        job.flags |= 1;
      }
      queueFlush();
    }
  }
  function queueFlush() {
    if (!isFlushing && !isFlushPending) {
      isFlushPending = true;
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray$1(cb)) {
      if (activePostFlushCbs && cb.id === -1) {
        activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
      } else if (!(cb.flags & 1)) {
        pendingPostFlushCbs.push(cb);
        if (!(cb.flags & 4)) {
          cb.flags |= 1;
        }
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
    for (; i < queue.length; i++) {
      const cb = queue[i];
      if (cb && cb.flags & 2) {
        if (instance && cb.id !== instance.uid) {
          continue;
        }
        queue.splice(i, 1);
        i--;
        cb();
        cb.flags &= ~1;
      }
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)].sort(
        (a, b) => getId(a) - getId(b)
      );
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        const cb = activePostFlushCbs[postFlushIndex];
        if (!(cb.flags & 8)) cb();
        cb.flags &= ~1;
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
  function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && !(job.flags & 8)) {
          if (false) ;
          callWithErrorHandling(
            job,
            job.i,
            job.i ? 15 : 14
          );
          job.flags &= ~1;
        }
      }
    } finally {
      flushIndex = 0;
      queue.length = 0;
      flushPostFlushCbs();
      isFlushing = false;
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs();
      }
    }
  }
  let currentRenderingInstance = null;
  let currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
      return vnode;
    }
    const instance = getComponentPublicInstance(currentRenderingInstance);
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
      if (dir) {
        if (isFunction$1(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
      const binding = bindings[i];
      if (oldBindings) {
        binding.oldValue = oldBindings[i].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  const TeleportEndKey = Symbol("_vte");
  const isTeleport = (type2) => type2.__isTeleport;
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function defineComponent(options, extraOptions) {
    return isFunction$1(options) ? (
      // #8326: extend call and options.name access are considered side-effects
      // by Rollup, so we have to wrap it in a pure-annotated IIFE.
      /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))()
    ) : options;
  }
  function markAsyncBoundary(instance) {
    instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
  }
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray$1(rawRef)) {
      rawRef.forEach(
        (r, i) => setRef(
          r,
          oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i] : oldRawRef),
          parentSuspense,
          vnode,
          isUnmount
        )
      );
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref3 } = rawRef;
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref3) {
      if (isString$1(oldRef)) {
        refs[oldRef] = null;
        if (hasOwn$2(setupState, oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef$1(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction$1(ref3)) {
      callWithErrorHandling(ref3, owner, 12, [value, refs]);
    } else {
      const _isString = isString$1(ref3);
      const _isRef = isRef$1(ref3);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? hasOwn$2(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
            if (isUnmount) {
              isArray$1(existing) && remove(existing, refValue);
            } else {
              if (!isArray$1(existing)) {
                if (_isString) {
                  refs[ref3] = [refValue];
                  if (hasOwn$2(setupState, ref3)) {
                    setupState[ref3] = refs[ref3];
                  }
                } else {
                  ref3.value = [refValue];
                  if (rawRef.k) refs[rawRef.k] = ref3.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref3] = value;
            if (hasOwn$2(setupState, ref3)) {
              setupState[ref3] = value;
            }
          } else if (_isRef) {
            ref3.value = value;
            if (rawRef.k) refs[rawRef.k] = value;
          } else ;
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      }
    }
  }
  const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type2, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type2, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type2, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
    const injected = injectHook(
      type2,
      hook,
      keepAliveRoot,
      true
      /* prepend */
    );
    onUnmounted(() => {
      remove(keepAliveRoot[type2], injected);
    }, target);
  }
  function injectHook(type2, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type2] || (target[type2] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        pauseTracking();
        const reset = setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type2, args);
        reset();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    }
  }
  const createHook = (lifecycle) => (hook, target = currentInstance) => {
    if (!isInSSRComponentSetup || lifecycle === "sp") {
      injectHook(lifecycle, (...args) => hook(...args), target);
    }
  };
  const onBeforeMount = createHook("bm");
  const onMounted = createHook("m");
  const onBeforeUpdate = createHook(
    "bu"
  );
  const onUpdated = createHook("u");
  const onBeforeUnmount = createHook(
    "bum"
  );
  const onUnmounted = createHook("um");
  const onServerPrefetch = createHook(
    "sp"
  );
  const onRenderTriggered = createHook("rtg");
  const onRenderTracked = createHook("rtc");
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = cache;
    const sourceIsArray = isArray$1(source);
    if (sourceIsArray || isString$1(source)) {
      const sourceIsReactiveArray = sourceIsArray && isReactive(source);
      if (sourceIsReactiveArray) {
        source = shallowReadArray(source);
      }
      ret = new Array(source.length);
      for (let i = 0, l = source.length; i < l; i++) {
        ret[i] = renderItem(
          sourceIsReactiveArray ? toReactive(source[i]) : source[i],
          i,
          void 0,
          cached
        );
      }
    } else if (typeof source === "number") {
      ret = new Array(source);
      for (let i = 0; i < source; i++) {
        ret[i] = renderItem(i + 1, i, void 0, cached);
      }
    } else if (isObject$1(source)) {
      if (source[Symbol.iterator]) {
        ret = Array.from(
          source,
          (item, i) => renderItem(item, i, void 0, cached)
        );
      } else {
        const keys = Object.keys(source);
        ret = new Array(keys.length);
        for (let i = 0, l = keys.length; i < l; i++) {
          const key = keys[i];
          ret[i] = renderItem(source[key], key, i, cached);
        }
      }
    } else {
      ret = [];
    }
    return ret;
  }
  const getPublicInstance = (i) => {
    if (!i) return null;
    if (isStatefulComponent(i)) return getComponentPublicInstance(i);
    return getPublicInstance(i.parent);
  };
  const publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
      $: (i) => i,
      $el: (i) => i.vnode.el,
      $data: (i) => i.data,
      $props: (i) => i.props,
      $attrs: (i) => i.attrs,
      $slots: (i) => i.slots,
      $refs: (i) => i.refs,
      $parent: (i) => getPublicInstance(i.parent),
      $root: (i) => getPublicInstance(i.root),
      $host: (i) => i.ce,
      $emit: (i) => i.emit,
      $options: (i) => resolveMergedOptions(i),
      $forceUpdate: (i) => i.f || (i.f = () => {
        queueJob(i.update);
      }),
      $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
      $watch: (i) => instanceWatch.bind(i)
    })
  );
  const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$2(state, key);
  const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      if (key === "__v_skip") {
        return true;
      }
      const { ctx, setupState, data, props, accessCache, type: type2, appContext } = instance;
      let normalizedProps;
      if (key[0] !== "$") {
        const n = accessCache[key];
        if (n !== void 0) {
          switch (n) {
            case 1:
              return setupState[key];
            case 2:
              return data[key];
            case 4:
              return ctx[key];
            case 3:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn$2(data, key)) {
          accessCache[key] = 2;
          return data[key];
        } else if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (normalizedProps = instance.propsOptions[0]) && hasOwn$2(normalizedProps, key)
        ) {
          accessCache[key] = 3;
          return props[key];
        } else if (ctx !== EMPTY_OBJ && hasOwn$2(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (shouldCacheAccess) {
          accessCache[key] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance.attrs, "get", "");
        }
        return publicGetter(instance);
      } else if (
        // css module (injected by vue-loader)
        (cssModule = type2.__cssModules) && (cssModule = cssModule[key])
      ) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn$2(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (
        // global properties
        globalProperties = appContext.config.globalProperties, hasOwn$2(globalProperties, key)
      ) {
        {
          return globalProperties[key];
        }
      } else ;
    },
    set({ _: instance }, key, value) {
      const { data, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (data !== EMPTY_OBJ && hasOwn$2(data, key)) {
        data[key] = value;
        return true;
      } else if (hasOwn$2(instance.props, key)) {
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        return false;
      } else {
        {
          ctx[key] = value;
        }
      }
      return true;
    },
    has({
      _: { data, setupState, accessCache, ctx, appContext, propsOptions }
    }, key) {
      let normalizedProps;
      return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn$2(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$2(normalizedProps, key) || hasOwn$2(ctx, key) || hasOwn$2(publicPropertiesMap, key) || hasOwn$2(appContext.config.globalProperties, key);
    },
    defineProperty(target, key, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key] = 0;
      } else if (hasOwn$2(descriptor, "value")) {
        this.set(target, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key, descriptor);
    }
  };
  function normalizePropsOrEmits(props) {
    return isArray$1(props) ? props.reduce(
      (normalized, p2) => (normalized[p2] = null, normalized),
      {}
    ) : props;
  }
  let shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook(options.beforeCreate, instance, "bc");
    }
    const {
      // state
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      // lifecycle
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render: render2,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      // public API
      expose,
      inheritAttrs,
      // assets
      components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = null;
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction$1(methodHandler)) {
          {
            ctx[key] = methodHandler.bind(publicThis);
          }
        }
      }
    }
    if (dataOptions) {
      const data = dataOptions.call(publicThis, publicThis);
      if (!isObject$1(data)) ;
      else {
        instance.data = reactive(data);
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
        const c = computed({
          get: get2,
          set: set2
        });
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => c.value,
          set: (v) => c.value = v
        });
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray$1(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray$1(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render2 && instance.render === NOOP) {
      instance.render = render2;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
    if (serverPrefetch) {
      markAsyncBoundary(instance);
    }
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray$1(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject$1(opt)) {
        if ("default" in opt) {
          injected = inject(
            opt.from || key,
            opt.default,
            true
          );
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef$1(injected)) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
    }
  }
  function callHook(hook, instance, type2) {
    callWithAsyncErrorHandling(
      isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
      instance,
      type2
    );
  }
  function createWatcher(raw, ctx, publicThis, key) {
    let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString$1(raw)) {
      const handler = ctx[raw];
      if (isFunction$1(handler)) {
        {
          watch(getter, handler);
        }
      }
    } else if (isFunction$1(raw)) {
      {
        watch(getter, raw.bind(publicThis));
      }
    } else if (isObject$1(raw)) {
      if (isArray$1(raw)) {
        raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
      } else {
        const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction$1(handler)) {
          watch(getter, handler, raw);
        }
      }
    } else ;
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const {
      mixins: globalMixins,
      optionsCache: cache,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
        );
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    if (isObject$1(base)) {
      cache.set(base, resolved);
    }
    return resolved;
  }
  function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        (m) => mergeOptions(to, m, strats, true)
      );
    }
    for (const key in from) {
      if (asMixin && key === "expose") ;
      else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
      }
    }
    return to;
  }
  const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return extend$1(
        isFunction$1(to) ? to.call(this, this) : to,
        isFunction$1(from) ? from.call(this, this) : from
      );
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray$1(raw)) {
      const res = {};
      for (let i = 0; i < raw.length; i++) {
        res[raw[i]] = raw[i];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from) : from;
  }
  function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
      if (isArray$1(to) && isArray$1(from)) {
        return [.../* @__PURE__ */ new Set([...to, ...from])];
      }
      return extend$1(
        /* @__PURE__ */ Object.create(null),
        normalizePropsOrEmits(to),
        normalizePropsOrEmits(from != null ? from : {})
      );
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to, from) {
    if (!to) return from;
    if (!from) return to;
    const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
    for (const key in from) {
      merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let uid$1 = 0;
  function createAppAPI(render2, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction$1(rootComponent)) {
        rootComponent = extend$1({}, rootComponent);
      }
      if (rootProps != null && !isObject$1(rootProps)) {
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = /* @__PURE__ */ new WeakSet();
      const pluginCleanupFns = [];
      let isMounted = false;
      const app = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version,
        get config() {
          return context.config;
        },
        set config(v) {
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin)) ;
          else if (plugin && isFunction$1(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app, ...options);
          } else if (isFunction$1(plugin)) {
            installedPlugins.add(plugin);
            plugin(app, ...options);
          } else ;
          return app;
        },
        mixin(mixin) {
          {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            }
          }
          return app;
        },
        component(name, component) {
          if (!component) {
            return context.components[name];
          }
          context.components[name] = component;
          return app;
        },
        directive(name, directive) {
          if (!directive) {
            return context.directives[name];
          }
          context.directives[name] = directive;
          return app;
        },
        mount(rootContainer, isHydrate, namespace) {
          if (!isMounted) {
            const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (namespace === true) {
              namespace = "svg";
            } else if (namespace === false) {
              namespace = void 0;
            }
            if (isHydrate && hydrate) {
              hydrate(vnode, rootContainer);
            } else {
              render2(vnode, rootContainer, namespace);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            return getComponentPublicInstance(vnode.component);
          }
        },
        onUnmount(cleanupFn) {
          pluginCleanupFns.push(cleanupFn);
        },
        unmount() {
          if (isMounted) {
            callWithAsyncErrorHandling(
              pluginCleanupFns,
              app._instance,
              16
            );
            render2(null, app._container);
            delete app._container.__vue_app__;
          }
        },
        provide(key, value) {
          context.provides[key] = value;
          return app;
        },
        runWithContext(fn) {
          const lastApp = currentApp;
          currentApp = app;
          try {
            return fn();
          } finally {
            currentApp = lastApp;
          }
        }
      };
      return app;
    };
  }
  let currentApp = null;
  function provide(key, value) {
    if (!currentInstance) ;
    else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else ;
    }
  }
  function hasInjectionContext() {
    return !!(currentInstance || currentRenderingInstance || currentApp);
  }
  const internalObjectProto = {};
  const createInternalObject = () => Object.create(internalObjectProto);
  const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = createInternalObject();
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
      // always force full diff in dev
      // - #1942 if hmr is enabled with sfc component
      // - vite#872 non-sfc component used by sfc component
      (optimized || patchFlag > 0) && !(patchFlag & 16)
    ) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i = 0; i < propsToUpdate.length; i++) {
          let key = propsToUpdate[i];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          const value = rawProps[key];
          if (options) {
            if (hasOwn$2(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize$1(key);
              props[camelizedKey] = resolvePropValue(
                options,
                rawCurrentProps,
                camelizedKey,
                value,
                instance,
                false
              );
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || // for camelCase
        !hasOwn$2(rawProps, key) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = hyphenate$1(key)) === key || !hasOwn$2(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && // for camelCase
            (rawPrevProps[key] !== void 0 || // for kebab-case
            rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(
                options,
                rawCurrentProps,
                key,
                void 0,
                instance,
                true
              );
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn$2(rawProps, key) && true) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance.attrs, "set", "");
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options && hasOwn$2(options, camelKey = camelize$1(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs) || value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i = 0; i < needCastKeys.length; i++) {
        const key = needCastKeys[i];
        props[key] = resolvePropValue(
          options,
          rawCurrentProps,
          key,
          castValues[key],
          instance,
          !hasOwn$2(castValues, key)
        );
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
      const hasDefault = hasOwn$2(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            const reset = setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(
              null,
              props
            );
            reset();
          }
        } else {
          value = defaultValue;
        }
        if (instance.ce) {
          instance.ce._setProp(key, value);
        }
      }
      if (opt[
        0
        /* shouldCast */
      ]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[
          1
          /* shouldCastTrue */
        ] && (value === "" || value === hyphenate$1(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  const mixinPropsCache = /* @__PURE__ */ new WeakMap();
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = asMixin ? mixinPropsCache : appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction$1(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys] = normalizePropsOptions(raw2, appContext, true);
        extend$1(normalized, props);
        if (keys) needCastKeys.push(...keys);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$1(comp)) {
        cache.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray$1(raw)) {
      for (let i = 0; i < raw.length; i++) {
        const normalizedKey = camelize$1(raw[i]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      for (const key in raw) {
        const normalizedKey = camelize$1(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend$1({}, opt);
          const propType = prop.type;
          let shouldCast = false;
          let shouldCastTrue = true;
          if (isArray$1(propType)) {
            for (let index = 0; index < propType.length; ++index) {
              const type2 = propType[index];
              const typeName = isFunction$1(type2) && type2.name;
              if (typeName === "Boolean") {
                shouldCast = true;
                break;
              } else if (typeName === "String") {
                shouldCastTrue = false;
              }
            }
          } else {
            shouldCast = isFunction$1(propType) && propType.name === "Boolean";
          }
          prop[
            0
            /* shouldCast */
          ] = shouldCast;
          prop[
            1
            /* shouldCastTrue */
          ] = shouldCastTrue;
          if (shouldCast || hasOwn$2(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject$1(comp)) {
      cache.set(comp, res);
    }
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$" && !isReservedProp(key)) {
      return true;
    }
    return false;
  }
  const isInternalKey = (key) => key[0] === "_" || key === "$stable";
  const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  const normalizeSlot = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (false) ;
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key)) continue;
      const value = rawSlots[key];
      if (isFunction$1(value)) {
        slots[key] = normalizeSlot(key, value, ctx);
      } else if (value != null) {
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  const normalizeVNodeSlots = (instance, children) => {
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  const assignSlots = (slots, children, optimized) => {
    for (const key in children) {
      if (optimized || key !== "_") {
        slots[key] = children[key];
      }
    }
  };
  const initSlots = (instance, children, optimized) => {
    const slots = instance.slots = createInternalObject();
    if (instance.vnode.shapeFlag & 32) {
      const type2 = children._;
      if (type2) {
        assignSlots(slots, children, optimized);
        if (optimized) {
          def$1(slots, "_", type2, true);
        }
      } else {
        normalizeObjectSlots(children, slots);
      }
    } else if (children) {
      normalizeVNodeSlots(instance, children);
    }
  };
  const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type2 = children._;
      if (type2) {
        if (optimized && type2 === 1) {
          needDeletionCheck = false;
        } else {
          assignSlots(slots, children, optimized);
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
          delete slots[key];
        }
      }
    }
  };
  const queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    const target = getGlobalThis();
    target.__VUE__ = true;
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type: type2, ref: ref3, shapeFlag } = n2;
      switch (type2) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, namespace);
          }
          break;
        case Fragment:
          processFragment(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          break;
        default:
          if (shapeFlag & 1) {
            processElement(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 6) {
            processComponent(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 64) {
            type2.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (shapeFlag & 128) {
            type2.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else ;
      }
      if (ref3 != null && parentComponent) {
        setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateText(n2.children),
          container,
          anchor
        );
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateComment(n2.children || ""),
          container,
          anchor
        );
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, namespace) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace,
        n2.el,
        n2.anchor
      );
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      if (n2.type === "svg") {
        namespace = "svg";
      } else if (n2.type === "math") {
        namespace = "mathml";
      }
      if (n1 == null) {
        mountElement(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { props, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(
        vnode.type,
        namespace,
        props && props.is,
        props
      );
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(vnode, namespace),
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], namespace, parentComponent);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value, namespace);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i = 0; i < slotScopeIds.length; i++) {
          hostSetScopeId(el, slotScopeIds[i]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
          const parentVNode = parentComponent.vnode;
          setScopeId(
            el,
            parentVNode,
            parentVNode.scopeId,
            parentVNode.slotScopeIds,
            parentComponent.parent
          );
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
      for (let i = start; i < children.length; i++) {
        const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
        patch(
          null,
          child,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
        hostSetElementText(el, "");
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          el,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds
        );
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds,
          false
        );
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, oldProps, newProps, parentComponent, namespace);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, namespace);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              const key = propsToUpdate[i];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(el, key, prev, next, namespace, parentComponent);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
      for (let i = 0; i < newChildren.length; i++) {
        const oldVNode = oldChildren[i];
        const newVNode = newChildren[i];
        const container = (
          // oldVNode may be an errored async setup() component inside Suspense
          // which will not have a mounted element
          oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
          // of the Fragment itself so it can move its children.
          (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
          // which also requires the correct parent container
          !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
          oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
            // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer
          )
        );
        patch(
          oldVNode,
          newVNode,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          true
        );
      }
    };
    const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(
                el,
                key,
                oldProps[key],
                null,
                namespace,
                parentComponent
              );
            }
          }
        }
        for (const key in newProps) {
          if (isReservedProp(key)) continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(el, key, prev, next, namespace, parentComponent);
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(
          // #10007
          // such fragment like `<></>` will be compiled into
          // a fragment which doesn't have a children.
          // In this case fallback to an empty array
          n2.children || [],
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            container,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          if (
            // #2080 if the stable fragment has a key, it's a <template v-for> that may
            //  get moved around. Make sure all root level vnodes inherit el.
            // #2134 or if it's a component root, it may also get moved around
            // as the component is being moved.
            n2.key != null || parentComponent && n2 === parentComponent.subTree
          ) {
            traverseStaticChildren(
              n1,
              n2,
              true
              /* shallow */
            );
          }
        } else {
          patchChildren(
            n1,
            n2,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(
            n2,
            container,
            anchor,
            namespace,
            optimized
          );
        } else {
          mountComponent(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            optimized
          );
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
      const instance = initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      );
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        setupComponent(instance, false, optimized);
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
      } else {
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          namespace,
          optimized
        );
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          updateComponentPreRender(instance, n2, optimized);
          return;
        } else {
          instance.next = n2;
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m, parent, root, type: type2 } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns$1(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          toggleRecurse(instance, true);
          if (el && hydrateNode) {
            const hydrateSubTree = () => {
              instance.subTree = renderComponentRoot(instance);
              hydrateNode(
                el,
                instance.subTree,
                instance,
                parentSuspense,
                null
              );
            };
            if (isAsyncWrapperVNode) {
              type2.__asyncHydrate(
                el,
                instance,
                hydrateSubTree
              );
            } else {
              hydrateSubTree();
            }
          } else {
            if (root.ce) {
              root.ce._injectChildStyle(type2);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            patch(
              null,
              subTree,
              container,
              anchor,
              instance,
              parentSuspense,
              namespace
            );
            initialVNode.el = subTree.el;
          }
          if (m) {
            queuePostRenderEffect(m, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
              parentSuspense
            );
          }
          if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u, parent, vnode } = instance;
          {
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(() => {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          let originNext = next;
          let vnodeHook;
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns$1(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          toggleRecurse(instance, true);
          const nextTree = renderComponentRoot(instance);
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          patch(
            prevTree,
            nextTree,
            // parent may have changed if it's in a teleport
            hostParentNode(prevTree.el),
            // anchor may have changed if it's in a fragment
            getNextHostNode(prevTree),
            instance,
            parentSuspense,
            namespace
          );
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, next, vnode),
              parentSuspense
            );
          }
        }
      };
      instance.scope.on();
      const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
      instance.scope.off();
      const update = instance.update = effect2.run.bind(effect2);
      const job = instance.job = effect2.runIfDirty.bind(effect2);
      job.i = instance;
      job.id = instance.uid;
      effect2.scheduler = () => queueJob(job);
      toggleRecurse(instance, true);
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i;
      for (i = 0; i < commonLength; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        patch(
          c1[i],
          nextChild,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
      if (oldLength > newLength) {
        unmountChildren(
          c1,
          parentComponent,
          parentSuspense,
          true,
          false,
          commonLength
        );
      } else {
        mountChildren(
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized,
          commonLength
        );
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let i = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i <= e1 && i <= e2) {
        const n1 = c1[i];
        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        i++;
      }
      while (i <= e1 && i <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i > e1) {
        if (i <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i <= e2) {
            patch(
              null,
              c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            i++;
          }
        }
      } else if (i > e2) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } else {
        const s1 = i;
        const s2 = i;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i = s2; i <= e2; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (nextChild.key != null) {
            keyToNewIndexMap.set(nextChild.key, i);
          }
        }
        let j;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
        for (i = s1; i <= e1; i++) {
          const prevChild = c1[i];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j = s2; j <= e2; j++) {
              if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                newIndex = j;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(
              prevChild,
              c2[newIndex],
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j = increasingNewIndexSequence.length - 1;
        for (i = toBePatched - 1; i >= 0; i--) {
          const nextIndex = s2 + i;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i] === 0) {
            patch(
              null,
              nextChild,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (moved) {
            if (j < 0 || i !== increasingNewIndexSequence[j]) {
              move(nextChild, container, anchor, 2);
            } else {
              j--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type: type2, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type2.move(vnode, container, anchor, internals);
        return;
      }
      if (type2 === Fragment) {
        hostInsert(el, container, anchor);
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type2 === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type: type2,
        props,
        ref: ref3,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs,
        cacheIndex
      } = vnode;
      if (patchFlag === -2) {
        optimized = false;
      }
      if (ref3 != null) {
        setRef(ref3, null, parentSuspense, vnode, true);
      }
      if (cacheIndex != null) {
        parentComponent.renderCache[cacheIndex] = void 0;
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(
            vnode,
            parentComponent,
            parentSuspense,
            internals,
            doRemove
          );
        } else if (dynamicChildren && // #5154
        // when v-once is used inside a block, setBlockTracking(-1) marks the
        // parent block with hasOnce: true
        // so that it doesn't take the fast path during unmount - otherwise
        // components nested in v-once are never unmounted.
        !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
        (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(
            dynamicChildren,
            parentComponent,
            parentSuspense,
            false,
            true
          );
        } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type: type2, el, anchor, transition } = vnode;
      if (type2 === Fragment) {
        {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type2 === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      const { bum, scope, job, subTree, um, m, a } = instance;
      invalidateMount(m);
      invalidateMount(a);
      if (bum) {
        invokeArrayFns$1(bum);
      }
      scope.stop();
      if (job) {
        job.flags |= 8;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i = start; i < children.length; i++) {
        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      const el = hostNextSibling(vnode.anchor || vnode.el);
      const teleportEnd = el && el[TeleportEndKey];
      return teleportEnd ? hostNextSibling(teleportEnd) : el;
    };
    let isFlushing2 = false;
    const render2 = (vnode, container, namespace) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(
          container._vnode || null,
          vnode,
          container,
          null,
          null,
          null,
          namespace
        );
      }
      container._vnode = vnode;
      if (!isFlushing2) {
        isFlushing2 = true;
        flushPreFlushCbs();
        flushPostFlushCbs();
        isFlushing2 = false;
      }
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate;
    let hydrateNode;
    return {
      render: render2,
      hydrate,
      createApp: createAppAPI(render2, hydrate)
    };
  }
  function resolveChildrenNamespace({ type: type2, props }, currentNamespace) {
    return currentNamespace === "svg" && type2 === "foreignObject" || currentNamespace === "mathml" && type2 === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse({ effect: effect2, job }, allowed) {
    if (allowed) {
      effect2.flags |= 32;
      job.flags |= 4;
    } else {
      effect2.flags &= ~32;
      job.flags &= ~4;
    }
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray$1(ch1) && isArray$1(ch2)) {
      for (let i = 0; i < ch1.length; i++) {
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }
          if (!shallow && c2.patchFlag !== -2)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
      const arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p2[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = u + v >> 1;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p2[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p2[v];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }
  function invalidateMount(hooks) {
    if (hooks) {
      for (let i = 0; i < hooks.length; i++)
        hooks[i].flags |= 8;
    }
  }
  const ssrContextKey = Symbol.for("v-scx");
  const useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey);
      return ctx;
    }
  };
  function watch(source, cb, options) {
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb, options = EMPTY_OBJ) {
    const { immediate, deep, flush, once } = options;
    const baseWatchOptions = extend$1({}, options);
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else if (!cb || immediate) {
        baseWatchOptions.once = true;
      } else {
        return {
          stop: NOOP,
          resume: NOOP,
          pause: NOOP
        };
      }
    }
    const instance = currentInstance;
    baseWatchOptions.call = (fn, type2, args) => callWithAsyncErrorHandling(fn, instance, type2, args);
    let isPre = false;
    if (flush === "post") {
      baseWatchOptions.scheduler = (job) => {
        queuePostRenderEffect(job, instance && instance.suspense);
      };
    } else if (flush !== "sync") {
      isPre = true;
      baseWatchOptions.scheduler = (job, isFirstRun) => {
        if (isFirstRun) {
          job();
        } else {
          queueJob(job);
        }
      };
    }
    baseWatchOptions.augmentJob = (job) => {
      if (cb) {
        job.flags |= 4;
      }
      if (isPre) {
        job.flags |= 2;
        if (instance) {
          job.id = instance.uid;
          job.i = instance;
        }
      }
    };
    const watchHandle = watch$1(source, cb, baseWatchOptions);
    if (ssrCleanup) ssrCleanup.push(watchHandle);
    return watchHandle;
  }
  function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction$1(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const reset = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    reset();
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i = 0; i < segments.length && cur; i++) {
        cur = cur[segments[i]];
      }
      return cur;
    };
  }
  const getModelModifiers = (props, modelName) => {
    return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize$1(modelName)}Modifiers`] || props[`${hyphenate$1(modelName)}Modifiers`];
  };
  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props = instance.vnode.props || EMPTY_OBJ;
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
    if (modifiers) {
      if (modifiers.trim) {
        args = rawArgs.map((a) => isString$1(a) ? a.trim() : a);
      }
      if (modifiers.number) {
        args = rawArgs.map(looseToNumber$1);
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
    props[handlerName = toHandlerKey(camelize$1(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate$1(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(
        handler,
        instance,
        6,
        args
      );
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(
        onceHandler,
        instance,
        6,
        args
      );
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction$1(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend$1(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$1(comp)) {
        cache.set(comp, null);
      }
      return null;
    }
    if (isArray$1(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend$1(normalized, raw);
    }
    if (isObject$1(comp)) {
      cache.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn$1(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn$2(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$2(options, hyphenate$1(key)) || hasOwn$2(options, key);
  }
  function markAttrsAccessed() {
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit: emit2,
      render: render2,
      renderCache,
      props,
      data,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    const prev = setCurrentRenderingInstance(instance);
    let result;
    let fallthroughAttrs;
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        const thisProxy = false ? new Proxy(proxyToUse, {
          get(target, key, receiver) {
            warn$1(
              `Property '${String(
                key
              )}' was accessed via 'this'. Avoid using 'this' in templates.`
            );
            return Reflect.get(target, key, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(
          render2.call(
            thisProxy,
            proxyToUse,
            renderCache,
            false ? shallowReadonly(props) : props,
            setupState,
            data,
            ctx
          )
        );
        fallthroughAttrs = attrs;
      } else {
        const render22 = Component;
        if (false) ;
        result = normalizeVNode(
          render22.length > 1 ? render22(
            false ? shallowReadonly(props) : props,
            false ? {
              get attrs() {
                markAttrsAccessed();
                return shallowReadonly(attrs);
              },
              slots,
              emit: emit2
            } : { attrs, slots, emit: emit2 }
          ) : render22(
            false ? shallowReadonly(props) : props,
            null
          )
        );
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root = result;
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root;
      if (keys.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys.some(isModelListener$1)) {
            fallthroughAttrs = filterModelListeners(
              fallthroughAttrs,
              propsOptions
            );
          }
          root = cloneVNode(root, fallthroughAttrs, false, true);
        }
      }
    }
    if (vnode.dirs) {
      root = cloneVNode(root, null, false, true);
      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      root.transition = vnode.transition;
    }
    {
      result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
      if (key === "class" || key === "style" || isOn$1(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
      if (!isModelListener$1(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i = 0; i < dynamicProps.length; i++) {
          const key = dynamicProps[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
      const key = nextKeys[i];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    while (parent) {
      const root = parent.subTree;
      if (root.suspense && root.suspense.activeBranch === vnode) {
        root.el = vnode.el;
      }
      if (root === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
      } else {
        break;
      }
    }
  }
  const isSuspense = (type2) => type2.__isSuspense;
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray$1(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  const Fragment = Symbol.for("v-fgt");
  const Text = Symbol.for("v-txt");
  const Comment = Symbol.for("v-cmt");
  const Static = Symbol.for("v-stc");
  const blockStack = [];
  let currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  let isBlockTreeEnabled = 1;
  function setBlockTracking(value) {
    isBlockTreeEnabled += value;
    if (value < 0 && currentBlock) {
      currentBlock.hasOnce = true;
    }
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type2, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
      createBaseVNode(
        type2,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        true
      )
    );
  }
  function createBlock(type2, props, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type2,
        props,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    return n1.type === n2.type && n1.key === n2.key;
  }
  const normalizeKey = ({ key }) => key != null ? key : null;
  const normalizeRef = ({
    ref: ref3,
    ref_key,
    ref_for
  }) => {
    if (typeof ref3 === "number") {
      ref3 = "" + ref3;
    }
    return ref3 != null ? isString$1(ref3) || isRef$1(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
  };
  function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type: type2,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type2.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString$1(children) ? 8 : 16;
    }
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  const createVNode = _createVNode;
  function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
      type2 = Comment;
    }
    if (isVNode(type2)) {
      const cloned = cloneVNode(
        type2,
        props,
        true
        /* mergeRef: true */
      );
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type2)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag = -2;
      return cloned;
    }
    if (isClassComponent(type2)) {
      type2 = type2.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString$1(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject$1(style)) {
        if (isProxy(style) && !isArray$1(style)) {
          style = extend$1({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString$1(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject$1(type2) ? 4 : isFunction$1(type2) ? 2 : 0;
    return createBaseVNode(
      type2,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props) {
    if (!props) return null;
    return isProxy(props) || isInternalObject(props) ? extend$1({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
    const { props, ref: ref3, patchFlag, children, transition } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? (
        // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
      ) : ref3,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children,
      target: vnode.target,
      targetStart: vnode.targetStart,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: preserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition,
      // These should technically only be non-null on mounted VNodes. However,
      // they *should* be copied for kept-alive vnodes. So we just always copy
      // them since them being non-null during a mount doesn't affect the logic as
      // they will simply be overwritten.
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    if (transition && cloneTransition) {
      setTransitionHooks(
        cloned,
        transition.clone(cloned)
      );
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray$1(child)) {
      return createVNode(
        Fragment,
        null,
        // #3666, avoid reference pollution when reusing vnode
        child.slice()
      );
    } else if (typeof child === "object") {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type2 = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray$1(children)) {
      type2 = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type2 = 32;
        const slotFlag = children._;
        if (!slotFlag && !isInternalObject(children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction$1(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type2 = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type2 = 16;
        children = [createTextVNode(children)];
      } else {
        type2 = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type2;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
      const toMerge = args[i];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn$1(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  const emptyAppContext = createAppContext();
  let uid = 0;
  function createComponentInstance(vnode, parent, suspense) {
    const type2 = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type: type2,
      parent,
      appContext,
      root: null,
      // to be immediately set
      next: null,
      subTree: null,
      // will be set synchronously right after creation
      effect: null,
      update: null,
      // will be set synchronously right after creation
      job: null,
      scope: new EffectScope(
        true
        /* detached */
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      ids: parent ? parent.ids : ["", 0, 0],
      accessCache: null,
      renderCache: [],
      // local resolved assets
      components: null,
      directives: null,
      // resolved props and emits options
      propsOptions: normalizePropsOptions(type2, appContext),
      emitsOptions: normalizeEmitsOptions(type2, appContext),
      // emit
      emit: null,
      // to be set immediately
      emitted: null,
      // props default value
      propsDefaults: EMPTY_OBJ,
      // inheritAttrs
      inheritAttrs: type2.inheritAttrs,
      // state
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      // suspense related
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      // lifecycle hooks
      // not using enums here because it results in computed properties
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    {
      instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  let currentInstance = null;
  let internalSetCurrentInstance;
  let setInSSRSetupState;
  {
    const g = getGlobalThis();
    const registerGlobalSetter = (key, setter) => {
      let setters;
      if (!(setters = g[key])) setters = g[key] = [];
      setters.push(setter);
      return (v) => {
        if (setters.length > 1) setters.forEach((set2) => set2(v));
        else setters[0](v);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      `__VUE_INSTANCE_SETTERS__`,
      (v) => currentInstance = v
    );
    setInSSRSetupState = registerGlobalSetter(
      `__VUE_SSR_SETTERS__`,
      (v) => isInSSRComponentSetup = v
    );
  }
  const setCurrentInstance = (instance) => {
    const prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return () => {
      instance.scope.off();
      internalSetCurrentInstance(prev);
    };
  };
  const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false, optimized = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children, optimized);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    const { setup } = Component;
    if (setup) {
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      const reset = setCurrentInstance(instance);
      pauseTracking();
      const setupResult = callWithErrorHandling(
        setup,
        instance,
        0,
        [
          instance.props,
          setupContext
        ]
      );
      resetTracking();
      reset();
      if (isPromise$1(setupResult)) {
        if (!isAsyncWrapper(instance)) markAsyncBoundary(instance);
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction$1(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject$1(setupResult)) {
      instance.setupState = proxyRefs(setupResult);
    } else ;
    finishComponentSetup(instance, isSSR);
  }
  let compile;
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      if (!isSSR && compile && !Component.render) {
        const template = Component.template || resolveMergedOptions(instance).template;
        if (template) {
          const { isCustomElement, compilerOptions } = instance.appContext.config;
          const { delimiters, compilerOptions: componentCompilerOptions } = Component;
          const finalCompilerOptions = extend$1(
            extend$1(
              {
                isCustomElement,
                delimiters
              },
              compilerOptions
            ),
            componentCompilerOptions
          );
          Component.render = compile(template, finalCompilerOptions);
        }
      }
      instance.render = Component.render || NOOP;
    }
    {
      const reset = setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        reset();
      }
    }
  }
  const attrsProxyHandlers = {
    get(target, key) {
      track(target, "get", "");
      return target[key];
    }
  };
  function createSetupContext(instance) {
    const expose = (exposed) => {
      instance.exposed = exposed || {};
    };
    {
      return {
        attrs: new Proxy(instance.attrs, attrsProxyHandlers),
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getComponentPublicInstance(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has(target, key) {
          return key in target || key in publicPropertiesMap;
        }
      }));
    } else {
      return instance.proxy;
    }
  }
  const classifyRE = /(?:^|[-_])(\w)/g;
  const classify = (str2) => str2.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component, includeInferred = true) {
    return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
      const match = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component) {
            return key;
          }
        }
      };
      name = inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction$1(value) && "__vccOpts" in value;
  }
  const computed = (getterOrOptions, debugOptions) => {
    const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    return c;
  };
  const version = "3.5.0-beta.3";
  /**
  * @vue/shared v3.5.0-beta.3
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function makeMap(str2, expectsLowerCase) {
    const set2 = new Set(str2.split(","));
    return (val) => set2.has(val);
  }
  const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  const isModelListener = (key) => key.startsWith("onUpdate:");
  const extend = Object.assign;
  const hasOwnProperty = Object.prototype.hasOwnProperty;
  const hasOwn$1 = (val, key) => hasOwnProperty.call(val, key);
  const isArray = Array.isArray;
  const isSet = (val) => toTypeString(val) === "[object Set]";
  const isDate = (val) => toTypeString(val) === "[object Date]";
  const isFunction = (val) => typeof val === "function";
  const isString = (val) => typeof val === "string";
  const isSymbol = (val) => typeof val === "symbol";
  const isObject = (val) => val !== null && typeof val === "object";
  const objectToString = Object.prototype.toString;
  const toTypeString = (value) => objectToString.call(value);
  const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
  const cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str2) => {
      const hit = cache[str2];
      return hit || (cache[str2] = fn(str2));
    };
  };
  const camelizeRE = /-(\w)/g;
  const camelize = cacheStringFunction(
    (str2) => {
      return str2.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    }
  );
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction(
    (str2) => str2.replace(hyphenateRE, "-$1").toLowerCase()
  );
  const capitalize = cacheStringFunction((str2) => {
    return str2.charAt(0).toUpperCase() + str2.slice(1);
  });
  const invokeArrayFns = (fns, ...arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](...arg);
    }
  };
  const looseToNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  const toNumber = (val) => {
    const n = isString(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
  };
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  function looseCompareArrays(a, b) {
    if (a.length !== b.length) return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
      equal = looseEqual(a[i], b[i]);
    }
    return equal;
  }
  function looseEqual(a, b) {
    if (a === b) return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isSymbol(a);
    bValidType = isSymbol(b);
    if (aValidType || bValidType) {
      return a === b;
    }
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
      if (!aValidType || !bValidType) {
        return false;
      }
      const aKeysCount = Object.keys(a).length;
      const bKeysCount = Object.keys(b).length;
      if (aKeysCount !== bKeysCount) {
        return false;
      }
      for (const key in a) {
        const aHasKey = a.hasOwnProperty(key);
        const bHasKey = b.hasOwnProperty(key);
        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
          return false;
        }
      }
    }
    return String(a) === String(b);
  }
  function looseIndexOf(arr, val) {
    return arr.findIndex((item) => looseEqual(item, val));
  }
  /**
  * @vue/runtime-dom v3.5.0-beta.3
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  let policy = void 0;
  const tt = typeof window !== "undefined" && window.trustedTypes;
  if (tt) {
    try {
      policy = /* @__PURE__ */ tt.createPolicy("vue", {
        createHTML: (val) => val
      });
    } catch (e) {
    }
  }
  const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
  const svgNS = "http://www.w3.org/2000/svg";
  const mathmlNS = "http://www.w3.org/1998/Math/MathML";
  const doc = typeof document !== "undefined" ? document : null;
  const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  const nodeOps = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag2, namespace, is, props) => {
      const el = namespace === "svg" ? doc.createElementNS(svgNS, tag2) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag2) : is ? doc.createElement(tag2, { is }) : doc.createElement(tag2);
      if (tag2 === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
      node.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id) {
      el.setAttribute(id, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, namespace, start, end) {
      const before = anchor ? anchor.previousSibling : parent.lastChild;
      if (start && (start === end || start.nextSibling)) {
        while (true) {
          parent.insertBefore(start.cloneNode(true), anchor);
          if (start === end || !(start = start.nextSibling)) break;
        }
      } else {
        templateContainer.innerHTML = unsafeToTrustedHTML(
          namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
        );
        const template = templateContainer.content;
        if (namespace === "svg" || namespace === "mathml") {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent.insertBefore(template, anchor);
      }
      return [
        // first
        before ? before.nextSibling : parent.firstChild,
        // last
        anchor ? anchor.previousSibling : parent.lastChild
      ];
    }
  };
  const vtcKey = Symbol("_vtc");
  function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  const vShowOriginalDisplay = Symbol("_vod");
  const vShowHidden = Symbol("_vsh");
  const CSS_VAR_TEXT = Symbol("");
  const displayRE = /(^|;)\s*display\s*:/;
  function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString(next);
    let hasControlledDisplay = false;
    if (next && !isCssString) {
      if (prev) {
        if (!isString(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        } else {
          for (const prevStyle of prev.split(";")) {
            const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
      }
      for (const key in next) {
        if (key === "display") {
          hasControlledDisplay = true;
        }
        setStyle(style, key, next[key]);
      }
    } else {
      if (isCssString) {
        if (prev !== next) {
          const cssVarText = style[CSS_VAR_TEXT];
          if (cssVarText) {
            next += ";" + cssVarText;
          }
          style.cssText = next;
          hasControlledDisplay = displayRE.test(next);
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
    }
    if (vShowOriginalDisplay in el) {
      el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
      if (el[vShowHidden]) {
        style.display = "none";
      }
    }
  }
  const importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
    if (isArray(val)) {
      val.forEach((v) => setStyle(style, name, v));
    } else {
      if (val == null) val = "";
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(
            hyphenate(prefixed),
            val.replace(importantRE, ""),
            "important"
          );
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  const prefixes = ["Webkit", "Moz", "ms"];
  const prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize$1(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize(name);
    for (let i = 0; i < prefixes.length; i++) {
      const prefixed = prefixes[i] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  const xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance, isBoolean = isSpecialBooleanAttr(key)) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      if (value == null || isBoolean && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(
          key,
          isBoolean ? "" : isSymbol(value) ? String(value) : value
        );
      }
    }
  }
  function patchDOMProp(el, key, value, parentComponent) {
    if (key === "innerHTML" || key === "textContent") {
      if (value == null) return;
      el[key] = value;
      return;
    }
    const tag2 = el.tagName;
    if (key === "value" && tag2 !== "PROGRESS" && // custom elements may use _value internally
    !tag2.includes("-")) {
      const oldValue = tag2 === "OPTION" ? el.getAttribute("value") || "" : el.value;
      const newValue = value == null ? "" : String(value);
      if (oldValue !== newValue || !("_value" in el)) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      el._value = value;
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type2 = typeof el[key];
      if (type2 === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type2 === "string") {
        value = "";
        needRemove = true;
      } else if (type2 === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key] = value;
    } catch (e) {
    }
    needRemove && el.removeAttribute(key);
  }
  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  const veiKey = Symbol("_vei");
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = nextValue;
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(
          nextValue,
          instance
        );
        addEventListener(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m;
      while (m = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m[0].length);
        options[m[0].toLowerCase()] = true;
      }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options];
  }
  let cachedNow = 0;
  const p = /* @__PURE__ */ Promise.resolve();
  const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      if (!e._vts) {
        e._vts = Date.now();
      } else if (e._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e, invoker.value),
        instance,
        5,
        [e]
      );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray(value)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map(
        (fn) => (e2) => !e2._stopped && fn && fn(e2)
      );
    } else {
      return value;
    }
  }
  const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
  key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
  const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
    const isSVG = namespace === "svg";
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(el, key, nextValue);
      if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
        patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
      }
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && isNativeOn(key) && isFunction(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (key === "width" || key === "height") {
      const tag2 = el.tagName;
      if (tag2 === "IMG" || tag2 === "VIDEO" || tag2 === "CANVAS" || tag2 === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key) && isString(value)) {
      return false;
    }
    if (key in el) {
      return true;
    }
    if (el._isVueCE && (/[A-Z]/.test(key) || !isString(value))) {
      return true;
    }
    return false;
  }
  const REMOVAL = {};
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function defineCustomElement(options, extraOptions, _createApp) {
    const Comp = /* @__PURE__ */ defineComponent(options, extraOptions);
    if (isPlainObject$1(Comp)) extend(Comp, extraOptions);
    class VueCustomElement extends VueElement {
      constructor(initialProps) {
        super(Comp, initialProps, _createApp);
      }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
  }
  const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
  };
  class VueElement extends BaseClass {
    constructor(_def, _props = {}, _createApp = createApp) {
      super();
      this._def = _def;
      this._props = _props;
      this._createApp = _createApp;
      this._isVueCE = true;
      this._instance = null;
      this._app = null;
      this._nonce = this._def.nonce;
      this._connected = false;
      this._resolved = false;
      this._numberProps = null;
      this._styleChildren = /* @__PURE__ */ new WeakSet();
      this._ob = null;
      if (this.shadowRoot && _createApp !== createApp) {
        this._root = this.shadowRoot;
      } else {
        if (_def.shadowRoot !== false) {
          this.attachShadow({ mode: "open" });
          this._root = this.shadowRoot;
        } else {
          this._root = this;
        }
      }
      if (!this._def.__asyncLoader) {
        this._resolveProps(this._def);
      }
    }
    connectedCallback() {
      if (!this.shadowRoot) {
        this._parseSlots();
      }
      this._connected = true;
      let parent = this;
      while (parent = parent && (parent.parentNode || parent.host)) {
        if (parent instanceof VueElement) {
          this._parent = parent;
          break;
        }
      }
      if (!this._instance) {
        if (this._resolved) {
          this._setParent();
          this._update();
        } else {
          if (parent && parent._pendingResolve) {
            this._pendingResolve = parent._pendingResolve.then(() => {
              this._pendingResolve = void 0;
              this._resolveDef();
            });
          } else {
            this._resolveDef();
          }
        }
      }
    }
    _setParent(parent = this._parent) {
      if (parent) {
        this._instance.parent = parent._instance;
        this._instance.provides = parent._instance.provides;
      }
    }
    disconnectedCallback() {
      this._connected = false;
      nextTick(() => {
        if (!this._connected) {
          if (this._ob) {
            this._ob.disconnect();
            this._ob = null;
          }
          this._app && this._app.unmount();
          this._instance.ce = void 0;
          this._app = this._instance = null;
        }
      });
    }
    /**
     * resolve inner component definition (handle possible async component)
     */
    _resolveDef() {
      if (this._pendingResolve) {
        return;
      }
      for (let i = 0; i < this.attributes.length; i++) {
        this._setAttr(this.attributes[i].name);
      }
      this._ob = new MutationObserver((mutations) => {
        for (const m of mutations) {
          this._setAttr(m.attributeName);
        }
      });
      this._ob.observe(this, { attributes: true });
      const resolve = (def2, isAsync = false) => {
        this._resolved = true;
        this._pendingResolve = void 0;
        const { props, styles } = def2;
        let numberProps;
        if (props && !isArray(props)) {
          for (const key in props) {
            const opt = props[key];
            if (opt === Number || opt && opt.type === Number) {
              if (key in this._props) {
                this._props[key] = toNumber(this._props[key]);
              }
              (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key)] = true;
            }
          }
        }
        this._numberProps = numberProps;
        if (isAsync) {
          this._resolveProps(def2);
        }
        if (this.shadowRoot) {
          this._applyStyles(styles);
        }
        this._mount(def2);
      };
      const asyncDef = this._def.__asyncLoader;
      if (asyncDef) {
        this._pendingResolve = asyncDef().then(
          (def2) => resolve(this._def = def2, true)
        );
      } else {
        resolve(this._def);
      }
    }
    _mount(def2) {
      this._app = this._createApp(def2);
      if (def2.configureApp) {
        def2.configureApp(this._app);
      }
      this._app._ceVNode = this._createVNode();
      this._app.mount(this._root);
      const exposed = this._instance && this._instance.exposed;
      if (!exposed) return;
      for (const key in exposed) {
        if (!hasOwn$1(this, key)) {
          Object.defineProperty(this, key, {
            // unwrap ref to be consistent with public instance behavior
            get: () => unref(exposed[key])
          });
        }
      }
    }
    _resolveProps(def2) {
      const { props } = def2;
      const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});
      for (const key of Object.keys(this)) {
        if (key[0] !== "_" && declaredPropKeys.includes(key)) {
          this._setProp(key, this[key]);
        }
      }
      for (const key of declaredPropKeys.map(camelize)) {
        Object.defineProperty(this, key, {
          get() {
            return this._getProp(key);
          },
          set(val) {
            this._setProp(key, val, true, true);
          }
        });
      }
    }
    _setAttr(key) {
      if (key.startsWith("data-v-")) return;
      const has2 = this.hasAttribute(key);
      let value = has2 ? this.getAttribute(key) : REMOVAL;
      const camelKey = camelize(key);
      if (has2 && this._numberProps && this._numberProps[camelKey]) {
        value = toNumber(value);
      }
      this._setProp(camelKey, value, false, true);
    }
    /**
     * @internal
     */
    _getProp(key) {
      return this._props[key];
    }
    /**
     * @internal
     */
    _setProp(key, val, shouldReflect = true, shouldUpdate = false) {
      if (val !== this._props[key]) {
        if (val === REMOVAL) {
          delete this._props[key];
        } else {
          this._props[key] = val;
        }
        if (shouldUpdate && this._instance) {
          this._update();
        }
        if (shouldReflect) {
          if (val === true) {
            this.setAttribute(hyphenate(key), "");
          } else if (typeof val === "string" || typeof val === "number") {
            this.setAttribute(hyphenate(key), val + "");
          } else if (!val) {
            this.removeAttribute(hyphenate(key));
          }
        }
      }
    }
    _update() {
      render(this._createVNode(), this._root);
    }
    _createVNode() {
      const baseProps = {};
      if (!this.shadowRoot) {
        baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);
      }
      const vnode = createVNode(this._def, extend(baseProps, this._props));
      if (!this._instance) {
        vnode.ce = (instance) => {
          this._instance = instance;
          instance.ce = this;
          instance.isCE = true;
          const dispatch = (event, args) => {
            this.dispatchEvent(
              new CustomEvent(
                event,
                isPlainObject$1(args[0]) ? extend({ detail: args }, args[0]) : { detail: args }
              )
            );
          };
          instance.emit = (event, ...args) => {
            dispatch(event, args);
            if (hyphenate(event) !== event) {
              dispatch(hyphenate(event), args);
            }
          };
          this._setParent();
        };
      }
      return vnode;
    }
    _applyStyles(styles, owner) {
      if (!styles) return;
      if (owner) {
        if (owner === this._def || this._styleChildren.has(owner)) {
          return;
        }
        this._styleChildren.add(owner);
      }
      const nonce = this._nonce;
      for (let i = styles.length - 1; i >= 0; i--) {
        const s = document.createElement("style");
        if (nonce) s.setAttribute("nonce", nonce);
        s.textContent = styles[i];
        this.shadowRoot.prepend(s);
      }
    }
    /**
     * Only called when shaddowRoot is false
     */
    _parseSlots() {
      const slots = this._slots = {};
      let n;
      while (n = this.firstChild) {
        const slotName = n.nodeType === 1 && n.getAttribute("slot") || "default";
        (slots[slotName] || (slots[slotName] = [])).push(n);
        this.removeChild(n);
      }
    }
    /**
     * Only called when shaddowRoot is false
     */
    _renderSlots() {
      const outlets = this.querySelectorAll("slot");
      const scopeId = this._instance.type.__scopeId;
      for (let i = 0; i < outlets.length; i++) {
        const o = outlets[i];
        const slotName = o.getAttribute("name") || "default";
        const content = this._slots[slotName];
        const parent = o.parentNode;
        if (content) {
          for (const n of content) {
            if (scopeId && n.nodeType === 1) {
              const id = scopeId + "-s";
              const walker = document.createTreeWalker(n, 1);
              n.setAttribute(id, "");
              let child;
              while (child = walker.nextNode()) {
                child.setAttribute(id, "");
              }
            }
            parent.insertBefore(n, o);
          }
        } else {
          while (o.firstChild) parent.insertBefore(o.firstChild, o);
        }
        parent.removeChild(o);
      }
    }
    /**
     * @internal
     */
    _injectChildStyle(comp) {
      this._applyStyles(comp.styles, comp);
    }
    /**
     * @internal
     */
    _removeChildStyle(comp) {
    }
  }
  const getModelAssigner = (vnode) => {
    const fn = vnode.props["onUpdate:modelValue"] || false;
    return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
  };
  function onCompositionStart(e) {
    e.target.composing = true;
  }
  function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
      target.composing = false;
      target.dispatchEvent(new Event("input"));
    }
  }
  const assignKey = Symbol("_assign");
  const vModelText = {
    created(el, { modifiers: { lazy, trim, number } }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      const castToNumber = number || vnode.props && vnode.props.type === "number";
      addEventListener(el, lazy ? "change" : "input", (e) => {
        if (e.target.composing) return;
        let domValue = el.value;
        if (trim) {
          domValue = domValue.trim();
        }
        if (castToNumber) {
          domValue = looseToNumber(domValue);
        }
        el[assignKey](domValue);
      });
      if (trim) {
        addEventListener(el, "change", () => {
          el.value = el.value.trim();
        });
      }
      if (!lazy) {
        addEventListener(el, "compositionstart", onCompositionStart);
        addEventListener(el, "compositionend", onCompositionEnd);
        addEventListener(el, "change", onCompositionEnd);
      }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted(el, { value }) {
      el.value = value == null ? "" : value;
    },
    beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      if (el.composing) return;
      const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
      const newValue = value == null ? "" : value;
      if (elValue === newValue) {
        return;
      }
      if (document.activeElement === el && el.type !== "range") {
        if (lazy && value === oldValue) {
          return;
        }
        if (trim && el.value.trim() === newValue) {
          return;
        }
      }
      el.value = newValue;
    }
  };
  const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created(el, { value, modifiers: { number } }, vnode) {
      const isSetModel = isSet(value);
      addEventListener(el, "change", () => {
        const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
          (o) => number ? looseToNumber(getValue(o)) : getValue(o)
        );
        el[assignKey](
          el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
        );
        el._assigning = true;
        nextTick(() => {
          el._assigning = false;
        });
      });
      el[assignKey] = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted(el, { value, modifiers: { number } }) {
      setSelected(el, value);
    },
    beforeUpdate(el, _binding, vnode) {
      el[assignKey] = getModelAssigner(vnode);
    },
    updated(el, { value, modifiers: { number } }) {
      if (!el._assigning) {
        setSelected(el, value);
      }
    }
  };
  function setSelected(el, value, number) {
    const isMultiple = el.multiple;
    const isArrayValue = isArray(value);
    if (isMultiple && !isArrayValue && !isSet(value)) {
      return;
    }
    for (let i = 0, l = el.options.length; i < l; i++) {
      const option = el.options[i];
      const optionValue = getValue(option);
      if (isMultiple) {
        if (isArrayValue) {
          const optionType = typeof optionValue;
          if (optionType === "string" || optionType === "number") {
            option.selected = value.some((v) => String(v) === String(optionValue));
          } else {
            option.selected = looseIndexOf(value, optionValue) > -1;
          }
        } else {
          option.selected = value.has(optionValue);
        }
      } else if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) el.selectedIndex = i;
        return;
      }
    }
    if (!isMultiple && el.selectedIndex !== -1) {
      el.selectedIndex = -1;
    }
  }
  function getValue(el) {
    return "_value" in el ? el._value : el.value;
  }
  const keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
  };
  const withKeys = (fn, modifiers) => {
    const cache = fn._withKeys || (fn._withKeys = {});
    const cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = (event) => {
      if (!("key" in event)) {
        return;
      }
      const eventKey = hyphenate(event.key);
      if (modifiers.some(
        (k) => k === eventKey || keyNames[k] === eventKey
      )) {
        return fn(event);
      }
    });
  };
  const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
  let renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  const render = (...args) => {
    ensureRenderer().render(...args);
  };
  const createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container) return;
      const component = app._component;
      if (!isFunction(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      if (container.nodeType === 1) {
        container.textContent = "";
      }
      const proxy = mount(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  };
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function normalizeContainer(container) {
    if (isString(container)) {
      const res = document.querySelector(container);
      return res;
    }
    return container;
  }
  const VERSION = "4.56.0";
  let auto = false;
  let kind = void 0;
  let fetch$1 = void 0;
  let FormData$1 = void 0;
  let File$1 = void 0;
  let ReadableStream$1 = void 0;
  let getMultipartRequestOptions = void 0;
  let getDefaultAgent = void 0;
  let fileFromPath = void 0;
  let isFsReadStream = void 0;
  function setShims(shims, options = { auto: false }) {
    if (auto) {
      throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
    }
    if (kind) {
      throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``);
    }
    auto = options.auto;
    kind = shims.kind;
    fetch$1 = shims.fetch;
    FormData$1 = shims.FormData;
    File$1 = shims.File;
    ReadableStream$1 = shims.ReadableStream;
    getMultipartRequestOptions = shims.getMultipartRequestOptions;
    getDefaultAgent = shims.getDefaultAgent;
    fileFromPath = shims.fileFromPath;
    isFsReadStream = shims.isFsReadStream;
  }
  class MultipartBody {
    constructor(body) {
      this.body = body;
    }
    get [Symbol.toStringTag]() {
      return "MultipartBody";
    }
  }
  function getRuntime({ manuallyImported } = {}) {
    const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import  from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
    let _fetch, _Request, _Response, _Headers;
    try {
      _fetch = fetch;
      _Request = Request;
      _Response = Response;
      _Headers = Headers;
    } catch (error) {
      throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
    }
    return {
      kind: "web",
      fetch: _fetch,
      Request: _Request,
      Response: _Response,
      Headers: _Headers,
      FormData: (
        // @ts-ignore
        typeof FormData !== "undefined" ? FormData : class FormData {
          // @ts-ignore
          constructor() {
            throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
          }
        }
      ),
      Blob: typeof Blob !== "undefined" ? Blob : class Blob {
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
        }
      },
      File: (
        // @ts-ignore
        typeof File !== "undefined" ? File : class File {
          // @ts-ignore
          constructor() {
            throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
          }
        }
      ),
      ReadableStream: (
        // @ts-ignore
        typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
          // @ts-ignore
          constructor() {
            throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
          }
        }
      ),
      getMultipartRequestOptions: async (form, opts) => ({
        ...opts,
        body: new MultipartBody(form)
      }),
      getDefaultAgent: (url) => void 0,
      fileFromPath: () => {
        throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
      },
      isFsReadStream: (value) => false
    };
  }
  if (!kind) setShims(getRuntime(), { auto: true });
  class Stream {
    constructor(iterator2, controller) {
      this.iterator = iterator2;
      this.controller = controller;
    }
    static fromSSEResponse(response, controller) {
      let consumed = false;
      async function* iterator2() {
        if (consumed) {
          throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        }
        consumed = true;
        let done = false;
        try {
          for await (const sse of _iterSSEMessages(response, controller)) {
            if (done)
              continue;
            if (sse.data.startsWith("[DONE]")) {
              done = true;
              continue;
            }
            if (sse.event === null) {
              let data;
              try {
                data = JSON.parse(sse.data);
              } catch (e) {
                console.error(`Could not parse message into JSON:`, sse.data);
                console.error(`From chunk:`, sse.raw);
                throw e;
              }
              if (data && data.error) {
                throw new APIError(void 0, data.error, void 0, void 0);
              }
              yield data;
            } else {
              let data;
              try {
                data = JSON.parse(sse.data);
              } catch (e) {
                console.error(`Could not parse message into JSON:`, sse.data);
                console.error(`From chunk:`, sse.raw);
                throw e;
              }
              if (sse.event == "error") {
                throw new APIError(void 0, data.error, data.message, void 0);
              }
              yield { event: sse.event, data };
            }
          }
          done = true;
        } catch (e) {
          if (e instanceof Error && e.name === "AbortError")
            return;
          throw e;
        } finally {
          if (!done)
            controller.abort();
        }
      }
      return new Stream(iterator2, controller);
    }
    /**
     * Generates a Stream from a newline-separated ReadableStream
     * where each item is a JSON value.
     */
    static fromReadableStream(readableStream, controller) {
      let consumed = false;
      async function* iterLines() {
        const lineDecoder = new LineDecoder();
        const iter = readableStreamAsyncIterable(readableStream);
        for await (const chunk of iter) {
          for (const line of lineDecoder.decode(chunk)) {
            yield line;
          }
        }
        for (const line of lineDecoder.flush()) {
          yield line;
        }
      }
      async function* iterator2() {
        if (consumed) {
          throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        }
        consumed = true;
        let done = false;
        try {
          for await (const line of iterLines()) {
            if (done)
              continue;
            if (line)
              yield JSON.parse(line);
          }
          done = true;
        } catch (e) {
          if (e instanceof Error && e.name === "AbortError")
            return;
          throw e;
        } finally {
          if (!done)
            controller.abort();
        }
      }
      return new Stream(iterator2, controller);
    }
    [Symbol.asyncIterator]() {
      return this.iterator();
    }
    /**
     * Splits the stream into two streams which can be
     * independently read from at different speeds.
     */
    tee() {
      const left = [];
      const right = [];
      const iterator2 = this.iterator();
      const teeIterator = (queue2) => {
        return {
          next: () => {
            if (queue2.length === 0) {
              const result = iterator2.next();
              left.push(result);
              right.push(result);
            }
            return queue2.shift();
          }
        };
      };
      return [
        new Stream(() => teeIterator(left), this.controller),
        new Stream(() => teeIterator(right), this.controller)
      ];
    }
    /**
     * Converts this stream to a newline-separated ReadableStream of
     * JSON stringified values in the stream
     * which can be turned back into a Stream with `Stream.fromReadableStream()`.
     */
    toReadableStream() {
      const self2 = this;
      let iter;
      const encoder = new TextEncoder();
      return new ReadableStream$1({
        async start() {
          iter = self2[Symbol.asyncIterator]();
        },
        async pull(ctrl) {
          try {
            const { value, done } = await iter.next();
            if (done)
              return ctrl.close();
            const bytes = encoder.encode(JSON.stringify(value) + "\n");
            ctrl.enqueue(bytes);
          } catch (err) {
            ctrl.error(err);
          }
        },
        async cancel() {
          var _a2;
          await ((_a2 = iter.return) == null ? void 0 : _a2.call(iter));
        }
      });
    }
  }
  async function* _iterSSEMessages(response, controller) {
    if (!response.body) {
      controller.abort();
      throw new OpenAIError(`Attempted to iterate over a response with no body`);
    }
    const sseDecoder = new SSEDecoder();
    const lineDecoder = new LineDecoder();
    const iter = readableStreamAsyncIterable(response.body);
    for await (const sseChunk of iterSSEChunks(iter)) {
      for (const line of lineDecoder.decode(sseChunk)) {
        const sse = sseDecoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    for (const line of lineDecoder.flush()) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  async function* iterSSEChunks(iterator2) {
    let data = new Uint8Array();
    for await (const chunk of iterator2) {
      if (chunk == null) {
        continue;
      }
      const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
      let newData = new Uint8Array(data.length + binaryChunk.length);
      newData.set(data);
      newData.set(binaryChunk, data.length);
      data = newData;
      let patternIndex;
      while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
        yield data.slice(0, patternIndex);
        data = data.slice(patternIndex);
      }
    }
    if (data.length > 0) {
      yield data;
    }
  }
  function findDoubleNewlineIndex(buffer) {
    const newline2 = 10;
    const carriage = 13;
    for (let i = 0; i < buffer.length - 2; i++) {
      if (buffer[i] === newline2 && buffer[i + 1] === newline2) {
        return i + 2;
      }
      if (buffer[i] === carriage && buffer[i + 1] === carriage) {
        return i + 2;
      }
      if (buffer[i] === carriage && buffer[i + 1] === newline2 && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline2) {
        return i + 4;
      }
    }
    return -1;
  }
  class SSEDecoder {
    constructor() {
      this.event = null;
      this.data = [];
      this.chunks = [];
    }
    decode(line) {
      if (line.endsWith("\r")) {
        line = line.substring(0, line.length - 1);
      }
      if (!line) {
        if (!this.event && !this.data.length)
          return null;
        const sse = {
          event: this.event,
          data: this.data.join("\n"),
          raw: this.chunks
        };
        this.event = null;
        this.data = [];
        this.chunks = [];
        return sse;
      }
      this.chunks.push(line);
      if (line.startsWith(":")) {
        return null;
      }
      let [fieldname, _, value] = partition(line, ":");
      if (value.startsWith(" ")) {
        value = value.substring(1);
      }
      if (fieldname === "event") {
        this.event = value;
      } else if (fieldname === "data") {
        this.data.push(value);
      }
      return null;
    }
  }
  class LineDecoder {
    constructor() {
      this.buffer = [];
      this.trailingCR = false;
    }
    decode(chunk) {
      let text = this.decodeText(chunk);
      if (this.trailingCR) {
        text = "\r" + text;
        this.trailingCR = false;
      }
      if (text.endsWith("\r")) {
        this.trailingCR = true;
        text = text.slice(0, -1);
      }
      if (!text) {
        return [];
      }
      const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
      let lines = text.split(LineDecoder.NEWLINE_REGEXP);
      if (trailingNewline) {
        lines.pop();
      }
      if (lines.length === 1 && !trailingNewline) {
        this.buffer.push(lines[0]);
        return [];
      }
      if (this.buffer.length > 0) {
        lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
        this.buffer = [];
      }
      if (!trailingNewline) {
        this.buffer = [lines.pop() || ""];
      }
      return lines;
    }
    decodeText(bytes) {
      if (bytes == null)
        return "";
      if (typeof bytes === "string")
        return bytes;
      if (typeof Buffer !== "undefined") {
        if (bytes instanceof Buffer) {
          return bytes.toString();
        }
        if (bytes instanceof Uint8Array) {
          return Buffer.from(bytes).toString();
        }
        throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
      }
      if (typeof TextDecoder !== "undefined") {
        if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
          this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8"));
          return this.textDecoder.decode(bytes);
        }
        throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
      }
      throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
    }
    flush() {
      if (!this.buffer.length && !this.trailingCR) {
        return [];
      }
      const lines = [this.buffer.join("")];
      this.buffer = [];
      this.trailingCR = false;
      return lines;
    }
  }
  LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
  LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
  function partition(str2, delimiter) {
    const index = str2.indexOf(delimiter);
    if (index !== -1) {
      return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
    }
    return [str2, "", ""];
  }
  function readableStreamAsyncIterable(stream) {
    if (stream[Symbol.asyncIterator])
      return stream;
    const reader = stream.getReader();
    return {
      async next() {
        try {
          const result = await reader.read();
          if (result == null ? void 0 : result.done)
            reader.releaseLock();
          return result;
        } catch (e) {
          reader.releaseLock();
          throw e;
        }
      },
      async return() {
        const cancelPromise = reader.cancel();
        reader.releaseLock();
        await cancelPromise;
        return { done: true, value: void 0 };
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  const isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
  const isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
  const isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
  const isUploadable = (value) => {
    return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
  };
  async function toFile(value, name, options) {
    var _a2;
    value = await value;
    options ?? (options = isFileLike(value) ? { lastModified: value.lastModified, type: value.type } : {});
    if (isResponseLike(value)) {
      const blob = await value.blob();
      name || (name = new URL(value.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
      return new File$1([blob], name, options);
    }
    const bits = await getBytes(value);
    name || (name = getName(value) ?? "unknown_file");
    if (!options.type) {
      const type2 = (_a2 = bits[0]) == null ? void 0 : _a2.type;
      if (typeof type2 === "string") {
        options = { ...options, type: type2 };
      }
    }
    return new File$1(bits, name, options);
  }
  async function getBytes(value) {
    var _a2;
    let parts = [];
    if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
    value instanceof ArrayBuffer) {
      parts.push(value);
    } else if (isBlobLike(value)) {
      parts.push(await value.arrayBuffer());
    } else if (isAsyncIterableIterator(value)) {
      for await (const chunk of value) {
        parts.push(chunk);
      }
    } else {
      throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a2 = value == null ? void 0 : value.constructor) == null ? void 0 : _a2.name}; props: ${propsForError(value)}`);
    }
    return parts;
  }
  function propsForError(value) {
    const props = Object.getOwnPropertyNames(value);
    return `[${props.map((p2) => `"${p2}"`).join(", ")}]`;
  }
  function getName(value) {
    var _a2;
    return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
    ((_a2 = getStringFromMaybeBuffer(value.path)) == null ? void 0 : _a2.split(/[\\/]/).pop());
  }
  const getStringFromMaybeBuffer = (x) => {
    if (typeof x === "string")
      return x;
    if (typeof Buffer !== "undefined" && x instanceof Buffer)
      return String(x);
    return void 0;
  };
  const isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
  const isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
  const multipartFormRequestOptions = async (opts) => {
    const form = await createForm(opts.body);
    return getMultipartRequestOptions(form, opts);
  };
  const createForm = async (body) => {
    const form = new FormData$1();
    await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
    return form;
  };
  const addFormValue = async (form, key, value) => {
    if (value === void 0)
      return;
    if (value == null) {
      throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
    }
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      form.append(key, String(value));
    } else if (isUploadable(value)) {
      const file = await toFile(value);
      form.append(key, file);
    } else if (Array.isArray(value)) {
      await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
    } else if (typeof value === "object") {
      await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
    } else {
      throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
    }
  };
  var define_process_env_default = {};
  var __classPrivateFieldSet$3 = function(receiver, state, value, kind2, f) {
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return state.set(receiver, value), value;
  };
  var __classPrivateFieldGet$4 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _AbstractPage_client;
  async function defaultParseResponse(props) {
    const { response } = props;
    if (props.options.stream) {
      debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller);
      }
      return Stream.fromSSEResponse(response, props.controller);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const isJSON = (contentType == null ? void 0 : contentType.includes("application/json")) || (contentType == null ? void 0 : contentType.includes("application/vnd.api+json"));
    if (isJSON) {
      const json = await response.json();
      debug("response", response.status, response.url, response.headers, json);
      return json;
    }
    const text = await response.text();
    debug("response", response.status, response.url, response.headers, text);
    return text;
  }
  class APIPromise extends Promise {
    constructor(responsePromise, parseResponse = defaultParseResponse) {
      super((resolve) => {
        resolve(null);
      });
      this.responsePromise = responsePromise;
      this.parseResponse = parseResponse;
    }
    _thenUnwrap(transform) {
      return new APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props)));
    }
    /**
     * Gets the raw `Response` instance instead of parsing the response
     * data.
     *
     * If you want to parse the response body but still get the `Response`
     * instance, you can use {@link withResponse()}.
     *
     *  Getting the wrong TypeScript type for `Response`?
     * Try setting `"moduleResolution": "NodeNext"` if you can,
     * or add one of these imports before your first `import  from 'openai'`:
     * - `import 'openai/shims/node'` (if you're running on Node)
     * - `import 'openai/shims/web'` (otherwise)
     */
    asResponse() {
      return this.responsePromise.then((p2) => p2.response);
    }
    /**
     * Gets the parsed response data and the raw `Response` instance.
     *
     * If you just want to get the raw `Response` instance without parsing it,
     * you can use {@link asResponse()}.
     *
     *
     *  Getting the wrong TypeScript type for `Response`?
     * Try setting `"moduleResolution": "NodeNext"` if you can,
     * or add one of these imports before your first `import  from 'openai'`:
     * - `import 'openai/shims/node'` (if you're running on Node)
     * - `import 'openai/shims/web'` (otherwise)
     */
    async withResponse() {
      const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
      return { data, response };
    }
    parse() {
      if (!this.parsedPromise) {
        this.parsedPromise = this.responsePromise.then(this.parseResponse);
      }
      return this.parsedPromise;
    }
    then(onfulfilled, onrejected) {
      return this.parse().then(onfulfilled, onrejected);
    }
    catch(onrejected) {
      return this.parse().catch(onrejected);
    }
    finally(onfinally) {
      return this.parse().finally(onfinally);
    }
  }
  class APIClient {
    constructor({
      baseURL,
      maxRetries = 2,
      timeout = 6e5,
      // 10 minutes
      httpAgent,
      fetch: overridenFetch
    }) {
      this.baseURL = baseURL;
      this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
      this.timeout = validatePositiveInteger("timeout", timeout);
      this.httpAgent = httpAgent;
      this.fetch = overridenFetch ?? fetch$1;
    }
    authHeaders(opts) {
      return {};
    }
    /**
     * Override this to add your own default headers, for example:
     *
     *  {
     *    ...super.defaultHeaders(),
     *    Authorization: 'Bearer 123',
     *  }
     */
    defaultHeaders(opts) {
      return {
        Accept: "application/json",
        "Content-Type": "application/json",
        "User-Agent": this.getUserAgent(),
        ...getPlatformHeaders(),
        ...this.authHeaders(opts)
      };
    }
    /**
     * Override this to add your own headers validation:
     */
    validateHeaders(headers, customHeaders) {
    }
    defaultIdempotencyKey() {
      return `stainless-node-retry-${uuid4()}`;
    }
    get(path, opts) {
      return this.methodRequest("get", path, opts);
    }
    post(path, opts) {
      return this.methodRequest("post", path, opts);
    }
    patch(path, opts) {
      return this.methodRequest("patch", path, opts);
    }
    put(path, opts) {
      return this.methodRequest("put", path, opts);
    }
    delete(path, opts) {
      return this.methodRequest("delete", path, opts);
    }
    methodRequest(method, path, opts) {
      return this.request(Promise.resolve(opts).then(async (opts2) => {
        const body = opts2 && isBlobLike(opts2 == null ? void 0 : opts2.body) ? new DataView(await opts2.body.arrayBuffer()) : (opts2 == null ? void 0 : opts2.body) instanceof DataView ? opts2.body : (opts2 == null ? void 0 : opts2.body) instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2 == null ? void 0 : opts2.body) ? new DataView(opts2.body.buffer) : opts2 == null ? void 0 : opts2.body;
        return { method, path, ...opts2, body };
      }));
    }
    getAPIList(path, Page2, opts) {
      return this.requestAPIList(Page2, { method: "get", path, ...opts });
    }
    calculateContentLength(body) {
      if (typeof body === "string") {
        if (typeof Buffer !== "undefined") {
          return Buffer.byteLength(body, "utf8").toString();
        }
        if (typeof TextEncoder !== "undefined") {
          const encoder = new TextEncoder();
          const encoded = encoder.encode(body);
          return encoded.length.toString();
        }
      } else if (ArrayBuffer.isView(body)) {
        return body.byteLength.toString();
      }
      return null;
    }
    buildRequest(options) {
      var _a2;
      const { method, path, query, headers = {} } = options;
      const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
      const contentLength = this.calculateContentLength(body);
      const url = this.buildURL(path, query);
      if ("timeout" in options)
        validatePositiveInteger("timeout", options.timeout);
      const timeout = options.timeout ?? this.timeout;
      const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);
      const minAgentTimeout = timeout + 1e3;
      if (typeof ((_a2 = httpAgent == null ? void 0 : httpAgent.options) == null ? void 0 : _a2.timeout) === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
        httpAgent.options.timeout = minAgentTimeout;
      }
      if (this.idempotencyHeader && method !== "get") {
        if (!options.idempotencyKey)
          options.idempotencyKey = this.defaultIdempotencyKey();
        headers[this.idempotencyHeader] = options.idempotencyKey;
      }
      const reqHeaders = this.buildHeaders({ options, headers, contentLength });
      const req = {
        method,
        ...body && { body },
        headers: reqHeaders,
        ...httpAgent && { agent: httpAgent },
        // @ts-ignore node-fetch uses a custom AbortSignal type that is
        // not compatible with standard web types
        signal: options.signal ?? null
      };
      return { req, url, timeout };
    }
    buildHeaders({ options, headers, contentLength }) {
      const reqHeaders = {};
      if (contentLength) {
        reqHeaders["content-length"] = contentLength;
      }
      const defaultHeaders = this.defaultHeaders(options);
      applyHeadersMut(reqHeaders, defaultHeaders);
      applyHeadersMut(reqHeaders, headers);
      if (isMultipartBody(options.body) && kind !== "node") {
        delete reqHeaders["content-type"];
      }
      this.validateHeaders(reqHeaders, headers);
      return reqHeaders;
    }
    /**
     * Used as a callback for mutating the given `FinalRequestOptions` object.
     */
    async prepareOptions(options) {
    }
    /**
     * Used as a callback for mutating the given `RequestInit` object.
     *
     * This is useful for cases where you want to add certain headers based off of
     * the request properties, e.g. `method` or `url`.
     */
    async prepareRequest(request, { url, options }) {
    }
    parseHeaders(headers) {
      return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
    }
    makeStatusError(status, error, message, headers) {
      return APIError.generate(status, error, message, headers);
    }
    request(options, remainingRetries = null) {
      return new APIPromise(this.makeRequest(options, remainingRetries));
    }
    async makeRequest(optionsInput, retriesRemaining) {
      var _a2, _b;
      const options = await optionsInput;
      if (retriesRemaining == null) {
        retriesRemaining = options.maxRetries ?? this.maxRetries;
      }
      await this.prepareOptions(options);
      const { req, url, timeout } = this.buildRequest(options);
      await this.prepareRequest(req, { url, options });
      debug("request", url, options, req.headers);
      if ((_a2 = options.signal) == null ? void 0 : _a2.aborted) {
        throw new APIUserAbortError();
      }
      const controller = new AbortController();
      const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
      if (response instanceof Error) {
        if ((_b = options.signal) == null ? void 0 : _b.aborted) {
          throw new APIUserAbortError();
        }
        if (retriesRemaining) {
          return this.retryRequest(options, retriesRemaining);
        }
        if (response.name === "AbortError") {
          throw new APIConnectionTimeoutError();
        }
        throw new APIConnectionError({ cause: response });
      }
      const responseHeaders = createResponseHeaders(response.headers);
      if (!response.ok) {
        if (retriesRemaining && this.shouldRetry(response)) {
          const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
          debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
          return this.retryRequest(options, retriesRemaining, responseHeaders);
        }
        const errText = await response.text().catch((e) => castToError(e).message);
        const errJSON = safeJSON(errText);
        const errMessage = errJSON ? void 0 : errText;
        const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
        debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
        const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
        throw err;
      }
      return { response, options, controller };
    }
    requestAPIList(Page2, options) {
      const request = this.makeRequest(options, null);
      return new PagePromise(this, request, Page2);
    }
    buildURL(path, query) {
      const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
      const defaultQuery = this.defaultQuery();
      if (!isEmptyObj(defaultQuery)) {
        query = { ...defaultQuery, ...query };
      }
      if (typeof query === "object" && query && !Array.isArray(query)) {
        url.search = this.stringifyQuery(query);
      }
      return url.toString();
    }
    stringifyQuery(query) {
      return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
        if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
        }
        if (value === null) {
          return `${encodeURIComponent(key)}=`;
        }
        throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
      }).join("&");
    }
    async fetchWithTimeout(url, init2, ms, controller) {
      const { signal, ...options } = init2 || {};
      if (signal)
        signal.addEventListener("abort", () => controller.abort());
      const timeout = setTimeout(() => controller.abort(), ms);
      return this.getRequestClient().fetch.call(void 0, url, { signal: controller.signal, ...options }).finally(() => {
        clearTimeout(timeout);
      });
    }
    getRequestClient() {
      return { fetch: this.fetch };
    }
    shouldRetry(response) {
      const shouldRetryHeader = response.headers.get("x-should-retry");
      if (shouldRetryHeader === "true")
        return true;
      if (shouldRetryHeader === "false")
        return false;
      if (response.status === 408)
        return true;
      if (response.status === 409)
        return true;
      if (response.status === 429)
        return true;
      if (response.status >= 500)
        return true;
      return false;
    }
    async retryRequest(options, retriesRemaining, responseHeaders) {
      let timeoutMillis;
      const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after-ms"];
      if (retryAfterMillisHeader) {
        const timeoutMs = parseFloat(retryAfterMillisHeader);
        if (!Number.isNaN(timeoutMs)) {
          timeoutMillis = timeoutMs;
        }
      }
      const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after"];
      if (retryAfterHeader && !timeoutMillis) {
        const timeoutSeconds = parseFloat(retryAfterHeader);
        if (!Number.isNaN(timeoutSeconds)) {
          timeoutMillis = timeoutSeconds * 1e3;
        } else {
          timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
        }
      }
      if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
        const maxRetries = options.maxRetries ?? this.maxRetries;
        timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
      }
      await sleep$1(timeoutMillis);
      return this.makeRequest(options, retriesRemaining - 1);
    }
    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
      const initialRetryDelay = 0.5;
      const maxRetryDelay = 8;
      const numRetries = maxRetries - retriesRemaining;
      const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
      const jitter = 1 - Math.random() * 0.25;
      return sleepSeconds * jitter * 1e3;
    }
    getUserAgent() {
      return `${this.constructor.name}/JS ${VERSION}`;
    }
  }
  class AbstractPage {
    constructor(client, response, body, options) {
      _AbstractPage_client.set(this, void 0);
      __classPrivateFieldSet$3(this, _AbstractPage_client, client);
      this.options = options;
      this.response = response;
      this.body = body;
    }
    hasNextPage() {
      const items = this.getPaginatedItems();
      if (!items.length)
        return false;
      return this.nextPageInfo() != null;
    }
    async getNextPage() {
      const nextInfo = this.nextPageInfo();
      if (!nextInfo) {
        throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
      }
      const nextOptions = { ...this.options };
      if ("params" in nextInfo && typeof nextOptions.query === "object") {
        nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
      } else if ("url" in nextInfo) {
        const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
        for (const [key, value] of params) {
          nextInfo.url.searchParams.set(key, value);
        }
        nextOptions.query = void 0;
        nextOptions.path = nextInfo.url.toString();
      }
      return await __classPrivateFieldGet$4(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
    }
    async *iterPages() {
      let page = this;
      yield page;
      while (page.hasNextPage()) {
        page = await page.getNextPage();
        yield page;
      }
    }
    async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
      for await (const page of this.iterPages()) {
        for (const item of page.getPaginatedItems()) {
          yield item;
        }
      }
    }
  }
  class PagePromise extends APIPromise {
    constructor(client, request, Page2) {
      super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
    }
    /**
     * Allow auto-paginating iteration on an unawaited list call, eg:
     *
     *    for await (const item of client.items.list()) {
     *      console.log(item)
     *    }
     */
    async *[Symbol.asyncIterator]() {
      const page = await this;
      for await (const item of page) {
        yield item;
      }
    }
  }
  const createResponseHeaders = (headers) => {
    return new Proxy(Object.fromEntries(
      // @ts-ignore
      headers.entries()
    ), {
      get(target, name) {
        const key = name.toString();
        return target[key.toLowerCase()] || target[key];
      }
    });
  };
  const requestOptionsKeys = {
    method: true,
    path: true,
    query: true,
    body: true,
    headers: true,
    maxRetries: true,
    stream: true,
    timeout: true,
    httpAgent: true,
    signal: true,
    idempotencyKey: true,
    __binaryRequest: true,
    __binaryResponse: true,
    __streamClass: true
  };
  const isRequestOptions = (obj) => {
    return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
  };
  const getPlatformProperties = () => {
    var _a2;
    if (typeof Deno !== "undefined" && Deno.build != null) {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": normalizePlatform(Deno.build.os),
        "X-Stainless-Arch": normalizeArch(Deno.build.arch),
        "X-Stainless-Runtime": "deno",
        "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : ((_a2 = Deno.version) == null ? void 0 : _a2.deno) ?? "unknown"
      };
    }
    if (typeof EdgeRuntime !== "undefined") {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": `other:${EdgeRuntime}`,
        "X-Stainless-Runtime": "edge",
        "X-Stainless-Runtime-Version": process.version
      };
    }
    if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": normalizePlatform(process.platform),
        "X-Stainless-Arch": normalizeArch(process.arch),
        "X-Stainless-Runtime": "node",
        "X-Stainless-Runtime-Version": process.version
      };
    }
    const browserInfo = getBrowserInfo();
    if (browserInfo) {
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": "unknown",
        "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
        "X-Stainless-Runtime-Version": browserInfo.version
      };
    }
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": "unknown",
      "X-Stainless-Runtime-Version": "unknown"
    };
  };
  function getBrowserInfo() {
    if (typeof navigator === "undefined" || !navigator) {
      return null;
    }
    const browserPatterns = [
      { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
      { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
    ];
    for (const { key, pattern } of browserPatterns) {
      const match = pattern.exec(navigator.userAgent);
      if (match) {
        const major = match[1] || 0;
        const minor = match[2] || 0;
        const patch = match[3] || 0;
        return { browser: key, version: `${major}.${minor}.${patch}` };
      }
    }
    return null;
  }
  const normalizeArch = (arch) => {
    if (arch === "x32")
      return "x32";
    if (arch === "x86_64" || arch === "x64")
      return "x64";
    if (arch === "arm")
      return "arm";
    if (arch === "aarch64" || arch === "arm64")
      return "arm64";
    if (arch)
      return `other:${arch}`;
    return "unknown";
  };
  const normalizePlatform = (platform) => {
    platform = platform.toLowerCase();
    if (platform.includes("ios"))
      return "iOS";
    if (platform === "android")
      return "Android";
    if (platform === "darwin")
      return "MacOS";
    if (platform === "win32")
      return "Windows";
    if (platform === "freebsd")
      return "FreeBSD";
    if (platform === "openbsd")
      return "OpenBSD";
    if (platform === "linux")
      return "Linux";
    if (platform)
      return `Other:${platform}`;
    return "Unknown";
  };
  let _platformHeaders;
  const getPlatformHeaders = () => {
    return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
  };
  const safeJSON = (text) => {
    try {
      return JSON.parse(text);
    } catch (err) {
      return void 0;
    }
  };
  const startsWithSchemeRegexp = new RegExp("^(?:[a-z]+:)?//", "i");
  const isAbsoluteURL = (url) => {
    return startsWithSchemeRegexp.test(url);
  };
  const sleep$1 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
  const validatePositiveInteger = (name, n) => {
    if (typeof n !== "number" || !Number.isInteger(n)) {
      throw new OpenAIError(`${name} must be an integer`);
    }
    if (n < 0) {
      throw new OpenAIError(`${name} must be a positive integer`);
    }
    return n;
  };
  const castToError = (err) => {
    if (err instanceof Error)
      return err;
    return new Error(err);
  };
  const readEnv = (env) => {
    var _a2, _b, _c, _d;
    if (typeof process !== "undefined") {
      return ((_a2 = define_process_env_default == null ? void 0 : define_process_env_default[env]) == null ? void 0 : _a2.trim()) ?? void 0;
    }
    if (typeof Deno !== "undefined") {
      return (_d = (_c = (_b = Deno.env) == null ? void 0 : _b.get) == null ? void 0 : _c.call(_b, env)) == null ? void 0 : _d.trim();
    }
    return void 0;
  };
  function isEmptyObj(obj) {
    if (!obj)
      return true;
    for (const _k in obj)
      return false;
    return true;
  }
  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  function applyHeadersMut(targetHeaders, newHeaders) {
    for (const k in newHeaders) {
      if (!hasOwn(newHeaders, k))
        continue;
      const lowerKey = k.toLowerCase();
      if (!lowerKey)
        continue;
      const val = newHeaders[k];
      if (val === null) {
        delete targetHeaders[lowerKey];
      } else if (val !== void 0) {
        targetHeaders[lowerKey] = val;
      }
    }
  }
  function debug(action, ...args) {
    if (typeof process !== "undefined" && (define_process_env_default == null ? void 0 : define_process_env_default["DEBUG"]) === "true") {
      console.log(`OpenAI:DEBUG:${action}`, ...args);
    }
  }
  const uuid4 = () => {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  };
  const isRunningInBrowser = () => {
    return (
      // @ts-ignore
      typeof window !== "undefined" && // @ts-ignore
      typeof window.document !== "undefined" && // @ts-ignore
      typeof navigator !== "undefined"
    );
  };
  function isObj(obj) {
    return obj != null && typeof obj === "object" && !Array.isArray(obj);
  }
  class OpenAIError extends Error {
  }
  class APIError extends OpenAIError {
    constructor(status, error, message, headers) {
      super(`${APIError.makeMessage(status, error, message)}`);
      this.status = status;
      this.headers = headers;
      this.request_id = headers == null ? void 0 : headers["x-request-id"];
      const data = error;
      this.error = data;
      this.code = data == null ? void 0 : data["code"];
      this.param = data == null ? void 0 : data["param"];
      this.type = data == null ? void 0 : data["type"];
    }
    static makeMessage(status, error, message) {
      const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
      if (status && msg) {
        return `${status} ${msg}`;
      }
      if (status) {
        return `${status} status code (no body)`;
      }
      if (msg) {
        return msg;
      }
      return "(no status code or body)";
    }
    static generate(status, errorResponse, message, headers) {
      if (!status) {
        return new APIConnectionError({ cause: castToError(errorResponse) });
      }
      const error = errorResponse == null ? void 0 : errorResponse["error"];
      if (status === 400) {
        return new BadRequestError(status, error, message, headers);
      }
      if (status === 401) {
        return new AuthenticationError(status, error, message, headers);
      }
      if (status === 403) {
        return new PermissionDeniedError(status, error, message, headers);
      }
      if (status === 404) {
        return new NotFoundError(status, error, message, headers);
      }
      if (status === 409) {
        return new ConflictError(status, error, message, headers);
      }
      if (status === 422) {
        return new UnprocessableEntityError(status, error, message, headers);
      }
      if (status === 429) {
        return new RateLimitError(status, error, message, headers);
      }
      if (status >= 500) {
        return new InternalServerError(status, error, message, headers);
      }
      return new APIError(status, error, message, headers);
    }
  }
  class APIUserAbortError extends APIError {
    constructor({ message } = {}) {
      super(void 0, void 0, message || "Request was aborted.", void 0);
      this.status = void 0;
    }
  }
  class APIConnectionError extends APIError {
    constructor({ message, cause }) {
      super(void 0, void 0, message || "Connection error.", void 0);
      this.status = void 0;
      if (cause)
        this.cause = cause;
    }
  }
  class APIConnectionTimeoutError extends APIConnectionError {
    constructor({ message } = {}) {
      super({ message: message ?? "Request timed out." });
    }
  }
  class BadRequestError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 400;
    }
  }
  class AuthenticationError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 401;
    }
  }
  class PermissionDeniedError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 403;
    }
  }
  class NotFoundError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 404;
    }
  }
  class ConflictError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 409;
    }
  }
  class UnprocessableEntityError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 422;
    }
  }
  class RateLimitError extends APIError {
    constructor() {
      super(...arguments);
      this.status = 429;
    }
  }
  class InternalServerError extends APIError {
  }
  class LengthFinishReasonError extends OpenAIError {
    constructor() {
      super(`Could not parse response content as the length limit was reached`);
    }
  }
  class ContentFilterFinishReasonError extends OpenAIError {
    constructor() {
      super(`Could not parse response content as the request was rejected by the content filter`);
    }
  }
  class Page extends AbstractPage {
    constructor(client, response, body, options) {
      super(client, response, body, options);
      this.data = body.data || [];
      this.object = body.object;
    }
    getPaginatedItems() {
      return this.data ?? [];
    }
    // @deprecated Please use `nextPageInfo()` instead
    /**
     * This page represents a response that isn't actually paginated at the API level
     * so there will never be any next page params.
     */
    nextPageParams() {
      return null;
    }
    nextPageInfo() {
      return null;
    }
  }
  class CursorPage extends AbstractPage {
    constructor(client, response, body, options) {
      super(client, response, body, options);
      this.data = body.data || [];
    }
    getPaginatedItems() {
      return this.data ?? [];
    }
    // @deprecated Please use `nextPageInfo()` instead
    nextPageParams() {
      const info = this.nextPageInfo();
      if (!info)
        return null;
      if ("params" in info)
        return info.params;
      const params = Object.fromEntries(info.url.searchParams);
      if (!Object.keys(params).length)
        return null;
      return params;
    }
    nextPageInfo() {
      var _a2;
      const data = this.getPaginatedItems();
      if (!data.length) {
        return null;
      }
      const id = (_a2 = data[data.length - 1]) == null ? void 0 : _a2.id;
      if (!id) {
        return null;
      }
      return { params: { after: id } };
    }
  }
  class APIResource {
    constructor(client) {
      this._client = client;
    }
  }
  let Completions$2 = class Completions extends APIResource {
    create(body, options) {
      return this._client.post("/chat/completions", { body, ...options, stream: body.stream ?? false });
    }
  };
  /* @__PURE__ */ (function(Completions2) {
  })(Completions$2 || (Completions$2 = {}));
  let Chat$1 = class Chat extends APIResource {
    constructor() {
      super(...arguments);
      this.completions = new Completions$2(this._client);
    }
  };
  (function(Chat2) {
    Chat2.Completions = Completions$2;
  })(Chat$1 || (Chat$1 = {}));
  class Speech extends APIResource {
    /**
     * Generates audio from the input text.
     */
    create(body, options) {
      return this._client.post("/audio/speech", { body, ...options, __binaryResponse: true });
    }
  }
  /* @__PURE__ */ (function(Speech2) {
  })(Speech || (Speech = {}));
  class Transcriptions extends APIResource {
    /**
     * Transcribes audio into the input language.
     */
    create(body, options) {
      return this._client.post("/audio/transcriptions", multipartFormRequestOptions({ body, ...options }));
    }
  }
  /* @__PURE__ */ (function(Transcriptions2) {
  })(Transcriptions || (Transcriptions = {}));
  class Translations extends APIResource {
    /**
     * Translates audio into English.
     */
    create(body, options) {
      return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options }));
    }
  }
  /* @__PURE__ */ (function(Translations2) {
  })(Translations || (Translations = {}));
  class Audio extends APIResource {
    constructor() {
      super(...arguments);
      this.transcriptions = new Transcriptions(this._client);
      this.translations = new Translations(this._client);
      this.speech = new Speech(this._client);
    }
  }
  (function(Audio2) {
    Audio2.Transcriptions = Transcriptions;
    Audio2.Translations = Translations;
    Audio2.Speech = Speech;
  })(Audio || (Audio = {}));
  class Batches extends APIResource {
    /**
     * Creates and executes a batch from an uploaded file of requests
     */
    create(body, options) {
      return this._client.post("/batches", { body, ...options });
    }
    /**
     * Retrieves a batch.
     */
    retrieve(batchId, options) {
      return this._client.get(`/batches/${batchId}`, options);
    }
    list(query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/batches", BatchesPage, { query, ...options });
    }
    /**
     * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
     * 10 minutes, before changing to `cancelled`, where it will have partial results
     * (if any) available in the output file.
     */
    cancel(batchId, options) {
      return this._client.post(`/batches/${batchId}/cancel`, options);
    }
  }
  class BatchesPage extends CursorPage {
  }
  (function(Batches2) {
    Batches2.BatchesPage = BatchesPage;
  })(Batches || (Batches = {}));
  class Assistants extends APIResource {
    /**
     * Create an assistant with a model and instructions.
     */
    create(body, options) {
      return this._client.post("/assistants", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves an assistant.
     */
    retrieve(assistantId, options) {
      return this._client.get(`/assistants/${assistantId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies an assistant.
     */
    update(assistantId, body, options) {
      return this._client.post(`/assistants/${assistantId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/assistants", AssistantsPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Delete an assistant.
     */
    del(assistantId, options) {
      return this._client.delete(`/assistants/${assistantId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  }
  class AssistantsPage extends CursorPage {
  }
  (function(Assistants2) {
    Assistants2.AssistantsPage = AssistantsPage;
  })(Assistants || (Assistants = {}));
  function isRunnableFunctionWithParse(fn) {
    return typeof fn.parse === "function";
  }
  const isAssistantMessage = (message) => {
    return (message == null ? void 0 : message.role) === "assistant";
  };
  const isFunctionMessage = (message) => {
    return (message == null ? void 0 : message.role) === "function";
  };
  const isToolMessage = (message) => {
    return (message == null ? void 0 : message.role) === "tool";
  };
  var __classPrivateFieldSet$2 = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet$3 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _EventStream_instances, _EventStream_connectedPromise, _EventStream_resolveConnectedPromise, _EventStream_rejectConnectedPromise, _EventStream_endPromise, _EventStream_resolveEndPromise, _EventStream_rejectEndPromise, _EventStream_listeners, _EventStream_ended, _EventStream_errored, _EventStream_aborted, _EventStream_catchingPromiseCreated, _EventStream_handleError;
  class EventStream {
    constructor() {
      _EventStream_instances.add(this);
      this.controller = new AbortController();
      _EventStream_connectedPromise.set(this, void 0);
      _EventStream_resolveConnectedPromise.set(this, () => {
      });
      _EventStream_rejectConnectedPromise.set(this, () => {
      });
      _EventStream_endPromise.set(this, void 0);
      _EventStream_resolveEndPromise.set(this, () => {
      });
      _EventStream_rejectEndPromise.set(this, () => {
      });
      _EventStream_listeners.set(this, {});
      _EventStream_ended.set(this, false);
      _EventStream_errored.set(this, false);
      _EventStream_aborted.set(this, false);
      _EventStream_catchingPromiseCreated.set(this, false);
      __classPrivateFieldSet$2(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {
        __classPrivateFieldSet$2(this, _EventStream_resolveConnectedPromise, resolve, "f");
        __classPrivateFieldSet$2(this, _EventStream_rejectConnectedPromise, reject, "f");
      }), "f");
      __classPrivateFieldSet$2(this, _EventStream_endPromise, new Promise((resolve, reject) => {
        __classPrivateFieldSet$2(this, _EventStream_resolveEndPromise, resolve, "f");
        __classPrivateFieldSet$2(this, _EventStream_rejectEndPromise, reject, "f");
      }), "f");
      __classPrivateFieldGet$3(this, _EventStream_connectedPromise, "f").catch(() => {
      });
      __classPrivateFieldGet$3(this, _EventStream_endPromise, "f").catch(() => {
      });
    }
    _run(executor) {
      setTimeout(() => {
        executor().then(() => {
          this._emitFinal();
          this._emit("end");
        }, __classPrivateFieldGet$3(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
      }, 0);
    }
    _connected() {
      if (this.ended)
        return;
      __classPrivateFieldGet$3(this, _EventStream_resolveConnectedPromise, "f").call(this);
      this._emit("connect");
    }
    get ended() {
      return __classPrivateFieldGet$3(this, _EventStream_ended, "f");
    }
    get errored() {
      return __classPrivateFieldGet$3(this, _EventStream_errored, "f");
    }
    get aborted() {
      return __classPrivateFieldGet$3(this, _EventStream_aborted, "f");
    }
    abort() {
      this.controller.abort();
    }
    /**
     * Adds the listener function to the end of the listeners array for the event.
     * No checks are made to see if the listener has already been added. Multiple calls passing
     * the same combination of event and listener will result in the listener being added, and
     * called, multiple times.
     * @returns this ChatCompletionStream, so that calls can be chained
     */
    on(event, listener) {
      const listeners = __classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event] = []);
      listeners.push({ listener });
      return this;
    }
    /**
     * Removes the specified listener from the listener array for the event.
     * off() will remove, at most, one instance of a listener from the listener array. If any single
     * listener has been added multiple times to the listener array for the specified event, then
     * off() must be called multiple times to remove each instance.
     * @returns this ChatCompletionStream, so that calls can be chained
     */
    off(event, listener) {
      const listeners = __classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event];
      if (!listeners)
        return this;
      const index = listeners.findIndex((l) => l.listener === listener);
      if (index >= 0)
        listeners.splice(index, 1);
      return this;
    }
    /**
     * Adds a one-time listener function for the event. The next time the event is triggered,
     * this listener is removed and then invoked.
     * @returns this ChatCompletionStream, so that calls can be chained
     */
    once(event, listener) {
      const listeners = __classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event] = []);
      listeners.push({ listener, once: true });
      return this;
    }
    /**
     * This is similar to `.once()`, but returns a Promise that resolves the next time
     * the event is triggered, instead of calling a listener callback.
     * @returns a Promise that resolves the next time given event is triggered,
     * or rejects if an error is emitted.  (If you request the 'error' event,
     * returns a promise that resolves with the error).
     *
     * Example:
     *
     *   const message = await stream.emitted('message') // rejects if the stream errors
     */
    emitted(event) {
      return new Promise((resolve, reject) => {
        __classPrivateFieldSet$2(this, _EventStream_catchingPromiseCreated, true, "f");
        if (event !== "error")
          this.once("error", reject);
        this.once(event, resolve);
      });
    }
    async done() {
      __classPrivateFieldSet$2(this, _EventStream_catchingPromiseCreated, true, "f");
      await __classPrivateFieldGet$3(this, _EventStream_endPromise, "f");
    }
    _emit(event, ...args) {
      if (__classPrivateFieldGet$3(this, _EventStream_ended, "f")) {
        return;
      }
      if (event === "end") {
        __classPrivateFieldSet$2(this, _EventStream_ended, true, "f");
        __classPrivateFieldGet$3(this, _EventStream_resolveEndPromise, "f").call(this);
      }
      const listeners = __classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event];
      if (listeners) {
        __classPrivateFieldGet$3(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
        listeners.forEach(({ listener }) => listener(...args));
      }
      if (event === "abort") {
        const error = args[0];
        if (!__classPrivateFieldGet$3(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
          Promise.reject(error);
        }
        __classPrivateFieldGet$3(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
        __classPrivateFieldGet$3(this, _EventStream_rejectEndPromise, "f").call(this, error);
        this._emit("end");
        return;
      }
      if (event === "error") {
        const error = args[0];
        if (!__classPrivateFieldGet$3(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
          Promise.reject(error);
        }
        __classPrivateFieldGet$3(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
        __classPrivateFieldGet$3(this, _EventStream_rejectEndPromise, "f").call(this, error);
        this._emit("end");
      }
    }
    _emitFinal() {
    }
  }
  _EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError2(error) {
    __classPrivateFieldSet$2(this, _EventStream_errored, true, "f");
    if (error instanceof Error && error.name === "AbortError") {
      error = new APIUserAbortError();
    }
    if (error instanceof APIUserAbortError) {
      __classPrivateFieldSet$2(this, _EventStream_aborted, true, "f");
      return this._emit("abort", error);
    }
    if (error instanceof OpenAIError) {
      return this._emit("error", error);
    }
    if (error instanceof Error) {
      const openAIError = new OpenAIError(error.message);
      openAIError.cause = error;
      return this._emit("error", openAIError);
    }
    return this._emit("error", new OpenAIError(String(error)));
  };
  function isAutoParsableResponseFormat(response_format) {
    return (response_format == null ? void 0 : response_format["$brand"]) === "auto-parseable-response-format";
  }
  function isAutoParsableTool(tool) {
    return (tool == null ? void 0 : tool["$brand"]) === "auto-parseable-tool";
  }
  function maybeParseChatCompletion(completion, params) {
    if (!params || !hasAutoParseableInput(params)) {
      return {
        ...completion,
        choices: completion.choices.map((choice) => ({
          ...choice,
          message: { ...choice.message, parsed: null, tool_calls: choice.message.tool_calls ?? [] }
        }))
      };
    }
    return parseChatCompletion(completion, params);
  }
  function parseChatCompletion(completion, params) {
    const choices = completion.choices.map((choice) => {
      var _a2;
      if (choice.finish_reason === "length") {
        throw new LengthFinishReasonError();
      }
      if (choice.finish_reason === "content_filter") {
        throw new ContentFilterFinishReasonError();
      }
      return {
        ...choice,
        message: {
          ...choice.message,
          tool_calls: ((_a2 = choice.message.tool_calls) == null ? void 0 : _a2.map((toolCall) => parseToolCall(params, toolCall))) ?? [],
          parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
        }
      };
    });
    return { ...completion, choices };
  }
  function parseResponseFormat(params, content) {
    var _a2, _b;
    if (((_a2 = params.response_format) == null ? void 0 : _a2.type) !== "json_schema") {
      return null;
    }
    if (((_b = params.response_format) == null ? void 0 : _b.type) === "json_schema") {
      if ("$parseRaw" in params.response_format) {
        const response_format = params.response_format;
        return response_format.$parseRaw(content);
      }
      return JSON.parse(content);
    }
    return null;
  }
  function parseToolCall(params, toolCall) {
    var _a2;
    const inputTool = (_a2 = params.tools) == null ? void 0 : _a2.find((inputTool2) => {
      var _a3;
      return ((_a3 = inputTool2.function) == null ? void 0 : _a3.name) === toolCall.function.name;
    });
    return {
      ...toolCall,
      function: {
        ...toolCall.function,
        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCall.function.arguments) : null
      }
    };
  }
  function shouldParseToolCall(params, toolCall) {
    var _a2;
    if (!params) {
      return false;
    }
    const inputTool = (_a2 = params.tools) == null ? void 0 : _a2.find((inputTool2) => {
      var _a3;
      return ((_a3 = inputTool2.function) == null ? void 0 : _a3.name) === toolCall.function.name;
    });
    return isAutoParsableTool(inputTool) || (inputTool == null ? void 0 : inputTool.function.strict) || false;
  }
  function hasAutoParseableInput(params) {
    var _a2;
    if (isAutoParsableResponseFormat(params.response_format)) {
      return true;
    }
    return ((_a2 = params.tools) == null ? void 0 : _a2.some((t) => isAutoParsableTool(t) || t.type === "function" && t.function.strict === true)) ?? false;
  }
  function validateInputTools(tools) {
    for (const tool of tools ?? []) {
      if (tool.type !== "function") {
        throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
      }
      if (tool.function.strict !== true) {
        throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
      }
    }
  }
  var __classPrivateFieldGet$2 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionCall, _AbstractChatCompletionRunner_getFinalFunctionCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;
  const DEFAULT_MAX_CHAT_COMPLETIONS = 10;
  class AbstractChatCompletionRunner extends EventStream {
    constructor() {
      super(...arguments);
      _AbstractChatCompletionRunner_instances.add(this);
      this._chatCompletions = [];
      this.messages = [];
    }
    _addChatCompletion(chatCompletion) {
      var _a2;
      this._chatCompletions.push(chatCompletion);
      this._emit("chatCompletion", chatCompletion);
      const message = (_a2 = chatCompletion.choices[0]) == null ? void 0 : _a2.message;
      if (message)
        this._addMessage(message);
      return chatCompletion;
    }
    _addMessage(message, emit2 = true) {
      if (!("content" in message))
        message.content = null;
      this.messages.push(message);
      if (emit2) {
        this._emit("message", message);
        if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {
          this._emit("functionCallResult", message.content);
        } else if (isAssistantMessage(message) && message.function_call) {
          this._emit("functionCall", message.function_call);
        } else if (isAssistantMessage(message) && message.tool_calls) {
          for (const tool_call of message.tool_calls) {
            if (tool_call.type === "function") {
              this._emit("functionCall", tool_call.function);
            }
          }
        }
      }
    }
    /**
     * @returns a promise that resolves with the final ChatCompletion, or rejects
     * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
     */
    async finalChatCompletion() {
      await this.done();
      const completion = this._chatCompletions[this._chatCompletions.length - 1];
      if (!completion)
        throw new OpenAIError("stream ended without producing a ChatCompletion");
      return completion;
    }
    /**
     * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
     */
    async finalContent() {
      await this.done();
      return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    }
    /**
     * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
     * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
     */
    async finalMessage() {
      await this.done();
      return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    }
    /**
     * @returns a promise that resolves with the content of the final FunctionCall, or rejects
     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
     */
    async finalFunctionCall() {
      await this.done();
      return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
    }
    async finalFunctionCallResult() {
      await this.done();
      return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
    }
    async totalUsage() {
      await this.done();
      return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
    }
    allChatCompletions() {
      return [...this._chatCompletions];
    }
    _emitFinal() {
      const completion = this._chatCompletions[this._chatCompletions.length - 1];
      if (completion)
        this._emit("finalChatCompletion", completion);
      const finalMessage = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
      if (finalMessage)
        this._emit("finalMessage", finalMessage);
      const finalContent = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
      if (finalContent)
        this._emit("finalContent", finalContent);
      const finalFunctionCall = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
      if (finalFunctionCall)
        this._emit("finalFunctionCall", finalFunctionCall);
      const finalFunctionCallResult = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
      if (finalFunctionCallResult != null)
        this._emit("finalFunctionCallResult", finalFunctionCallResult);
      if (this._chatCompletions.some((c) => c.usage)) {
        this._emit("totalUsage", __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
      }
    }
    async _createChatCompletion(client, params, options) {
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
      const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
      this._connected();
      return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
    }
    async _runChatCompletion(client, params, options) {
      for (const message of params.messages) {
        this._addMessage(message, false);
      }
      return await this._createChatCompletion(client, params, options);
    }
    async _runFunctions(client, params, options) {
      var _a2;
      const role = "function";
      const { function_call = "auto", stream, ...restParams } = params;
      const singleFunctionToCall = typeof function_call !== "string" && (function_call == null ? void 0 : function_call.name);
      const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
      const functionsByName = {};
      for (const f of params.functions) {
        functionsByName[f.name || f.function.name] = f;
      }
      const functions = params.functions.map((f) => ({
        name: f.name || f.function.name,
        parameters: f.parameters,
        description: f.description
      }));
      for (const message of params.messages) {
        this._addMessage(message, false);
      }
      for (let i = 0; i < maxChatCompletions; ++i) {
        const chatCompletion = await this._createChatCompletion(client, {
          ...restParams,
          function_call,
          functions,
          messages: [...this.messages]
        }, options);
        const message = (_a2 = chatCompletion.choices[0]) == null ? void 0 : _a2.message;
        if (!message) {
          throw new OpenAIError(`missing message in ChatCompletion response`);
        }
        if (!message.function_call)
          return;
        const { name, arguments: args } = message.function_call;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map((f) => JSON.stringify(f.name)).join(", ")}. Please try again`;
          this._addMessage({ role, name, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, name, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error) {
          this._addMessage({
            role,
            name,
            content: error instanceof Error ? error.message : String(error)
          });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, name, content });
        if (singleFunctionToCall)
          return;
      }
    }
    async _runTools(client, params, options) {
      var _a2, _b, _c;
      const role = "tool";
      const { tool_choice = "auto", stream, ...restParams } = params;
      const singleFunctionToCall = typeof tool_choice !== "string" && ((_a2 = tool_choice == null ? void 0 : tool_choice.function) == null ? void 0 : _a2.name);
      const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
      const inputTools = params.tools.map((tool) => {
        if (isAutoParsableTool(tool)) {
          if (!tool.$callback) {
            throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
          }
          return {
            type: "function",
            function: {
              function: tool.$callback,
              name: tool.function.name,
              description: tool.function.description || "",
              parameters: tool.function.parameters,
              parse: tool.$parseRaw,
              strict: true
            }
          };
        }
        return tool;
      });
      const functionsByName = {};
      for (const f of inputTools) {
        if (f.type === "function") {
          functionsByName[f.function.name || f.function.function.name] = f.function;
        }
      }
      const tools = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
        type: "function",
        function: {
          name: t.function.name || t.function.function.name,
          parameters: t.function.parameters,
          description: t.function.description,
          strict: t.function.strict
        }
      } : t) : void 0;
      for (const message of params.messages) {
        this._addMessage(message, false);
      }
      for (let i = 0; i < maxChatCompletions; ++i) {
        const chatCompletion = await this._createChatCompletion(client, {
          ...restParams,
          tool_choice,
          tools,
          messages: [...this.messages]
        }, options);
        const message = (_b = chatCompletion.choices[0]) == null ? void 0 : _b.message;
        if (!message) {
          throw new OpenAIError(`missing message in ChatCompletion response`);
        }
        if (!((_c = message.tool_calls) == null ? void 0 : _c.length)) {
          return;
        }
        for (const tool_call of message.tool_calls) {
          if (tool_call.type !== "function")
            continue;
          const tool_call_id = tool_call.id;
          const { name, arguments: args } = tool_call.function;
          const fn = functionsByName[name];
          if (!fn) {
            const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
            this._addMessage({ role, tool_call_id, content: content2 });
            continue;
          } else if (singleFunctionToCall && singleFunctionToCall !== name) {
            const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
            this._addMessage({ role, tool_call_id, content: content2 });
            continue;
          }
          let parsed;
          try {
            parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
          } catch (error) {
            const content2 = error instanceof Error ? error.message : String(error);
            this._addMessage({ role, tool_call_id, content: content2 });
            continue;
          }
          const rawContent = await fn.function(parsed, this);
          const content = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
          this._addMessage({ role, tool_call_id, content });
          if (singleFunctionToCall) {
            return;
          }
        }
      }
      return;
    }
  }
  _AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
    return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
  }, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
    let i = this.messages.length;
    while (i-- > 0) {
      const message = this.messages[i];
      if (isAssistantMessage(message)) {
        const { function_call, ...rest } = message;
        const ret = {
          ...rest,
          content: message.content ?? null,
          refusal: message.refusal ?? null
        };
        if (function_call) {
          ret.function_call = function_call;
        }
        return ret;
      }
    }
    throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
  }, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall2() {
    var _a2, _b;
    for (let i = this.messages.length - 1; i >= 0; i--) {
      const message = this.messages[i];
      if (isAssistantMessage(message) && (message == null ? void 0 : message.function_call)) {
        return message.function_call;
      }
      if (isAssistantMessage(message) && ((_a2 = message == null ? void 0 : message.tool_calls) == null ? void 0 : _a2.length)) {
        return (_b = message.tool_calls.at(-1)) == null ? void 0 : _b.function;
      }
    }
    return;
  }, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult2() {
    for (let i = this.messages.length - 1; i >= 0; i--) {
      const message = this.messages[i];
      if (isFunctionMessage(message) && message.content != null) {
        return message.content;
      }
      if (isToolMessage(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => {
        var _a2;
        return x.role === "assistant" && ((_a2 = x.tool_calls) == null ? void 0 : _a2.some((y) => y.type === "function" && y.id === message.tool_call_id));
      })) {
        return message.content;
      }
    }
    return;
  }, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
    const total = {
      completion_tokens: 0,
      prompt_tokens: 0,
      total_tokens: 0
    };
    for (const { usage } of this._chatCompletions) {
      if (usage) {
        total.completion_tokens += usage.completion_tokens;
        total.prompt_tokens += usage.prompt_tokens;
        total.total_tokens += usage.total_tokens;
      }
    }
    return total;
  }, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
    if (params.n != null && params.n > 1) {
      throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
    }
  }, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
    return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
  };
  class ChatCompletionRunner extends AbstractChatCompletionRunner {
    /** @deprecated - please use `runTools` instead. */
    static runFunctions(client, params, options) {
      const runner = new ChatCompletionRunner();
      const opts = {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
      };
      runner._run(() => runner._runFunctions(client, params, opts));
      return runner;
    }
    static runTools(client, params, options) {
      const runner = new ChatCompletionRunner();
      const opts = {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
      };
      runner._run(() => runner._runTools(client, params, opts));
      return runner;
    }
    _addMessage(message) {
      super._addMessage(message);
      if (isAssistantMessage(message) && message.content) {
        this._emit("content", message.content);
      }
    }
  }
  const tokenize = (input) => {
    let current = 0;
    let tokens = [];
    while (current < input.length) {
      let char = input[current];
      if (char === "\\") {
        current++;
        continue;
      }
      if (char === "{") {
        tokens.push({
          type: "brace",
          value: "{"
        });
        current++;
        continue;
      }
      if (char === "}") {
        tokens.push({
          type: "brace",
          value: "}"
        });
        current++;
        continue;
      }
      if (char === "[") {
        tokens.push({
          type: "paren",
          value: "["
        });
        current++;
        continue;
      }
      if (char === "]") {
        tokens.push({
          type: "paren",
          value: "]"
        });
        current++;
        continue;
      }
      if (char === ":") {
        tokens.push({
          type: "separator",
          value: ":"
        });
        current++;
        continue;
      }
      if (char === ",") {
        tokens.push({
          type: "delimiter",
          value: ","
        });
        current++;
        continue;
      }
      if (char === '"') {
        let value = "";
        let danglingQuote = false;
        char = input[++current];
        while (char !== '"') {
          if (current === input.length) {
            danglingQuote = true;
            break;
          }
          if (char === "\\") {
            current++;
            if (current === input.length) {
              danglingQuote = true;
              break;
            }
            value += char + input[current];
            char = input[++current];
          } else {
            value += char;
            char = input[++current];
          }
        }
        char = input[++current];
        if (!danglingQuote) {
          tokens.push({
            type: "string",
            value
          });
        }
        continue;
      }
      let WHITESPACE = /\s/;
      if (char && WHITESPACE.test(char)) {
        current++;
        continue;
      }
      let NUMBERS = /[0-9]/;
      if (char && NUMBERS.test(char) || char === "-" || char === ".") {
        let value = "";
        if (char === "-") {
          value += char;
          char = input[++current];
        }
        while (char && NUMBERS.test(char) || char === ".") {
          value += char;
          char = input[++current];
        }
        tokens.push({
          type: "number",
          value
        });
        continue;
      }
      let LETTERS = /[a-z]/i;
      if (char && LETTERS.test(char)) {
        let value = "";
        while (char && LETTERS.test(char)) {
          if (current === input.length) {
            break;
          }
          value += char;
          char = input[++current];
        }
        if (value == "true" || value == "false" || value === "null") {
          tokens.push({
            type: "name",
            value
          });
        } else {
          current++;
          continue;
        }
        continue;
      }
      current++;
    }
    return tokens;
  }, strip = (tokens) => {
    if (tokens.length === 0) {
      return tokens;
    }
    let lastToken = tokens[tokens.length - 1];
    switch (lastToken.type) {
      case "separator":
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      case "number":
        let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];
        if (lastCharacterOfLastToken === "." || lastCharacterOfLastToken === "-") {
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
        }
      case "string":
        let tokenBeforeTheLastToken = tokens[tokens.length - 2];
        if ((tokenBeforeTheLastToken == null ? void 0 : tokenBeforeTheLastToken.type) === "delimiter") {
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
        } else if ((tokenBeforeTheLastToken == null ? void 0 : tokenBeforeTheLastToken.type) === "brace" && tokenBeforeTheLastToken.value === "{") {
          tokens = tokens.slice(0, tokens.length - 1);
          return strip(tokens);
        }
        break;
      case "delimiter":
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
    }
    return tokens;
  }, unstrip = (tokens) => {
    let tail = [];
    tokens.map((token) => {
      if (token.type === "brace") {
        if (token.value === "{") {
          tail.push("}");
        } else {
          tail.splice(tail.lastIndexOf("}"), 1);
        }
      }
      if (token.type === "paren") {
        if (token.value === "[") {
          tail.push("]");
        } else {
          tail.splice(tail.lastIndexOf("]"), 1);
        }
      }
    });
    if (tail.length > 0) {
      tail.reverse().map((item) => {
        if (item === "}") {
          tokens.push({
            type: "brace",
            value: "}"
          });
        } else if (item === "]") {
          tokens.push({
            type: "paren",
            value: "]"
          });
        }
      });
    }
    return tokens;
  }, generate = (tokens) => {
    let output = "";
    tokens.map((token) => {
      switch (token.type) {
        case "string":
          output += '"' + token.value + '"';
          break;
        default:
          output += token.value;
          break;
      }
    });
    return output;
  }, partialParse = (input) => JSON.parse(generate(unstrip(strip(tokenize(input)))));
  var __classPrivateFieldSet$1 = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet$1 = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _ChatCompletionStream_instances, _ChatCompletionStream_params, _ChatCompletionStream_choiceEventStates, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_getChoiceEventState, _ChatCompletionStream_addChunk, _ChatCompletionStream_emitToolCallDoneEvent, _ChatCompletionStream_emitContentDoneEvents, _ChatCompletionStream_endRequest, _ChatCompletionStream_getAutoParseableResponseFormat, _ChatCompletionStream_accumulateChatCompletion;
  class ChatCompletionStream extends AbstractChatCompletionRunner {
    constructor(params) {
      super();
      _ChatCompletionStream_instances.add(this);
      _ChatCompletionStream_params.set(this, void 0);
      _ChatCompletionStream_choiceEventStates.set(this, void 0);
      _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
      __classPrivateFieldSet$1(this, _ChatCompletionStream_params, params, "f");
      __classPrivateFieldSet$1(this, _ChatCompletionStream_choiceEventStates, [], "f");
    }
    get currentChatCompletionSnapshot() {
      return __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    }
    /**
     * Intended for use on the frontend, consuming a stream produced with
     * `.toReadableStream()` on the backend.
     *
     * Note that messages sent to the model do not appear in `.on('message')`
     * in this context.
     */
    static fromReadableStream(stream) {
      const runner = new ChatCompletionStream(null);
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    static createChatCompletion(client, params, options) {
      const runner = new ChatCompletionStream(params);
      runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
      return runner;
    }
    async _createChatCompletion(client, params, options) {
      var _a2;
      super._createChatCompletion;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
      const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
      this._connected();
      for await (const chunk of stream) {
        __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      }
      if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
        throw new APIUserAbortError();
      }
      return this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
    }
    async _fromReadableStream(readableStream, options) {
      var _a2;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
      this._connected();
      const stream = Stream.fromReadableStream(readableStream, this.controller);
      let chatId;
      for await (const chunk of stream) {
        if (chatId && chatId !== chunk.id) {
          this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
        }
        __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
        chatId = chunk.id;
      }
      if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
        throw new APIUserAbortError();
      }
      return this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
    }
    [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
      if (this.ended)
        return;
      __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
    }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState2(choice) {
      let state = __classPrivateFieldGet$1(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
      if (state) {
        return state;
      }
      state = {
        content_done: false,
        refusal_done: false,
        logprobs_content_done: false,
        logprobs_refusal_done: false,
        done_tool_calls: /* @__PURE__ */ new Set(),
        current_tool_call_index: null
      };
      __classPrivateFieldGet$1(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
      return state;
    }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
      if (this.ended)
        return;
      const completion = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
      this._emit("chunk", chunk, completion);
      for (const choice of chunk.choices) {
        const choiceSnapshot = completion.choices[choice.index];
        if (choice.delta.content != null && ((_a2 = choiceSnapshot.message) == null ? void 0 : _a2.role) === "assistant" && ((_b = choiceSnapshot.message) == null ? void 0 : _b.content)) {
          this._emit("content", choice.delta.content, choiceSnapshot.message.content);
          this._emit("content.delta", {
            delta: choice.delta.content,
            snapshot: choiceSnapshot.message.content,
            parsed: choiceSnapshot.message.parsed
          });
        }
        if (choice.delta.refusal != null && ((_c = choiceSnapshot.message) == null ? void 0 : _c.role) === "assistant" && ((_d = choiceSnapshot.message) == null ? void 0 : _d.refusal)) {
          this._emit("refusal.delta", {
            delta: choice.delta.refusal,
            snapshot: choiceSnapshot.message.refusal
          });
        }
        if (((_e = choice.logprobs) == null ? void 0 : _e.content) != null && ((_f = choiceSnapshot.message) == null ? void 0 : _f.role) === "assistant") {
          this._emit("logprobs.content.delta", {
            content: (_g = choice.logprobs) == null ? void 0 : _g.content,
            snapshot: ((_h = choiceSnapshot.logprobs) == null ? void 0 : _h.content) ?? []
          });
        }
        if (((_i = choice.logprobs) == null ? void 0 : _i.refusal) != null && ((_j = choiceSnapshot.message) == null ? void 0 : _j.role) === "assistant") {
          this._emit("logprobs.refusal.delta", {
            refusal: (_k = choice.logprobs) == null ? void 0 : _k.refusal,
            snapshot: ((_l = choiceSnapshot.logprobs) == null ? void 0 : _l.refusal) ?? []
          });
        }
        const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
        if (choiceSnapshot.finish_reason) {
          __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        for (const toolCall of choice.delta.tool_calls ?? []) {
          if (state.current_tool_call_index !== toolCall.index) {
            __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
            if (state.current_tool_call_index != null) {
              __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
            }
          }
          state.current_tool_call_index = toolCall.index;
        }
        for (const toolCallDelta of choice.delta.tool_calls ?? []) {
          const toolCallSnapshot = (_m = choiceSnapshot.message.tool_calls) == null ? void 0 : _m[toolCallDelta.index];
          if (!(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type)) {
            continue;
          }
          if ((toolCallSnapshot == null ? void 0 : toolCallSnapshot.type) === "function") {
            this._emit("tool_calls.function.arguments.delta", {
              name: (_n = toolCallSnapshot.function) == null ? void 0 : _n.name,
              index: toolCallDelta.index,
              arguments: toolCallSnapshot.function.arguments,
              parsed_arguments: toolCallSnapshot.function.parsed_arguments,
              arguments_delta: ((_o = toolCallDelta.function) == null ? void 0 : _o.arguments) ?? ""
            });
          } else {
            assertNever(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type);
          }
        }
      }
    }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
      var _a2, _b, _c;
      const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (state.done_tool_calls.has(toolCallIndex)) {
        return;
      }
      const toolCallSnapshot = (_a2 = choiceSnapshot.message.tool_calls) == null ? void 0 : _a2[toolCallIndex];
      if (!toolCallSnapshot) {
        throw new Error("no tool call snapshot");
      }
      if (!toolCallSnapshot.type) {
        throw new Error("tool call snapshot missing `type`");
      }
      if (toolCallSnapshot.type === "function") {
        const inputTool = (_c = (_b = __classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _b.tools) == null ? void 0 : _c.find((tool) => tool.type === "function" && tool.function.name === toolCallSnapshot.function.name);
        this._emit("tool_calls.function.arguments.done", {
          name: toolCallSnapshot.function.name,
          index: toolCallIndex,
          arguments: toolCallSnapshot.function.arguments,
          parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCallSnapshot.function.arguments) : null
        });
      } else {
        assertNever(toolCallSnapshot.type);
      }
    }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
      var _a2, _b;
      const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.message.content && !state.content_done) {
        state.content_done = true;
        const responseFormat = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
        this._emit("content.done", {
          content: choiceSnapshot.message.content,
          parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
        });
      }
      if (choiceSnapshot.message.refusal && !state.refusal_done) {
        state.refusal_done = true;
        this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
      }
      if (((_a2 = choiceSnapshot.logprobs) == null ? void 0 : _a2.content) && !state.logprobs_content_done) {
        state.logprobs_content_done = true;
        this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
      }
      if (((_b = choiceSnapshot.logprobs) == null ? void 0 : _b.refusal) && !state.logprobs_refusal_done) {
        state.logprobs_refusal_done = true;
        this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
      }
    }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
      if (this.ended) {
        throw new OpenAIError(`stream has ended, this shouldn't happen`);
      }
      const snapshot = __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
      if (!snapshot) {
        throw new OpenAIError(`request ended without sending any chunks`);
      }
      __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
      __classPrivateFieldSet$1(this, _ChatCompletionStream_choiceEventStates, [], "f");
      return finalizeChatCompletion(snapshot, __classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f"));
    }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
      var _a2;
      const responseFormat = (_a2 = __classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _a2.response_format;
      if (isAutoParsableResponseFormat(responseFormat)) {
        return responseFormat;
      }
      return null;
    }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
      var _a2, _b, _c, _d;
      let snapshot = __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
      const { choices, ...rest } = chunk;
      if (!snapshot) {
        snapshot = __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
          ...rest,
          choices: []
        }, "f");
      } else {
        Object.assign(snapshot, rest);
      }
      for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {
        let choice = snapshot.choices[index];
        if (!choice) {
          choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };
        }
        if (logprobs) {
          if (!choice.logprobs) {
            choice.logprobs = Object.assign({}, logprobs);
          } else {
            const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
            Object.assign(choice.logprobs, rest3);
            if (content2) {
              (_a2 = choice.logprobs).content ?? (_a2.content = []);
              choice.logprobs.content.push(...content2);
            }
            if (refusal2) {
              (_b = choice.logprobs).refusal ?? (_b.refusal = []);
              choice.logprobs.refusal.push(...refusal2);
            }
          }
        }
        if (finish_reason) {
          choice.finish_reason = finish_reason;
          if (__classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput(__classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f"))) {
            if (finish_reason === "length") {
              throw new LengthFinishReasonError();
            }
            if (finish_reason === "content_filter") {
              throw new ContentFilterFinishReasonError();
            }
          }
        }
        Object.assign(choice, other);
        if (!delta)
          continue;
        const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
        Object.assign(choice.message, rest2);
        if (refusal) {
          choice.message.refusal = (choice.message.refusal || "") + refusal;
        }
        if (role)
          choice.message.role = role;
        if (function_call) {
          if (!choice.message.function_call) {
            choice.message.function_call = function_call;
          } else {
            if (function_call.name)
              choice.message.function_call.name = function_call.name;
            if (function_call.arguments) {
              (_c = choice.message.function_call).arguments ?? (_c.arguments = "");
              choice.message.function_call.arguments += function_call.arguments;
            }
          }
        }
        if (content) {
          choice.message.content = (choice.message.content || "") + content;
          if (!choice.message.refusal && __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
            choice.message.parsed = partialParse(choice.message.content);
          }
        }
        if (tool_calls) {
          if (!choice.message.tool_calls)
            choice.message.tool_calls = [];
          for (const { index: index2, id, type: type2, function: fn, ...rest3 } of tool_calls) {
            const tool_call = (_d = choice.message.tool_calls)[index2] ?? (_d[index2] = {});
            Object.assign(tool_call, rest3);
            if (id)
              tool_call.id = id;
            if (type2)
              tool_call.type = type2;
            if (fn)
              tool_call.function ?? (tool_call.function = { name: fn.name ?? "", arguments: "" });
            if (fn == null ? void 0 : fn.name)
              tool_call.function.name = fn.name;
            if (fn == null ? void 0 : fn.arguments) {
              tool_call.function.arguments += fn.arguments;
              if (shouldParseToolCall(__classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f"), tool_call)) {
                tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
              }
            }
          }
        }
      }
      return snapshot;
    }, Symbol.asyncIterator)]() {
      const pushQueue = [];
      const readQueue = [];
      let done = false;
      this.on("chunk", (chunk) => {
        const reader = readQueue.shift();
        if (reader) {
          reader.resolve(chunk);
        } else {
          pushQueue.push(chunk);
        }
      });
      this.on("end", () => {
        done = true;
        for (const reader of readQueue) {
          reader.resolve(void 0);
        }
        readQueue.length = 0;
      });
      this.on("abort", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      this.on("error", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      return {
        next: async () => {
          if (!pushQueue.length) {
            if (done) {
              return { value: void 0, done: true };
            }
            return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
          }
          const chunk = pushQueue.shift();
          return { value: chunk, done: false };
        },
        return: async () => {
          this.abort();
          return { value: void 0, done: true };
        }
      };
    }
    toReadableStream() {
      const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
      return stream.toReadableStream();
    }
  }
  function finalizeChatCompletion(snapshot, params) {
    const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
    const completion = {
      ...rest,
      id,
      choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {
        if (!finish_reason) {
          throw new OpenAIError(`missing finish_reason for choice ${index}`);
        }
        const { content = null, function_call, tool_calls, ...messageRest } = message;
        const role = message.role;
        if (!role) {
          throw new OpenAIError(`missing role for choice ${index}`);
        }
        if (function_call) {
          const { arguments: args, name } = function_call;
          if (args == null) {
            throw new OpenAIError(`missing function_call.arguments for choice ${index}`);
          }
          if (!name) {
            throw new OpenAIError(`missing function_call.name for choice ${index}`);
          }
          return {
            ...choiceRest,
            message: {
              content,
              function_call: { arguments: args, name },
              role,
              refusal: message.refusal ?? null
            },
            finish_reason,
            index,
            logprobs
          };
        }
        if (tool_calls) {
          return {
            ...choiceRest,
            index,
            finish_reason,
            logprobs,
            message: {
              ...messageRest,
              role,
              content,
              refusal: message.refusal ?? null,
              tool_calls: tool_calls.map((tool_call, i) => {
                const { function: fn, type: type2, id: id2, ...toolRest } = tool_call;
                const { arguments: args, name, ...fnRest } = fn || {};
                if (id2 == null) {
                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id
${str(snapshot)}`);
                }
                if (type2 == null) {
                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type
${str(snapshot)}`);
                }
                if (name == null) {
                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name
${str(snapshot)}`);
                }
                if (args == null) {
                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments
${str(snapshot)}`);
                }
                return { ...toolRest, id: id2, type: type2, function: { ...fnRest, name, arguments: args } };
              })
            }
          };
        }
        return {
          ...choiceRest,
          message: { ...messageRest, content, role, refusal: message.refusal ?? null },
          finish_reason,
          index,
          logprobs
        };
      }),
      created,
      model,
      object: "chat.completion",
      ...system_fingerprint ? { system_fingerprint } : {}
    };
    return maybeParseChatCompletion(completion, params);
  }
  function str(x) {
    return JSON.stringify(x);
  }
  function assertNever(_x) {
  }
  class ChatCompletionStreamingRunner extends ChatCompletionStream {
    static fromReadableStream(stream) {
      const runner = new ChatCompletionStreamingRunner(null);
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    /** @deprecated - please use `runTools` instead. */
    static runFunctions(client, params, options) {
      const runner = new ChatCompletionStreamingRunner(null);
      const opts = {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
      };
      runner._run(() => runner._runFunctions(client, params, opts));
      return runner;
    }
    static runTools(client, params, options) {
      const runner = new ChatCompletionStreamingRunner(
        // @ts-expect-error TODO these types are incompatible
        params
      );
      const opts = {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
      };
      runner._run(() => runner._runTools(client, params, opts));
      return runner;
    }
  }
  let Completions$1 = class Completions extends APIResource {
    async parse(body, options) {
      validateInputTools(body.tools);
      const completion = await this._client.chat.completions.create(body, {
        ...options,
        headers: {
          ...options == null ? void 0 : options.headers,
          "X-Stainless-Helper-Method": "beta.chat.completions.parse"
        }
      });
      return parseChatCompletion(completion, body);
    }
    runFunctions(body, options) {
      if (body.stream) {
        return ChatCompletionStreamingRunner.runFunctions(this._client, body, options);
      }
      return ChatCompletionRunner.runFunctions(this._client, body, options);
    }
    runTools(body, options) {
      if (body.stream) {
        return ChatCompletionStreamingRunner.runTools(this._client, body, options);
      }
      return ChatCompletionRunner.runTools(this._client, body, options);
    }
    /**
     * Creates a chat completion stream
     */
    stream(body, options) {
      return ChatCompletionStream.createChatCompletion(this._client, body, options);
    }
  };
  class Chat extends APIResource {
    constructor() {
      super(...arguments);
      this.completions = new Completions$1(this._client);
    }
  }
  (function(Chat2) {
    Chat2.Completions = Completions$1;
  })(Chat || (Chat = {}));
  var __classPrivateFieldGet = function(receiver, state, kind2, f) {
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
    if (kind2 === "m") throw new TypeError("Private method is not writable");
    if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _AssistantStream_instances, _AssistantStream_events, _AssistantStream_runStepSnapshots, _AssistantStream_messageSnapshots, _AssistantStream_messageSnapshot, _AssistantStream_finalRun, _AssistantStream_currentContentIndex, _AssistantStream_currentContent, _AssistantStream_currentToolCallIndex, _AssistantStream_currentToolCall, _AssistantStream_currentEvent, _AssistantStream_currentRunSnapshot, _AssistantStream_currentRunStepSnapshot, _AssistantStream_addEvent, _AssistantStream_endRequest, _AssistantStream_handleMessage, _AssistantStream_handleRunStep, _AssistantStream_handleEvent, _AssistantStream_accumulateRunStep, _AssistantStream_accumulateMessage, _AssistantStream_accumulateContent, _AssistantStream_handleRun;
  class AssistantStream extends EventStream {
    constructor() {
      super(...arguments);
      _AssistantStream_instances.add(this);
      _AssistantStream_events.set(this, []);
      _AssistantStream_runStepSnapshots.set(this, {});
      _AssistantStream_messageSnapshots.set(this, {});
      _AssistantStream_messageSnapshot.set(this, void 0);
      _AssistantStream_finalRun.set(this, void 0);
      _AssistantStream_currentContentIndex.set(this, void 0);
      _AssistantStream_currentContent.set(this, void 0);
      _AssistantStream_currentToolCallIndex.set(this, void 0);
      _AssistantStream_currentToolCall.set(this, void 0);
      _AssistantStream_currentEvent.set(this, void 0);
      _AssistantStream_currentRunSnapshot.set(this, void 0);
      _AssistantStream_currentRunStepSnapshot.set(this, void 0);
    }
    [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
      const pushQueue = [];
      const readQueue = [];
      let done = false;
      this.on("event", (event) => {
        const reader = readQueue.shift();
        if (reader) {
          reader.resolve(event);
        } else {
          pushQueue.push(event);
        }
      });
      this.on("end", () => {
        done = true;
        for (const reader of readQueue) {
          reader.resolve(void 0);
        }
        readQueue.length = 0;
      });
      this.on("abort", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      this.on("error", (err) => {
        done = true;
        for (const reader of readQueue) {
          reader.reject(err);
        }
        readQueue.length = 0;
      });
      return {
        next: async () => {
          if (!pushQueue.length) {
            if (done) {
              return { value: void 0, done: true };
            }
            return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
          }
          const chunk = pushQueue.shift();
          return { value: chunk, done: false };
        },
        return: async () => {
          this.abort();
          return { value: void 0, done: true };
        }
      };
    }
    static fromReadableStream(stream) {
      const runner = new AssistantStream();
      runner._run(() => runner._fromReadableStream(stream));
      return runner;
    }
    async _fromReadableStream(readableStream, options) {
      var _a2;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      this._connected();
      const stream = Stream.fromReadableStream(readableStream, this.controller);
      for await (const event of stream) {
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
      }
      if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
        throw new APIUserAbortError();
      }
      return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
    }
    toReadableStream() {
      const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
      return stream.toReadableStream();
    }
    static createToolAssistantStream(threadId, runId, runs, params, options) {
      const runner = new AssistantStream();
      runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
      }));
      return runner;
    }
    async _createToolAssistantStream(run, threadId, runId, params, options) {
      var _a2;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      const body = { ...params, stream: true };
      const stream = await run.submitToolOutputs(threadId, runId, body, {
        ...options,
        signal: this.controller.signal
      });
      this._connected();
      for await (const event of stream) {
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
      }
      if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
        throw new APIUserAbortError();
      }
      return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
    }
    static createThreadAssistantStream(params, thread, options) {
      const runner = new AssistantStream();
      runner._run(() => runner._threadAssistantStream(params, thread, {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
      }));
      return runner;
    }
    static createAssistantStream(threadId, runs, params, options) {
      const runner = new AssistantStream();
      runner._run(() => runner._runAssistantStream(threadId, runs, params, {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
      }));
      return runner;
    }
    currentEvent() {
      return __classPrivateFieldGet(this, _AssistantStream_currentEvent, "f");
    }
    currentRun() {
      return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, "f");
    }
    currentMessageSnapshot() {
      return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f");
    }
    currentRunStepSnapshot() {
      return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, "f");
    }
    async finalRunSteps() {
      await this.done();
      return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f"));
    }
    async finalMessages() {
      await this.done();
      return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f"));
    }
    async finalRun() {
      await this.done();
      if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
        throw Error("Final run was not received.");
      return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
    }
    async _createThreadAssistantStream(thread, params, options) {
      var _a2;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      const body = { ...params, stream: true };
      const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
      this._connected();
      for await (const event of stream) {
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
      }
      if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
        throw new APIUserAbortError();
      }
      return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
    }
    async _createAssistantStream(run, threadId, params, options) {
      var _a2;
      const signal = options == null ? void 0 : options.signal;
      if (signal) {
        if (signal.aborted)
          this.controller.abort();
        signal.addEventListener("abort", () => this.controller.abort());
      }
      const body = { ...params, stream: true };
      const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });
      this._connected();
      for await (const event of stream) {
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
      }
      if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
        throw new APIUserAbortError();
      }
      return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
    }
    static accumulateDelta(acc, delta) {
      for (const [key, deltaValue] of Object.entries(delta)) {
        if (!acc.hasOwnProperty(key)) {
          acc[key] = deltaValue;
          continue;
        }
        let accValue = acc[key];
        if (accValue === null || accValue === void 0) {
          acc[key] = deltaValue;
          continue;
        }
        if (key === "index" || key === "type") {
          acc[key] = deltaValue;
          continue;
        }
        if (typeof accValue === "string" && typeof deltaValue === "string") {
          accValue += deltaValue;
        } else if (typeof accValue === "number" && typeof deltaValue === "number") {
          accValue += deltaValue;
        } else if (isObj(accValue) && isObj(deltaValue)) {
          accValue = this.accumulateDelta(accValue, deltaValue);
        } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
          if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
            accValue.push(...deltaValue);
            continue;
          }
        } else {
          throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
        }
        acc[key] = accValue;
      }
      return acc;
    }
    _addRun(run) {
      return run;
    }
    async _threadAssistantStream(params, thread, options) {
      return await this._createThreadAssistantStream(thread, params, options);
    }
    async _runAssistantStream(threadId, runs, params, options) {
      return await this._createAssistantStream(runs, threadId, params, options);
    }
    async _runToolAssistantStream(threadId, runId, runs, params, options) {
      return await this._createToolAssistantStream(runs, threadId, runId, params, options);
    }
  }
  _AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _AssistantStream_currentEvent, event, "f");
    __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
    switch (event.event) {
      case "thread.created":
        break;
      case "thread.run.created":
      case "thread.run.queued":
      case "thread.run.in_progress":
      case "thread.run.requires_action":
      case "thread.run.completed":
      case "thread.run.failed":
      case "thread.run.cancelling":
      case "thread.run.cancelled":
      case "thread.run.expired":
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
        break;
      case "thread.run.step.created":
      case "thread.run.step.in_progress":
      case "thread.run.step.delta":
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
        break;
      case "thread.message.created":
      case "thread.message.in_progress":
      case "thread.message.delta":
      case "thread.message.completed":
      case "thread.message.incomplete":
        __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
        break;
      case "error":
        throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    }
  }, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run has not been received");
    return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
  }, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
    const [accumulatedMessage, newContent] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
    __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
    __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
    for (const content of newContent) {
      const snapshotContent = accumulatedMessage.content[content.index];
      if ((snapshotContent == null ? void 0 : snapshotContent.type) == "text") {
        this._emit("textCreated", snapshotContent.text);
      }
    }
    switch (event.event) {
      case "thread.message.created":
        this._emit("messageCreated", event.data);
        break;
      case "thread.message.in_progress":
        break;
      case "thread.message.delta":
        this._emit("messageDelta", event.data.delta, accumulatedMessage);
        if (event.data.delta.content) {
          for (const content of event.data.delta.content) {
            if (content.type == "text" && content.text) {
              let textDelta = content.text;
              let snapshot = accumulatedMessage.content[content.index];
              if (snapshot && snapshot.type == "text") {
                this._emit("textDelta", textDelta, snapshot.text);
              } else {
                throw Error("The snapshot associated with this text delta is not text or missing");
              }
            }
            if (content.index != __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")) {
              if (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f")) {
                switch (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f").type) {
                  case "text":
                    this._emit("textDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                    break;
                  case "image_file":
                    this._emit("imageFileDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                    break;
                }
              }
              __classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index, "f");
            }
            __classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
          }
        }
        break;
      case "thread.message.completed":
      case "thread.message.incomplete":
        if (__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
          const currentContent = event.data.content[__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")];
          if (currentContent) {
            switch (currentContent.type) {
              case "image_file":
                this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                break;
              case "text":
                this._emit("textDone", currentContent.text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                break;
            }
          }
        }
        if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f")) {
          this._emit("messageDone", event.data);
        }
        __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, void 0, "f");
    }
  }, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
    const accumulatedRunStep = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
    __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
    switch (event.event) {
      case "thread.run.step.created":
        this._emit("runStepCreated", event.data);
        break;
      case "thread.run.step.delta":
        const delta = event.data.delta;
        if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
          for (const toolCall of delta.step_details.tool_calls) {
            if (toolCall.index == __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, "f")) {
              this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
            } else {
              if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
                this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
              }
              __classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
              __classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
              if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"))
                this._emit("toolCallCreated", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
            }
          }
        }
        this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
        break;
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
        const details = event.data.step_details;
        if (details.type == "tool_calls") {
          if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
            this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
            __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, "f");
          }
        }
        this._emit("runStepDone", event.data, accumulatedRunStep);
        break;
    }
  }, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
    __classPrivateFieldGet(this, _AssistantStream_events, "f").push(event);
    this._emit("event", event);
  }, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
    switch (event.event) {
      case "thread.run.step.created":
        __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
        return event.data;
      case "thread.run.step.delta":
        let snapshot = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
        if (!snapshot) {
          throw Error("Received a RunStepDelta before creation of a snapshot");
        }
        let data = event.data;
        if (data.delta) {
          const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);
          __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
        }
        return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
      case "thread.run.step.in_progress":
        __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
        break;
    }
    if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
      return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    throw new Error("No snapshot available");
  }, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
    let newContent = [];
    switch (event.event) {
      case "thread.message.created":
        return [event.data, newContent];
      case "thread.message.delta":
        if (!snapshot) {
          throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
        }
        let data = event.data;
        if (data.delta.content) {
          for (const contentElement of data.delta.content) {
            if (contentElement.index in snapshot.content) {
              let currentContent = snapshot.content[contentElement.index];
              snapshot.content[contentElement.index] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
            } else {
              snapshot.content[contentElement.index] = contentElement;
              newContent.push(contentElement);
            }
          }
        }
        return [snapshot, newContent];
      case "thread.message.in_progress":
      case "thread.message.completed":
      case "thread.message.incomplete":
        if (snapshot) {
          return [snapshot, newContent];
        } else {
          throw Error("Received thread message event with no existing snapshot");
        }
    }
    throw Error("Tried to accumulate a non-message event");
  }, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
    return AssistantStream.accumulateDelta(currentContent, contentElement);
  }, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
    __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data, "f");
    switch (event.event) {
      case "thread.run.created":
        break;
      case "thread.run.queued":
        break;
      case "thread.run.in_progress":
        break;
      case "thread.run.requires_action":
      case "thread.run.cancelled":
      case "thread.run.failed":
      case "thread.run.completed":
      case "thread.run.expired":
        __classPrivateFieldSet(this, _AssistantStream_finalRun, event.data, "f");
        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, "f");
        }
        break;
    }
  };
  class Messages extends APIResource {
    /**
     * Create a message.
     */
    create(threadId, body, options) {
      return this._client.post(`/threads/${threadId}/messages`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieve a message.
     */
    retrieve(threadId, messageId, options) {
      return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies a message.
     */
    update(threadId, messageId, body, options) {
      return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(threadId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list(threadId, {}, query);
      }
      return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Deletes a message.
     */
    del(threadId, messageId, options) {
      return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  }
  class MessagesPage extends CursorPage {
  }
  (function(Messages2) {
    Messages2.MessagesPage = MessagesPage;
  })(Messages || (Messages = {}));
  class Steps extends APIResource {
    /**
     * Retrieves a run step.
     */
    retrieve(threadId, runId, stepId, options) {
      return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(threadId, runId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list(threadId, runId, {}, query);
      }
      return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  }
  class RunStepsPage extends CursorPage {
  }
  (function(Steps2) {
    Steps2.RunStepsPage = RunStepsPage;
  })(Steps || (Steps = {}));
  class Runs extends APIResource {
    constructor() {
      super(...arguments);
      this.steps = new Steps(this._client);
    }
    create(threadId, body, options) {
      return this._client.post(`/threads/${threadId}/runs`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
        stream: body.stream ?? false
      });
    }
    /**
     * Retrieves a run.
     */
    retrieve(threadId, runId, options) {
      return this._client.get(`/threads/${threadId}/runs/${runId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies a run.
     */
    update(threadId, runId, body, options) {
      return this._client.post(`/threads/${threadId}/runs/${runId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(threadId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list(threadId, {}, query);
      }
      return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Cancels a run that is `in_progress`.
     */
    cancel(threadId, runId, options) {
      return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * A helper to create a run an poll for a terminal state. More information on Run
     * lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    async createAndPoll(threadId, body, options) {
      const run = await this.create(threadId, body, options);
      return await this.poll(threadId, run.id, options);
    }
    /**
     * Create a Run stream
     *
     * @deprecated use `stream` instead
     */
    createAndStream(threadId, body, options) {
      return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
    }
    /**
     * A helper to poll a run status until it reaches a terminal state. More
     * information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    async poll(threadId, runId, options) {
      const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
      if (options == null ? void 0 : options.pollIntervalMs) {
        headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
      }
      while (true) {
        const { data: run, response } = await this.retrieve(threadId, runId, {
          ...options,
          headers: { ...options == null ? void 0 : options.headers, ...headers }
        }).withResponse();
        switch (run.status) {
          case "queued":
          case "in_progress":
          case "cancelling":
            let sleepInterval = 5e3;
            if (options == null ? void 0 : options.pollIntervalMs) {
              sleepInterval = options.pollIntervalMs;
            } else {
              const headerInterval = response.headers.get("openai-poll-after-ms");
              if (headerInterval) {
                const headerIntervalMs = parseInt(headerInterval);
                if (!isNaN(headerIntervalMs)) {
                  sleepInterval = headerIntervalMs;
                }
              }
            }
            await sleep$1(sleepInterval);
            break;
          case "requires_action":
          case "incomplete":
          case "cancelled":
          case "completed":
          case "failed":
          case "expired":
            return run;
        }
      }
    }
    /**
     * Create a Run stream
     */
    stream(threadId, body, options) {
      return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
    }
    submitToolOutputs(threadId, runId, body, options) {
      return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
        stream: body.stream ?? false
      });
    }
    /**
     * A helper to submit a tool output to a run and poll for a terminal run state.
     * More information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    async submitToolOutputsAndPoll(threadId, runId, body, options) {
      const run = await this.submitToolOutputs(threadId, runId, body, options);
      return await this.poll(threadId, run.id, options);
    }
    /**
     * Submit the tool outputs from a previous run and stream the run to a terminal
     * state. More information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    submitToolOutputsStream(threadId, runId, body, options) {
      return AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);
    }
  }
  class RunsPage extends CursorPage {
  }
  (function(Runs2) {
    Runs2.RunsPage = RunsPage;
    Runs2.Steps = Steps;
    Runs2.RunStepsPage = RunStepsPage;
  })(Runs || (Runs = {}));
  class Threads extends APIResource {
    constructor() {
      super(...arguments);
      this.runs = new Runs(this._client);
      this.messages = new Messages(this._client);
    }
    create(body = {}, options) {
      if (isRequestOptions(body)) {
        return this.create({}, body);
      }
      return this._client.post("/threads", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves a thread.
     */
    retrieve(threadId, options) {
      return this._client.get(`/threads/${threadId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies a thread.
     */
    update(threadId, body, options) {
      return this._client.post(`/threads/${threadId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Delete a thread.
     */
    del(threadId, options) {
      return this._client.delete(`/threads/${threadId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    createAndRun(body, options) {
      return this._client.post("/threads/runs", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers },
        stream: body.stream ?? false
      });
    }
    /**
     * A helper to create a thread, start a run and then poll for a terminal state.
     * More information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */
    async createAndRunPoll(body, options) {
      const run = await this.createAndRun(body, options);
      return await this.runs.poll(run.thread_id, run.id, options);
    }
    /**
     * Create a thread and stream the run back
     */
    createAndRunStream(body, options) {
      return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
    }
  }
  (function(Threads2) {
    Threads2.Runs = Runs;
    Threads2.RunsPage = RunsPage;
    Threads2.Messages = Messages;
    Threads2.MessagesPage = MessagesPage;
  })(Threads || (Threads = {}));
  const allSettledWithThrow = async (promises) => {
    const results = await Promise.allSettled(promises);
    const rejected = results.filter((result) => result.status === "rejected");
    if (rejected.length) {
      for (const result of rejected) {
        console.error(result.reason);
      }
      throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
    }
    const values = [];
    for (const result of results) {
      if (result.status === "fulfilled") {
        values.push(result.value);
      }
    }
    return values;
  };
  let Files$1 = class Files extends APIResource {
    /**
     * Create a vector store file by attaching a
     * [File](https://platform.openai.com/docs/api-reference/files) to a
     * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
     */
    create(vectorStoreId, body, options) {
      return this._client.post(`/vector_stores/${vectorStoreId}/files`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves a vector store file.
     */
    retrieve(vectorStoreId, fileId, options) {
      return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(vectorStoreId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list(vectorStoreId, {}, query);
      }
      return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Delete a vector store file. This will remove the file from the vector store but
     * the file itself will not be deleted. To delete the file, use the
     * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
     * endpoint.
     */
    del(vectorStoreId, fileId, options) {
      return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Attach a file to the given vector store and wait for it to be processed.
     */
    async createAndPoll(vectorStoreId, body, options) {
      const file = await this.create(vectorStoreId, body, options);
      return await this.poll(vectorStoreId, file.id, options);
    }
    /**
     * Wait for the vector store file to finish processing.
     *
     * Note: this will return even if the file failed to process, you need to check
     * file.last_error and file.status to handle these cases
     */
    async poll(vectorStoreId, fileId, options) {
      const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
      if (options == null ? void 0 : options.pollIntervalMs) {
        headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
      }
      while (true) {
        const fileResponse = await this.retrieve(vectorStoreId, fileId, {
          ...options,
          headers
        }).withResponse();
        const file = fileResponse.data;
        switch (file.status) {
          case "in_progress":
            let sleepInterval = 5e3;
            if (options == null ? void 0 : options.pollIntervalMs) {
              sleepInterval = options.pollIntervalMs;
            } else {
              const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
              if (headerInterval) {
                const headerIntervalMs = parseInt(headerInterval);
                if (!isNaN(headerIntervalMs)) {
                  sleepInterval = headerIntervalMs;
                }
              }
            }
            await sleep$1(sleepInterval);
            break;
          case "failed":
          case "completed":
            return file;
        }
      }
    }
    /**
     * Upload a file to the `files` API and then attach it to the given vector store.
     *
     * Note the file will be asynchronously processed (you can use the alternative
     * polling helper method to wait for processing to complete).
     */
    async upload(vectorStoreId, file, options) {
      const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options);
      return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
    }
    /**
     * Add a file to a vector store and poll until processing is complete.
     */
    async uploadAndPoll(vectorStoreId, file, options) {
      const fileInfo = await this.upload(vectorStoreId, file, options);
      return await this.poll(vectorStoreId, fileInfo.id, options);
    }
  };
  class VectorStoreFilesPage extends CursorPage {
  }
  (function(Files2) {
    Files2.VectorStoreFilesPage = VectorStoreFilesPage;
  })(Files$1 || (Files$1 = {}));
  class FileBatches extends APIResource {
    /**
     * Create a vector store file batch.
     */
    create(vectorStoreId, body, options) {
      return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves a vector store file batch.
     */
    retrieve(vectorStoreId, batchId, options) {
      return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Cancel a vector store file batch. This attempts to cancel the processing of
     * files in this batch as soon as possible.
     */
    cancel(vectorStoreId, batchId, options) {
      return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Create a vector store batch and poll until all files have been processed.
     */
    async createAndPoll(vectorStoreId, body, options) {
      const batch = await this.create(vectorStoreId, body);
      return await this.poll(vectorStoreId, batch.id, options);
    }
    listFiles(vectorStoreId, batchId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.listFiles(vectorStoreId, batchId, {}, query);
      }
      return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, VectorStoreFilesPage, { query, ...options, headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers } });
    }
    /**
     * Wait for the given file batch to be processed.
     *
     * Note: this will return even if one of the files failed to process, you need to
     * check batch.file_counts.failed_count to handle this case.
     */
    async poll(vectorStoreId, batchId, options) {
      const headers = { ...options == null ? void 0 : options.headers, "X-Stainless-Poll-Helper": "true" };
      if (options == null ? void 0 : options.pollIntervalMs) {
        headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
      }
      while (true) {
        const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {
          ...options,
          headers
        }).withResponse();
        switch (batch.status) {
          case "in_progress":
            let sleepInterval = 5e3;
            if (options == null ? void 0 : options.pollIntervalMs) {
              sleepInterval = options.pollIntervalMs;
            } else {
              const headerInterval = response.headers.get("openai-poll-after-ms");
              if (headerInterval) {
                const headerIntervalMs = parseInt(headerInterval);
                if (!isNaN(headerIntervalMs)) {
                  sleepInterval = headerIntervalMs;
                }
              }
            }
            await sleep$1(sleepInterval);
            break;
          case "failed":
          case "cancelled":
          case "completed":
            return batch;
        }
      }
    }
    /**
     * Uploads the given files concurrently and then creates a vector store file batch.
     *
     * The concurrency limit is configurable using the `maxConcurrency` parameter.
     */
    async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
      if (files == null || files.length == 0) {
        throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
      }
      const configuredConcurrency = (options == null ? void 0 : options.maxConcurrency) ?? 5;
      const concurrencyLimit = Math.min(configuredConcurrency, files.length);
      const client = this._client;
      const fileIterator = files.values();
      const allFileIds = [...fileIds];
      async function processFiles(iterator2) {
        for (let item of iterator2) {
          const fileObj = await client.files.create({ file: item, purpose: "assistants" }, options);
          allFileIds.push(fileObj.id);
        }
      }
      const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
      await allSettledWithThrow(workers);
      return await this.createAndPoll(vectorStoreId, {
        file_ids: allFileIds
      });
    }
  }
  /* @__PURE__ */ (function(FileBatches2) {
  })(FileBatches || (FileBatches = {}));
  class VectorStores extends APIResource {
    constructor() {
      super(...arguments);
      this.files = new Files$1(this._client);
      this.fileBatches = new FileBatches(this._client);
    }
    /**
     * Create a vector store.
     */
    create(body, options) {
      return this._client.post("/vector_stores", {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Retrieves a vector store.
     */
    retrieve(vectorStoreId, options) {
      return this._client.get(`/vector_stores/${vectorStoreId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Modifies a vector store.
     */
    update(vectorStoreId, body, options) {
      return this._client.post(`/vector_stores/${vectorStoreId}`, {
        body,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    list(query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/vector_stores", VectorStoresPage, {
        query,
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Delete a vector store.
     */
    del(vectorStoreId, options) {
      return this._client.delete(`/vector_stores/${vectorStoreId}`, {
        ...options,
        headers: { "OpenAI-Beta": "assistants=v2", ...options == null ? void 0 : options.headers }
      });
    }
  }
  class VectorStoresPage extends CursorPage {
  }
  (function(VectorStores2) {
    VectorStores2.VectorStoresPage = VectorStoresPage;
    VectorStores2.Files = Files$1;
    VectorStores2.VectorStoreFilesPage = VectorStoreFilesPage;
    VectorStores2.FileBatches = FileBatches;
  })(VectorStores || (VectorStores = {}));
  class Beta extends APIResource {
    constructor() {
      super(...arguments);
      this.vectorStores = new VectorStores(this._client);
      this.chat = new Chat(this._client);
      this.assistants = new Assistants(this._client);
      this.threads = new Threads(this._client);
    }
  }
  (function(Beta2) {
    Beta2.VectorStores = VectorStores;
    Beta2.VectorStoresPage = VectorStoresPage;
    Beta2.Chat = Chat;
    Beta2.Assistants = Assistants;
    Beta2.AssistantsPage = AssistantsPage;
    Beta2.Threads = Threads;
  })(Beta || (Beta = {}));
  class Completions extends APIResource {
    create(body, options) {
      return this._client.post("/completions", { body, ...options, stream: body.stream ?? false });
    }
  }
  /* @__PURE__ */ (function(Completions2) {
  })(Completions || (Completions = {}));
  class Embeddings extends APIResource {
    /**
     * Creates an embedding vector representing the input text.
     */
    create(body, options) {
      return this._client.post("/embeddings", { body, ...options });
    }
  }
  /* @__PURE__ */ (function(Embeddings2) {
  })(Embeddings || (Embeddings = {}));
  class Files extends APIResource {
    /**
     * Upload a file that can be used across various endpoints. Individual files can be
     * up to 512 MB, and the size of all files uploaded by one organization can be up
     * to 100 GB.
     *
     * The Assistants API supports files up to 2 million tokens and of specific file
     * types. See the
     * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
     * details.
     *
     * The Fine-tuning API only supports `.jsonl` files. The input also has certain
     * required formats for fine-tuning
     * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
     * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
     * models.
     *
     * The Batch API only supports `.jsonl` files up to 100 MB in size. The input also
     * has a specific required
     * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
     *
     * Please [contact us](https://help.openai.com/) if you need to increase these
     * storage limits.
     */
    create(body, options) {
      return this._client.post("/files", multipartFormRequestOptions({ body, ...options }));
    }
    /**
     * Returns information about a specific file.
     */
    retrieve(fileId, options) {
      return this._client.get(`/files/${fileId}`, options);
    }
    list(query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/files", FileObjectsPage, { query, ...options });
    }
    /**
     * Delete a file.
     */
    del(fileId, options) {
      return this._client.delete(`/files/${fileId}`, options);
    }
    /**
     * Returns the contents of the specified file.
     */
    content(fileId, options) {
      return this._client.get(`/files/${fileId}/content`, { ...options, __binaryResponse: true });
    }
    /**
     * Returns the contents of the specified file.
     *
     * @deprecated The `.content()` method should be used instead
     */
    retrieveContent(fileId, options) {
      return this._client.get(`/files/${fileId}/content`, {
        ...options,
        headers: { Accept: "application/json", ...options == null ? void 0 : options.headers }
      });
    }
    /**
     * Waits for the given file to be processed, default timeout is 30 mins.
     */
    async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
      const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
      const start = Date.now();
      let file = await this.retrieve(id);
      while (!file.status || !TERMINAL_STATES.has(file.status)) {
        await sleep$1(pollInterval);
        file = await this.retrieve(id);
        if (Date.now() - start > maxWait) {
          throw new APIConnectionTimeoutError({
            message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
          });
        }
      }
      return file;
    }
  }
  class FileObjectsPage extends Page {
  }
  (function(Files2) {
    Files2.FileObjectsPage = FileObjectsPage;
  })(Files || (Files = {}));
  class Checkpoints extends APIResource {
    list(fineTuningJobId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list(fineTuningJobId, {}, query);
      }
      return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage, { query, ...options });
    }
  }
  class FineTuningJobCheckpointsPage extends CursorPage {
  }
  (function(Checkpoints2) {
    Checkpoints2.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;
  })(Checkpoints || (Checkpoints = {}));
  class Jobs extends APIResource {
    constructor() {
      super(...arguments);
      this.checkpoints = new Checkpoints(this._client);
    }
    /**
     * Creates a fine-tuning job which begins the process of creating a new model from
     * a given dataset.
     *
     * Response includes details of the enqueued job including job status and the name
     * of the fine-tuned models once complete.
     *
     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
     */
    create(body, options) {
      return this._client.post("/fine_tuning/jobs", { body, ...options });
    }
    /**
     * Get info about a fine-tuning job.
     *
     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
     */
    retrieve(fineTuningJobId, options) {
      return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
    }
    list(query = {}, options) {
      if (isRequestOptions(query)) {
        return this.list({}, query);
      }
      return this._client.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options });
    }
    /**
     * Immediately cancel a fine-tune job.
     */
    cancel(fineTuningJobId, options) {
      return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
    }
    listEvents(fineTuningJobId, query = {}, options) {
      if (isRequestOptions(query)) {
        return this.listEvents(fineTuningJobId, {}, query);
      }
      return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
        query,
        ...options
      });
    }
  }
  class FineTuningJobsPage extends CursorPage {
  }
  class FineTuningJobEventsPage extends CursorPage {
  }
  (function(Jobs2) {
    Jobs2.FineTuningJobsPage = FineTuningJobsPage;
    Jobs2.FineTuningJobEventsPage = FineTuningJobEventsPage;
    Jobs2.Checkpoints = Checkpoints;
    Jobs2.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;
  })(Jobs || (Jobs = {}));
  class FineTuning extends APIResource {
    constructor() {
      super(...arguments);
      this.jobs = new Jobs(this._client);
    }
  }
  (function(FineTuning2) {
    FineTuning2.Jobs = Jobs;
    FineTuning2.FineTuningJobsPage = FineTuningJobsPage;
    FineTuning2.FineTuningJobEventsPage = FineTuningJobEventsPage;
  })(FineTuning || (FineTuning = {}));
  class Images extends APIResource {
    /**
     * Creates a variation of a given image.
     */
    createVariation(body, options) {
      return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options }));
    }
    /**
     * Creates an edited or extended image given an original image and a prompt.
     */
    edit(body, options) {
      return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options }));
    }
    /**
     * Creates an image given a prompt.
     */
    generate(body, options) {
      return this._client.post("/images/generations", { body, ...options });
    }
  }
  /* @__PURE__ */ (function(Images2) {
  })(Images || (Images = {}));
  class Models extends APIResource {
    /**
     * Retrieves a model instance, providing basic information about the model such as
     * the owner and permissioning.
     */
    retrieve(model, options) {
      return this._client.get(`/models/${model}`, options);
    }
    /**
     * Lists the currently available models, and provides basic information about each
     * one such as the owner and availability.
     */
    list(options) {
      return this._client.getAPIList("/models", ModelsPage, options);
    }
    /**
     * Delete a fine-tuned model. You must have the Owner role in your organization to
     * delete a model.
     */
    del(model, options) {
      return this._client.delete(`/models/${model}`, options);
    }
  }
  class ModelsPage extends Page {
  }
  (function(Models2) {
    Models2.ModelsPage = ModelsPage;
  })(Models || (Models = {}));
  class Moderations extends APIResource {
    /**
     * Classifies if text is potentially harmful.
     */
    create(body, options) {
      return this._client.post("/moderations", { body, ...options });
    }
  }
  /* @__PURE__ */ (function(Moderations2) {
  })(Moderations || (Moderations = {}));
  class Parts extends APIResource {
    /**
     * Adds a
     * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
     * A Part represents a chunk of bytes from the file you are trying to upload.
     *
     * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
     * maximum of 8 GB.
     *
     * It is possible to add multiple Parts in parallel. You can decide the intended
     * order of the Parts when you
     * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
     */
    create(uploadId, body, options) {
      return this._client.post(`/uploads/${uploadId}/parts`, multipartFormRequestOptions({ body, ...options }));
    }
  }
  /* @__PURE__ */ (function(Parts2) {
  })(Parts || (Parts = {}));
  class Uploads extends APIResource {
    constructor() {
      super(...arguments);
      this.parts = new Parts(this._client);
    }
    /**
     * Creates an intermediate
     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
     * that you can add
     * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
     * Currently, an Upload can accept at most 8 GB in total and expires after an hour
     * after you create it.
     *
     * Once you complete the Upload, we will create a
     * [File](https://platform.openai.com/docs/api-reference/files/object) object that
     * contains all the parts you uploaded. This File is usable in the rest of our
     * platform as a regular File object.
     *
     * For certain `purpose`s, the correct `mime_type` must be specified. Please refer
     * to documentation for the supported MIME types for your use case:
     *
     * - [Assistants](https://platform.openai.com/docs/assistants/tools/file-search/supported-files)
     *
     * For guidance on the proper filename extensions for each purpose, please follow
     * the documentation on
     * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
     */
    create(body, options) {
      return this._client.post("/uploads", { body, ...options });
    }
    /**
     * Cancels the Upload. No Parts may be added after an Upload is cancelled.
     */
    cancel(uploadId, options) {
      return this._client.post(`/uploads/${uploadId}/cancel`, options);
    }
    /**
     * Completes the
     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
     *
     * Within the returned Upload object, there is a nested
     * [File](https://platform.openai.com/docs/api-reference/files/object) object that
     * is ready to use in the rest of the platform.
     *
     * You can specify the order of the Parts by passing in an ordered list of the Part
     * IDs.
     *
     * The number of bytes uploaded upon completion must match the number of bytes
     * initially specified when creating the Upload object. No Parts may be added after
     * an Upload is completed.
     */
    complete(uploadId, body, options) {
      return this._client.post(`/uploads/${uploadId}/complete`, { body, ...options });
    }
  }
  (function(Uploads2) {
    Uploads2.Parts = Parts;
  })(Uploads || (Uploads = {}));
  var _a;
  class OpenAI extends APIClient {
    /**
     * API Client for interfacing with the OpenAI API.
     *
     * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
     * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
     * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
     * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
     */
    constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = readEnv("OPENAI_ORG_ID") ?? null, project = readEnv("OPENAI_PROJECT_ID") ?? null, ...opts } = {}) {
      if (apiKey === void 0) {
        throw new OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
      }
      const options = {
        apiKey,
        organization,
        project,
        ...opts,
        baseURL: baseURL || `https://api.openai.com/v1`
      };
      if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
        throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
      }
      super({
        baseURL: options.baseURL,
        timeout: options.timeout ?? 6e5,
        httpAgent: options.httpAgent,
        maxRetries: options.maxRetries,
        fetch: options.fetch
      });
      this.completions = new Completions(this);
      this.chat = new Chat$1(this);
      this.embeddings = new Embeddings(this);
      this.files = new Files(this);
      this.images = new Images(this);
      this.audio = new Audio(this);
      this.moderations = new Moderations(this);
      this.models = new Models(this);
      this.fineTuning = new FineTuning(this);
      this.beta = new Beta(this);
      this.batches = new Batches(this);
      this.uploads = new Uploads(this);
      this._options = options;
      this.apiKey = apiKey;
      this.organization = organization;
      this.project = project;
    }
    defaultQuery() {
      return this._options.defaultQuery;
    }
    defaultHeaders(opts) {
      return {
        ...super.defaultHeaders(opts),
        "OpenAI-Organization": this.organization,
        "OpenAI-Project": this.project,
        ...this._options.defaultHeaders
      };
    }
    authHeaders(opts) {
      return { Authorization: `Bearer ${this.apiKey}` };
    }
  }
  _a = OpenAI;
  OpenAI.OpenAI = _a;
  OpenAI.DEFAULT_TIMEOUT = 6e5;
  OpenAI.OpenAIError = OpenAIError;
  OpenAI.APIError = APIError;
  OpenAI.APIConnectionError = APIConnectionError;
  OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
  OpenAI.APIUserAbortError = APIUserAbortError;
  OpenAI.NotFoundError = NotFoundError;
  OpenAI.ConflictError = ConflictError;
  OpenAI.RateLimitError = RateLimitError;
  OpenAI.BadRequestError = BadRequestError;
  OpenAI.AuthenticationError = AuthenticationError;
  OpenAI.InternalServerError = InternalServerError;
  OpenAI.PermissionDeniedError = PermissionDeniedError;
  OpenAI.UnprocessableEntityError = UnprocessableEntityError;
  OpenAI.toFile = toFile;
  OpenAI.fileFromPath = fileFromPath;
  (function(OpenAI2) {
    OpenAI2.Page = Page;
    OpenAI2.CursorPage = CursorPage;
    OpenAI2.Completions = Completions;
    OpenAI2.Chat = Chat$1;
    OpenAI2.Embeddings = Embeddings;
    OpenAI2.Files = Files;
    OpenAI2.FileObjectsPage = FileObjectsPage;
    OpenAI2.Images = Images;
    OpenAI2.Audio = Audio;
    OpenAI2.Moderations = Moderations;
    OpenAI2.Models = Models;
    OpenAI2.ModelsPage = ModelsPage;
    OpenAI2.FineTuning = FineTuning;
    OpenAI2.Beta = Beta;
    OpenAI2.Batches = Batches;
    OpenAI2.BatchesPage = BatchesPage;
    OpenAI2.Uploads = Uploads;
  })(OpenAI || (OpenAI = {}));
  var isVue2 = false;
  /*!
   * pinia v2.2.4
   * (c) 2024 Eduardo San Martin Morote
   * @license MIT
   */
  let activePinia;
  const setActivePinia = (pinia) => activePinia = pinia;
  const piniaSymbol = (
    /* istanbul ignore next */
    Symbol()
  );
  function isPlainObject(o) {
    return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
  }
  var MutationType;
  (function(MutationType2) {
    MutationType2["direct"] = "direct";
    MutationType2["patchObject"] = "patch object";
    MutationType2["patchFunction"] = "patch function";
  })(MutationType || (MutationType = {}));
  function createPinia() {
    const scope = effectScope(true);
    const state = scope.run(() => ref({}));
    let _p = [];
    let toBeInstalled = [];
    const pinia = markRaw({
      install(app) {
        setActivePinia(pinia);
        {
          pinia._a = app;
          app.provide(piniaSymbol, pinia);
          app.config.globalProperties.$pinia = pinia;
          toBeInstalled.forEach((plugin) => _p.push(plugin));
          toBeInstalled = [];
        }
      },
      use(plugin) {
        if (!this._a && !isVue2) {
          toBeInstalled.push(plugin);
        } else {
          _p.push(plugin);
        }
        return this;
      },
      _p,
      // it's actually undefined here
      // @ts-expect-error
      _a: null,
      _e: scope,
      _s: /* @__PURE__ */ new Map(),
      state
    });
    return pinia;
  }
  const noop = () => {
  };
  function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
    subscriptions.push(callback);
    const removeSubscription = () => {
      const idx = subscriptions.indexOf(callback);
      if (idx > -1) {
        subscriptions.splice(idx, 1);
        onCleanup();
      }
    };
    if (!detached && getCurrentScope()) {
      onScopeDispose(removeSubscription);
    }
    return removeSubscription;
  }
  function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.slice().forEach((callback) => {
      callback(...args);
    });
  }
  const fallbackRunWithContext = (fn) => fn();
  const ACTION_MARKER = Symbol();
  const ACTION_NAME = Symbol();
  function mergeReactiveObjects(target, patchToApply) {
    if (target instanceof Map && patchToApply instanceof Map) {
      patchToApply.forEach((value, key) => target.set(key, value));
    } else if (target instanceof Set && patchToApply instanceof Set) {
      patchToApply.forEach(target.add, target);
    }
    for (const key in patchToApply) {
      if (!patchToApply.hasOwnProperty(key))
        continue;
      const subPatch = patchToApply[key];
      const targetValue = target[key];
      if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !isRef$1(subPatch) && !isReactive(subPatch)) {
        target[key] = mergeReactiveObjects(targetValue, subPatch);
      } else {
        target[key] = subPatch;
      }
    }
    return target;
  }
  const skipHydrateSymbol = (
    /* istanbul ignore next */
    Symbol()
  );
  function shouldHydrate(obj) {
    return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
  }
  const { assign } = Object;
  function isComputed(o) {
    return !!(isRef$1(o) && o.effect);
  }
  function createOptionsStore(id, options, pinia, hot) {
    const { state, actions, getters } = options;
    const initialState = pinia.state.value[id];
    let store;
    function setup() {
      if (!initialState && true) {
        {
          pinia.state.value[id] = state ? state() : {};
        }
      }
      const localState = toRefs(pinia.state.value[id]);
      return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
        computedGetters[name] = markRaw(computed(() => {
          setActivePinia(pinia);
          const store2 = pinia._s.get(id);
          return getters[name].call(store2, store2);
        }));
        return computedGetters;
      }, {}));
    }
    store = createSetupStore(id, setup, options, pinia, hot, true);
    return store;
  }
  function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign({ actions: {} }, options);
    const $subscribeOptions = { deep: true };
    let isListening;
    let isSyncListening;
    let subscriptions = [];
    let actionSubscriptions = [];
    let debuggerEvents;
    const initialState = pinia.state.value[$id];
    if (!isOptionsStore && !initialState && true) {
      {
        pinia.state.value[$id] = {};
      }
    }
    ref({});
    let activeListener;
    function $patch(partialStateOrMutator) {
      let subscriptionMutation;
      isListening = isSyncListening = false;
      if (typeof partialStateOrMutator === "function") {
        partialStateOrMutator(pinia.state.value[$id]);
        subscriptionMutation = {
          type: MutationType.patchFunction,
          storeId: $id,
          events: debuggerEvents
        };
      } else {
        mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
        subscriptionMutation = {
          type: MutationType.patchObject,
          payload: partialStateOrMutator,
          storeId: $id,
          events: debuggerEvents
        };
      }
      const myListenerId = activeListener = Symbol();
      nextTick().then(() => {
        if (activeListener === myListenerId) {
          isListening = true;
        }
      });
      isSyncListening = true;
      triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
    }
    const $reset = isOptionsStore ? function $reset2() {
      const { state } = options;
      const newState = state ? state() : {};
      this.$patch(($state) => {
        assign($state, newState);
      });
    } : (
      /* istanbul ignore next */
      noop
    );
    function $dispose() {
      scope.stop();
      subscriptions = [];
      actionSubscriptions = [];
      pinia._s.delete($id);
    }
    const action = (fn, name = "") => {
      if (ACTION_MARKER in fn) {
        fn[ACTION_NAME] = name;
        return fn;
      }
      const wrappedAction = function() {
        setActivePinia(pinia);
        const args = Array.from(arguments);
        const afterCallbackList = [];
        const onErrorCallbackList = [];
        function after(callback) {
          afterCallbackList.push(callback);
        }
        function onError(callback) {
          onErrorCallbackList.push(callback);
        }
        triggerSubscriptions(actionSubscriptions, {
          args,
          name: wrappedAction[ACTION_NAME],
          store,
          after,
          onError
        });
        let ret;
        try {
          ret = fn.apply(this && this.$id === $id ? this : store, args);
        } catch (error) {
          triggerSubscriptions(onErrorCallbackList, error);
          throw error;
        }
        if (ret instanceof Promise) {
          return ret.then((value) => {
            triggerSubscriptions(afterCallbackList, value);
            return value;
          }).catch((error) => {
            triggerSubscriptions(onErrorCallbackList, error);
            return Promise.reject(error);
          });
        }
        triggerSubscriptions(afterCallbackList, ret);
        return ret;
      };
      wrappedAction[ACTION_MARKER] = true;
      wrappedAction[ACTION_NAME] = name;
      return wrappedAction;
    };
    const partialStore = {
      _p: pinia,
      // _s: scope,
      $id,
      $onAction: addSubscription.bind(null, actionSubscriptions),
      $patch,
      $reset,
      $subscribe(callback, options2 = {}) {
        const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
        const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {
          if (options2.flush === "sync" ? isSyncListening : isListening) {
            callback({
              storeId: $id,
              type: MutationType.direct,
              events: debuggerEvents
            }, state);
          }
        }, assign({}, $subscribeOptions, options2)));
        return removeSubscription;
      },
      $dispose
    };
    const store = reactive(partialStore);
    pinia._s.set($id, store);
    const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
    const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(() => setup({ action }))));
    for (const key in setupStore) {
      const prop = setupStore[key];
      if (isRef$1(prop) && !isComputed(prop) || isReactive(prop)) {
        if (!isOptionsStore) {
          if (initialState && shouldHydrate(prop)) {
            if (isRef$1(prop)) {
              prop.value = initialState[key];
            } else {
              mergeReactiveObjects(prop, initialState[key]);
            }
          }
          {
            pinia.state.value[$id][key] = prop;
          }
        }
      } else if (typeof prop === "function") {
        const actionValue = action(prop, key);
        {
          setupStore[key] = actionValue;
        }
        optionsForPlugin.actions[key] = prop;
      } else ;
    }
    {
      assign(store, setupStore);
      assign(toRaw(store), setupStore);
    }
    Object.defineProperty(store, "$state", {
      get: () => pinia.state.value[$id],
      set: (state) => {
        $patch(($state) => {
          assign($state, state);
        });
      }
    });
    pinia._p.forEach((extender) => {
      {
        assign(store, scope.run(() => extender({
          store,
          app: pinia._a,
          pinia,
          options: optionsForPlugin
        })));
      }
    });
    if (initialState && isOptionsStore && options.hydrate) {
      options.hydrate(store.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store;
  }
  // @__NO_SIDE_EFFECTS__
  function defineStore(idOrOptions, setup, setupOptions) {
    let id;
    let options;
    const isSetupStore = typeof setup === "function";
    {
      id = idOrOptions;
      options = isSetupStore ? setupOptions : setup;
    }
    function useStore(pinia, hot) {
      const hasContext = hasInjectionContext();
      pinia = // in test mode, ignore the argument provided as we can always retrieve a
      // pinia instance with getActivePinia()
      pinia || (hasContext ? inject(piniaSymbol, null) : null);
      if (pinia)
        setActivePinia(pinia);
      pinia = activePinia;
      if (!pinia._s.has(id)) {
        if (isSetupStore) {
          createSetupStore(id, setup, options, pinia);
        } else {
          createOptionsStore(id, options, pinia);
        }
      }
      const store = pinia._s.get(id);
      return store;
    }
    useStore.$id = id;
    return useStore;
  }
  function isPromise(obj) {
    return obj && typeof obj.then === "function";
  }
  Promise.resolve(false);
  Promise.resolve(true);
  var PROMISE_RESOLVED_VOID = Promise.resolve();
  function sleep(time, resolveWith) {
    if (!time) time = 0;
    return new Promise(function(res) {
      return setTimeout(function() {
        return res(resolveWith);
      }, time);
    });
  }
  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
  }
  function randomToken() {
    return Math.random().toString(36).substring(2);
  }
  var lastMs = 0;
  function microSeconds$4() {
    var ret = Date.now() * 1e3;
    if (ret <= lastMs) {
      ret = lastMs + 1;
    }
    lastMs = ret;
    return ret;
  }
  var microSeconds$3 = microSeconds$4;
  var type$3 = "native";
  function create$3(channelName) {
    var state = {
      time: microSeconds$4(),
      messagesCallback: null,
      bc: new BroadcastChannel(channelName),
      subFns: []
      // subscriberFunctions
    };
    state.bc.onmessage = function(msgEvent) {
      if (state.messagesCallback) {
        state.messagesCallback(msgEvent.data);
      }
    };
    return state;
  }
  function close$3(channelState) {
    channelState.bc.close();
    channelState.subFns = [];
  }
  function postMessage$3(channelState, messageJson) {
    try {
      channelState.bc.postMessage(messageJson, false);
      return PROMISE_RESOLVED_VOID;
    } catch (err) {
      return Promise.reject(err);
    }
  }
  function onMessage$3(channelState, fn) {
    channelState.messagesCallback = fn;
  }
  function canBeUsed$3() {
    if (typeof globalThis !== "undefined" && globalThis.Deno && globalThis.Deno.args) {
      return true;
    }
    if ((typeof window !== "undefined" || typeof self !== "undefined") && typeof BroadcastChannel === "function") {
      if (BroadcastChannel._pubkey) {
        throw new Error("BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill");
      }
      return true;
    } else {
      return false;
    }
  }
  function averageResponseTime$3() {
    return 150;
  }
  var NativeMethod = {
    create: create$3,
    close: close$3,
    onMessage: onMessage$3,
    postMessage: postMessage$3,
    canBeUsed: canBeUsed$3,
    type: type$3,
    averageResponseTime: averageResponseTime$3,
    microSeconds: microSeconds$3
  };
  class ObliviousSet {
    constructor(ttl) {
      __publicField(this, "ttl");
      __publicField(this, "map", /* @__PURE__ */ new Map());
      /**
       * Creating calls to setTimeout() is expensive,
       * so we only do that if there is not timeout already open.
       */
      __publicField(this, "_to", false);
      this.ttl = ttl;
    }
    has(value) {
      return this.map.has(value);
    }
    add(value) {
      this.map.set(value, now());
      if (!this._to) {
        this._to = true;
        setTimeout(() => {
          this._to = false;
          removeTooOldValues(this);
        }, 0);
      }
    }
    clear() {
      this.map.clear();
    }
  }
  function removeTooOldValues(obliviousSet) {
    const olderThen = now() - obliviousSet.ttl;
    const iterator2 = obliviousSet.map[Symbol.iterator]();
    while (true) {
      const next = iterator2.next().value;
      if (!next) {
        return;
      }
      const value = next[0];
      const time = next[1];
      if (time < olderThen) {
        obliviousSet.map.delete(value);
      } else {
        return;
      }
    }
  }
  function now() {
    return Date.now();
  }
  function fillOptionsWithDefaults() {
    var originalOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var options = JSON.parse(JSON.stringify(originalOptions));
    if (typeof options.webWorkerSupport === "undefined") options.webWorkerSupport = true;
    if (!options.idb) options.idb = {};
    if (!options.idb.ttl) options.idb.ttl = 1e3 * 45;
    if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;
    if (originalOptions.idb && typeof originalOptions.idb.onclose === "function") options.idb.onclose = originalOptions.idb.onclose;
    if (!options.localstorage) options.localstorage = {};
    if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1e3 * 60;
    if (originalOptions.methods) options.methods = originalOptions.methods;
    if (!options.node) options.node = {};
    if (!options.node.ttl) options.node.ttl = 1e3 * 60 * 2;
    if (!options.node.maxParallelWrites) options.node.maxParallelWrites = 2048;
    if (typeof options.node.useFastPath === "undefined") options.node.useFastPath = true;
    return options;
  }
  var microSeconds$2 = microSeconds$4;
  var DB_PREFIX = "pubkey.broadcast-channel-0-";
  var OBJECT_STORE_ID = "messages";
  var TRANSACTION_SETTINGS = {
    durability: "relaxed"
  };
  var type$2 = "idb";
  function getIdb() {
    if (typeof indexedDB !== "undefined") return indexedDB;
    if (typeof window !== "undefined") {
      if (typeof window.mozIndexedDB !== "undefined") return window.mozIndexedDB;
      if (typeof window.webkitIndexedDB !== "undefined") return window.webkitIndexedDB;
      if (typeof window.msIndexedDB !== "undefined") return window.msIndexedDB;
    }
    return false;
  }
  function commitIndexedDBTransaction(tx) {
    if (tx.commit) {
      tx.commit();
    }
  }
  function createDatabase(channelName) {
    var IndexedDB = getIdb();
    var dbName = DB_PREFIX + channelName;
    var openRequest = IndexedDB.open(dbName);
    openRequest.onupgradeneeded = function(ev) {
      var db = ev.target.result;
      db.createObjectStore(OBJECT_STORE_ID, {
        keyPath: "id",
        autoIncrement: true
      });
    };
    return new Promise(function(res, rej) {
      openRequest.onerror = function(ev) {
        return rej(ev);
      };
      openRequest.onsuccess = function() {
        res(openRequest.result);
      };
    });
  }
  function writeMessage(db, readerUuid, messageJson) {
    var time = Date.now();
    var writeObject = {
      uuid: readerUuid,
      time,
      data: messageJson
    };
    var tx = db.transaction([OBJECT_STORE_ID], "readwrite", TRANSACTION_SETTINGS);
    return new Promise(function(res, rej) {
      tx.oncomplete = function() {
        return res();
      };
      tx.onerror = function(ev) {
        return rej(ev);
      };
      var objectStore = tx.objectStore(OBJECT_STORE_ID);
      objectStore.add(writeObject);
      commitIndexedDBTransaction(tx);
    });
  }
  function getMessagesHigherThan(db, lastCursorId) {
    var tx = db.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
    var objectStore = tx.objectStore(OBJECT_STORE_ID);
    var ret = [];
    var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
    if (objectStore.getAll) {
      var getAllRequest = objectStore.getAll(keyRangeValue);
      return new Promise(function(res, rej) {
        getAllRequest.onerror = function(err) {
          return rej(err);
        };
        getAllRequest.onsuccess = function(e) {
          res(e.target.result);
        };
      });
    }
    function openCursor() {
      try {
        keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
        return objectStore.openCursor(keyRangeValue);
      } catch (e) {
        return objectStore.openCursor();
      }
    }
    return new Promise(function(res, rej) {
      var openCursorRequest = openCursor();
      openCursorRequest.onerror = function(err) {
        return rej(err);
      };
      openCursorRequest.onsuccess = function(ev) {
        var cursor = ev.target.result;
        if (cursor) {
          if (cursor.value.id < lastCursorId + 1) {
            cursor["continue"](lastCursorId + 1);
          } else {
            ret.push(cursor.value);
            cursor["continue"]();
          }
        } else {
          commitIndexedDBTransaction(tx);
          res(ret);
        }
      };
    });
  }
  function removeMessagesById(channelState, ids) {
    if (channelState.closed) {
      return Promise.resolve([]);
    }
    var tx = channelState.db.transaction(OBJECT_STORE_ID, "readwrite", TRANSACTION_SETTINGS);
    var objectStore = tx.objectStore(OBJECT_STORE_ID);
    return Promise.all(ids.map(function(id) {
      var deleteRequest = objectStore["delete"](id);
      return new Promise(function(res) {
        deleteRequest.onsuccess = function() {
          return res();
        };
      });
    }));
  }
  function getOldMessages(db, ttl) {
    var olderThen = Date.now() - ttl;
    var tx = db.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
    var objectStore = tx.objectStore(OBJECT_STORE_ID);
    var ret = [];
    return new Promise(function(res) {
      objectStore.openCursor().onsuccess = function(ev) {
        var cursor = ev.target.result;
        if (cursor) {
          var msgObk = cursor.value;
          if (msgObk.time < olderThen) {
            ret.push(msgObk);
            cursor["continue"]();
          } else {
            commitIndexedDBTransaction(tx);
            res(ret);
          }
        } else {
          res(ret);
        }
      };
    });
  }
  function cleanOldMessages(channelState) {
    return getOldMessages(channelState.db, channelState.options.idb.ttl).then(function(tooOld) {
      return removeMessagesById(channelState, tooOld.map(function(msg) {
        return msg.id;
      }));
    });
  }
  function create$2(channelName, options) {
    options = fillOptionsWithDefaults(options);
    return createDatabase(channelName).then(function(db) {
      var state = {
        closed: false,
        lastCursorId: 0,
        channelName,
        options,
        uuid: randomToken(),
        /**
         * emittedMessagesIds
         * contains all messages that have been emitted before
         * @type {ObliviousSet}
         */
        eMIs: new ObliviousSet(options.idb.ttl * 2),
        // ensures we do not read messages in parallel
        writeBlockPromise: PROMISE_RESOLVED_VOID,
        messagesCallback: null,
        readQueuePromises: [],
        db
      };
      db.onclose = function() {
        state.closed = true;
        if (options.idb.onclose) options.idb.onclose();
      };
      _readLoop(state);
      return state;
    });
  }
  function _readLoop(state) {
    if (state.closed) return;
    readNewMessages(state).then(function() {
      return sleep(state.options.idb.fallbackInterval);
    }).then(function() {
      return _readLoop(state);
    });
  }
  function _filterMessage(msgObj, state) {
    if (msgObj.uuid === state.uuid) return false;
    if (state.eMIs.has(msgObj.id)) return false;
    if (msgObj.data.time < state.messagesCallbackTime) return false;
    return true;
  }
  function readNewMessages(state) {
    if (state.closed) return PROMISE_RESOLVED_VOID;
    if (!state.messagesCallback) return PROMISE_RESOLVED_VOID;
    return getMessagesHigherThan(state.db, state.lastCursorId).then(function(newerMessages) {
      var useMessages = newerMessages.filter(function(msgObj) {
        return !!msgObj;
      }).map(function(msgObj) {
        if (msgObj.id > state.lastCursorId) {
          state.lastCursorId = msgObj.id;
        }
        return msgObj;
      }).filter(function(msgObj) {
        return _filterMessage(msgObj, state);
      }).sort(function(msgObjA, msgObjB) {
        return msgObjA.time - msgObjB.time;
      });
      useMessages.forEach(function(msgObj) {
        if (state.messagesCallback) {
          state.eMIs.add(msgObj.id);
          state.messagesCallback(msgObj.data);
        }
      });
      return PROMISE_RESOLVED_VOID;
    });
  }
  function close$2(channelState) {
    channelState.closed = true;
    channelState.db.close();
  }
  function postMessage$2(channelState, messageJson) {
    channelState.writeBlockPromise = channelState.writeBlockPromise.then(function() {
      return writeMessage(channelState.db, channelState.uuid, messageJson);
    }).then(function() {
      if (randomInt(0, 10) === 0) {
        cleanOldMessages(channelState);
      }
    });
    return channelState.writeBlockPromise;
  }
  function onMessage$2(channelState, fn, time) {
    channelState.messagesCallbackTime = time;
    channelState.messagesCallback = fn;
    readNewMessages(channelState);
  }
  function canBeUsed$2() {
    return !!getIdb();
  }
  function averageResponseTime$2(options) {
    return options.idb.fallbackInterval * 2;
  }
  var IndexedDBMethod = {
    create: create$2,
    close: close$2,
    onMessage: onMessage$2,
    postMessage: postMessage$2,
    canBeUsed: canBeUsed$2,
    type: type$2,
    averageResponseTime: averageResponseTime$2,
    microSeconds: microSeconds$2
  };
  var microSeconds$1 = microSeconds$4;
  var KEY_PREFIX = "pubkey.broadcastChannel-";
  var type$1 = "localstorage";
  function getLocalStorage() {
    var localStorage;
    if (typeof window === "undefined") return null;
    try {
      localStorage = window.localStorage;
      localStorage = window["ie8-eventlistener/storage"] || window.localStorage;
    } catch (e) {
    }
    return localStorage;
  }
  function storageKey(channelName) {
    return KEY_PREFIX + channelName;
  }
  function postMessage$1(channelState, messageJson) {
    return new Promise(function(res) {
      sleep().then(function() {
        var key = storageKey(channelState.channelName);
        var writeObj = {
          token: randomToken(),
          time: Date.now(),
          data: messageJson,
          uuid: channelState.uuid
        };
        var value = JSON.stringify(writeObj);
        getLocalStorage().setItem(key, value);
        var ev = document.createEvent("Event");
        ev.initEvent("storage", true, true);
        ev.key = key;
        ev.newValue = value;
        window.dispatchEvent(ev);
        res();
      });
    });
  }
  function addStorageEventListener(channelName, fn) {
    var key = storageKey(channelName);
    var listener = function listener2(ev) {
      if (ev.key === key) {
        fn(JSON.parse(ev.newValue));
      }
    };
    window.addEventListener("storage", listener);
    return listener;
  }
  function removeStorageEventListener(listener) {
    window.removeEventListener("storage", listener);
  }
  function create$1(channelName, options) {
    options = fillOptionsWithDefaults(options);
    if (!canBeUsed$1()) {
      throw new Error("BroadcastChannel: localstorage cannot be used");
    }
    var uuid = randomToken();
    var eMIs = new ObliviousSet(options.localstorage.removeTimeout);
    var state = {
      channelName,
      uuid,
      eMIs
      // emittedMessagesIds
    };
    state.listener = addStorageEventListener(channelName, function(msgObj) {
      if (!state.messagesCallback) return;
      if (msgObj.uuid === uuid) return;
      if (!msgObj.token || eMIs.has(msgObj.token)) return;
      if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return;
      eMIs.add(msgObj.token);
      state.messagesCallback(msgObj.data);
    });
    return state;
  }
  function close$1(channelState) {
    removeStorageEventListener(channelState.listener);
  }
  function onMessage$1(channelState, fn, time) {
    channelState.messagesCallbackTime = time;
    channelState.messagesCallback = fn;
  }
  function canBeUsed$1() {
    var ls = getLocalStorage();
    if (!ls) return false;
    try {
      var key = "__broadcastchannel_check";
      ls.setItem(key, "works");
      ls.removeItem(key);
    } catch (e) {
      return false;
    }
    return true;
  }
  function averageResponseTime$1() {
    var defaultTime = 120;
    var userAgent = navigator.userAgent.toLowerCase();
    if (userAgent.includes("safari") && !userAgent.includes("chrome")) {
      return defaultTime * 2;
    }
    return defaultTime;
  }
  var LocalstorageMethod = {
    create: create$1,
    close: close$1,
    onMessage: onMessage$1,
    postMessage: postMessage$1,
    canBeUsed: canBeUsed$1,
    type: type$1,
    averageResponseTime: averageResponseTime$1,
    microSeconds: microSeconds$1
  };
  var microSeconds = microSeconds$4;
  var type = "simulate";
  var SIMULATE_CHANNELS = /* @__PURE__ */ new Set();
  function create(channelName) {
    var state = {
      time: microSeconds(),
      name: channelName,
      messagesCallback: null
    };
    SIMULATE_CHANNELS.add(state);
    return state;
  }
  function close(channelState) {
    SIMULATE_CHANNELS["delete"](channelState);
  }
  var SIMULATE_DELAY_TIME = 5;
  function postMessage(channelState, messageJson) {
    return new Promise(function(res) {
      return setTimeout(function() {
        var channelArray = Array.from(SIMULATE_CHANNELS);
        channelArray.forEach(function(channel) {
          if (channel.name === channelState.name && // has same name
          channel !== channelState && // not own channel
          !!channel.messagesCallback && // has subscribers
          channel.time < messageJson.time) {
            channel.messagesCallback(messageJson);
          }
        });
        res();
      }, SIMULATE_DELAY_TIME);
    });
  }
  function onMessage(channelState, fn) {
    channelState.messagesCallback = fn;
  }
  function canBeUsed() {
    return true;
  }
  function averageResponseTime() {
    return SIMULATE_DELAY_TIME;
  }
  var SimulateMethod = {
    create,
    close,
    onMessage,
    postMessage,
    canBeUsed,
    type,
    averageResponseTime,
    microSeconds
  };
  var METHODS = [
    NativeMethod,
    // fastest
    IndexedDBMethod,
    LocalstorageMethod
  ];
  function chooseMethod(options) {
    var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);
    if (options.type) {
      if (options.type === "simulate") {
        return SimulateMethod;
      }
      var ret = chooseMethods.find(function(m) {
        return m.type === options.type;
      });
      if (!ret) throw new Error("method-type " + options.type + " not found");
      else return ret;
    }
    if (!options.webWorkerSupport) {
      chooseMethods = chooseMethods.filter(function(m) {
        return m.type !== "idb";
      });
    }
    var useMethod = chooseMethods.find(function(method) {
      return method.canBeUsed();
    });
    if (!useMethod) {
      throw new Error("No usable method found in " + JSON.stringify(METHODS.map(function(m) {
        return m.type;
      })));
    } else {
      return useMethod;
    }
  }
  var OPEN_BROADCAST_CHANNELS = /* @__PURE__ */ new Set();
  var lastId = 0;
  var BroadcastChannel$1 = function BroadcastChannel2(name, options) {
    this.id = lastId++;
    OPEN_BROADCAST_CHANNELS.add(this);
    this.name = name;
    if (ENFORCED_OPTIONS) {
      options = ENFORCED_OPTIONS;
    }
    this.options = fillOptionsWithDefaults(options);
    this.method = chooseMethod(this.options);
    this._iL = false;
    this._onML = null;
    this._addEL = {
      message: [],
      internal: []
    };
    this._uMP = /* @__PURE__ */ new Set();
    this._befC = [];
    this._prepP = null;
    _prepareChannel(this);
  };
  BroadcastChannel$1._pubkey = true;
  var ENFORCED_OPTIONS;
  BroadcastChannel$1.prototype = {
    postMessage: function postMessage2(msg) {
      if (this.closed) {
        throw new Error("BroadcastChannel.postMessage(): Cannot post message after channel has closed " + /**
         * In the past when this error appeared, it was really hard to debug.
         * So now we log the msg together with the error so it at least
         * gives some clue about where in your application this happens.
         */
        JSON.stringify(msg));
      }
      return _post(this, "message", msg);
    },
    postInternal: function postInternal(msg) {
      return _post(this, "internal", msg);
    },
    set onmessage(fn) {
      var time = this.method.microSeconds();
      var listenObj = {
        time,
        fn
      };
      _removeListenerObject(this, "message", this._onML);
      if (fn && typeof fn === "function") {
        this._onML = listenObj;
        _addListenerObject(this, "message", listenObj);
      } else {
        this._onML = null;
      }
    },
    addEventListener: function addEventListener2(type2, fn) {
      var time = this.method.microSeconds();
      var listenObj = {
        time,
        fn
      };
      _addListenerObject(this, type2, listenObj);
    },
    removeEventListener: function removeEventListener2(type2, fn) {
      var obj = this._addEL[type2].find(function(obj2) {
        return obj2.fn === fn;
      });
      _removeListenerObject(this, type2, obj);
    },
    close: function close2() {
      var _this = this;
      if (this.closed) {
        return;
      }
      OPEN_BROADCAST_CHANNELS["delete"](this);
      this.closed = true;
      var awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;
      this._onML = null;
      this._addEL.message = [];
      return awaitPrepare.then(function() {
        return Promise.all(Array.from(_this._uMP));
      }).then(function() {
        return Promise.all(_this._befC.map(function(fn) {
          return fn();
        }));
      }).then(function() {
        return _this.method.close(_this._state);
      });
    },
    get type() {
      return this.method.type;
    },
    get isClosed() {
      return this.closed;
    }
  };
  function _post(broadcastChannel, type2, msg) {
    var time = broadcastChannel.method.microSeconds();
    var msgObj = {
      time,
      type: type2,
      data: msg
    };
    var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;
    return awaitPrepare.then(function() {
      var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);
      broadcastChannel._uMP.add(sendPromise);
      sendPromise["catch"]().then(function() {
        return broadcastChannel._uMP["delete"](sendPromise);
      });
      return sendPromise;
    });
  }
  function _prepareChannel(channel) {
    var maybePromise = channel.method.create(channel.name, channel.options);
    if (isPromise(maybePromise)) {
      channel._prepP = maybePromise;
      maybePromise.then(function(s) {
        channel._state = s;
      });
    } else {
      channel._state = maybePromise;
    }
  }
  function _hasMessageListeners(channel) {
    if (channel._addEL.message.length > 0) return true;
    if (channel._addEL.internal.length > 0) return true;
    return false;
  }
  function _addListenerObject(channel, type2, obj) {
    channel._addEL[type2].push(obj);
    _startListening(channel);
  }
  function _removeListenerObject(channel, type2, obj) {
    channel._addEL[type2] = channel._addEL[type2].filter(function(o) {
      return o !== obj;
    });
    _stopListening(channel);
  }
  function _startListening(channel) {
    if (!channel._iL && _hasMessageListeners(channel)) {
      var listenerFn = function listenerFn2(msgObj) {
        channel._addEL[msgObj.type].forEach(function(listenerObject) {
          if (msgObj.time >= listenerObject.time) {
            listenerObject.fn(msgObj.data);
          }
        });
      };
      var time = channel.method.microSeconds();
      if (channel._prepP) {
        channel._prepP.then(function() {
          channel._iL = true;
          channel.method.onMessage(channel._state, listenerFn, time);
        });
      } else {
        channel._iL = true;
        channel.method.onMessage(channel._state, listenerFn, time);
      }
    }
  }
  function _stopListening(channel) {
    if (channel._iL && !_hasMessageListeners(channel)) {
      channel._iL = false;
      var time = channel.method.microSeconds();
      channel.method.onMessage(channel._state, null, time);
    }
  }
  function serialize(obj, serializer = { serialize: JSON.stringify, deserialize: JSON.parse }) {
    return serializer.deserialize(serializer.serialize(obj));
  }
  function stateHasKey(key, $state) {
    return Object.keys($state).includes(key);
  }
  function PiniaSharedState({
    enable = true,
    initialize = true,
    type: type2,
    serializer
  }) {
    return ({ store, options }) => {
      var _a2, _b, _c;
      const isEnabled = ((_a2 = options == null ? void 0 : options.share) == null ? void 0 : _a2.enable) ?? enable;
      const omittedKeys = ((_b = options == null ? void 0 : options.share) == null ? void 0 : _b.omit) ?? [];
      if (!isEnabled)
        return;
      const channel = new BroadcastChannel$1(store.$id, {
        type: type2
      });
      let timestamp = 0;
      let externalUpdate = false;
      const keysToUpdate = Object.keys(store.$state).filter((key) => !omittedKeys.includes(key) && stateHasKey(key, store.$state));
      channel.onmessage = (newState) => {
        if (newState === void 0) {
          channel.postMessage({
            timestamp,
            state: serialize(store.$state, serializer)
          });
          return;
        }
        if (newState.timestamp <= timestamp)
          return;
        externalUpdate = true;
        timestamp = Date.now();
        store.$patch((state) => {
          keysToUpdate.forEach((key) => {
            state[key] = newState.state[key];
          });
        });
      };
      const shouldInitialize = ((_c = options == null ? void 0 : options.share) == null ? void 0 : _c.initialize) ?? initialize;
      if (shouldInitialize)
        channel.postMessage(void 0);
      store.$subscribe((_, state) => {
        if (!externalUpdate) {
          timestamp = Date.now();
          channel.postMessage({
            timestamp,
            state: serialize(state, serializer)
          });
        }
        externalUpdate = false;
      });
    };
  }
  const AI_CLIENT_PROVIDER = Symbol("client");
  const configureAppWithProviders = ({ client, systemPrompt }) => (app) => {
    const pinia = createPinia();
    pinia.use(PiniaSharedState({ enable: true, initialize: false, type: "localstorage" }));
    app.use(pinia).provide(AI_CLIENT_PROVIDER, {
      client,
      systemPrompt
    });
  };
  function useAI() {
    return inject(AI_CLIENT_PROVIDER);
  }
  const useChatboxStore = /* @__PURE__ */ defineStore("chatbox", {
    state: () => ({
      models: [],
      selectedModel: "",
      systemPrompt: "",
      userMessages: [],
      newMessage: "",
      maxTokens: 5e3
    }),
    actions: {
      setSystemPrompt(prompt) {
        this.systemPrompt = prompt;
      },
      setModels(models) {
        this.models = models;
      },
      setSelectedModel(model) {
        this.selectedModel = model;
      },
      addMessage(message) {
        this.userMessages.push(message);
      },
      setNewMessage(message) {
        this.newMessage = message;
      },
      clearNewMessage() {
        this.newMessage = "";
      },
      clearMessages() {
        this.userMessages = [];
      }
    },
    getters: {
      messages: (state) => {
        return [
          { role: "system", content: state.systemPrompt },
          ...state.userMessages
        ];
      }
    }
  });
  function _getDefaults() {
    return {
      async: false,
      breaks: false,
      extensions: null,
      gfm: true,
      hooks: null,
      pedantic: false,
      renderer: null,
      silent: false,
      tokenizer: null,
      walkTokens: null
    };
  }
  let _defaults = _getDefaults();
  function changeDefaults(newDefaults) {
    _defaults = newDefaults;
  }
  const escapeTest = /[&<>"']/;
  const escapeReplace = new RegExp(escapeTest.source, "g");
  const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
  const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
  const escapeReplacements = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  const getEscapeReplacement = (ch) => escapeReplacements[ch];
  function escape$1(html2, encode) {
    if (encode) {
      if (escapeTest.test(html2)) {
        return html2.replace(escapeReplace, getEscapeReplacement);
      }
    } else {
      if (escapeTestNoEncode.test(html2)) {
        return html2.replace(escapeReplaceNoEncode, getEscapeReplacement);
      }
    }
    return html2;
  }
  const caret = /(^|[^\[])\^/g;
  function edit(regex, opt) {
    let source = typeof regex === "string" ? regex : regex.source;
    opt = opt || "";
    const obj = {
      replace: (name, val) => {
        let valSource = typeof val === "string" ? val : val.source;
        valSource = valSource.replace(caret, "$1");
        source = source.replace(name, valSource);
        return obj;
      },
      getRegex: () => {
        return new RegExp(source, opt);
      }
    };
    return obj;
  }
  function cleanUrl(href) {
    try {
      href = encodeURI(href).replace(/%25/g, "%");
    } catch {
      return null;
    }
    return href;
  }
  const noopTest = { exec: () => null };
  function splitCells(tableRow, count) {
    const row = tableRow.replace(/\|/g, (match, offset, str2) => {
      let escaped = false;
      let curr = offset;
      while (--curr >= 0 && str2[curr] === "\\")
        escaped = !escaped;
      if (escaped) {
        return "|";
      } else {
        return " |";
      }
    }), cells = row.split(/ \|/);
    let i = 0;
    if (!cells[0].trim()) {
      cells.shift();
    }
    if (cells.length > 0 && !cells[cells.length - 1].trim()) {
      cells.pop();
    }
    if (count) {
      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count)
          cells.push("");
      }
    }
    for (; i < cells.length; i++) {
      cells[i] = cells[i].trim().replace(/\\\|/g, "|");
    }
    return cells;
  }
  function rtrim(str2, c, invert) {
    const l = str2.length;
    if (l === 0) {
      return "";
    }
    let suffLen = 0;
    while (suffLen < l) {
      const currChar = str2.charAt(l - suffLen - 1);
      if (currChar === c && !invert) {
        suffLen++;
      } else if (currChar !== c && invert) {
        suffLen++;
      } else {
        break;
      }
    }
    return str2.slice(0, l - suffLen);
  }
  function findClosingBracket(str2, b) {
    if (str2.indexOf(b[1]) === -1) {
      return -1;
    }
    let level = 0;
    for (let i = 0; i < str2.length; i++) {
      if (str2[i] === "\\") {
        i++;
      } else if (str2[i] === b[0]) {
        level++;
      } else if (str2[i] === b[1]) {
        level--;
        if (level < 0) {
          return i;
        }
      }
    }
    return -1;
  }
  function outputLink(cap, link2, raw, lexer) {
    const href = link2.href;
    const title = link2.title ? escape$1(link2.title) : null;
    const text = cap[1].replace(/\\([\[\]])/g, "$1");
    if (cap[0].charAt(0) !== "!") {
      lexer.state.inLink = true;
      const token = {
        type: "link",
        raw,
        href,
        title,
        text,
        tokens: lexer.inlineTokens(text)
      };
      lexer.state.inLink = false;
      return token;
    }
    return {
      type: "image",
      raw,
      href,
      title,
      text: escape$1(text)
    };
  }
  function indentCodeCompensation(raw, text) {
    const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
    if (matchIndentToCode === null) {
      return text;
    }
    const indentToCode = matchIndentToCode[1];
    return text.split("\n").map((node) => {
      const matchIndentInNode = node.match(/^\s+/);
      if (matchIndentInNode === null) {
        return node;
      }
      const [indentInNode] = matchIndentInNode;
      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }
      return node;
    }).join("\n");
  }
  class _Tokenizer {
    // set by the lexer
    constructor(options) {
      __publicField(this, "options");
      __publicField(this, "rules");
      // set by the lexer
      __publicField(this, "lexer");
      this.options = options || _defaults;
    }
    space(src) {
      const cap = this.rules.block.newline.exec(src);
      if (cap && cap[0].length > 0) {
        return {
          type: "space",
          raw: cap[0]
        };
      }
    }
    code(src) {
      const cap = this.rules.block.code.exec(src);
      if (cap) {
        const text = cap[0].replace(/^(?: {1,4}| {0,3}\t)/gm, "");
        return {
          type: "code",
          raw: cap[0],
          codeBlockStyle: "indented",
          text: !this.options.pedantic ? rtrim(text, "\n") : text
        };
      }
    }
    fences(src) {
      const cap = this.rules.block.fences.exec(src);
      if (cap) {
        const raw = cap[0];
        const text = indentCodeCompensation(raw, cap[3] || "");
        return {
          type: "code",
          raw,
          lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cap[2],
          text
        };
      }
    }
    heading(src) {
      const cap = this.rules.block.heading.exec(src);
      if (cap) {
        let text = cap[2].trim();
        if (/#$/.test(text)) {
          const trimmed = rtrim(text, "#");
          if (this.options.pedantic) {
            text = trimmed.trim();
          } else if (!trimmed || / $/.test(trimmed)) {
            text = trimmed.trim();
          }
        }
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[1].length,
          text,
          tokens: this.lexer.inline(text)
        };
      }
    }
    hr(src) {
      const cap = this.rules.block.hr.exec(src);
      if (cap) {
        return {
          type: "hr",
          raw: rtrim(cap[0], "\n")
        };
      }
    }
    blockquote(src) {
      const cap = this.rules.block.blockquote.exec(src);
      if (cap) {
        let lines = rtrim(cap[0], "\n").split("\n");
        let raw = "";
        let text = "";
        const tokens = [];
        while (lines.length > 0) {
          let inBlockquote = false;
          const currentLines = [];
          let i;
          for (i = 0; i < lines.length; i++) {
            if (/^ {0,3}>/.test(lines[i])) {
              currentLines.push(lines[i]);
              inBlockquote = true;
            } else if (!inBlockquote) {
              currentLines.push(lines[i]);
            } else {
              break;
            }
          }
          lines = lines.slice(i);
          const currentRaw = currentLines.join("\n");
          const currentText = currentRaw.replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, "\n    $1").replace(/^ {0,3}>[ \t]?/gm, "");
          raw = raw ? `${raw}
${currentRaw}` : currentRaw;
          text = text ? `${text}
${currentText}` : currentText;
          const top = this.lexer.state.top;
          this.lexer.state.top = true;
          this.lexer.blockTokens(currentText, tokens, true);
          this.lexer.state.top = top;
          if (lines.length === 0) {
            break;
          }
          const lastToken = tokens[tokens.length - 1];
          if ((lastToken == null ? void 0 : lastToken.type) === "code") {
            break;
          } else if ((lastToken == null ? void 0 : lastToken.type) === "blockquote") {
            const oldToken = lastToken;
            const newText = oldToken.raw + "\n" + lines.join("\n");
            const newToken = this.blockquote(newText);
            tokens[tokens.length - 1] = newToken;
            raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;
            text = text.substring(0, text.length - oldToken.text.length) + newToken.text;
            break;
          } else if ((lastToken == null ? void 0 : lastToken.type) === "list") {
            const oldToken = lastToken;
            const newText = oldToken.raw + "\n" + lines.join("\n");
            const newToken = this.list(newText);
            tokens[tokens.length - 1] = newToken;
            raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;
            text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;
            lines = newText.substring(tokens[tokens.length - 1].raw.length).split("\n");
            continue;
          }
        }
        return {
          type: "blockquote",
          raw,
          tokens,
          text
        };
      }
    }
    list(src) {
      let cap = this.rules.block.list.exec(src);
      if (cap) {
        let bull = cap[1].trim();
        const isordered = bull.length > 1;
        const list2 = {
          type: "list",
          raw: "",
          ordered: isordered,
          start: isordered ? +bull.slice(0, -1) : "",
          loose: false,
          items: []
        };
        bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
        if (this.options.pedantic) {
          bull = isordered ? bull : "[*+-]";
        }
        const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
        let endsWithBlankLine = false;
        while (src) {
          let endEarly = false;
          let raw = "";
          let itemContents = "";
          if (!(cap = itemRegex.exec(src))) {
            break;
          }
          if (this.rules.block.hr.test(src)) {
            break;
          }
          raw = cap[0];
          src = src.substring(raw.length);
          let line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length));
          let nextLine = src.split("\n", 1)[0];
          let blankLine = !line.trim();
          let indent = 0;
          if (this.options.pedantic) {
            indent = 2;
            itemContents = line.trimStart();
          } else if (blankLine) {
            indent = cap[1].length + 1;
          } else {
            indent = cap[2].search(/[^ ]/);
            indent = indent > 4 ? 1 : indent;
            itemContents = line.slice(indent);
            indent += cap[1].length;
          }
          if (blankLine && /^[ \t]*$/.test(nextLine)) {
            raw += nextLine + "\n";
            src = src.substring(nextLine.length + 1);
            endEarly = true;
          }
          if (!endEarly) {
            const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
            const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
            const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
            const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
            while (src) {
              const rawLine = src.split("\n", 1)[0];
              let nextLineWithoutTabs;
              nextLine = rawLine;
              if (this.options.pedantic) {
                nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
                nextLineWithoutTabs = nextLine;
              } else {
                nextLineWithoutTabs = nextLine.replace(/\t/g, "    ");
              }
              if (fencesBeginRegex.test(nextLine)) {
                break;
              }
              if (headingBeginRegex.test(nextLine)) {
                break;
              }
              if (nextBulletRegex.test(nextLine)) {
                break;
              }
              if (hrRegex.test(nextLine)) {
                break;
              }
              if (nextLineWithoutTabs.search(/[^ ]/) >= indent || !nextLine.trim()) {
                itemContents += "\n" + nextLineWithoutTabs.slice(indent);
              } else {
                if (blankLine) {
                  break;
                }
                if (line.replace(/\t/g, "    ").search(/[^ ]/) >= 4) {
                  break;
                }
                if (fencesBeginRegex.test(line)) {
                  break;
                }
                if (headingBeginRegex.test(line)) {
                  break;
                }
                if (hrRegex.test(line)) {
                  break;
                }
                itemContents += "\n" + nextLine;
              }
              if (!blankLine && !nextLine.trim()) {
                blankLine = true;
              }
              raw += rawLine + "\n";
              src = src.substring(rawLine.length + 1);
              line = nextLineWithoutTabs.slice(indent);
            }
          }
          if (!list2.loose) {
            if (endsWithBlankLine) {
              list2.loose = true;
            } else if (/\n[ \t]*\n[ \t]*$/.test(raw)) {
              endsWithBlankLine = true;
            }
          }
          let istask = null;
          let ischecked;
          if (this.options.gfm) {
            istask = /^\[[ xX]\] /.exec(itemContents);
            if (istask) {
              ischecked = istask[0] !== "[ ] ";
              itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
            }
          }
          list2.items.push({
            type: "list_item",
            raw,
            task: !!istask,
            checked: ischecked,
            loose: false,
            text: itemContents,
            tokens: []
          });
          list2.raw += raw;
        }
        list2.items[list2.items.length - 1].raw = list2.items[list2.items.length - 1].raw.trimEnd();
        list2.items[list2.items.length - 1].text = list2.items[list2.items.length - 1].text.trimEnd();
        list2.raw = list2.raw.trimEnd();
        for (let i = 0; i < list2.items.length; i++) {
          this.lexer.state.top = false;
          list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
          if (!list2.loose) {
            const spacers = list2.items[i].tokens.filter((t) => t.type === "space");
            const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
            list2.loose = hasMultipleLineBreaks;
          }
        }
        if (list2.loose) {
          for (let i = 0; i < list2.items.length; i++) {
            list2.items[i].loose = true;
          }
        }
        return list2;
      }
    }
    html(src) {
      const cap = this.rules.block.html.exec(src);
      if (cap) {
        const token = {
          type: "html",
          block: true,
          raw: cap[0],
          pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
          text: cap[0]
        };
        return token;
      }
    }
    def(src) {
      const cap = this.rules.block.def.exec(src);
      if (cap) {
        const tag2 = cap[1].toLowerCase().replace(/\s+/g, " ");
        const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "";
        const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cap[3];
        return {
          type: "def",
          tag: tag2,
          raw: cap[0],
          href,
          title
        };
      }
    }
    table(src) {
      const cap = this.rules.block.table.exec(src);
      if (!cap) {
        return;
      }
      if (!/[:|]/.test(cap[2])) {
        return;
      }
      const headers = splitCells(cap[1]);
      const aligns = cap[2].replace(/^\||\| *$/g, "").split("|");
      const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : [];
      const item = {
        type: "table",
        raw: cap[0],
        header: [],
        align: [],
        rows: []
      };
      if (headers.length !== aligns.length) {
        return;
      }
      for (const align of aligns) {
        if (/^ *-+: *$/.test(align)) {
          item.align.push("right");
        } else if (/^ *:-+: *$/.test(align)) {
          item.align.push("center");
        } else if (/^ *:-+ *$/.test(align)) {
          item.align.push("left");
        } else {
          item.align.push(null);
        }
      }
      for (let i = 0; i < headers.length; i++) {
        item.header.push({
          text: headers[i],
          tokens: this.lexer.inline(headers[i]),
          header: true,
          align: item.align[i]
        });
      }
      for (const row of rows) {
        item.rows.push(splitCells(row, item.header.length).map((cell, i) => {
          return {
            text: cell,
            tokens: this.lexer.inline(cell),
            header: false,
            align: item.align[i]
          };
        }));
      }
      return item;
    }
    lheading(src) {
      const cap = this.rules.block.lheading.exec(src);
      if (cap) {
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[2].charAt(0) === "=" ? 1 : 2,
          text: cap[1],
          tokens: this.lexer.inline(cap[1])
        };
      }
    }
    paragraph(src) {
      const cap = this.rules.block.paragraph.exec(src);
      if (cap) {
        const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
        return {
          type: "paragraph",
          raw: cap[0],
          text,
          tokens: this.lexer.inline(text)
        };
      }
    }
    text(src) {
      const cap = this.rules.block.text.exec(src);
      if (cap) {
        return {
          type: "text",
          raw: cap[0],
          text: cap[0],
          tokens: this.lexer.inline(cap[0])
        };
      }
    }
    escape(src) {
      const cap = this.rules.inline.escape.exec(src);
      if (cap) {
        return {
          type: "escape",
          raw: cap[0],
          text: escape$1(cap[1])
        };
      }
    }
    tag(src) {
      const cap = this.rules.inline.tag.exec(src);
      if (cap) {
        if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
          this.lexer.state.inLink = true;
        } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
          this.lexer.state.inLink = false;
        }
        if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = true;
        } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = false;
        }
        return {
          type: "html",
          raw: cap[0],
          inLink: this.lexer.state.inLink,
          inRawBlock: this.lexer.state.inRawBlock,
          block: false,
          text: cap[0]
        };
      }
    }
    link(src) {
      const cap = this.rules.inline.link.exec(src);
      if (cap) {
        const trimmedUrl = cap[2].trim();
        if (!this.options.pedantic && /^</.test(trimmedUrl)) {
          if (!/>$/.test(trimmedUrl)) {
            return;
          }
          const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
            return;
          }
        } else {
          const lastParenIndex = findClosingBracket(cap[2], "()");
          if (lastParenIndex > -1) {
            const start = cap[0].indexOf("!") === 0 ? 5 : 4;
            const linkLen = start + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = "";
          }
        }
        let href = cap[2];
        let title = "";
        if (this.options.pedantic) {
          const link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
          if (link2) {
            href = link2[1];
            title = link2[3];
          }
        } else {
          title = cap[3] ? cap[3].slice(1, -1) : "";
        }
        href = href.trim();
        if (/^</.test(href)) {
          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
            href = href.slice(1);
          } else {
            href = href.slice(1, -1);
          }
        }
        return outputLink(cap, {
          href: href ? href.replace(this.rules.inline.anyPunctuation, "$1") : href,
          title: title ? title.replace(this.rules.inline.anyPunctuation, "$1") : title
        }, cap[0], this.lexer);
      }
    }
    reflink(src, links) {
      let cap;
      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
        const linkString = (cap[2] || cap[1]).replace(/\s+/g, " ");
        const link2 = links[linkString.toLowerCase()];
        if (!link2) {
          const text = cap[0].charAt(0);
          return {
            type: "text",
            raw: text,
            text
          };
        }
        return outputLink(cap, link2, cap[0], this.lexer);
      }
    }
    emStrong(src, maskedSrc, prevChar = "") {
      let match = this.rules.inline.emStrongLDelim.exec(src);
      if (!match)
        return;
      if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
        return;
      const nextChar = match[1] || match[2] || "";
      if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
        const lLength = [...match[0]].length - 1;
        let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
        const endReg = match[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
        endReg.lastIndex = 0;
        maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
        while ((match = endReg.exec(maskedSrc)) != null) {
          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
          if (!rDelim)
            continue;
          rLength = [...rDelim].length;
          if (match[3] || match[4]) {
            delimTotal += rLength;
            continue;
          } else if (match[5] || match[6]) {
            if (lLength % 3 && !((lLength + rLength) % 3)) {
              midDelimTotal += rLength;
              continue;
            }
          }
          delimTotal -= rLength;
          if (delimTotal > 0)
            continue;
          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
          const lastCharLength = [...match[0]][0].length;
          const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
          if (Math.min(lLength, rLength) % 2) {
            const text2 = raw.slice(1, -1);
            return {
              type: "em",
              raw,
              text: text2,
              tokens: this.lexer.inlineTokens(text2)
            };
          }
          const text = raw.slice(2, -2);
          return {
            type: "strong",
            raw,
            text,
            tokens: this.lexer.inlineTokens(text)
          };
        }
      }
    }
    codespan(src) {
      const cap = this.rules.inline.code.exec(src);
      if (cap) {
        let text = cap[2].replace(/\n/g, " ");
        const hasNonSpaceChars = /[^ ]/.test(text);
        const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
          text = text.substring(1, text.length - 1);
        }
        text = escape$1(text, true);
        return {
          type: "codespan",
          raw: cap[0],
          text
        };
      }
    }
    br(src) {
      const cap = this.rules.inline.br.exec(src);
      if (cap) {
        return {
          type: "br",
          raw: cap[0]
        };
      }
    }
    del(src) {
      const cap = this.rules.inline.del.exec(src);
      if (cap) {
        return {
          type: "del",
          raw: cap[0],
          text: cap[2],
          tokens: this.lexer.inlineTokens(cap[2])
        };
      }
    }
    autolink(src) {
      const cap = this.rules.inline.autolink.exec(src);
      if (cap) {
        let text, href;
        if (cap[2] === "@") {
          text = escape$1(cap[1]);
          href = "mailto:" + text;
        } else {
          text = escape$1(cap[1]);
          href = text;
        }
        return {
          type: "link",
          raw: cap[0],
          text,
          href,
          tokens: [
            {
              type: "text",
              raw: text,
              text
            }
          ]
        };
      }
    }
    url(src) {
      var _a2;
      let cap;
      if (cap = this.rules.inline.url.exec(src)) {
        let text, href;
        if (cap[2] === "@") {
          text = escape$1(cap[0]);
          href = "mailto:" + text;
        } else {
          let prevCapZero;
          do {
            prevCapZero = cap[0];
            cap[0] = ((_a2 = this.rules.inline._backpedal.exec(cap[0])) == null ? void 0 : _a2[0]) ?? "";
          } while (prevCapZero !== cap[0]);
          text = escape$1(cap[0]);
          if (cap[1] === "www.") {
            href = "http://" + cap[0];
          } else {
            href = cap[0];
          }
        }
        return {
          type: "link",
          raw: cap[0],
          text,
          href,
          tokens: [
            {
              type: "text",
              raw: text,
              text
            }
          ]
        };
      }
    }
    inlineText(src) {
      const cap = this.rules.inline.text.exec(src);
      if (cap) {
        let text;
        if (this.lexer.state.inRawBlock) {
          text = cap[0];
        } else {
          text = escape$1(cap[0]);
        }
        return {
          type: "text",
          raw: cap[0],
          text
        };
      }
    }
  }
  const newline = /^(?:[ \t]*(?:\n|$))+/;
  const blockCode = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
  const fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
  const hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
  const heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
  const bullet = /(?:[*+-]|\d{1,9}[.)])/;
  const lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).getRegex();
  const _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
  const blockText = /^[^\n]+/;
  const _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
  const def = edit(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
  const list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
  const _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
  const _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
  const html = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  const paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
  const blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex();
  const blockNormal = {
    blockquote,
    code: blockCode,
    def,
    fences,
    heading,
    hr,
    html,
    lheading,
    list,
    newline,
    paragraph,
    table: noopTest,
    text: blockText
  };
  const gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
  const blockGfm = {
    ...blockNormal,
    table: gfmTable,
    paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
  };
  const blockPedantic = {
    ...blockNormal,
    html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest,
    // fences not supported
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
  };
  const escape = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
  const inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
  const br = /^( {2,}|\\)\n(?!\s*$)/;
  const inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
  const _punctuation = "\\p{P}\\p{S}";
  const punctuation = edit(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, _punctuation).getRegex();
  const blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
  const emStrongLDelim = edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, _punctuation).getRegex();
  const emStrongRDelimAst = edit("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, _punctuation).getRegex();
  const emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, _punctuation).getRegex();
  const anyPunctuation = edit(/\\([punct])/, "gu").replace(/punct/g, _punctuation).getRegex();
  const autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
  const _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex();
  const tag = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
  const _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  const link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
  const reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex();
  const nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex();
  const reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex();
  const inlineNormal = {
    _backpedal: noopTest,
    // only used for GFM url
    anyPunctuation,
    autolink,
    blockSkip,
    br,
    code: inlineCode,
    del: noopTest,
    emStrongLDelim,
    emStrongRDelimAst,
    emStrongRDelimUnd,
    escape,
    link,
    nolink,
    punctuation,
    reflink,
    reflinkSearch,
    tag,
    text: inlineText,
    url: noopTest
  };
  const inlinePedantic = {
    ...inlineNormal,
    link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
  };
  const inlineGfm = {
    ...inlineNormal,
    escape: edit(escape).replace("])", "~|])").getRegex(),
    url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
  };
  const inlineBreaks = {
    ...inlineGfm,
    br: edit(br).replace("{2,}", "*").getRegex(),
    text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
  };
  const block = {
    normal: blockNormal,
    gfm: blockGfm,
    pedantic: blockPedantic
  };
  const inline = {
    normal: inlineNormal,
    gfm: inlineGfm,
    breaks: inlineBreaks,
    pedantic: inlinePedantic
  };
  class _Lexer {
    constructor(options) {
      __publicField(this, "tokens");
      __publicField(this, "options");
      __publicField(this, "state");
      __publicField(this, "tokenizer");
      __publicField(this, "inlineQueue");
      this.tokens = [];
      this.tokens.links = /* @__PURE__ */ Object.create(null);
      this.options = options || _defaults;
      this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      this.tokenizer.lexer = this;
      this.inlineQueue = [];
      this.state = {
        inLink: false,
        inRawBlock: false,
        top: true
      };
      const rules = {
        block: block.normal,
        inline: inline.normal
      };
      if (this.options.pedantic) {
        rules.block = block.pedantic;
        rules.inline = inline.pedantic;
      } else if (this.options.gfm) {
        rules.block = block.gfm;
        if (this.options.breaks) {
          rules.inline = inline.breaks;
        } else {
          rules.inline = inline.gfm;
        }
      }
      this.tokenizer.rules = rules;
    }
    /**
     * Expose Rules
     */
    static get rules() {
      return {
        block,
        inline
      };
    }
    /**
     * Static Lex Method
     */
    static lex(src, options) {
      const lexer = new _Lexer(options);
      return lexer.lex(src);
    }
    /**
     * Static Lex Inline Method
     */
    static lexInline(src, options) {
      const lexer = new _Lexer(options);
      return lexer.inlineTokens(src);
    }
    /**
     * Preprocessing
     */
    lex(src) {
      src = src.replace(/\r\n|\r/g, "\n");
      this.blockTokens(src, this.tokens);
      for (let i = 0; i < this.inlineQueue.length; i++) {
        const next = this.inlineQueue[i];
        this.inlineTokens(next.src, next.tokens);
      }
      this.inlineQueue = [];
      return this.tokens;
    }
    blockTokens(src, tokens = [], lastParagraphClipped = false) {
      if (this.options.pedantic) {
        src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
      }
      let token;
      let lastToken;
      let cutSrc;
      while (src) {
        if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.space(src)) {
          src = src.substring(token.raw.length);
          if (token.raw.length === 1 && tokens.length > 0) {
            tokens[tokens.length - 1].raw += "\n";
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.code(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.fences(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.heading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.hr(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.blockquote(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.list(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.html(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.def(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.raw;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else if (!this.tokens.links[token.tag]) {
            this.tokens.links[token.tag] = {
              href: token.href,
              title: token.title
            };
          }
          continue;
        }
        if (token = this.tokenizer.table(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.lheading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        cutSrc = src;
        if (this.options.extensions && this.options.extensions.startBlock) {
          let startIndex = Infinity;
          const tempSrc = src.slice(1);
          let tempStart;
          this.options.extensions.startBlock.forEach((getStartIndex) => {
            tempStart = getStartIndex.call({ lexer: this }, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        }
        if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
          lastToken = tokens[tokens.length - 1];
          if (lastParagraphClipped && (lastToken == null ? void 0 : lastToken.type) === "paragraph") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          lastParagraphClipped = cutSrc.length !== src.length;
          src = src.substring(token.raw.length);
          continue;
        }
        if (token = this.tokenizer.text(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "text") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      this.state.top = true;
      return tokens;
    }
    inline(src, tokens = []) {
      this.inlineQueue.push({ src, tokens });
      return tokens;
    }
    /**
     * Lexing/Compiling
     */
    inlineTokens(src, tokens = []) {
      let token, lastToken, cutSrc;
      let maskedSrc = src;
      let match;
      let keepPrevChar, prevChar;
      if (this.tokens.links) {
        const links = Object.keys(this.tokens.links);
        if (links.length > 0) {
          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
            if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
              maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
            }
          }
        }
      }
      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      }
      while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
      }
      while (src) {
        if (!keepPrevChar) {
          prevChar = "";
        }
        keepPrevChar = false;
        if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.escape(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.tag(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && token.type === "text" && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.link(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.reflink(src, this.tokens.links)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && token.type === "text" && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.codespan(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.br(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.del(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.autolink(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (!this.state.inLink && (token = this.tokenizer.url(src))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        cutSrc = src;
        if (this.options.extensions && this.options.extensions.startInline) {
          let startIndex = Infinity;
          const tempSrc = src.slice(1);
          let tempStart;
          this.options.extensions.startInline.forEach((getStartIndex) => {
            tempStart = getStartIndex.call({ lexer: this }, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        }
        if (token = this.tokenizer.inlineText(cutSrc)) {
          src = src.substring(token.raw.length);
          if (token.raw.slice(-1) !== "_") {
            prevChar = token.raw.slice(-1);
          }
          keepPrevChar = true;
          lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      return tokens;
    }
  }
  class _Renderer {
    // set by the parser
    constructor(options) {
      __publicField(this, "options");
      __publicField(this, "parser");
      this.options = options || _defaults;
    }
    space(token) {
      return "";
    }
    code({ text, lang, escaped }) {
      var _a2;
      const langString = (_a2 = (lang || "").match(/^\S*/)) == null ? void 0 : _a2[0];
      const code = text.replace(/\n$/, "") + "\n";
      if (!langString) {
        return "<pre><code>" + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
      }
      return '<pre><code class="language-' + escape$1(langString) + '">' + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
    }
    blockquote({ tokens }) {
      const body = this.parser.parse(tokens);
      return `<blockquote>
${body}</blockquote>
`;
    }
    html({ text }) {
      return text;
    }
    heading({ tokens, depth }) {
      return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>
`;
    }
    hr(token) {
      return "<hr>\n";
    }
    list(token) {
      const ordered = token.ordered;
      const start = token.start;
      let body = "";
      for (let j = 0; j < token.items.length; j++) {
        const item = token.items[j];
        body += this.listitem(item);
      }
      const type2 = ordered ? "ol" : "ul";
      const startAttr = ordered && start !== 1 ? ' start="' + start + '"' : "";
      return "<" + type2 + startAttr + ">\n" + body + "</" + type2 + ">\n";
    }
    listitem(item) {
      let itemBody = "";
      if (item.task) {
        const checkbox = this.checkbox({ checked: !!item.checked });
        if (item.loose) {
          if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
            item.tokens[0].text = checkbox + " " + item.tokens[0].text;
            if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
              item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
            }
          } else {
            item.tokens.unshift({
              type: "text",
              raw: checkbox + " ",
              text: checkbox + " "
            });
          }
        } else {
          itemBody += checkbox + " ";
        }
      }
      itemBody += this.parser.parse(item.tokens, !!item.loose);
      return `<li>${itemBody}</li>
`;
    }
    checkbox({ checked }) {
      return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
    }
    paragraph({ tokens }) {
      return `<p>${this.parser.parseInline(tokens)}</p>
`;
    }
    table(token) {
      let header = "";
      let cell = "";
      for (let j = 0; j < token.header.length; j++) {
        cell += this.tablecell(token.header[j]);
      }
      header += this.tablerow({ text: cell });
      let body = "";
      for (let j = 0; j < token.rows.length; j++) {
        const row = token.rows[j];
        cell = "";
        for (let k = 0; k < row.length; k++) {
          cell += this.tablecell(row[k]);
        }
        body += this.tablerow({ text: cell });
      }
      if (body)
        body = `<tbody>${body}</tbody>`;
      return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
    }
    tablerow({ text }) {
      return `<tr>
${text}</tr>
`;
    }
    tablecell(token) {
      const content = this.parser.parseInline(token.tokens);
      const type2 = token.header ? "th" : "td";
      const tag2 = token.align ? `<${type2} align="${token.align}">` : `<${type2}>`;
      return tag2 + content + `</${type2}>
`;
    }
    /**
     * span level renderer
     */
    strong({ tokens }) {
      return `<strong>${this.parser.parseInline(tokens)}</strong>`;
    }
    em({ tokens }) {
      return `<em>${this.parser.parseInline(tokens)}</em>`;
    }
    codespan({ text }) {
      return `<code>${text}</code>`;
    }
    br(token) {
      return "<br>";
    }
    del({ tokens }) {
      return `<del>${this.parser.parseInline(tokens)}</del>`;
    }
    link({ href, title, tokens }) {
      const text = this.parser.parseInline(tokens);
      const cleanHref = cleanUrl(href);
      if (cleanHref === null) {
        return text;
      }
      href = cleanHref;
      let out = '<a href="' + href + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += ">" + text + "</a>";
      return out;
    }
    image({ href, title, text }) {
      const cleanHref = cleanUrl(href);
      if (cleanHref === null) {
        return text;
      }
      href = cleanHref;
      let out = `<img src="${href}" alt="${text}"`;
      if (title) {
        out += ` title="${title}"`;
      }
      out += ">";
      return out;
    }
    text(token) {
      return "tokens" in token && token.tokens ? this.parser.parseInline(token.tokens) : token.text;
    }
  }
  class _TextRenderer {
    // no need for block level renderers
    strong({ text }) {
      return text;
    }
    em({ text }) {
      return text;
    }
    codespan({ text }) {
      return text;
    }
    del({ text }) {
      return text;
    }
    html({ text }) {
      return text;
    }
    text({ text }) {
      return text;
    }
    link({ text }) {
      return "" + text;
    }
    image({ text }) {
      return "" + text;
    }
    br() {
      return "";
    }
  }
  class _Parser {
    constructor(options) {
      __publicField(this, "options");
      __publicField(this, "renderer");
      __publicField(this, "textRenderer");
      this.options = options || _defaults;
      this.options.renderer = this.options.renderer || new _Renderer();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.renderer.parser = this;
      this.textRenderer = new _TextRenderer();
    }
    /**
     * Static Parse Method
     */
    static parse(tokens, options) {
      const parser = new _Parser(options);
      return parser.parse(tokens);
    }
    /**
     * Static Parse Inline Method
     */
    static parseInline(tokens, options) {
      const parser = new _Parser(options);
      return parser.parseInline(tokens);
    }
    /**
     * Parse Loop
     */
    parse(tokens, top = true) {
      let out = "";
      for (let i = 0; i < tokens.length; i++) {
        const anyToken = tokens[i];
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {
          const genericToken = anyToken;
          const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
          if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
            out += ret || "";
            continue;
          }
        }
        const token = anyToken;
        switch (token.type) {
          case "space": {
            out += this.renderer.space(token);
            continue;
          }
          case "hr": {
            out += this.renderer.hr(token);
            continue;
          }
          case "heading": {
            out += this.renderer.heading(token);
            continue;
          }
          case "code": {
            out += this.renderer.code(token);
            continue;
          }
          case "table": {
            out += this.renderer.table(token);
            continue;
          }
          case "blockquote": {
            out += this.renderer.blockquote(token);
            continue;
          }
          case "list": {
            out += this.renderer.list(token);
            continue;
          }
          case "html": {
            out += this.renderer.html(token);
            continue;
          }
          case "paragraph": {
            out += this.renderer.paragraph(token);
            continue;
          }
          case "text": {
            let textToken = token;
            let body = this.renderer.text(textToken);
            while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
              textToken = tokens[++i];
              body += "\n" + this.renderer.text(textToken);
            }
            if (top) {
              out += this.renderer.paragraph({
                type: "paragraph",
                raw: body,
                text: body,
                tokens: [{ type: "text", raw: body, text: body }]
              });
            } else {
              out += body;
            }
            continue;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return "";
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
    /**
     * Parse Inline Tokens
     */
    parseInline(tokens, renderer2) {
      renderer2 = renderer2 || this.renderer;
      let out = "";
      for (let i = 0; i < tokens.length; i++) {
        const anyToken = tokens[i];
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {
          const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);
          if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(anyToken.type)) {
            out += ret || "";
            continue;
          }
        }
        const token = anyToken;
        switch (token.type) {
          case "escape": {
            out += renderer2.text(token);
            break;
          }
          case "html": {
            out += renderer2.html(token);
            break;
          }
          case "link": {
            out += renderer2.link(token);
            break;
          }
          case "image": {
            out += renderer2.image(token);
            break;
          }
          case "strong": {
            out += renderer2.strong(token);
            break;
          }
          case "em": {
            out += renderer2.em(token);
            break;
          }
          case "codespan": {
            out += renderer2.codespan(token);
            break;
          }
          case "br": {
            out += renderer2.br(token);
            break;
          }
          case "del": {
            out += renderer2.del(token);
            break;
          }
          case "text": {
            out += renderer2.text(token);
            break;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return "";
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
  }
  class _Hooks {
    constructor(options) {
      __publicField(this, "options");
      __publicField(this, "block");
      this.options = options || _defaults;
    }
    /**
     * Process markdown before marked
     */
    preprocess(markdown) {
      return markdown;
    }
    /**
     * Process HTML after marked is finished
     */
    postprocess(html2) {
      return html2;
    }
    /**
     * Process all tokens before walk tokens
     */
    processAllTokens(tokens) {
      return tokens;
    }
    /**
     * Provide function to tokenize markdown
     */
    provideLexer() {
      return this.block ? _Lexer.lex : _Lexer.lexInline;
    }
    /**
     * Provide function to parse tokens
     */
    provideParser() {
      return this.block ? _Parser.parse : _Parser.parseInline;
    }
  }
  __publicField(_Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
    "preprocess",
    "postprocess",
    "processAllTokens"
  ]));
  class Marked {
    constructor(...args) {
      __publicField(this, "defaults", _getDefaults());
      __publicField(this, "options", this.setOptions);
      __publicField(this, "parse", this.parseMarkdown(true));
      __publicField(this, "parseInline", this.parseMarkdown(false));
      __publicField(this, "Parser", _Parser);
      __publicField(this, "Renderer", _Renderer);
      __publicField(this, "TextRenderer", _TextRenderer);
      __publicField(this, "Lexer", _Lexer);
      __publicField(this, "Tokenizer", _Tokenizer);
      __publicField(this, "Hooks", _Hooks);
      this.use(...args);
    }
    /**
     * Run callback for every token
     */
    walkTokens(tokens, callback) {
      var _a2, _b;
      let values = [];
      for (const token of tokens) {
        values = values.concat(callback.call(this, token));
        switch (token.type) {
          case "table": {
            const tableToken = token;
            for (const cell of tableToken.header) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
            for (const row of tableToken.rows) {
              for (const cell of row) {
                values = values.concat(this.walkTokens(cell.tokens, callback));
              }
            }
            break;
          }
          case "list": {
            const listToken = token;
            values = values.concat(this.walkTokens(listToken.items, callback));
            break;
          }
          default: {
            const genericToken = token;
            if ((_b = (_a2 = this.defaults.extensions) == null ? void 0 : _a2.childTokens) == null ? void 0 : _b[genericToken.type]) {
              this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
                const tokens2 = genericToken[childTokens].flat(Infinity);
                values = values.concat(this.walkTokens(tokens2, callback));
              });
            } else if (genericToken.tokens) {
              values = values.concat(this.walkTokens(genericToken.tokens, callback));
            }
          }
        }
      }
      return values;
    }
    use(...args) {
      const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
      args.forEach((pack) => {
        const opts = { ...pack };
        opts.async = this.defaults.async || opts.async || false;
        if (pack.extensions) {
          pack.extensions.forEach((ext) => {
            if (!ext.name) {
              throw new Error("extension name required");
            }
            if ("renderer" in ext) {
              const prevRenderer = extensions.renderers[ext.name];
              if (prevRenderer) {
                extensions.renderers[ext.name] = function(...args2) {
                  let ret = ext.renderer.apply(this, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args2);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if ("tokenizer" in ext) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              const extLevel = extensions[ext.level];
              if (extLevel) {
                extLevel.unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) {
                if (ext.level === "block") {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === "inline") {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if ("childTokens" in ext && ext.childTokens) {
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
          opts.extensions = extensions;
        }
        if (pack.renderer) {
          const renderer2 = this.defaults.renderer || new _Renderer(this.defaults);
          for (const prop in pack.renderer) {
            if (!(prop in renderer2)) {
              throw new Error(`renderer '${prop}' does not exist`);
            }
            if (["options", "parser"].includes(prop)) {
              continue;
            }
            const rendererProp = prop;
            const rendererFunc = pack.renderer[rendererProp];
            const prevRenderer = renderer2[rendererProp];
            renderer2[rendererProp] = (...args2) => {
              let ret = rendererFunc.apply(renderer2, args2);
              if (ret === false) {
                ret = prevRenderer.apply(renderer2, args2);
              }
              return ret || "";
            };
          }
          opts.renderer = renderer2;
        }
        if (pack.tokenizer) {
          const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
          for (const prop in pack.tokenizer) {
            if (!(prop in tokenizer)) {
              throw new Error(`tokenizer '${prop}' does not exist`);
            }
            if (["options", "rules", "lexer"].includes(prop)) {
              continue;
            }
            const tokenizerProp = prop;
            const tokenizerFunc = pack.tokenizer[tokenizerProp];
            const prevTokenizer = tokenizer[tokenizerProp];
            tokenizer[tokenizerProp] = (...args2) => {
              let ret = tokenizerFunc.apply(tokenizer, args2);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args2);
              }
              return ret;
            };
          }
          opts.tokenizer = tokenizer;
        }
        if (pack.hooks) {
          const hooks = this.defaults.hooks || new _Hooks();
          for (const prop in pack.hooks) {
            if (!(prop in hooks)) {
              throw new Error(`hook '${prop}' does not exist`);
            }
            if (["options", "block"].includes(prop)) {
              continue;
            }
            const hooksProp = prop;
            const hooksFunc = pack.hooks[hooksProp];
            const prevHook = hooks[hooksProp];
            if (_Hooks.passThroughHooks.has(prop)) {
              hooks[hooksProp] = (arg) => {
                if (this.defaults.async) {
                  return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                    return prevHook.call(hooks, ret2);
                  });
                }
                const ret = hooksFunc.call(hooks, arg);
                return prevHook.call(hooks, ret);
              };
            } else {
              hooks[hooksProp] = (...args2) => {
                let ret = hooksFunc.apply(hooks, args2);
                if (ret === false) {
                  ret = prevHook.apply(hooks, args2);
                }
                return ret;
              };
            }
          }
          opts.hooks = hooks;
        }
        if (pack.walkTokens) {
          const walkTokens = this.defaults.walkTokens;
          const packWalktokens = pack.walkTokens;
          opts.walkTokens = function(token) {
            let values = [];
            values.push(packWalktokens.call(this, token));
            if (walkTokens) {
              values = values.concat(walkTokens.call(this, token));
            }
            return values;
          };
        }
        this.defaults = { ...this.defaults, ...opts };
      });
      return this;
    }
    setOptions(opt) {
      this.defaults = { ...this.defaults, ...opt };
      return this;
    }
    lexer(src, options) {
      return _Lexer.lex(src, options ?? this.defaults);
    }
    parser(tokens, options) {
      return _Parser.parse(tokens, options ?? this.defaults);
    }
    parseMarkdown(blockType) {
      const parse = (src, options) => {
        const origOpt = { ...options };
        const opt = { ...this.defaults, ...origOpt };
        const throwError = this.onError(!!opt.silent, !!opt.async);
        if (this.defaults.async === true && origOpt.async === false) {
          return throwError(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
        }
        if (typeof src === "undefined" || src === null) {
          return throwError(new Error("marked(): input parameter is undefined or null"));
        }
        if (typeof src !== "string") {
          return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
        }
        if (opt.hooks) {
          opt.hooks.options = opt;
          opt.hooks.block = blockType;
        }
        const lexer = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline;
        const parser = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;
        if (opt.async) {
          return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
        }
        try {
          if (opt.hooks) {
            src = opt.hooks.preprocess(src);
          }
          let tokens = lexer(src, opt);
          if (opt.hooks) {
            tokens = opt.hooks.processAllTokens(tokens);
          }
          if (opt.walkTokens) {
            this.walkTokens(tokens, opt.walkTokens);
          }
          let html2 = parser(tokens, opt);
          if (opt.hooks) {
            html2 = opt.hooks.postprocess(html2);
          }
          return html2;
        } catch (e) {
          return throwError(e);
        }
      };
      return parse;
    }
    onError(silent, async) {
      return (e) => {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (silent) {
          const msg = "<p>An error occurred:</p><pre>" + escape$1(e.message + "", true) + "</pre>";
          if (async) {
            return Promise.resolve(msg);
          }
          return msg;
        }
        if (async) {
          return Promise.reject(e);
        }
        throw e;
      };
    }
  }
  const markedInstance = new Marked();
  function marked(src, opt) {
    return markedInstance.parse(src, opt);
  }
  marked.options = marked.setOptions = function(options) {
    markedInstance.setOptions(options);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
  };
  marked.getDefaults = _getDefaults;
  marked.defaults = _defaults;
  marked.use = function(...args) {
    markedInstance.use(...args);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
  };
  marked.walkTokens = function(tokens, callback) {
    return markedInstance.walkTokens(tokens, callback);
  };
  marked.parseInline = markedInstance.parseInline;
  marked.Parser = _Parser;
  marked.parser = _Parser.parse;
  marked.Renderer = _Renderer;
  marked.TextRenderer = _TextRenderer;
  marked.Lexer = _Lexer;
  marked.lexer = _Lexer.lex;
  marked.Tokenizer = _Tokenizer;
  marked.Hooks = _Hooks;
  marked.parse = marked;
  marked.options;
  marked.setOptions;
  marked.use;
  marked.walkTokens;
  marked.parseInline;
  _Parser.parse;
  _Lexer.lex;
  const _hoisted_1 = {
    "data-theme": "light",
    class: "max-w-lg mx-auto p-4 border border-gray-300 rounded-lg shadow-md"
  };
  const _hoisted_2 = { class: "mb-4" };
  const _hoisted_3 = { class: "mb-2" };
  const _hoisted_4 = ["value"];
  const _hoisted_5 = { class: "mb-4" };
  const _hoisted_6 = {
    key: 0,
    class: "text-center"
  };
  const _hoisted_7 = { class: "text-gray-500" };
  const _hoisted_8 = ["innerHTML"];
  const _hoisted_9 = { class: "flex" };
  const _sfc_main = /* @__PURE__ */ defineComponent({
    __name: "SimpleChat",
    props: {
      text: { type: String }
    },
    setup(__props) {
      const chatbox = useChatboxStore();
      const { client, systemPrompt } = useAI();
      const fetchModels = async () => {
        try {
          const response = await client.models.list();
          chatbox.setModels(response.data.map((model) => model.id));
          chatbox.setSelectedModel(chatbox.models[0]);
        } catch (error) {
          console.error("Failed to fetch models:", error);
        }
      };
      const controller = new AbortController();
      const sendMessage = async () => {
        if (!chatbox.newMessage) return;
        chatbox.addMessage({
          content: chatbox.newMessage,
          role: "user"
        });
        try {
          const response = await client.chat.completions.create(
            {
              model: chatbox.selectedModel,
              messages: chatbox.messages,
              max_tokens: chatbox.maxTokens
            },
            { signal: controller.signal }
          );
          chatbox.addMessage({
            content: response.choices[0].message.content,
            role: "assistant"
          });
        } catch (error) {
          console.error("Failed to send message:", error);
        } finally {
          chatbox.clearNewMessage();
        }
      };
      const clearMessages = () => {
        controller.abort();
        chatbox.clearMessages();
      };
      const copyText = async () => {
        try {
          console.log(`userMessages ${typeof chatbox.userMessages}`);
          console.log(chatbox.userMessages.length);
          console.log(chatbox.userMessages);
          if (chatbox.userMessages.length > 0) {
          }
        } catch (err) {
          console.error("Failed to copy:", err);
        }
      };
      onMounted(async () => {
        await fetchModels();
        chatbox.setSystemPrompt(systemPrompt);
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1, [
          createBaseVNode("div", _hoisted_2, [
            createBaseVNode("button", {
              onClick: clearMessages,
              class: "btn btn-error btn-sm float-right"
            }, " Clear Messages "),
            createBaseVNode("button", {
              onClick: copyText,
              class: "px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500"
            }, " Copy Last Response "),
            _cache[3] || (_cache[3] = createBaseVNode("h2", { class: "text-xl font-semibold" }, "Chat", -1)),
            createBaseVNode("div", _hoisted_3, [
              _cache[2] || (_cache[2] = createBaseVNode("label", {
                for: "model-select",
                class: "block text-gray-700"
              }, "Select Model:", -1)),
              withDirectives(createBaseVNode("select", {
                id: "model-select",
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(chatbox).selectedModel = $event),
                class: "select select-bordered select-sm w-full max-w-xs"
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(chatbox).models, (model) => {
                  return openBlock(), createElementBlock("option", {
                    key: model,
                    value: model
                  }, toDisplayString(model), 9, _hoisted_4);
                }), 128))
              ], 512), [
                [vModelSelect, unref(chatbox).selectedModel]
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_5, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(chatbox).messages, (message, index) => {
              return openBlock(), createElementBlock("div", {
                key: index,
                class: "mb-2"
              }, [
                message.role === "system" ? (openBlock(), createElementBlock("div", _hoisted_6, [
                  createBaseVNode("p", _hoisted_7, toDisplayString(message.content), 1)
                ])) : createCommentVNode("", true),
                message.role !== "system" ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass({ "text-right": message.role === "user" })
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass(["inline-block p-2 rounded-lg", message.role === "user" ? "bg-blue-500 text-white" : "bg-gray-300 text-black"]),
                    innerHTML: unref(marked).parse(message.content)
                  }, null, 10, _hoisted_8)
                ], 2)) : createCommentVNode("", true)
              ]);
            }), 128))
          ]),
          createBaseVNode("div", _hoisted_9, [
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(chatbox).newMessage = $event),
              onKeyup: withKeys(sendMessage, ["enter"]),
              type: "text",
              placeholder: "Type a message...",
              class: "w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            }, null, 544), [
              [vModelText, unref(chatbox).newMessage]
            ]),
            createBaseVNode("button", {
              onClick: sendMessage,
              class: "ml-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
            }, " Send ")
          ])
        ]);
      };
    }
  });
  const _style_0 = '[data-v-1d30cf0f]:root,\n[data-theme][data-v-1d30cf0f] {\n    background-color: var(--fallback-b1,oklch(var(--b1)/1));\n    color: var(--fallback-bc,oklch(var(--bc)/1))\n}\n@supports not (color: oklch(0% 0 0)) {\n[data-v-1d30cf0f]:root {\n        color-scheme: light;\n        --fallback-p: #491eff;\n        --fallback-pc: #d4dbff;\n        --fallback-s: #ff41c7;\n        --fallback-sc: #fff9fc;\n        --fallback-a: #00cfbd;\n        --fallback-ac: #00100d;\n        --fallback-n: #2b3440;\n        --fallback-nc: #d7dde4;\n        --fallback-b1: #ffffff;\n        --fallback-b2: #e5e6e6;\n        --fallback-b3: #e5e6e6;\n        --fallback-bc: #1f2937;\n        --fallback-in: #00b3f0;\n        --fallback-inc: #000000;\n        --fallback-su: #00ca92;\n        --fallback-suc: #000000;\n        --fallback-wa: #ffc22d;\n        --fallback-wac: #000000;\n        --fallback-er: #ff6f70;\n        --fallback-erc: #000000\n    }\n@media (prefers-color-scheme: dark) {\n[data-v-1d30cf0f]:root {\n            color-scheme: dark;\n            --fallback-p: #7582ff;\n            --fallback-pc: #050617;\n            --fallback-s: #ff71cf;\n            --fallback-sc: #190211;\n            --fallback-a: #00c7b5;\n            --fallback-ac: #000e0c;\n            --fallback-n: #2a323c;\n            --fallback-nc: #a6adbb;\n            --fallback-b1: #1d232a;\n            --fallback-b2: #191e24;\n            --fallback-b3: #15191e;\n            --fallback-bc: #a6adbb;\n            --fallback-in: #00b3f0;\n            --fallback-inc: #000000;\n            --fallback-su: #00ca92;\n            --fallback-suc: #000000;\n            --fallback-wa: #ffc22d;\n            --fallback-wac: #000000;\n            --fallback-er: #ff6f70;\n            --fallback-erc: #000000\n        }\n}\n}\nhtml[data-v-1d30cf0f] {\n    -webkit-tap-highlight-color: transparent\n}\n[data-v-1d30cf0f] {\n    scrollbar-color: color-mix(in oklch, currentColor 35%, transparent) transparent\n}\n[data-v-1d30cf0f]:hover {\n    scrollbar-color: color-mix(in oklch, currentColor 60%, transparent) transparent\n}\n[data-v-1d30cf0f]:root {\n    color-scheme: light;\n    --in: 72.06% 0.191 231.6;\n    --su: 64.8% 0.150 160;\n    --wa: 84.71% 0.199 83.87;\n    --er: 71.76% 0.221 22.18;\n    --pc: 89.824% 0.06192 275.75;\n    --ac: 15.352% 0.0368 183.61;\n    --inc: 0% 0 0;\n    --suc: 0% 0 0;\n    --wac: 0% 0 0;\n    --erc: 0% 0 0;\n    --rounded-box: 1rem;\n    --rounded-btn: 0.5rem;\n    --rounded-badge: 1.9rem;\n    --animation-btn: 0.25s;\n    --animation-input: .2s;\n    --btn-focus-scale: 0.95;\n    --border-btn: 1px;\n    --tab-border: 1px;\n    --tab-radius: 0.5rem;\n    --p: 49.12% 0.3096 275.75;\n    --s: 69.71% 0.329 342.55;\n    --sc: 98.71% 0.0106 342.55;\n    --a: 76.76% 0.184 183.61;\n    --n: 32.1785% 0.02476 255.701624;\n    --nc: 89.4994% 0.011585 252.096176;\n    --b1: 100% 0 0;\n    --b2: 96.1151% 0 0;\n    --b3: 92.4169% 0.00108 197.137559;\n    --bc: 27.8078% 0.029596 256.847952\n}\n@media (prefers-color-scheme: dark) {\n[data-v-1d30cf0f]:root {\n        color-scheme: dark;\n        --in: 72.06% 0.191 231.6;\n        --su: 64.8% 0.150 160;\n        --wa: 84.71% 0.199 83.87;\n        --er: 71.76% 0.221 22.18;\n        --pc: 13.138% 0.0392 275.75;\n        --sc: 14.96% 0.052 342.55;\n        --ac: 14.902% 0.0334 183.61;\n        --inc: 0% 0 0;\n        --suc: 0% 0 0;\n        --wac: 0% 0 0;\n        --erc: 0% 0 0;\n        --rounded-box: 1rem;\n        --rounded-btn: 0.5rem;\n        --rounded-badge: 1.9rem;\n        --animation-btn: 0.25s;\n        --animation-input: .2s;\n        --btn-focus-scale: 0.95;\n        --border-btn: 1px;\n        --tab-border: 1px;\n        --tab-radius: 0.5rem;\n        --p: 65.69% 0.196 275.75;\n        --s: 74.8% 0.26 342.55;\n        --a: 74.51% 0.167 183.61;\n        --n: 31.3815% 0.021108 254.139175;\n        --nc: 74.6477% 0.0216 264.435964;\n        --b1: 25.3267% 0.015896 252.417568;\n        --b2: 23.2607% 0.013807 253.100675;\n        --b3: 21.1484% 0.01165 254.087939;\n        --bc: 74.6477% 0.0216 264.435964\n    }\n}\n[data-theme=light][data-v-1d30cf0f] {\n    color-scheme: light;\n    --in: 72.06% 0.191 231.6;\n    --su: 64.8% 0.150 160;\n    --wa: 84.71% 0.199 83.87;\n    --er: 71.76% 0.221 22.18;\n    --pc: 89.824% 0.06192 275.75;\n    --ac: 15.352% 0.0368 183.61;\n    --inc: 0% 0 0;\n    --suc: 0% 0 0;\n    --wac: 0% 0 0;\n    --erc: 0% 0 0;\n    --rounded-box: 1rem;\n    --rounded-btn: 0.5rem;\n    --rounded-badge: 1.9rem;\n    --animation-btn: 0.25s;\n    --animation-input: .2s;\n    --btn-focus-scale: 0.95;\n    --border-btn: 1px;\n    --tab-border: 1px;\n    --tab-radius: 0.5rem;\n    --p: 49.12% 0.3096 275.75;\n    --s: 69.71% 0.329 342.55;\n    --sc: 98.71% 0.0106 342.55;\n    --a: 76.76% 0.184 183.61;\n    --n: 32.1785% 0.02476 255.701624;\n    --nc: 89.4994% 0.011585 252.096176;\n    --b1: 100% 0 0;\n    --b2: 96.1151% 0 0;\n    --b3: 92.4169% 0.00108 197.137559;\n    --bc: 27.8078% 0.029596 256.847952\n}\n[data-theme=dark][data-v-1d30cf0f] {\n    color-scheme: dark;\n    --in: 72.06% 0.191 231.6;\n    --su: 64.8% 0.150 160;\n    --wa: 84.71% 0.199 83.87;\n    --er: 71.76% 0.221 22.18;\n    --pc: 13.138% 0.0392 275.75;\n    --sc: 14.96% 0.052 342.55;\n    --ac: 14.902% 0.0334 183.61;\n    --inc: 0% 0 0;\n    --suc: 0% 0 0;\n    --wac: 0% 0 0;\n    --erc: 0% 0 0;\n    --rounded-box: 1rem;\n    --rounded-btn: 0.5rem;\n    --rounded-badge: 1.9rem;\n    --animation-btn: 0.25s;\n    --animation-input: .2s;\n    --btn-focus-scale: 0.95;\n    --border-btn: 1px;\n    --tab-border: 1px;\n    --tab-radius: 0.5rem;\n    --p: 65.69% 0.196 275.75;\n    --s: 74.8% 0.26 342.55;\n    --a: 74.51% 0.167 183.61;\n    --n: 31.3815% 0.021108 254.139175;\n    --nc: 74.6477% 0.0216 264.435964;\n    --b1: 25.3267% 0.015896 252.417568;\n    --b2: 23.2607% 0.013807 253.100675;\n    --b3: 21.1484% 0.01165 254.087939;\n    --bc: 74.6477% 0.0216 264.435964\n}\n[data-v-1d30cf0f],[data-v-1d30cf0f]::before,[data-v-1d30cf0f]::after {\n    --tw-border-spacing-x: 0;\n    --tw-border-spacing-y: 0;\n    --tw-translate-x: 0;\n    --tw-translate-y: 0;\n    --tw-rotate: 0;\n    --tw-skew-x: 0;\n    --tw-skew-y: 0;\n    --tw-scale-x: 1;\n    --tw-scale-y: 1;\n    --tw-pan-x:  ;\n    --tw-pan-y:  ;\n    --tw-pinch-zoom:  ;\n    --tw-scroll-snap-strictness: proximity;\n    --tw-gradient-from-position:  ;\n    --tw-gradient-via-position:  ;\n    --tw-gradient-to-position:  ;\n    --tw-ordinal:  ;\n    --tw-slashed-zero:  ;\n    --tw-numeric-figure:  ;\n    --tw-numeric-spacing:  ;\n    --tw-numeric-fraction:  ;\n    --tw-ring-inset:  ;\n    --tw-ring-offset-width: 0px;\n    --tw-ring-offset-color: #fff;\n    --tw-ring-color: rgb(59 130 246 / 0.5);\n    --tw-ring-offset-shadow: 0 0 #0000;\n    --tw-ring-shadow: 0 0 #0000;\n    --tw-shadow: 0 0 #0000;\n    --tw-shadow-colored: 0 0 #0000;\n    --tw-blur:  ;\n    --tw-brightness:  ;\n    --tw-contrast:  ;\n    --tw-grayscale:  ;\n    --tw-hue-rotate:  ;\n    --tw-invert:  ;\n    --tw-saturate:  ;\n    --tw-sepia:  ;\n    --tw-drop-shadow:  ;\n    --tw-backdrop-blur:  ;\n    --tw-backdrop-brightness:  ;\n    --tw-backdrop-contrast:  ;\n    --tw-backdrop-grayscale:  ;\n    --tw-backdrop-hue-rotate:  ;\n    --tw-backdrop-invert:  ;\n    --tw-backdrop-opacity:  ;\n    --tw-backdrop-saturate:  ;\n    --tw-backdrop-sepia:  ;\n    --tw-contain-size:  ;\n    --tw-contain-layout:  ;\n    --tw-contain-paint:  ;\n    --tw-contain-style:  \n}\n[data-v-1d30cf0f]::backdrop {\n    --tw-border-spacing-x: 0;\n    --tw-border-spacing-y: 0;\n    --tw-translate-x: 0;\n    --tw-translate-y: 0;\n    --tw-rotate: 0;\n    --tw-skew-x: 0;\n    --tw-skew-y: 0;\n    --tw-scale-x: 1;\n    --tw-scale-y: 1;\n    --tw-pan-x:  ;\n    --tw-pan-y:  ;\n    --tw-pinch-zoom:  ;\n    --tw-scroll-snap-strictness: proximity;\n    --tw-gradient-from-position:  ;\n    --tw-gradient-via-position:  ;\n    --tw-gradient-to-position:  ;\n    --tw-ordinal:  ;\n    --tw-slashed-zero:  ;\n    --tw-numeric-figure:  ;\n    --tw-numeric-spacing:  ;\n    --tw-numeric-fraction:  ;\n    --tw-ring-inset:  ;\n    --tw-ring-offset-width: 0px;\n    --tw-ring-offset-color: #fff;\n    --tw-ring-color: rgb(59 130 246 / 0.5);\n    --tw-ring-offset-shadow: 0 0 #0000;\n    --tw-ring-shadow: 0 0 #0000;\n    --tw-shadow: 0 0 #0000;\n    --tw-shadow-colored: 0 0 #0000;\n    --tw-blur:  ;\n    --tw-brightness:  ;\n    --tw-contrast:  ;\n    --tw-grayscale:  ;\n    --tw-hue-rotate:  ;\n    --tw-invert:  ;\n    --tw-saturate:  ;\n    --tw-sepia:  ;\n    --tw-drop-shadow:  ;\n    --tw-backdrop-blur:  ;\n    --tw-backdrop-brightness:  ;\n    --tw-backdrop-contrast:  ;\n    --tw-backdrop-grayscale:  ;\n    --tw-backdrop-hue-rotate:  ;\n    --tw-backdrop-invert:  ;\n    --tw-backdrop-opacity:  ;\n    --tw-backdrop-saturate:  ;\n    --tw-backdrop-sepia:  ;\n    --tw-contain-size:  ;\n    --tw-contain-layout:  ;\n    --tw-contain-paint:  ;\n    --tw-contain-style:  \n}\n.alert[data-v-1d30cf0f] {\n    display: grid;\n    width: 100%;\n    grid-auto-flow: row;\n    align-content: flex-start;\n    align-items: center;\n    justify-items: center;\n    gap: 1rem;\n    text-align: center;\n    border-radius: var(--rounded-box, 1rem);\n    border-width: 1px;\n    --tw-border-opacity: 1;\n    border-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-border-opacity)));\n    padding: 1rem;\n    --tw-text-opacity: 1;\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\n    --alert-bg: var(--fallback-b2,oklch(var(--b2)/1));\n    --alert-bg-mix: var(--fallback-b1,oklch(var(--b1)/1));\n    background-color: var(--alert-bg)\n}\n@media (min-width: 640px) {\n.alert[data-v-1d30cf0f] {\n        grid-auto-flow: column;\n        grid-template-columns: auto minmax(auto,1fr);\n        justify-items: start;\n        text-align: start\n}\n}\n.avatar.placeholder > div[data-v-1d30cf0f] {\n    display: flex;\n    align-items: center;\n    justify-content: center\n}\n@media (hover:hover) {\n.label a[data-v-1d30cf0f]:hover {\n        --tw-text-opacity: 1;\n        color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)))\n}\n}\n.btn[data-v-1d30cf0f] {\n    display: inline-flex;\n    height: 3rem;\n    min-height: 3rem;\n    flex-shrink: 0;\n    cursor: pointer;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n            user-select: none;\n    flex-wrap: wrap;\n    align-items: center;\n    justify-content: center;\n    border-radius: var(--rounded-btn, 0.5rem);\n    border-color: transparent;\n    border-color: oklch(var(--btn-color, var(--b2)) / var(--tw-border-opacity));\n    padding-left: 1rem;\n    padding-right: 1rem;\n    text-align: center;\n    font-size: 0.875rem;\n    line-height: 1em;\n    gap: 0.5rem;\n    font-weight: 600;\n    text-decoration-line: none;\n    transition-duration: 200ms;\n    transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\n    border-width: var(--border-btn, 1px);\n    transition-property: color, background-color, border-color, opacity, box-shadow, transform;\n    --tw-text-opacity: 1;\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\n    --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);\n    --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);\n    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n    outline-color: var(--fallback-bc,oklch(var(--bc)/1));\n    background-color: oklch(var(--btn-color, var(--b2)) / var(--tw-bg-opacity));\n    --tw-bg-opacity: 1;\n    --tw-border-opacity: 1\n}\n.btn-disabled[data-v-1d30cf0f],\n  .btn[disabled][data-v-1d30cf0f],\n  .btn[data-v-1d30cf0f]:disabled {\n    pointer-events: none\n}\n:where(.btn[data-v-1d30cf0f]:is(input[type="checkbox"])),\n:where(.btn[data-v-1d30cf0f]:is(input[type="radio"])) {\n    width: auto;\n    -webkit-appearance: none;\n       -moz-appearance: none;\n            appearance: none\n}\n.btn[data-v-1d30cf0f]:is(input[type="checkbox"]):after,\n.btn[data-v-1d30cf0f]:is(input[type="radio"]):after {\n    --tw-content: attr(aria-label);\n    content: var(--tw-content)\n}\n.chat[data-v-1d30cf0f] {\n    display: grid;\n    grid-template-columns: repeat(2, minmax(0, 1fr));\n    -moz-column-gap: 0.75rem;\n         column-gap: 0.75rem;\n    padding-top: 0.25rem;\n    padding-bottom: 0.25rem\n}\n@media (hover: hover) {\n.btn[data-v-1d30cf0f]:hover {\n        --tw-border-opacity: 1;\n        border-color: var(--fallback-b3,oklch(var(--b3)/var(--tw-border-opacity)));\n        --tw-bg-opacity: 1;\n        background-color: var(--fallback-b3,oklch(var(--b3)/var(--tw-bg-opacity)))\n}\n@supports (color: color-mix(in oklab, black, black)) {\n.btn[data-v-1d30cf0f]:hover {\n            background-color: color-mix(\n            in oklab,\n            oklch(var(--btn-color, var(--b2)) / var(--tw-bg-opacity, 1)) 90%,\n            black\n          );\n            border-color: color-mix(\n            in oklab,\n            oklch(var(--btn-color, var(--b2)) / var(--tw-border-opacity, 1)) 90%,\n            black\n          )\n}\n}\n@supports not (color: oklch(0% 0 0)) {\n.btn[data-v-1d30cf0f]:hover {\n            background-color: var(--btn-color, var(--fallback-b2));\n            border-color: var(--btn-color, var(--fallback-b2))\n}\n}\n.btn.glass[data-v-1d30cf0f]:hover {\n        --glass-opacity: 25%;\n        --glass-border-opacity: 15%\n    }\n.btn-outline.btn-error[data-v-1d30cf0f]:hover {\n        --tw-text-opacity: 1;\n        color: var(--fallback-erc,oklch(var(--erc)/var(--tw-text-opacity)))\n}\n@supports (color: color-mix(in oklab, black, black)) {\n.btn-outline.btn-error[data-v-1d30cf0f]:hover {\n            background-color: color-mix(in oklab, var(--fallback-er,oklch(var(--er)/1)) 90%, black);\n            border-color: color-mix(in oklab, var(--fallback-er,oklch(var(--er)/1)) 90%, black)\n}\n}\n.btn-disabled[data-v-1d30cf0f]:hover,\n    .btn[disabled][data-v-1d30cf0f]:hover,\n    .btn[data-v-1d30cf0f]:disabled:hover {\n        --tw-border-opacity: 0;\n        background-color: var(--fallback-n,oklch(var(--n)/var(--tw-bg-opacity)));\n        --tw-bg-opacity: 0.2;\n        color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\n        --tw-text-opacity: 0.2\n    }\n@supports (color: color-mix(in oklab, black, black)) {\n.btn[data-v-1d30cf0f]:is(input[type="checkbox"]:checked):hover, .btn[data-v-1d30cf0f]:is(input[type="radio"]:checked):hover {\n            background-color: color-mix(in oklab, var(--fallback-p,oklch(var(--p)/1)) 90%, black);\n            border-color: color-mix(in oklab, var(--fallback-p,oklch(var(--p)/1)) 90%, black)\n}\n}\n}\n.label[data-v-1d30cf0f] {\n    display: flex;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n            user-select: none;\n    align-items: center;\n    justify-content: space-between;\n    padding-left: 0.25rem;\n    padding-right: 0.25rem;\n    padding-top: 0.5rem;\n    padding-bottom: 0.5rem\n}\n.input[data-v-1d30cf0f] {\n    flex-shrink: 1;\n    -webkit-appearance: none;\n       -moz-appearance: none;\n            appearance: none;\n    height: 3rem;\n    padding-left: 1rem;\n    padding-right: 1rem;\n    font-size: 1rem;\n    line-height: 2;\n    line-height: 1.5rem;\n    border-radius: var(--rounded-btn, 0.5rem);\n    border-width: 1px;\n    border-color: transparent;\n    --tw-bg-opacity: 1;\n    background-color: var(--fallback-b1,oklch(var(--b1)/var(--tw-bg-opacity)))\n}\n.input[type="number"][data-v-1d30cf0f]::-webkit-inner-spin-button,\n.input-md[type="number"][data-v-1d30cf0f]::-webkit-inner-spin-button {\n    margin-top: -1rem;\n    margin-bottom: -1rem;\n    margin-inline-end: -1rem\n}\n.select[data-v-1d30cf0f] {\n    display: inline-flex;\n    cursor: pointer;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n            user-select: none;\n    -webkit-appearance: none;\n       -moz-appearance: none;\n            appearance: none;\n    height: 3rem;\n    min-height: 3rem;\n    padding-inline-start: 1rem;\n    padding-inline-end: 2.5rem;\n    font-size: 0.875rem;\n    line-height: 1.25rem;\n    line-height: 2;\n    border-radius: var(--rounded-btn, 0.5rem);\n    border-width: 1px;\n    border-color: transparent;\n    --tw-bg-opacity: 1;\n    background-color: var(--fallback-b1,oklch(var(--b1)/var(--tw-bg-opacity)));\n    background-image: linear-gradient(45deg, transparent 50%, currentColor 50%),\n    linear-gradient(135deg, currentColor 50%, transparent 50%);\n    background-position: calc(100% - 20px) calc(1px + 50%),\n    calc(100% - 16.1px) calc(1px + 50%);\n    background-size: 4px 4px,\n    4px 4px;\n    background-repeat: no-repeat\n}\n.select[multiple][data-v-1d30cf0f] {\n    height: auto\n}\n.btm-nav > * .label[data-v-1d30cf0f] {\n    font-size: 1rem;\n    line-height: 1.5rem\n}\n@media (prefers-reduced-motion: no-preference) {\n.btn[data-v-1d30cf0f] {\n        animation: button-pop-1d30cf0f var(--animation-btn, 0.25s) ease-out\n}\n}\n.btn[data-v-1d30cf0f]:active:hover,\n  .btn[data-v-1d30cf0f]:active:focus {\n    animation: button-pop-1d30cf0f 0s ease-out;\n    transform: scale(var(--btn-focus-scale, 0.97))\n}\n@supports not (color: oklch(0% 0 0)) {\n.btn[data-v-1d30cf0f] {\n        background-color: var(--btn-color, var(--fallback-b2));\n        border-color: var(--btn-color, var(--fallback-b2))\n}\n.btn-error[data-v-1d30cf0f] {\n        --btn-color: var(--fallback-er)\n    }\n}\n@supports (color: color-mix(in oklab, black, black)) {\n.btn-outline.btn-error.btn-active[data-v-1d30cf0f] {\n        background-color: color-mix(in oklab, var(--fallback-er,oklch(var(--er)/1)) 90%, black);\n        border-color: color-mix(in oklab, var(--fallback-er,oklch(var(--er)/1)) 90%, black)\n}\n}\n.btn[data-v-1d30cf0f]:focus-visible {\n    outline-style: solid;\n    outline-width: 2px;\n    outline-offset: 2px\n}\n@supports (color: oklch(0% 0 0)) {\n.btn-error[data-v-1d30cf0f] {\n        --btn-color: var(--er)\n    }\n}\n.btn-error[data-v-1d30cf0f] {\n    --tw-text-opacity: 1;\n    color: var(--fallback-erc,oklch(var(--erc)/var(--tw-text-opacity)));\n    outline-color: var(--fallback-er,oklch(var(--er)/1))\n}\n.btn.glass[data-v-1d30cf0f] {\n    --tw-shadow: 0 0 #0000;\n    --tw-shadow-colored: 0 0 #0000;\n    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n    outline-color: currentColor\n}\n.btn.glass.btn-active[data-v-1d30cf0f] {\n    --glass-opacity: 25%;\n    --glass-border-opacity: 15%\n}\n.btn-outline.btn-error[data-v-1d30cf0f] {\n    --tw-text-opacity: 1;\n    color: var(--fallback-er,oklch(var(--er)/var(--tw-text-opacity)))\n}\n.btn-outline.btn-error.btn-active[data-v-1d30cf0f] {\n    --tw-text-opacity: 1;\n    color: var(--fallback-erc,oklch(var(--erc)/var(--tw-text-opacity)))\n}\n.btn.btn-disabled[data-v-1d30cf0f],\n  .btn[disabled][data-v-1d30cf0f],\n  .btn[data-v-1d30cf0f]:disabled {\n    --tw-border-opacity: 0;\n    background-color: var(--fallback-n,oklch(var(--n)/var(--tw-bg-opacity)));\n    --tw-bg-opacity: 0.2;\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-text-opacity)));\n    --tw-text-opacity: 0.2\n}\n.btn[data-v-1d30cf0f]:is(input[type="checkbox"]:checked),\n.btn[data-v-1d30cf0f]:is(input[type="radio"]:checked) {\n    --tw-border-opacity: 1;\n    border-color: var(--fallback-p,oklch(var(--p)/var(--tw-border-opacity)));\n    --tw-bg-opacity: 1;\n    background-color: var(--fallback-p,oklch(var(--p)/var(--tw-bg-opacity)));\n    --tw-text-opacity: 1;\n    color: var(--fallback-pc,oklch(var(--pc)/var(--tw-text-opacity)))\n}\n.btn[data-v-1d30cf0f]:is(input[type="checkbox"]:checked):focus-visible, .btn[data-v-1d30cf0f]:is(input[type="radio"]:checked):focus-visible {\n    outline-color: var(--fallback-p,oklch(var(--p)/1))\n}\n@keyframes button-pop-1d30cf0f {\n0% {\n        transform: scale(var(--btn-focus-scale, 0.98))\n}\n40% {\n        transform: scale(1.02)\n}\n100% {\n        transform: scale(1)\n}\n}\n@keyframes checkmark-1d30cf0f {\n0% {\n        background-position-y: 5px\n}\n50% {\n        background-position-y: -2px\n}\n100% {\n        background-position-y: 0\n}\n}\n.input input[data-v-1d30cf0f] {\n    --tw-bg-opacity: 1;\n    background-color: var(--fallback-p,oklch(var(--p)/var(--tw-bg-opacity)));\n    background-color: transparent\n}\n.input input[data-v-1d30cf0f]:focus {\n    outline: 2px solid transparent;\n    outline-offset: 2px\n}\n.input[list][data-v-1d30cf0f]::-webkit-calendar-picker-indicator {\n    line-height: 1em\n}\n.input[data-v-1d30cf0f]:focus,\n  .input[data-v-1d30cf0f]:focus-within {\n    box-shadow: none;\n    border-color: var(--fallback-bc,oklch(var(--bc)/0.2));\n    outline-style: solid;\n    outline-width: 2px;\n    outline-offset: 2px;\n    outline-color: var(--fallback-bc,oklch(var(--bc)/0.2))\n}\n.input[data-v-1d30cf0f]:has(> input[disabled]),\n  .input-disabled[data-v-1d30cf0f],\n  .input[data-v-1d30cf0f]:disabled,\n  .input[disabled][data-v-1d30cf0f] {\n    cursor: not-allowed;\n    --tw-border-opacity: 1;\n    border-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-border-opacity)));\n    --tw-bg-opacity: 1;\n    background-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-bg-opacity)));\n    color: var(--fallback-bc,oklch(var(--bc)/0.4))\n}\n.input[data-v-1d30cf0f]:has(> input[disabled])::-moz-placeholder, .input-disabled[data-v-1d30cf0f]::-moz-placeholder, .input[data-v-1d30cf0f]:disabled::-moz-placeholder, .input[disabled][data-v-1d30cf0f]::-moz-placeholder {\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-placeholder-opacity)));\n    --tw-placeholder-opacity: 0.2\n}\n.input[data-v-1d30cf0f]:has(> input[disabled])::placeholder,\n  .input-disabled[data-v-1d30cf0f]::placeholder,\n  .input[data-v-1d30cf0f]:disabled::placeholder,\n  .input[disabled][data-v-1d30cf0f]::placeholder {\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-placeholder-opacity)));\n    --tw-placeholder-opacity: 0.2\n}\n.input:has(> input[disabled]) > input[disabled][data-v-1d30cf0f] {\n    cursor: not-allowed\n}\n.input[data-v-1d30cf0f]::-webkit-date-and-time-value {\n    text-align: inherit\n}\n.join[data-v-1d30cf0f] > :where(*:not(:first-child)):is(.btn) {\n    margin-inline-start: calc(var(--border-btn) * -1)\n}\n.mockup-browser .mockup-browser-toolbar .input[data-v-1d30cf0f] {\n    position: relative;\n    margin-left: auto;\n    margin-right: auto;\n    display: block;\n    height: 1.75rem;\n    width: 24rem;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    --tw-bg-opacity: 1;\n    background-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-bg-opacity)));\n    padding-left: 2rem;\n    direction: ltr\n}\n.mockup-browser .mockup-browser-toolbar .input[data-v-1d30cf0f]:before {\n    content: "";\n    position: absolute;\n    left: 0.5rem;\n    top: 50%;\n    aspect-ratio: 1 / 1;\n    height: 0.75rem;\n    --tw-translate-y: -50%;\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n    border-radius: 9999px;\n    border-width: 2px;\n    border-color: currentColor;\n    opacity: 0.6\n}\n.mockup-browser .mockup-browser-toolbar .input[data-v-1d30cf0f]:after {\n    content: "";\n    position: absolute;\n    left: 1.25rem;\n    top: 50%;\n    height: 0.5rem;\n    --tw-translate-y: 25%;\n    --tw-rotate: -45deg;\n    transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n    border-radius: 9999px;\n    border-width: 1px;\n    border-color: currentColor;\n    opacity: 0.6\n}\n@keyframes modal-pop-1d30cf0f {\n0% {\n        opacity: 0\n}\n}\n@keyframes progress-loading-1d30cf0f {\n50% {\n        background-position-x: -115%\n}\n}\n@keyframes radiomark-1d30cf0f {\n0% {\n        box-shadow: 0 0 0 12px var(--fallback-b1,oklch(var(--b1)/1)) inset,\n      0 0 0 12px var(--fallback-b1,oklch(var(--b1)/1)) inset\n}\n50% {\n        box-shadow: 0 0 0 3px var(--fallback-b1,oklch(var(--b1)/1)) inset,\n      0 0 0 3px var(--fallback-b1,oklch(var(--b1)/1)) inset\n}\n100% {\n        box-shadow: 0 0 0 4px var(--fallback-b1,oklch(var(--b1)/1)) inset,\n      0 0 0 4px var(--fallback-b1,oklch(var(--b1)/1)) inset\n}\n}\n@keyframes rating-pop-1d30cf0f {\n0% {\n        transform: translateY(-0.125em)\n}\n40% {\n        transform: translateY(-0.125em)\n}\n100% {\n        transform: translateY(0)\n}\n}\n.select-bordered[data-v-1d30cf0f] {\n    border-color: var(--fallback-bc,oklch(var(--bc)/0.2))\n}\n.select[data-v-1d30cf0f]:focus {\n    box-shadow: none;\n    border-color: var(--fallback-bc,oklch(var(--bc)/0.2));\n    outline-style: solid;\n    outline-width: 2px;\n    outline-offset: 2px;\n    outline-color: var(--fallback-bc,oklch(var(--bc)/0.2))\n}\n.select-disabled[data-v-1d30cf0f],\n  .select[data-v-1d30cf0f]:disabled,\n  .select[disabled][data-v-1d30cf0f] {\n    cursor: not-allowed;\n    --tw-border-opacity: 1;\n    border-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-border-opacity)));\n    --tw-bg-opacity: 1;\n    background-color: var(--fallback-b2,oklch(var(--b2)/var(--tw-bg-opacity)));\n    color: var(--fallback-bc,oklch(var(--bc)/0.4))\n}\n.select-disabled[data-v-1d30cf0f]::-moz-placeholder, .select[data-v-1d30cf0f]:disabled::-moz-placeholder, .select[disabled][data-v-1d30cf0f]::-moz-placeholder {\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-placeholder-opacity)));\n    --tw-placeholder-opacity: 0.2\n}\n.select-disabled[data-v-1d30cf0f]::placeholder,\n  .select[data-v-1d30cf0f]:disabled::placeholder,\n  .select[disabled][data-v-1d30cf0f]::placeholder {\n    color: var(--fallback-bc,oklch(var(--bc)/var(--tw-placeholder-opacity)));\n    --tw-placeholder-opacity: 0.2\n}\n.select-multiple[data-v-1d30cf0f],\n  .select[multiple][data-v-1d30cf0f],\n  .select[size].select[data-v-1d30cf0f]:not([size="1"]) {\n    background-image: none;\n    padding-right: 1rem\n}\n[dir="rtl"] .select[data-v-1d30cf0f] {\n    background-position: calc(0% + 12px) calc(1px + 50%),\n    calc(0% + 16px) calc(1px + 50%)\n}\n@keyframes skeleton-1d30cf0f {\nfrom {\n        background-position: 150%\n}\nto {\n        background-position: -50%\n}\n}\n@keyframes toast-pop-1d30cf0f {\n0% {\n        transform: scale(0.9);\n        opacity: 0\n}\n100% {\n        transform: scale(1);\n        opacity: 1\n}\n}\n.btn-sm[data-v-1d30cf0f] {\n    height: 2rem;\n    min-height: 2rem;\n    padding-left: 0.75rem;\n    padding-right: 0.75rem;\n    font-size: 0.875rem\n}\n.btn-square[data-v-1d30cf0f]:where(.btn-sm) {\n    height: 2rem;\n    width: 2rem;\n    padding: 0px\n}\n.btn-circle[data-v-1d30cf0f]:where(.btn-sm) {\n    height: 2rem;\n    width: 2rem;\n    border-radius: 9999px;\n    padding: 0px\n}\n.select-sm[data-v-1d30cf0f] {\n    height: 2rem;\n    min-height: 2rem;\n    padding-left: 0.75rem;\n    padding-right: 2rem;\n    font-size: 0.875rem;\n    line-height: 2rem\n}\n[dir="rtl"] .select-sm[data-v-1d30cf0f] {\n    padding-left: 2rem;\n    padding-right: 0.75rem\n}\n.join.join-vertical[data-v-1d30cf0f] > :where(*:not(:first-child)):is(.btn) {\n    margin-top: calc(var(--border-btn) * -1)\n}\n.join.join-horizontal[data-v-1d30cf0f] > :where(*:not(:first-child)):is(.btn) {\n    margin-inline-start: calc(var(--border-btn) * -1)\n}\n.float-right[data-v-1d30cf0f] {\n    float: right\n}\n.mx-auto[data-v-1d30cf0f] {\n    margin-left: auto;\n    margin-right: auto\n}\n.mb-2[data-v-1d30cf0f] {\n    margin-bottom: 0.5rem\n}\n.mb-4[data-v-1d30cf0f] {\n    margin-bottom: 1rem\n}\n.ml-2[data-v-1d30cf0f] {\n    margin-left: 0.5rem\n}\n.block[data-v-1d30cf0f] {\n    display: block\n}\n.inline-block[data-v-1d30cf0f] {\n    display: inline-block\n}\n.flex[data-v-1d30cf0f] {\n    display: flex\n}\n.w-full[data-v-1d30cf0f] {\n    width: 100%\n}\n.max-w-lg[data-v-1d30cf0f] {\n    max-width: 32rem\n}\n.max-w-xs[data-v-1d30cf0f] {\n    max-width: 20rem\n}\n.rounded-lg[data-v-1d30cf0f] {\n    border-radius: 0.5rem\n}\n.border[data-v-1d30cf0f] {\n    border-width: 1px\n}\n.border-gray-300[data-v-1d30cf0f] {\n    --tw-border-opacity: 1;\n    border-color: rgb(209 213 219 / var(--tw-border-opacity))\n}\n.bg-blue-500[data-v-1d30cf0f] {\n    --tw-bg-opacity: 1;\n    background-color: rgb(59 130 246 / var(--tw-bg-opacity))\n}\n.bg-gray-300[data-v-1d30cf0f] {\n    --tw-bg-opacity: 1;\n    background-color: rgb(209 213 219 / var(--tw-bg-opacity))\n}\n.bg-green-500[data-v-1d30cf0f] {\n    --tw-bg-opacity: 1;\n    background-color: rgb(34 197 94 / var(--tw-bg-opacity))\n}\n.p-2[data-v-1d30cf0f] {\n    padding: 0.5rem\n}\n.p-4[data-v-1d30cf0f] {\n    padding: 1rem\n}\n.px-4[data-v-1d30cf0f] {\n    padding-left: 1rem;\n    padding-right: 1rem\n}\n.py-2[data-v-1d30cf0f] {\n    padding-top: 0.5rem;\n    padding-bottom: 0.5rem\n}\n.text-center[data-v-1d30cf0f] {\n    text-align: center\n}\n.text-right[data-v-1d30cf0f] {\n    text-align: right\n}\n.text-xl[data-v-1d30cf0f] {\n    font-size: 1.25rem;\n    line-height: 1.75rem\n}\n.font-semibold[data-v-1d30cf0f] {\n    font-weight: 600\n}\n.text-black[data-v-1d30cf0f] {\n    --tw-text-opacity: 1;\n    color: rgb(0 0 0 / var(--tw-text-opacity))\n}\n.text-gray-500[data-v-1d30cf0f] {\n    --tw-text-opacity: 1;\n    color: rgb(107 114 128 / var(--tw-text-opacity))\n}\n.text-gray-700[data-v-1d30cf0f] {\n    --tw-text-opacity: 1;\n    color: rgb(55 65 81 / var(--tw-text-opacity))\n}\n.text-white[data-v-1d30cf0f] {\n    --tw-text-opacity: 1;\n    color: rgb(255 255 255 / var(--tw-text-opacity))\n}\n.shadow-md[data-v-1d30cf0f] {\n    --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);\n    --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);\n    box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)\n}\n.hover\\:bg-blue-600[data-v-1d30cf0f]:hover {\n    --tw-bg-opacity: 1;\n    background-color: rgb(37 99 235 / var(--tw-bg-opacity))\n}\n.hover\\:bg-green-600[data-v-1d30cf0f]:hover {\n    --tw-bg-opacity: 1;\n    background-color: rgb(22 163 74 / var(--tw-bg-opacity))\n}\n.focus\\:outline-none[data-v-1d30cf0f]:focus {\n    outline: 2px solid transparent;\n    outline-offset: 2px\n}\n.focus\\:ring-2[data-v-1d30cf0f]:focus {\n    --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\n    --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);\n    box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)\n}\n.focus\\:ring-blue-500[data-v-1d30cf0f]:focus {\n    --tw-ring-opacity: 1;\n    --tw-ring-color: rgb(59 130 246 / var(--tw-ring-opacity))\n}\n.focus\\:ring-green-500[data-v-1d30cf0f]:focus {\n    --tw-ring-opacity: 1;\n    --tw-ring-color: rgb(34 197 94 / var(--tw-ring-opacity))\n}\n';
  const _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };
  const SimpleChat = /* @__PURE__ */ _export_sfc(_sfc_main, [["styles", [_style_0]], ["__scopeId", "data-v-1d30cf0f"]]);
  async function fetchThroughlocalTeacheraideOpenAIGateway({
    endpoint,
    method,
    params
  }) {
    return ajax.call([
      {
        methodname: "local_teacheraide_openai_gateway",
        args: {
          endpoint,
          method,
          params
        }
      }
    ])[0];
  }
  const wwwroot = M.cfg.wwwroot;
  const webserviceBaseUrl = `${wwwroot}/webservice/restful/server.php/local_teacheraide_openai_gateway`;
  const webserviceFetch = async (url, init2) => {
    const endpoint = `${url}`.replace(webserviceBaseUrl, "");
    const method = init2 == null ? void 0 : init2.method;
    const body = init2 == null ? void 0 : init2.body;
    const res = await fetchThroughlocalTeacheraideOpenAIGateway({
      endpoint,
      method,
      params: body
    });
    return new Response(res.data, {
      // create standard Response object
      status: 200,
      headers: {
        "Content-Type": "application/json"
      }
    });
  };
  async function init({ systemPrompt }) {
    const client = new OpenAI({
      baseURL: webserviceBaseUrl,
      apiKey: "dummy",
      // This is a dummy API key, as the API key is not needed for using the webservice
      dangerouslyAllowBrowser: true,
      fetch: webserviceFetch
    });
    const configureApp = configureAppWithProviders({ client, systemPrompt });
    customElements.define(
      "teacheraide-simple-chat",
      /* @__PURE__ */ defineCustomElement(SimpleChat, { configureApp })
    );
  }
  exports.init = init;
  Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwLWxhenkuanMiLCJzb3VyY2VzIjpbIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L25vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWNvcmUvbm9kZV9tb2R1bGVzL0B2dWUvc2hhcmVkL2Rpc3Qvc2hhcmVkLmVzbS1idW5kbGVyLmpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9kaXN0L3J1bnRpbWUtY29yZS5lc20tYnVuZGxlci5qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWRvbS9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1kb20vZGlzdC9ydW50aW1lLWRvbS5lc20tYnVuZGxlci5qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3ZlcnNpb24ubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvX3NoaW1zL3JlZ2lzdHJ5Lm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL19zaGltcy9NdWx0aXBhcnRCb2R5Lm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL19zaGltcy93ZWItcnVudGltZS5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9fc2hpbXMvaW5kZXgubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvc3RyZWFtaW5nLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3VwbG9hZHMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvY29yZS5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9lcnJvci5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9wYWdpbmF0aW9uLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9jaGF0L2NoYXQubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2F1ZGlvL3NwZWVjaC5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9yZXNvdXJjZXMvYXVkaW8vdHJhbnNjcmlwdGlvbnMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2F1ZGlvL3RyYW5zbGF0aW9ucy5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9yZXNvdXJjZXMvYXVkaW8vYXVkaW8ubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2JhdGNoZXMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2JldGEvYXNzaXN0YW50cy5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9saWIvUnVubmFibGVGdW5jdGlvbi5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9saWIvY2hhdENvbXBsZXRpb25VdGlscy5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9saWIvRXZlbnRTdHJlYW0ubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvbGliL3BhcnNlci5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9saWIvQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lci5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9saWIvQ2hhdENvbXBsZXRpb25SdW5uZXIubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvX3ZlbmRvci9wYXJ0aWFsLWpzb24tcGFyc2VyL3BhcnNlci5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9saWIvQ2hhdENvbXBsZXRpb25TdHJlYW0ubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9iZXRhL2NoYXQvY29tcGxldGlvbnMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2JldGEvY2hhdC9jaGF0Lm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL2xpYi9Bc3Npc3RhbnRTdHJlYW0ubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2JldGEvdGhyZWFkcy9tZXNzYWdlcy5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9yZXNvdXJjZXMvYmV0YS90aHJlYWRzL3J1bnMvc3RlcHMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2JldGEvdGhyZWFkcy9ydW5zL3J1bnMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2JldGEvdGhyZWFkcy90aHJlYWRzLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL2xpYi9VdGlsLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9iZXRhL3ZlY3Rvci1zdG9yZXMvZmlsZXMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2JldGEvdmVjdG9yLXN0b3Jlcy9maWxlLWJhdGNoZXMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2JldGEvdmVjdG9yLXN0b3Jlcy92ZWN0b3Itc3RvcmVzLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9iZXRhL2JldGEubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL2NvbXBsZXRpb25zLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9lbWJlZGRpbmdzLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9maWxlcy5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9yZXNvdXJjZXMvZmluZS10dW5pbmcvam9icy9jaGVja3BvaW50cy5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9yZXNvdXJjZXMvZmluZS10dW5pbmcvam9icy9qb2JzLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9maW5lLXR1bmluZy9maW5lLXR1bmluZy5tanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29wZW5haS9yZXNvdXJjZXMvaW1hZ2VzLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy9tb2RlbHMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvcmVzb3VyY2VzL21vZGVyYXRpb25zLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy91cGxvYWRzL3BhcnRzLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvb3BlbmFpL3Jlc291cmNlcy91cGxvYWRzL3VwbG9hZHMubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9vcGVuYWkvaW5kZXgubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy92dWUtZGVtaS9saWIvaW5kZXgubWpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9waW5pYS9kaXN0L3BpbmlhLm1qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvdXRpbC5qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvbWV0aG9kcy9uYXRpdmUuanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL29ibGl2aW91cy1zZXQvZGlzdC9lc20vc3JjL2luZGV4LmpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9icm9hZGNhc3QtY2hhbm5lbC9kaXN0L2VzYnJvd3Nlci9vcHRpb25zLmpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9icm9hZGNhc3QtY2hhbm5lbC9kaXN0L2VzYnJvd3Nlci9tZXRob2RzL2luZGV4ZWQtZGIuanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL2Jyb2FkY2FzdC1jaGFubmVsL2Rpc3QvZXNicm93c2VyL21ldGhvZHMvbG9jYWxzdG9yYWdlLmpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9icm9hZGNhc3QtY2hhbm5lbC9kaXN0L2VzYnJvd3Nlci9tZXRob2RzL3NpbXVsYXRlLmpzIiwiLi4vLi4vdnVlL25vZGVfbW9kdWxlcy9icm9hZGNhc3QtY2hhbm5lbC9kaXN0L2VzYnJvd3Nlci9tZXRob2QtY2hvb3Nlci5qcyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9lc2Jyb3dzZXIvYnJvYWRjYXN0LWNoYW5uZWwuanMiLCIuLi8uLi92dWUvbm9kZV9tb2R1bGVzL3BpbmlhLXNoYXJlZC1zdGF0ZS9kaXN0L2luZGV4LmpzIiwiLi4vLi4vdnVlL3NyYy9wcm92aWRlci50cyIsIi4uLy4uL3Z1ZS9zcmMvc3RvcmUvY2hhdGJveC50cyIsIi4uLy4uL3Z1ZS9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuZXNtLmpzIiwiLi4vLi4vdnVlL3NyYy9jb21wb25lbnRzL1NpbXBsZUNoYXQudnVlIiwiLi4vLi4vdnVlL3NyYy93ZWJzZXJ2aWNlLnRzIiwiLi4vLi4vdnVlL3NyYy9tYWluLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuKiBAdnVlL3NoYXJlZCB2My41LjAtYmV0YS4zXG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtYWtlTWFwKHN0ciwgZXhwZWN0c0xvd2VyQ2FzZSkge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KHN0ci5zcGxpdChcIixcIikpO1xuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/ICh2YWwpID0+IHNldC5oYXModmFsLnRvTG93ZXJDYXNlKCkpIDogKHZhbCkgPT4gc2V0Lmhhcyh2YWwpO1xufVxuXG5jb25zdCBFTVBUWV9PQkogPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiB7fTtcbmNvbnN0IEVNUFRZX0FSUiA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xuY29uc3QgTk9PUCA9ICgpID0+IHtcbn07XG5jb25zdCBOTyA9ICgpID0+IGZhbHNlO1xuY29uc3QgaXNPbiA9IChrZXkpID0+IGtleS5jaGFyQ29kZUF0KDApID09PSAxMTEgJiYga2V5LmNoYXJDb2RlQXQoMSkgPT09IDExMCAmJiAvLyB1cHBlcmNhc2UgbGV0dGVyXG4oa2V5LmNoYXJDb2RlQXQoMikgPiAxMjIgfHwga2V5LmNoYXJDb2RlQXQoMikgPCA5Nyk7XG5jb25zdCBpc01vZGVsTGlzdGVuZXIgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aChcIm9uVXBkYXRlOlwiKTtcbmNvbnN0IGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XG5jb25zdCByZW1vdmUgPSAoYXJyLCBlbCkgPT4ge1xuICBjb25zdCBpID0gYXJyLmluZGV4T2YoZWwpO1xuICBpZiAoaSA+IC0xKSB7XG4gICAgYXJyLnNwbGljZShpLCAxKTtcbiAgfVxufTtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGhhc093biA9ICh2YWwsIGtleSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmNvbnN0IGlzTWFwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBNYXBdXCI7XG5jb25zdCBpc1NldCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgU2V0XVwiO1xuY29uc3QgaXNEYXRlID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBEYXRlXVwiO1xuY29uc3QgaXNSZWdFeHAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBpc1N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCI7XG5jb25zdCBpc1N5bWJvbCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3ltYm9sXCI7XG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiO1xuY29uc3QgaXNQcm9taXNlID0gKHZhbCkgPT4ge1xuICByZXR1cm4gKGlzT2JqZWN0KHZhbCkgfHwgaXNGdW5jdGlvbih2YWwpKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XG59O1xuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgdG9UeXBlU3RyaW5nID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbmNvbnN0IHRvUmF3VHlwZSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XG59O1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuY29uc3QgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJiBrZXkgIT09IFwiTmFOXCIgJiYga2V5WzBdICE9PSBcIi1cIiAmJiBcIlwiICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcm9wID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIC8vIHRoZSBsZWFkaW5nIGNvbW1hIGlzIGludGVudGlvbmFsIHNvIGVtcHR5IHN0cmluZyBcIlwiIGlzIGFsc28gaW5jbHVkZWRcbiAgXCIsa2V5LHJlZixyZWZfZm9yLHJlZl9rZXksb25Wbm9kZUJlZm9yZU1vdW50LG9uVm5vZGVNb3VudGVkLG9uVm5vZGVCZWZvcmVVcGRhdGUsb25Wbm9kZVVwZGF0ZWQsb25Wbm9kZUJlZm9yZVVubW91bnQsb25Wbm9kZVVubW91bnRlZFwiXG4pO1xuY29uc3QgaXNCdWlsdEluRGlyZWN0aXZlID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIFwiYmluZCxjbG9hayxlbHNlLWlmLGVsc2UsZm9yLGh0bWwsaWYsbW9kZWwsb24sb25jZSxwcmUsc2hvdyxzbG90LHRleHQsbWVtb1wiXG4pO1xuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKHN0cikgPT4ge1xuICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICB9O1xufTtcbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXG4gIChzdHIpID0+IHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IGMgPyBjLnRvVXBwZXJDYXNlKCkgOiBcIlwiKTtcbiAgfVxuKTtcbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbmNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXG4gIChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpXG4pO1xuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufSk7XG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiB7XG4gICAgY29uc3QgcyA9IHN0ciA/IGBvbiR7Y2FwaXRhbGl6ZShzdHIpfWAgOiBgYDtcbiAgICByZXR1cm4gcztcbiAgfVxuKTtcbmNvbnN0IGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiAhT2JqZWN0LmlzKHZhbHVlLCBvbGRWYWx1ZSk7XG5jb25zdCBpbnZva2VBcnJheUZucyA9IChmbnMsIC4uLmFyZykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGZuc1tpXSguLi5hcmcpO1xuICB9XG59O1xuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSwgd3JpdGFibGUgPSBmYWxzZSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGUsXG4gICAgdmFsdWVcbiAgfSk7XG59O1xuY29uc3QgbG9vc2VUb051bWJlciA9ICh2YWwpID0+IHtcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5jb25zdCB0b051bWJlciA9ICh2YWwpID0+IHtcbiAgY29uc3QgbiA9IGlzU3RyaW5nKHZhbCkgPyBOdW1iZXIodmFsKSA6IE5hTjtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5sZXQgX2dsb2JhbFRoaXM7XG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xuICByZXR1cm4gX2dsb2JhbFRoaXMgfHwgKF9nbG9iYWxUaGlzID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSk7XG59O1xuY29uc3QgaWRlbnRSRSA9IC9eW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bXyRhLXpBLVowLTlcXHhBMC1cXHVGRkZGXSokLztcbmZ1bmN0aW9uIGdlblByb3BzQWNjZXNzRXhwKG5hbWUpIHtcbiAgcmV0dXJuIGlkZW50UkUudGVzdChuYW1lKSA/IGBfX3Byb3BzLiR7bmFtZX1gIDogYF9fcHJvcHNbJHtKU09OLnN0cmluZ2lmeShuYW1lKX1dYDtcbn1cblxuY29uc3QgUGF0Y2hGbGFncyA9IHtcbiAgXCJURVhUXCI6IDEsXG4gIFwiMVwiOiBcIlRFWFRcIixcbiAgXCJDTEFTU1wiOiAyLFxuICBcIjJcIjogXCJDTEFTU1wiLFxuICBcIlNUWUxFXCI6IDQsXG4gIFwiNFwiOiBcIlNUWUxFXCIsXG4gIFwiUFJPUFNcIjogOCxcbiAgXCI4XCI6IFwiUFJPUFNcIixcbiAgXCJGVUxMX1BST1BTXCI6IDE2LFxuICBcIjE2XCI6IFwiRlVMTF9QUk9QU1wiLFxuICBcIk5FRURfSFlEUkFUSU9OXCI6IDMyLFxuICBcIjMyXCI6IFwiTkVFRF9IWURSQVRJT05cIixcbiAgXCJTVEFCTEVfRlJBR01FTlRcIjogNjQsXG4gIFwiNjRcIjogXCJTVEFCTEVfRlJBR01FTlRcIixcbiAgXCJLRVlFRF9GUkFHTUVOVFwiOiAxMjgsXG4gIFwiMTI4XCI6IFwiS0VZRURfRlJBR01FTlRcIixcbiAgXCJVTktFWUVEX0ZSQUdNRU5UXCI6IDI1NixcbiAgXCIyNTZcIjogXCJVTktFWUVEX0ZSQUdNRU5UXCIsXG4gIFwiTkVFRF9QQVRDSFwiOiA1MTIsXG4gIFwiNTEyXCI6IFwiTkVFRF9QQVRDSFwiLFxuICBcIkRZTkFNSUNfU0xPVFNcIjogMTAyNCxcbiAgXCIxMDI0XCI6IFwiRFlOQU1JQ19TTE9UU1wiLFxuICBcIkRFVl9ST09UX0ZSQUdNRU5UXCI6IDIwNDgsXG4gIFwiMjA0OFwiOiBcIkRFVl9ST09UX0ZSQUdNRU5UXCIsXG4gIFwiQ0FDSEVEXCI6IC0xLFxuICBcIi0xXCI6IFwiQ0FDSEVEXCIsXG4gIFwiQkFJTFwiOiAtMixcbiAgXCItMlwiOiBcIkJBSUxcIlxufTtcbmNvbnN0IFBhdGNoRmxhZ05hbWVzID0ge1xuICBbMV06IGBURVhUYCxcbiAgWzJdOiBgQ0xBU1NgLFxuICBbNF06IGBTVFlMRWAsXG4gIFs4XTogYFBST1BTYCxcbiAgWzE2XTogYEZVTExfUFJPUFNgLFxuICBbMzJdOiBgTkVFRF9IWURSQVRJT05gLFxuICBbNjRdOiBgU1RBQkxFX0ZSQUdNRU5UYCxcbiAgWzEyOF06IGBLRVlFRF9GUkFHTUVOVGAsXG4gIFsyNTZdOiBgVU5LRVlFRF9GUkFHTUVOVGAsXG4gIFs1MTJdOiBgTkVFRF9QQVRDSGAsXG4gIFsxMDI0XTogYERZTkFNSUNfU0xPVFNgLFxuICBbMjA0OF06IGBERVZfUk9PVF9GUkFHTUVOVGAsXG4gIFstMV06IGBIT0lTVEVEYCxcbiAgWy0yXTogYEJBSUxgXG59O1xuXG5jb25zdCBTaGFwZUZsYWdzID0ge1xuICBcIkVMRU1FTlRcIjogMSxcbiAgXCIxXCI6IFwiRUxFTUVOVFwiLFxuICBcIkZVTkNUSU9OQUxfQ09NUE9ORU5UXCI6IDIsXG4gIFwiMlwiOiBcIkZVTkNUSU9OQUxfQ09NUE9ORU5UXCIsXG4gIFwiU1RBVEVGVUxfQ09NUE9ORU5UXCI6IDQsXG4gIFwiNFwiOiBcIlNUQVRFRlVMX0NPTVBPTkVOVFwiLFxuICBcIlRFWFRfQ0hJTERSRU5cIjogOCxcbiAgXCI4XCI6IFwiVEVYVF9DSElMRFJFTlwiLFxuICBcIkFSUkFZX0NISUxEUkVOXCI6IDE2LFxuICBcIjE2XCI6IFwiQVJSQVlfQ0hJTERSRU5cIixcbiAgXCJTTE9UU19DSElMRFJFTlwiOiAzMixcbiAgXCIzMlwiOiBcIlNMT1RTX0NISUxEUkVOXCIsXG4gIFwiVEVMRVBPUlRcIjogNjQsXG4gIFwiNjRcIjogXCJURUxFUE9SVFwiLFxuICBcIlNVU1BFTlNFXCI6IDEyOCxcbiAgXCIxMjhcIjogXCJTVVNQRU5TRVwiLFxuICBcIkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRVwiOiAyNTYsXG4gIFwiMjU2XCI6IFwiQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFXCIsXG4gIFwiQ09NUE9ORU5UX0tFUFRfQUxJVkVcIjogNTEyLFxuICBcIjUxMlwiOiBcIkNPTVBPTkVOVF9LRVBUX0FMSVZFXCIsXG4gIFwiQ09NUE9ORU5UXCI6IDYsXG4gIFwiNlwiOiBcIkNPTVBPTkVOVFwiXG59O1xuXG5jb25zdCBTbG90RmxhZ3MgPSB7XG4gIFwiU1RBQkxFXCI6IDEsXG4gIFwiMVwiOiBcIlNUQUJMRVwiLFxuICBcIkRZTkFNSUNcIjogMixcbiAgXCIyXCI6IFwiRFlOQU1JQ1wiLFxuICBcIkZPUldBUkRFRFwiOiAzLFxuICBcIjNcIjogXCJGT1JXQVJERURcIlxufTtcbmNvbnN0IHNsb3RGbGFnc1RleHQgPSB7XG4gIFsxXTogXCJTVEFCTEVcIixcbiAgWzJdOiBcIkRZTkFNSUNcIixcbiAgWzNdOiBcIkZPUldBUkRFRFwiXG59O1xuXG5jb25zdCBHTE9CQUxTX0FMTE9XRUQgPSBcIkluZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCxjb25zb2xlLEVycm9yLFN5bWJvbFwiO1xuY29uc3QgaXNHbG9iYWxseUFsbG93ZWQgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChHTE9CQUxTX0FMTE9XRUQpO1xuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gaXNHbG9iYWxseUFsbG93ZWQ7XG5cbmNvbnN0IHJhbmdlID0gMjtcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XG4gIHN0YXJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc3RhcnQsIHNvdXJjZS5sZW5ndGgpKTtcbiAgZW5kID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZW5kLCBzb3VyY2UubGVuZ3RoKSk7XG4gIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFwiXCI7XG4gIGxldCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvKFxccj9cXG4pLyk7XG4gIGNvbnN0IG5ld2xpbmVTZXF1ZW5jZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMSk7XG4gIGxpbmVzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDApO1xuICBsZXQgY291bnQgPSAwO1xuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIChuZXdsaW5lU2VxdWVuY2VzW2ldICYmIG5ld2xpbmVTZXF1ZW5jZXNbaV0ubGVuZ3RoIHx8IDApO1xuICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XG4gICAgICAgIHJlcy5wdXNoKFxuICAgICAgICAgIGAke2xpbmV9JHtcIiBcIi5yZXBlYXQoTWF0aC5tYXgoMyAtIFN0cmluZyhsaW5lKS5sZW5ndGgsIDApKX18ICAke2xpbmVzW2pdfWBcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmV3TGluZVNlcUxlbmd0aCA9IG5ld2xpbmVTZXF1ZW5jZXNbal0gJiYgbmV3bGluZVNlcXVlbmNlc1tqXS5sZW5ndGggfHwgMDtcbiAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIChsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aCkpO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIFwiIFwiLnJlcGVhdChwYWQpICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xuICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gaXNTdHJpbmcoaXRlbSkgPyBwYXJzZVN0cmluZ1N0eWxlKGl0ZW0pIDogbm9ybWFsaXplU3R5bGUoaXRlbSk7XG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XG4gICAgICAgICAgcmVzW2tleV0gPSBub3JtYWxpemVkW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5jb25zdCBsaXN0RGVsaW1pdGVyUkUgPSAvOyg/IVteKF0qXFwpKS9nO1xuY29uc3QgcHJvcGVydHlEZWxpbWl0ZXJSRSA9IC86KFteXSspLztcbmNvbnN0IHN0eWxlQ29tbWVudFJFID0gL1xcL1xcKlteXSo/XFwqXFwvL2c7XG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGNzc1RleHQucmVwbGFjZShzdHlsZUNvbW1lbnRSRSwgXCJcIikuc3BsaXQobGlzdERlbGltaXRlclJFKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xuICBsZXQgcmV0ID0gXCJcIjtcbiAgaWYgKCFzdHlsZXMgfHwgaXNTdHJpbmcoc3R5bGVzKSkge1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XG4gICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XG4gIGxldCByZXMgPSBcIlwiO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmVzID0gdmFsdWU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgcmVzICs9IG5vcm1hbGl6ZWQgKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWVbbmFtZV0pIHtcbiAgICAgICAgcmVzICs9IG5hbWUgKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy50cmltKCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhwcm9wcykge1xuICBpZiAoIXByb3BzKSByZXR1cm4gbnVsbDtcbiAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XG4gICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gIH1cbiAgaWYgKHN0eWxlKSB7XG4gICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BzO1xufVxuXG5jb25zdCBIVE1MX1RBR1MgPSBcImh0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGhncm91cCxoMSxoMixoMyxoNCxoNSxoNixuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSxzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290XCI7XG5jb25zdCBTVkdfVEFHUyA9IFwic3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLGRlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCxmZURpc3RhbnRMaWdodCxmZURyb3BTaGFkb3csZmVGbG9vZCxmZUZ1bmNBLGZlRnVuY0IsZmVGdW5jRyxmZUZ1bmNSLGZlR2F1c3NpYW5CbHVyLGZlSW1hZ2UsZmVNZXJnZSxmZU1lcmdlTm9kZSxmZU1vcnBob2xvZ3ksZmVPZmZzZXQsZmVQb2ludExpZ2h0LGZlU3BlY3VsYXJMaWdodGluZyxmZVNwb3RMaWdodCxmZVRpbGUsZmVUdXJidWxlbmNlLGZpbHRlcixmb3JlaWduT2JqZWN0LGcsaGF0Y2gsaGF0Y2hwYXRoLGltYWdlLGxpbmUsbGluZWFyR3JhZGllbnQsbWFya2VyLG1hc2ssbWVzaCxtZXNoZ3JhZGllbnQsbWVzaHBhdGNoLG1lc2hyb3csbWV0YWRhdGEsbXBhdGgscGF0aCxwYXR0ZXJuLHBvbHlnb24scG9seWxpbmUscmFkaWFsR3JhZGllbnQscmVjdCxzZXQsc29saWRjb2xvcixzdG9wLHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0UGF0aCx0aXRsZSx0c3Bhbix1bmtub3duLHVzZSx2aWV3XCI7XG5jb25zdCBNQVRIX1RBR1MgPSBcImFubm90YXRpb24sYW5ub3RhdGlvbi14bWwsbWFjdGlvbixtYWxpZ25ncm91cCxtYWxpZ25tYXJrLG1hdGgsbWVuY2xvc2UsbWVycm9yLG1mZW5jZWQsbWZyYWMsbWZyYWN0aW9uLG1nbHlwaCxtaSxtbGFiZWxlZHRyLG1sb25nZGl2LG1tdWx0aXNjcmlwdHMsbW4sbW8sbW92ZXIsbXBhZGRlZCxtcGhhbnRvbSxtcHJlc2NyaXB0cyxtcm9vdCxtcm93LG1zLG1zY2Fycmllcyxtc2NhcnJ5LG1zZ3JvdXAsbXNsaW5lLG1zcGFjZSxtc3FydCxtc3Jvdyxtc3RhY2ssbXN0eWxlLG1zdWIsbXN1YnN1cCxtc3VwLG10YWJsZSxtdGQsbXRleHQsbXRyLG11bmRlcixtdW5kZXJvdmVyLG5vbmUsc2VtYW50aWNzXCI7XG5jb25zdCBWT0lEX1RBR1MgPSBcImFyZWEsYmFzZSxicixjb2wsZW1iZWQsaHIsaW1nLGlucHV0LGxpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyXCI7XG5jb25zdCBpc0hUTUxUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChIVE1MX1RBR1MpO1xuY29uc3QgaXNTVkdUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChTVkdfVEFHUyk7XG5jb25zdCBpc01hdGhNTFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKE1BVEhfVEFHUyk7XG5jb25zdCBpc1ZvaWRUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xuXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBzcGVjaWFsQm9vbGVhbkF0dHJzICsgYCxhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY29udHJvbHMsZGVmYXVsdCxkZWZlcixkaXNhYmxlZCxoaWRkZW4saW5lcnQsbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYFxuKTtcbmZ1bmN0aW9uIGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJcIjtcbn1cbmNvbnN0IHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzU1NSU2FmZUF0dHJOYW1lKG5hbWUpIHtcbiAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcbiAgfVxuICBjb25zdCBpc1Vuc2FmZSA9IHVuc2FmZUF0dHJDaGFyUkUudGVzdChuYW1lKTtcbiAgaWYgKGlzVW5zYWZlKSB7XG4gICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XG4gIH1cbiAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmU7XG59XG5jb25zdCBwcm9wc1RvQXR0ck1hcCA9IHtcbiAgYWNjZXB0Q2hhcnNldDogXCJhY2NlcHQtY2hhcnNldFwiLFxuICBjbGFzc05hbWU6IFwiY2xhc3NcIixcbiAgaHRtbEZvcjogXCJmb3JcIixcbiAgaHR0cEVxdWl2OiBcImh0dHAtZXF1aXZcIlxufTtcbmNvbnN0IGlzS25vd25IdG1sQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgYWNjZXB0LGFjY2VwdC1jaGFyc2V0LGFjY2Vzc2tleSxhY3Rpb24sYWxpZ24sYWxsb3csYWx0LGFzeW5jLGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSxhdXRvZm9jdXMsYXV0b3BsYXksYmFja2dyb3VuZCxiZ2NvbG9yLGJvcmRlcixidWZmZXJlZCxjYXB0dXJlLGNoYWxsZW5nZSxjaGFyc2V0LGNoZWNrZWQsY2l0ZSxjbGFzcyxjb2RlLGNvZGViYXNlLGNvbG9yLGNvbHMsY29sc3Bhbixjb250ZW50LGNvbnRlbnRlZGl0YWJsZSxjb250ZXh0bWVudSxjb250cm9scyxjb29yZHMsY3Jvc3NvcmlnaW4sY3NwLGRhdGEsZGF0ZXRpbWUsZGVjb2RpbmcsZGVmYXVsdCxkZWZlcixkaXIsZGlybmFtZSxkaXNhYmxlZCxkb3dubG9hZCxkcmFnZ2FibGUsZHJvcHpvbmUsZW5jdHlwZSxlbnRlcmtleWhpbnQsZm9yLGZvcm0sZm9ybWFjdGlvbixmb3JtZW5jdHlwZSxmb3JtbWV0aG9kLGZvcm1ub3ZhbGlkYXRlLGZvcm10YXJnZXQsaGVhZGVycyxoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LGljb24saWQsaW1wb3J0YW5jZSxpbmVydCxpbnRlZ3JpdHksaXNtYXAsaXRlbXByb3Asa2V5dHlwZSxraW5kLGxhYmVsLGxhbmcsbGFuZ3VhZ2UsbG9hZGluZyxsaXN0LGxvb3AsbG93LG1hbmlmZXN0LG1heCxtYXhsZW5ndGgsbWlubGVuZ3RoLG1lZGlhLG1pbixtdWx0aXBsZSxtdXRlZCxuYW1lLG5vdmFsaWRhdGUsb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIscHJlbG9hZCxyYWRpb2dyb3VwLHJlYWRvbmx5LHJlZmVycmVycG9saWN5LHJlbCxyZXF1aXJlZCxyZXZlcnNlZCxyb3dzLHJvd3NwYW4sc2FuZGJveCxzY29wZSxzY29wZWQsc2VsZWN0ZWQsc2hhcGUsc2l6ZSxzaXplcyxzbG90LHNwYW4sc3BlbGxjaGVjayxzcmMsc3JjZG9jLHNyY2xhbmcsc3Jjc2V0LHN0YXJ0LHN0ZXAsc3R5bGUsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLHZhbHVlLHdpZHRoLHdyYXBgXG4pO1xuY29uc3QgaXNLbm93blN2Z0F0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYHhtbG5zLGFjY2VudC1oZWlnaHQsYWNjdW11bGF0ZSxhZGRpdGl2ZSxhbGlnbm1lbnQtYmFzZWxpbmUsYWxwaGFiZXRpYyxhbXBsaXR1ZGUsYXJhYmljLWZvcm0sYXNjZW50LGF0dHJpYnV0ZU5hbWUsYXR0cmlidXRlVHlwZSxhemltdXRoLGJhc2VGcmVxdWVuY3ksYmFzZWxpbmUtc2hpZnQsYmFzZVByb2ZpbGUsYmJveCxiZWdpbixiaWFzLGJ5LGNhbGNNb2RlLGNhcC1oZWlnaHQsY2xhc3MsY2xpcCxjbGlwUGF0aFVuaXRzLGNsaXAtcGF0aCxjbGlwLXJ1bGUsY29sb3IsY29sb3ItaW50ZXJwb2xhdGlvbixjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMsY29sb3ItcHJvZmlsZSxjb2xvci1yZW5kZXJpbmcsY29udGVudFNjcmlwdFR5cGUsY29udGVudFN0eWxlVHlwZSxjcm9zc29yaWdpbixjdXJzb3IsY3gsY3ksZCxkZWNlbGVyYXRlLGRlc2NlbnQsZGlmZnVzZUNvbnN0YW50LGRpcmVjdGlvbixkaXNwbGF5LGRpdmlzb3IsZG9taW5hbnQtYmFzZWxpbmUsZHVyLGR4LGR5LGVkZ2VNb2RlLGVsZXZhdGlvbixlbmFibGUtYmFja2dyb3VuZCxlbmQsZXhwb25lbnQsZmlsbCxmaWxsLW9wYWNpdHksZmlsbC1ydWxlLGZpbHRlcixmaWx0ZXJSZXMsZmlsdGVyVW5pdHMsZmxvb2QtY29sb3IsZmxvb2Qtb3BhY2l0eSxmb250LWZhbWlseSxmb250LXNpemUsZm9udC1zaXplLWFkanVzdCxmb250LXN0cmV0Y2gsZm9udC1zdHlsZSxmb250LXZhcmlhbnQsZm9udC13ZWlnaHQsZm9ybWF0LGZyb20sZnIsZngsZnksZzEsZzIsZ2x5cGgtbmFtZSxnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsLGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsLGdseXBoUmVmLGdyYWRpZW50VHJhbnNmb3JtLGdyYWRpZW50VW5pdHMsaGFuZ2luZyxoZWlnaHQsaHJlZixocmVmbGFuZyxob3Jpei1hZHYteCxob3Jpei1vcmlnaW4teCxpZCxpZGVvZ3JhcGhpYyxpbWFnZS1yZW5kZXJpbmcsaW4saW4yLGludGVyY2VwdCxrLGsxLGsyLGszLGs0LGtlcm5lbE1hdHJpeCxrZXJuZWxVbml0TGVuZ3RoLGtlcm5pbmcsa2V5UG9pbnRzLGtleVNwbGluZXMsa2V5VGltZXMsbGFuZyxsZW5ndGhBZGp1c3QsbGV0dGVyLXNwYWNpbmcsbGlnaHRpbmctY29sb3IsbGltaXRpbmdDb25lQW5nbGUsbG9jYWwsbWFya2VyLWVuZCxtYXJrZXItbWlkLG1hcmtlci1zdGFydCxtYXJrZXJIZWlnaHQsbWFya2VyVW5pdHMsbWFya2VyV2lkdGgsbWFzayxtYXNrQ29udGVudFVuaXRzLG1hc2tVbml0cyxtYXRoZW1hdGljYWwsbWF4LG1lZGlhLG1ldGhvZCxtaW4sbW9kZSxuYW1lLG51bU9jdGF2ZXMsb2Zmc2V0LG9wYWNpdHksb3BlcmF0b3Isb3JkZXIsb3JpZW50LG9yaWVudGF0aW9uLG9yaWdpbixvdmVyZmxvdyxvdmVybGluZS1wb3NpdGlvbixvdmVybGluZS10aGlja25lc3MscGFub3NlLTEscGFpbnQtb3JkZXIscGF0aCxwYXRoTGVuZ3RoLHBhdHRlcm5Db250ZW50VW5pdHMscGF0dGVyblRyYW5zZm9ybSxwYXR0ZXJuVW5pdHMscGluZyxwb2ludGVyLWV2ZW50cyxwb2ludHMscG9pbnRzQXRYLHBvaW50c0F0WSxwb2ludHNBdFoscHJlc2VydmVBbHBoYSxwcmVzZXJ2ZUFzcGVjdFJhdGlvLHByaW1pdGl2ZVVuaXRzLHIscmFkaXVzLHJlZmVycmVyUG9saWN5LHJlZlgscmVmWSxyZWwscmVuZGVyaW5nLWludGVudCxyZXBlYXRDb3VudCxyZXBlYXREdXIscmVxdWlyZWRFeHRlbnNpb25zLHJlcXVpcmVkRmVhdHVyZXMscmVzdGFydCxyZXN1bHQscm90YXRlLHJ4LHJ5LHNjYWxlLHNlZWQsc2hhcGUtcmVuZGVyaW5nLHNsb3BlLHNwYWNpbmcsc3BlY3VsYXJDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LHNwZWVkLHNwcmVhZE1ldGhvZCxzdGFydE9mZnNldCxzdGREZXZpYXRpb24sc3RlbWgsc3RlbXYsc3RpdGNoVGlsZXMsc3RvcC1jb2xvcixzdG9wLW9wYWNpdHksc3RyaWtldGhyb3VnaC1wb3NpdGlvbixzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyxzdHJpbmcsc3Ryb2tlLHN0cm9rZS1kYXNoYXJyYXksc3Ryb2tlLWRhc2hvZmZzZXQsc3Ryb2tlLWxpbmVjYXAsc3Ryb2tlLWxpbmVqb2luLHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aCxzdHlsZSxzdXJmYWNlU2NhbGUsc3lzdGVtTGFuZ3VhZ2UsdGFiaW5kZXgsdGFibGVWYWx1ZXMsdGFyZ2V0LHRhcmdldFgsdGFyZ2V0WSx0ZXh0LWFuY2hvcix0ZXh0LWRlY29yYXRpb24sdGV4dC1yZW5kZXJpbmcsdGV4dExlbmd0aCx0byx0cmFuc2Zvcm0sdHJhbnNmb3JtLW9yaWdpbix0eXBlLHUxLHUyLHVuZGVybGluZS1wb3NpdGlvbix1bmRlcmxpbmUtdGhpY2tuZXNzLHVuaWNvZGUsdW5pY29kZS1iaWRpLHVuaWNvZGUtcmFuZ2UsdW5pdHMtcGVyLWVtLHYtYWxwaGFiZXRpYyx2LWhhbmdpbmcsdi1pZGVvZ3JhcGhpYyx2LW1hdGhlbWF0aWNhbCx2YWx1ZXMsdmVjdG9yLWVmZmVjdCx2ZXJzaW9uLHZlcnQtYWR2LXksdmVydC1vcmlnaW4teCx2ZXJ0LW9yaWdpbi15LHZpZXdCb3gsdmlld1RhcmdldCx2aXNpYmlsaXR5LHdpZHRoLHdpZHRocyx3b3JkLXNwYWNpbmcsd3JpdGluZy1tb2RlLHgseC1oZWlnaHQseDEseDIseENoYW5uZWxTZWxlY3Rvcix4bGluazphY3R1YXRlLHhsaW5rOmFyY3JvbGUseGxpbms6aHJlZix4bGluazpyb2xlLHhsaW5rOnNob3cseGxpbms6dGl0bGUseGxpbms6dHlwZSx4bWxuczp4bGluayx4bWw6YmFzZSx4bWw6bGFuZyx4bWw6c3BhY2UseSx5MSx5Mix5Q2hhbm5lbFNlbGVjdG9yLHosem9vbUFuZFBhbmBcbik7XG5mdW5jdGlvbiBpc1JlbmRlcmFibGVBdHRyVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIjtcbn1cblxuY29uc3QgZXNjYXBlUkUgPSAvW1wiJyY8Pl0vO1xuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgY29uc3Qgc3RyID0gXCJcIiArIHN0cmluZztcbiAgY29uc3QgbWF0Y2ggPSBlc2NhcGVSRS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGxldCBodG1sID0gXCJcIjtcbiAgbGV0IGVzY2FwZWQ7XG4gIGxldCBpbmRleDtcbiAgbGV0IGxhc3RJbmRleCA9IDA7XG4gIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgIGNhc2UgMzQ6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZxdW90O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZhbXA7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOTpcbiAgICAgICAgZXNjYXBlZCA9IFwiJiMzOTtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYwOlxuICAgICAgICBlc2NhcGVkID0gXCImbHQ7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmd0O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCk7XG4gICAgfVxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICBodG1sICs9IGVzY2FwZWQ7XG4gIH1cbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbmNvbnN0IGNvbW1lbnRTdHJpcFJFID0gL14tPz58PCEtLXwtLT58LS0hPnw8IS0kL2c7XG5mdW5jdGlvbiBlc2NhcGVIdG1sQ29tbWVudChzcmMpIHtcbiAgcmV0dXJuIHNyYy5yZXBsYWNlKGNvbW1lbnRTdHJpcFJFLCBcIlwiKTtcbn1cblxuZnVuY3Rpb24gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBsZXQgZXF1YWwgPSB0cnVlO1xuICBmb3IgKGxldCBpID0gMDsgZXF1YWwgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBlcXVhbCA9IGxvb3NlRXF1YWwoYVtpXSwgYltpXSk7XG4gIH1cbiAgcmV0dXJuIGVxdWFsO1xufVxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgbGV0IGFWYWxpZFR5cGUgPSBpc0RhdGUoYSk7XG4gIGxldCBiVmFsaWRUeXBlID0gaXNEYXRlKGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc1N5bWJvbChhKTtcbiAgYlZhbGlkVHlwZSA9IGlzU3ltYm9sKGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzQXJyYXkoYSk7XG4gIGJWYWxpZFR5cGUgPSBpc0FycmF5KGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSA6IGZhbHNlO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc09iamVjdChhKTtcbiAgYlZhbGlkVHlwZSA9IGlzT2JqZWN0KGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgaWYgKCFhVmFsaWRUeXBlIHx8ICFiVmFsaWRUeXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XG4gICAgY29uc3QgYktleXNDb3VudCA9IE9iamVjdC5rZXlzKGIpLmxlbmd0aDtcbiAgICBpZiAoYUtleXNDb3VudCAhPT0gYktleXNDb3VudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgICBjb25zdCBhSGFzS2V5ID0gYS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgY29uc3QgYkhhc0tleSA9IGIuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGlmIChhSGFzS2V5ICYmICFiSGFzS2V5IHx8ICFhSGFzS2V5ICYmIGJIYXNLZXkgfHwgIWxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xufVxuZnVuY3Rpb24gbG9vc2VJbmRleE9mKGFyciwgdmFsKSB7XG4gIHJldHVybiBhcnIuZmluZEluZGV4KChpdGVtKSA9PiBsb29zZUVxdWFsKGl0ZW0sIHZhbCkpO1xufVxuXG5jb25zdCBpc1JlZiA9ICh2YWwpID0+IHtcbiAgcmV0dXJuICEhKHZhbCAmJiB2YWxbXCJfX3ZfaXNSZWZcIl0gPT09IHRydWUpO1xufTtcbmNvbnN0IHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIGlzU3RyaW5nKHZhbCkgPyB2YWwgOiB2YWwgPT0gbnVsbCA/IFwiXCIgOiBpc0FycmF5KHZhbCkgfHwgaXNPYmplY3QodmFsKSAmJiAodmFsLnRvU3RyaW5nID09PSBvYmplY3RUb1N0cmluZyB8fCAhaXNGdW5jdGlvbih2YWwudG9TdHJpbmcpKSA/IGlzUmVmKHZhbCkgPyB0b0Rpc3BsYXlTdHJpbmcodmFsLnZhbHVlKSA6IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpIDogU3RyaW5nKHZhbCk7XG59O1xuY29uc3QgcmVwbGFjZXIgPSAoX2tleSwgdmFsKSA9PiB7XG4gIGlmIChpc1JlZih2YWwpKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VyKF9rZXksIHZhbC52YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBbYE1hcCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC5lbnRyaWVzKCldLnJlZHVjZShcbiAgICAgICAgKGVudHJpZXMsIFtrZXksIHZhbDJdLCBpKSA9PiB7XG4gICAgICAgICAgZW50cmllc1tzdHJpbmdpZnlTeW1ib2woa2V5LCBpKSArIFwiID0+XCJdID0gdmFsMjtcbiAgICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICAgICAgfSxcbiAgICAgICAge31cbiAgICAgIClcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW2BTZXQoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwudmFsdWVzKCldLm1hcCgodikgPT4gc3RyaW5naWZ5U3ltYm9sKHYpKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNTeW1ib2wodmFsKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlTeW1ib2wodmFsKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpICYmICFpc0FycmF5KHZhbCkgJiYgIWlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgIHJldHVybiBTdHJpbmcodmFsKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcbmNvbnN0IHN0cmluZ2lmeVN5bWJvbCA9ICh2LCBpID0gXCJcIikgPT4ge1xuICB2YXIgX2E7XG4gIHJldHVybiAoXG4gICAgLy8gU3ltYm9sLmRlc2NyaXB0aW9uIGluIGVzMjAxOSsgc28gd2UgbmVlZCB0byBjYXN0IGhlcmUgdG8gcGFzc1xuICAgIC8vIHRoZSBsaWI6IGVzMjAxNiBjaGVja1xuICAgIGlzU3ltYm9sKHYpID8gYFN5bWJvbCgkeyhfYSA9IHYuZGVzY3JpcHRpb24pICE9IG51bGwgPyBfYSA6IGl9KWAgOiB2XG4gICk7XG59O1xuXG5leHBvcnQgeyBFTVBUWV9BUlIsIEVNUFRZX09CSiwgTk8sIE5PT1AsIFBhdGNoRmxhZ05hbWVzLCBQYXRjaEZsYWdzLCBTaGFwZUZsYWdzLCBTbG90RmxhZ3MsIGNhbWVsaXplLCBjYXBpdGFsaXplLCBkZWYsIGVzY2FwZUh0bWwsIGVzY2FwZUh0bWxDb21tZW50LCBleHRlbmQsIGdlblByb3BzQWNjZXNzRXhwLCBnZW5lcmF0ZUNvZGVGcmFtZSwgZ2V0R2xvYmFsVGhpcywgaGFzQ2hhbmdlZCwgaGFzT3duLCBoeXBoZW5hdGUsIGluY2x1ZGVCb29sZWFuQXR0ciwgaW52b2tlQXJyYXlGbnMsIGlzQXJyYXksIGlzQm9vbGVhbkF0dHIsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaXNEYXRlLCBpc0Z1bmN0aW9uLCBpc0dsb2JhbGx5QWxsb3dlZCwgaXNHbG9iYWxseVdoaXRlbGlzdGVkLCBpc0hUTUxUYWcsIGlzSW50ZWdlcktleSwgaXNLbm93bkh0bWxBdHRyLCBpc0tub3duU3ZnQXR0ciwgaXNNYXAsIGlzTWF0aE1MVGFnLCBpc01vZGVsTGlzdGVuZXIsIGlzT2JqZWN0LCBpc09uLCBpc1BsYWluT2JqZWN0LCBpc1Byb21pc2UsIGlzUmVnRXhwLCBpc1JlbmRlcmFibGVBdHRyVmFsdWUsIGlzUmVzZXJ2ZWRQcm9wLCBpc1NTUlNhZmVBdHRyTmFtZSwgaXNTVkdUYWcsIGlzU2V0LCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNTdHJpbmcsIGlzU3ltYm9sLCBpc1ZvaWRUYWcsIGxvb3NlRXF1YWwsIGxvb3NlSW5kZXhPZiwgbG9vc2VUb051bWJlciwgbWFrZU1hcCwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgb2JqZWN0VG9TdHJpbmcsIHBhcnNlU3RyaW5nU3R5bGUsIHByb3BzVG9BdHRyTWFwLCByZW1vdmUsIHNsb3RGbGFnc1RleHQsIHN0cmluZ2lmeVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSwgdG9OdW1iZXIsIHRvUmF3VHlwZSwgdG9UeXBlU3RyaW5nIH07XG4iLCIvKipcbiogQHZ1ZS9yZWFjdGl2aXR5IHYzLjUuMC1iZXRhLjNcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbmltcG9ydCB7IGhhc0NoYW5nZWQsIGV4dGVuZCwgaXNBcnJheSwgaXNJbnRlZ2VyS2V5LCBpc1N5bWJvbCwgaXNNYXAsIGhhc093biwgaXNPYmplY3QsIG1ha2VNYXAsIGNhcGl0YWxpemUsIHRvUmF3VHlwZSwgZGVmLCBpc0Z1bmN0aW9uLCBFTVBUWV9PQkosIGlzU2V0LCBpc1BsYWluT2JqZWN0LCBOT09QLCByZW1vdmUgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmZ1bmN0aW9uIHdhcm4obXNnLCAuLi5hcmdzKSB7XG4gIGNvbnNvbGUud2FybihgW1Z1ZSB3YXJuXSAke21zZ31gLCAuLi5hcmdzKTtcbn1cblxubGV0IGFjdGl2ZUVmZmVjdFNjb3BlO1xuY2xhc3MgRWZmZWN0U2NvcGUge1xuICBjb25zdHJ1Y3RvcihkZXRhY2hlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5kZXRhY2hlZCA9IGRldGFjaGVkO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5lZmZlY3RzID0gW107XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5jbGVhbnVwcyA9IFtdO1xuICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5wYXJlbnQgPSBhY3RpdmVFZmZlY3RTY29wZTtcbiAgICBpZiAoIWRldGFjaGVkICYmIGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gICAgICB0aGlzLmluZGV4ID0gKGFjdGl2ZUVmZmVjdFNjb3BlLnNjb3BlcyB8fCAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzID0gW10pKS5wdXNoKFxuICAgICAgICB0aGlzXG4gICAgICApIC0gMTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG4gIHBhdXNlKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLnNjb3Blcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmVmZmVjdHNbaV0ucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlc3VtZXMgdGhlIGVmZmVjdCBzY29wZSwgaW5jbHVkaW5nIGFsbCBjaGlsZCBzY29wZXMgYW5kIGVmZmVjdHMuXG4gICAqL1xuICByZXN1bWUoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnNjb3Blcykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5zY29wZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnNjb3Blc1tpXS5yZXN1bWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJ1bihmbikge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRFZmZlY3RTY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gY3VycmVudEVmZmVjdFNjb3BlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihgY2Fubm90IHJ1biBhbiBpbmFjdGl2ZSBlZmZlY3Qgc2NvcGUuYCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb24oKSB7XG4gICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb2ZmKCkge1xuICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcy5wYXJlbnQ7XG4gIH1cbiAgc3RvcChmcm9tUGFyZW50KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgbGV0IGksIGw7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmVmZmVjdHNbaV0uc3RvcCgpO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2xlYW51cHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cHNbaV0oKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNjb3Blcykge1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5zY29wZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5zY29wZXNbaV0uc3RvcCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmRldGFjaGVkICYmIHRoaXMucGFyZW50ICYmICFmcm9tUGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLnBhcmVudC5zY29wZXMucG9wKCk7XG4gICAgICAgIGlmIChsYXN0ICYmIGxhc3QgIT09IHRoaXMpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5zY29wZXNbdGhpcy5pbmRleF0gPSBsYXN0O1xuICAgICAgICAgIGxhc3QuaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBhcmVudCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZWZmZWN0U2NvcGUoZGV0YWNoZWQpIHtcbiAgcmV0dXJuIG5ldyBFZmZlY3RTY29wZShkZXRhY2hlZCk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gIHJldHVybiBhY3RpdmVFZmZlY3RTY29wZTtcbn1cbmZ1bmN0aW9uIG9uU2NvcGVEaXNwb3NlKGZuLCBmYWlsU2lsZW50bHkgPSBmYWxzZSkge1xuICBpZiAoYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICBhY3RpdmVFZmZlY3RTY29wZS5jbGVhbnVwcy5wdXNoKGZuKTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFmYWlsU2lsZW50bHkpIHtcbiAgICB3YXJuKFxuICAgICAgYG9uU2NvcGVEaXNwb3NlKCkgaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGVmZmVjdCBzY29wZSB0byBiZSBhc3NvY2lhdGVkIHdpdGguYFxuICAgICk7XG4gIH1cbn1cblxubGV0IGFjdGl2ZVN1YjtcbmNvbnN0IEVmZmVjdEZsYWdzID0ge1xuICBcIkFDVElWRVwiOiAxLFxuICBcIjFcIjogXCJBQ1RJVkVcIixcbiAgXCJSVU5OSU5HXCI6IDIsXG4gIFwiMlwiOiBcIlJVTk5JTkdcIixcbiAgXCJUUkFDS0lOR1wiOiA0LFxuICBcIjRcIjogXCJUUkFDS0lOR1wiLFxuICBcIk5PVElGSUVEXCI6IDgsXG4gIFwiOFwiOiBcIk5PVElGSUVEXCIsXG4gIFwiRElSVFlcIjogMTYsXG4gIFwiMTZcIjogXCJESVJUWVwiLFxuICBcIkFMTE9XX1JFQ1VSU0VcIjogMzIsXG4gIFwiMzJcIjogXCJBTExPV19SRUNVUlNFXCIsXG4gIFwiUEFVU0VEXCI6IDY0LFxuICBcIjY0XCI6IFwiUEFVU0VEXCJcbn07XG5jb25zdCBwYXVzZWRRdWV1ZUVmZmVjdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbmNsYXNzIFJlYWN0aXZlRWZmZWN0IHtcbiAgY29uc3RydWN0b3IoZm4pIHtcbiAgICB0aGlzLmZuID0gZm47XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5kZXBzID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwc1RhaWwgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5mbGFncyA9IDEgfCA0O1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMubmV4dEVmZmVjdCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmNsZWFudXAgPSB2b2lkIDA7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSB2b2lkIDA7XG4gICAgaWYgKGFjdGl2ZUVmZmVjdFNjb3BlICYmIGFjdGl2ZUVmZmVjdFNjb3BlLmFjdGl2ZSkge1xuICAgICAgYWN0aXZlRWZmZWN0U2NvcGUuZWZmZWN0cy5wdXNoKHRoaXMpO1xuICAgIH1cbiAgfVxuICBwYXVzZSgpIHtcbiAgICB0aGlzLmZsYWdzIHw9IDY0O1xuICB9XG4gIHJlc3VtZSgpIHtcbiAgICBpZiAodGhpcy5mbGFncyAmIDY0KSB7XG4gICAgICB0aGlzLmZsYWdzICY9IH42NDtcbiAgICAgIGlmIChwYXVzZWRRdWV1ZUVmZmVjdHMuaGFzKHRoaXMpKSB7XG4gICAgICAgIHBhdXNlZFF1ZXVlRWZmZWN0cy5kZWxldGUodGhpcyk7XG4gICAgICAgIHRoaXMudHJpZ2dlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBub3RpZnkoKSB7XG4gICAgaWYgKHRoaXMuZmxhZ3MgJiAyICYmICEodGhpcy5mbGFncyAmIDMyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh0aGlzLmZsYWdzICYgOCkpIHtcbiAgICAgIHRoaXMuZmxhZ3MgfD0gODtcbiAgICAgIHRoaXMubmV4dEVmZmVjdCA9IGJhdGNoZWRFZmZlY3Q7XG4gICAgICBiYXRjaGVkRWZmZWN0ID0gdGhpcztcbiAgICB9XG4gIH1cbiAgcnVuKCkge1xuICAgIGlmICghKHRoaXMuZmxhZ3MgJiAxKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcbiAgICB9XG4gICAgdGhpcy5mbGFncyB8PSAyO1xuICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XG4gICAgcHJlcGFyZURlcHModGhpcyk7XG4gICAgY29uc3QgcHJldkVmZmVjdCA9IGFjdGl2ZVN1YjtcbiAgICBjb25zdCBwcmV2U2hvdWxkVHJhY2sgPSBzaG91bGRUcmFjaztcbiAgICBhY3RpdmVTdWIgPSB0aGlzO1xuICAgIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYWN0aXZlU3ViICE9PSB0aGlzKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJBY3RpdmUgZWZmZWN0IHdhcyBub3QgcmVzdG9yZWQgY29ycmVjdGx5IC0gdGhpcyBpcyBsaWtlbHkgYSBWdWUgaW50ZXJuYWwgYnVnLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjbGVhbnVwRGVwcyh0aGlzKTtcbiAgICAgIGFjdGl2ZVN1YiA9IHByZXZFZmZlY3Q7XG4gICAgICBzaG91bGRUcmFjayA9IHByZXZTaG91bGRUcmFjaztcbiAgICAgIHRoaXMuZmxhZ3MgJj0gfjI7XG4gICAgfVxuICB9XG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuZmxhZ3MgJiAxKSB7XG4gICAgICBmb3IgKGxldCBsaW5rID0gdGhpcy5kZXBzOyBsaW5rOyBsaW5rID0gbGluay5uZXh0RGVwKSB7XG4gICAgICAgIHJlbW92ZVN1YihsaW5rKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVwcyA9IHRoaXMuZGVwc1RhaWwgPSB2b2lkIDA7XG4gICAgICBjbGVhbnVwRWZmZWN0KHRoaXMpO1xuICAgICAgdGhpcy5vblN0b3AgJiYgdGhpcy5vblN0b3AoKTtcbiAgICAgIHRoaXMuZmxhZ3MgJj0gfjE7XG4gICAgfVxuICB9XG4gIHRyaWdnZXIoKSB7XG4gICAgaWYgKHRoaXMuZmxhZ3MgJiA2NCkge1xuICAgICAgcGF1c2VkUXVldWVFZmZlY3RzLmFkZCh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJ1bklmRGlydHkoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcnVuSWZEaXJ0eSgpIHtcbiAgICBpZiAoaXNEaXJ0eSh0aGlzKSkge1xuICAgICAgdGhpcy5ydW4oKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGRpcnR5KCkge1xuICAgIHJldHVybiBpc0RpcnR5KHRoaXMpO1xuICB9XG59XG5sZXQgYmF0Y2hEZXB0aCA9IDA7XG5sZXQgYmF0Y2hlZEVmZmVjdDtcbmZ1bmN0aW9uIHN0YXJ0QmF0Y2goKSB7XG4gIGJhdGNoRGVwdGgrKztcbn1cbmZ1bmN0aW9uIGVuZEJhdGNoKCkge1xuICBpZiAoYmF0Y2hEZXB0aCA+IDEpIHtcbiAgICBiYXRjaERlcHRoLS07XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhdGNoRGVwdGgtLTtcbiAgbGV0IGVycm9yO1xuICB3aGlsZSAoYmF0Y2hlZEVmZmVjdCkge1xuICAgIGxldCBlID0gYmF0Y2hlZEVmZmVjdDtcbiAgICBiYXRjaGVkRWZmZWN0ID0gdm9pZCAwO1xuICAgIHdoaWxlIChlKSB7XG4gICAgICBjb25zdCBuZXh0ID0gZS5uZXh0RWZmZWN0O1xuICAgICAgZS5uZXh0RWZmZWN0ID0gdm9pZCAwO1xuICAgICAgZS5mbGFncyAmPSB+ODtcbiAgICAgIGlmIChlLmZsYWdzICYgMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGUudHJpZ2dlcigpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZSA9IG5leHQ7XG4gICAgfVxuICB9XG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG59XG5mdW5jdGlvbiBwcmVwYXJlRGVwcyhzdWIpIHtcbiAgZm9yIChsZXQgbGluayA9IHN1Yi5kZXBzOyBsaW5rOyBsaW5rID0gbGluay5uZXh0RGVwKSB7XG4gICAgbGluay52ZXJzaW9uID0gLTE7XG4gICAgbGluay5wcmV2QWN0aXZlTGluayA9IGxpbmsuZGVwLmFjdGl2ZUxpbms7XG4gICAgbGluay5kZXAuYWN0aXZlTGluayA9IGxpbms7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFudXBEZXBzKHN1Yikge1xuICBsZXQgaGVhZDtcbiAgbGV0IHRhaWwgPSBzdWIuZGVwc1RhaWw7XG4gIGZvciAobGV0IGxpbmsgPSB0YWlsOyBsaW5rOyBsaW5rID0gbGluay5wcmV2RGVwKSB7XG4gICAgaWYgKGxpbmsudmVyc2lvbiA9PT0gLTEpIHtcbiAgICAgIGlmIChsaW5rID09PSB0YWlsKSB0YWlsID0gbGluay5wcmV2RGVwO1xuICAgICAgcmVtb3ZlU3ViKGxpbmspO1xuICAgICAgcmVtb3ZlRGVwKGxpbmspO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkID0gbGluaztcbiAgICB9XG4gICAgbGluay5kZXAuYWN0aXZlTGluayA9IGxpbmsucHJldkFjdGl2ZUxpbms7XG4gICAgbGluay5wcmV2QWN0aXZlTGluayA9IHZvaWQgMDtcbiAgfVxuICBzdWIuZGVwcyA9IGhlYWQ7XG4gIHN1Yi5kZXBzVGFpbCA9IHRhaWw7XG59XG5mdW5jdGlvbiBpc0RpcnR5KHN1Yikge1xuICBmb3IgKGxldCBsaW5rID0gc3ViLmRlcHM7IGxpbms7IGxpbmsgPSBsaW5rLm5leHREZXApIHtcbiAgICBpZiAobGluay5kZXAudmVyc2lvbiAhPT0gbGluay52ZXJzaW9uIHx8IGxpbmsuZGVwLmNvbXB1dGVkICYmIHJlZnJlc2hDb21wdXRlZChsaW5rLmRlcC5jb21wdXRlZCkgPT09IGZhbHNlIHx8IGxpbmsuZGVwLnZlcnNpb24gIT09IGxpbmsudmVyc2lvbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChzdWIuX2RpcnR5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmVmcmVzaENvbXB1dGVkKGNvbXB1dGVkKSB7XG4gIGlmIChjb21wdXRlZC5mbGFncyAmIDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNvbXB1dGVkLmZsYWdzICYgNCAmJiAhKGNvbXB1dGVkLmZsYWdzICYgMTYpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbXB1dGVkLmZsYWdzICY9IH4xNjtcbiAgaWYgKGNvbXB1dGVkLmdsb2JhbFZlcnNpb24gPT09IGdsb2JhbFZlcnNpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29tcHV0ZWQuZ2xvYmFsVmVyc2lvbiA9IGdsb2JhbFZlcnNpb247XG4gIGNvbnN0IGRlcCA9IGNvbXB1dGVkLmRlcDtcbiAgY29tcHV0ZWQuZmxhZ3MgfD0gMjtcbiAgaWYgKGRlcC52ZXJzaW9uID4gMCAmJiAhY29tcHV0ZWQuaXNTU1IgJiYgIWlzRGlydHkoY29tcHV0ZWQpKSB7XG4gICAgY29tcHV0ZWQuZmxhZ3MgJj0gfjI7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByZXZTdWIgPSBhY3RpdmVTdWI7XG4gIGNvbnN0IHByZXZTaG91bGRUcmFjayA9IHNob3VsZFRyYWNrO1xuICBhY3RpdmVTdWIgPSBjb21wdXRlZDtcbiAgc2hvdWxkVHJhY2sgPSB0cnVlO1xuICB0cnkge1xuICAgIHByZXBhcmVEZXBzKGNvbXB1dGVkKTtcbiAgICBjb25zdCB2YWx1ZSA9IGNvbXB1dGVkLmZuKCk7XG4gICAgaWYgKGRlcC52ZXJzaW9uID09PSAwIHx8IGhhc0NoYW5nZWQodmFsdWUsIGNvbXB1dGVkLl92YWx1ZSkpIHtcbiAgICAgIGNvbXB1dGVkLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgZGVwLnZlcnNpb24rKztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlcC52ZXJzaW9uKys7XG4gICAgdGhyb3cgZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIGFjdGl2ZVN1YiA9IHByZXZTdWI7XG4gICAgc2hvdWxkVHJhY2sgPSBwcmV2U2hvdWxkVHJhY2s7XG4gICAgY2xlYW51cERlcHMoY29tcHV0ZWQpO1xuICAgIGNvbXB1dGVkLmZsYWdzICY9IH4yO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVTdWIobGluaykge1xuICBjb25zdCB7IGRlcCwgcHJldlN1YiwgbmV4dFN1YiB9ID0gbGluaztcbiAgaWYgKHByZXZTdWIpIHtcbiAgICBwcmV2U3ViLm5leHRTdWIgPSBuZXh0U3ViO1xuICAgIGxpbmsucHJldlN1YiA9IHZvaWQgMDtcbiAgfVxuICBpZiAobmV4dFN1Yikge1xuICAgIG5leHRTdWIucHJldlN1YiA9IHByZXZTdWI7XG4gICAgbGluay5uZXh0U3ViID0gdm9pZCAwO1xuICB9XG4gIGlmIChkZXAuc3VicyA9PT0gbGluaykge1xuICAgIGRlcC5zdWJzID0gcHJldlN1YjtcbiAgfVxuICBpZiAoIWRlcC5zdWJzICYmIGRlcC5jb21wdXRlZCkge1xuICAgIGRlcC5jb21wdXRlZC5mbGFncyAmPSB+NDtcbiAgICBmb3IgKGxldCBsID0gZGVwLmNvbXB1dGVkLmRlcHM7IGw7IGwgPSBsLm5leHREZXApIHtcbiAgICAgIHJlbW92ZVN1YihsKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZURlcChsaW5rKSB7XG4gIGNvbnN0IHsgcHJldkRlcCwgbmV4dERlcCB9ID0gbGluaztcbiAgaWYgKHByZXZEZXApIHtcbiAgICBwcmV2RGVwLm5leHREZXAgPSBuZXh0RGVwO1xuICAgIGxpbmsucHJldkRlcCA9IHZvaWQgMDtcbiAgfVxuICBpZiAobmV4dERlcCkge1xuICAgIG5leHREZXAucHJldkRlcCA9IHByZXZEZXA7XG4gICAgbGluay5uZXh0RGVwID0gdm9pZCAwO1xuICB9XG59XG5mdW5jdGlvbiBlZmZlY3QoZm4sIG9wdGlvbnMpIHtcbiAgaWYgKGZuLmVmZmVjdCBpbnN0YW5jZW9mIFJlYWN0aXZlRWZmZWN0KSB7XG4gICAgZm4gPSBmbi5lZmZlY3QuZm47XG4gIH1cbiAgY29uc3QgZSA9IG5ldyBSZWFjdGl2ZUVmZmVjdChmbik7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgZXh0ZW5kKGUsIG9wdGlvbnMpO1xuICB9XG4gIHRyeSB7XG4gICAgZS5ydW4oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZS5zdG9wKCk7XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIGNvbnN0IHJ1bm5lciA9IGUucnVuLmJpbmQoZSk7XG4gIHJ1bm5lci5lZmZlY3QgPSBlO1xuICByZXR1cm4gcnVubmVyO1xufVxuZnVuY3Rpb24gc3RvcChydW5uZXIpIHtcbiAgcnVubmVyLmVmZmVjdC5zdG9wKCk7XG59XG5sZXQgc2hvdWxkVHJhY2sgPSB0cnVlO1xuY29uc3QgdHJhY2tTdGFjayA9IFtdO1xuZnVuY3Rpb24gcGF1c2VUcmFja2luZygpIHtcbiAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgc2hvdWxkVHJhY2sgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGVuYWJsZVRyYWNraW5nKCkge1xuICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xuICBzaG91bGRUcmFjayA9IHRydWU7XG59XG5mdW5jdGlvbiByZXNldFRyYWNraW5nKCkge1xuICBjb25zdCBsYXN0ID0gdHJhY2tTdGFjay5wb3AoKTtcbiAgc2hvdWxkVHJhY2sgPSBsYXN0ID09PSB2b2lkIDAgPyB0cnVlIDogbGFzdDtcbn1cbmZ1bmN0aW9uIG9uRWZmZWN0Q2xlYW51cChmbiwgZmFpbFNpbGVudGx5ID0gZmFsc2UpIHtcbiAgaWYgKGFjdGl2ZVN1YiBpbnN0YW5jZW9mIFJlYWN0aXZlRWZmZWN0KSB7XG4gICAgYWN0aXZlU3ViLmNsZWFudXAgPSBmbjtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFmYWlsU2lsZW50bHkpIHtcbiAgICB3YXJuKFxuICAgICAgYG9uRWZmZWN0Q2xlYW51cCgpIHdhcyBjYWxsZWQgd2hlbiB0aGVyZSB3YXMgbm8gYWN0aXZlIGVmZmVjdCB0byBhc3NvY2lhdGUgd2l0aC5gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYW51cEVmZmVjdChlKSB7XG4gIGNvbnN0IHsgY2xlYW51cCB9ID0gZTtcbiAgZS5jbGVhbnVwID0gdm9pZCAwO1xuICBpZiAoY2xlYW51cCkge1xuICAgIGNvbnN0IHByZXZTdWIgPSBhY3RpdmVTdWI7XG4gICAgYWN0aXZlU3ViID0gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGFjdGl2ZVN1YiA9IHByZXZTdWI7XG4gICAgfVxuICB9XG59XG5cbmxldCBnbG9iYWxWZXJzaW9uID0gMDtcbmNsYXNzIERlcCB7XG4gIGNvbnN0cnVjdG9yKGNvbXB1dGVkKSB7XG4gICAgdGhpcy5jb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgIHRoaXMudmVyc2lvbiA9IDA7XG4gICAgLyoqXG4gICAgICogTGluayBiZXR3ZWVuIHRoaXMgZGVwIGFuZCB0aGUgY3VycmVudCBhY3RpdmUgZWZmZWN0XG4gICAgICovXG4gICAgdGhpcy5hY3RpdmVMaW5rID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIERvdWJseSBsaW5rZWQgbGlzdCByZXByZXNlbnRpbmcgdGhlIHN1YnNjcmliaW5nIGVmZmVjdHMgKHRhaWwpXG4gICAgICovXG4gICAgdGhpcy5zdWJzID0gdm9pZCAwO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB0aGlzLnN1YnNIZWFkID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICB0cmFjayhkZWJ1Z0luZm8pIHtcbiAgICBpZiAoIWFjdGl2ZVN1YiB8fCAhc2hvdWxkVHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGxpbmsgPSB0aGlzLmFjdGl2ZUxpbms7XG4gICAgaWYgKGxpbmsgPT09IHZvaWQgMCB8fCBsaW5rLnN1YiAhPT0gYWN0aXZlU3ViKSB7XG4gICAgICBsaW5rID0gdGhpcy5hY3RpdmVMaW5rID0ge1xuICAgICAgICBkZXA6IHRoaXMsXG4gICAgICAgIHN1YjogYWN0aXZlU3ViLFxuICAgICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICAgIG5leHREZXA6IHZvaWQgMCxcbiAgICAgICAgcHJldkRlcDogdm9pZCAwLFxuICAgICAgICBuZXh0U3ViOiB2b2lkIDAsXG4gICAgICAgIHByZXZTdWI6IHZvaWQgMCxcbiAgICAgICAgcHJldkFjdGl2ZUxpbms6IHZvaWQgMFxuICAgICAgfTtcbiAgICAgIGlmICghYWN0aXZlU3ViLmRlcHMpIHtcbiAgICAgICAgYWN0aXZlU3ViLmRlcHMgPSBhY3RpdmVTdWIuZGVwc1RhaWwgPSBsaW5rO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluay5wcmV2RGVwID0gYWN0aXZlU3ViLmRlcHNUYWlsO1xuICAgICAgICBhY3RpdmVTdWIuZGVwc1RhaWwubmV4dERlcCA9IGxpbms7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzVGFpbCA9IGxpbms7XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlU3ViLmZsYWdzICYgNCkge1xuICAgICAgICBhZGRTdWIobGluayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsaW5rLnZlcnNpb24gPT09IC0xKSB7XG4gICAgICBsaW5rLnZlcnNpb24gPSB0aGlzLnZlcnNpb247XG4gICAgICBpZiAobGluay5uZXh0RGVwKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBsaW5rLm5leHREZXA7XG4gICAgICAgIG5leHQucHJldkRlcCA9IGxpbmsucHJldkRlcDtcbiAgICAgICAgaWYgKGxpbmsucHJldkRlcCkge1xuICAgICAgICAgIGxpbmsucHJldkRlcC5uZXh0RGVwID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBsaW5rLnByZXZEZXAgPSBhY3RpdmVTdWIuZGVwc1RhaWw7XG4gICAgICAgIGxpbmsubmV4dERlcCA9IHZvaWQgMDtcbiAgICAgICAgYWN0aXZlU3ViLmRlcHNUYWlsLm5leHREZXAgPSBsaW5rO1xuICAgICAgICBhY3RpdmVTdWIuZGVwc1RhaWwgPSBsaW5rO1xuICAgICAgICBpZiAoYWN0aXZlU3ViLmRlcHMgPT09IGxpbmspIHtcbiAgICAgICAgICBhY3RpdmVTdWIuZGVwcyA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYWN0aXZlU3ViLm9uVHJhY2spIHtcbiAgICAgIGFjdGl2ZVN1Yi5vblRyYWNrKFxuICAgICAgICBleHRlbmQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgZWZmZWN0OiBhY3RpdmVTdWJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlYnVnSW5mb1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbGluaztcbiAgfVxuICB0cmlnZ2VyKGRlYnVnSW5mbykge1xuICAgIHRoaXMudmVyc2lvbisrO1xuICAgIGdsb2JhbFZlcnNpb24rKztcbiAgICB0aGlzLm5vdGlmeShkZWJ1Z0luZm8pO1xuICB9XG4gIG5vdGlmeShkZWJ1Z0luZm8pIHtcbiAgICBzdGFydEJhdGNoKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGZvciAobGV0IGhlYWQgPSB0aGlzLnN1YnNIZWFkOyBoZWFkOyBoZWFkID0gaGVhZC5uZXh0U3ViKSB7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaGVhZC5zdWIub25UcmlnZ2VyICYmICEoaGVhZC5zdWIuZmxhZ3MgJiA4KSkge1xuICAgICAgICAgICAgaGVhZC5zdWIub25UcmlnZ2VyKFxuICAgICAgICAgICAgICBleHRlbmQoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZWZmZWN0OiBoZWFkLnN1YlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVidWdJbmZvXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBsaW5rID0gdGhpcy5zdWJzOyBsaW5rOyBsaW5rID0gbGluay5wcmV2U3ViKSB7XG4gICAgICAgIGxpbmsuc3ViLm5vdGlmeSgpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRkU3ViKGxpbmspIHtcbiAgY29uc3QgY29tcHV0ZWQgPSBsaW5rLmRlcC5jb21wdXRlZDtcbiAgaWYgKGNvbXB1dGVkICYmICFsaW5rLmRlcC5zdWJzKSB7XG4gICAgY29tcHV0ZWQuZmxhZ3MgfD0gNCB8IDE2O1xuICAgIGZvciAobGV0IGwgPSBjb21wdXRlZC5kZXBzOyBsOyBsID0gbC5uZXh0RGVwKSB7XG4gICAgICBhZGRTdWIobCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGN1cnJlbnRUYWlsID0gbGluay5kZXAuc3VicztcbiAgaWYgKGN1cnJlbnRUYWlsICE9PSBsaW5rKSB7XG4gICAgbGluay5wcmV2U3ViID0gY3VycmVudFRhaWw7XG4gICAgaWYgKGN1cnJlbnRUYWlsKSBjdXJyZW50VGFpbC5uZXh0U3ViID0gbGluaztcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBsaW5rLmRlcC5zdWJzSGVhZCA9PT0gdm9pZCAwKSB7XG4gICAgbGluay5kZXAuc3Vic0hlYWQgPSBsaW5rO1xuICB9XG4gIGxpbmsuZGVwLnN1YnMgPSBsaW5rO1xufVxuY29uc3QgdGFyZ2V0TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBJVEVSQVRFX0tFWSA9IFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IFwiT2JqZWN0IGl0ZXJhdGVcIiA6IFwiXCJcbik7XG5jb25zdCBNQVBfS0VZX0lURVJBVEVfS0VZID0gU3ltYm9sKFxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJNYXAga2V5cyBpdGVyYXRlXCIgOiBcIlwiXG4pO1xuY29uc3QgQVJSQVlfSVRFUkFURV9LRVkgPSBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIkFycmF5IGl0ZXJhdGVcIiA6IFwiXCJcbik7XG5mdW5jdGlvbiB0cmFjayh0YXJnZXQsIHR5cGUsIGtleSkge1xuICBpZiAoc2hvdWxkVHJhY2sgJiYgYWN0aXZlU3ViKSB7XG4gICAgbGV0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG4gICAgaWYgKCFkZXBzTWFwKSB7XG4gICAgICB0YXJnZXRNYXAuc2V0KHRhcmdldCwgZGVwc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBsZXQgZGVwID0gZGVwc01hcC5nZXQoa2V5KTtcbiAgICBpZiAoIWRlcCkge1xuICAgICAgZGVwc01hcC5zZXQoa2V5LCBkZXAgPSBuZXcgRGVwKCkpO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgZGVwLnRyYWNrKHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0eXBlLFxuICAgICAgICBrZXlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXAudHJhY2soKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXIodGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0KSB7XG4gIGNvbnN0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG4gIGlmICghZGVwc01hcCkge1xuICAgIGdsb2JhbFZlcnNpb24rKztcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGRlcHMgPSBbXTtcbiAgaWYgKHR5cGUgPT09IFwiY2xlYXJcIikge1xuICAgIGRlcHMgPSBbLi4uZGVwc01hcC52YWx1ZXMoKV07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdGFyZ2V0SXNBcnJheSA9IGlzQXJyYXkodGFyZ2V0KTtcbiAgICBjb25zdCBpc0FycmF5SW5kZXggPSB0YXJnZXRJc0FycmF5ICYmIGlzSW50ZWdlcktleShrZXkpO1xuICAgIGlmICh0YXJnZXRJc0FycmF5ICYmIGtleSA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgY29uc3QgbmV3TGVuZ3RoID0gTnVtYmVyKG5ld1ZhbHVlKTtcbiAgICAgIGRlcHNNYXAuZm9yRWFjaCgoZGVwLCBrZXkyKSA9PiB7XG4gICAgICAgIGlmIChrZXkyID09PSBcImxlbmd0aFwiIHx8IGtleTIgPT09IEFSUkFZX0lURVJBVEVfS0VZIHx8ICFpc1N5bWJvbChrZXkyKSAmJiBrZXkyID49IG5ld0xlbmd0aCkge1xuICAgICAgICAgIGRlcHMucHVzaChkZXApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHVzaCA9IChkZXApID0+IGRlcCAmJiBkZXBzLnB1c2goZGVwKTtcbiAgICAgIGlmIChrZXkgIT09IHZvaWQgMCkge1xuICAgICAgICBwdXNoKGRlcHNNYXAuZ2V0KGtleSkpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlJbmRleCkge1xuICAgICAgICBwdXNoKGRlcHNNYXAuZ2V0KEFSUkFZX0lURVJBVEVfS0VZKSk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICAgIGlmICghdGFyZ2V0SXNBcnJheSkge1xuICAgICAgICAgICAgcHVzaChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgcHVzaChkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5SW5kZXgpIHtcbiAgICAgICAgICAgIHB1c2goZGVwc01hcC5nZXQoXCJsZW5ndGhcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuICAgICAgICAgIGlmICghdGFyZ2V0SXNBcnJheSkge1xuICAgICAgICAgICAgcHVzaChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgcHVzaChkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2V0XCI6XG4gICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHB1c2goZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXJ0QmF0Y2goKTtcbiAgZm9yIChjb25zdCBkZXAgb2YgZGVwcykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBkZXAudHJpZ2dlcih7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAga2V5LFxuICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgIG9sZFRhcmdldFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlcC50cmlnZ2VyKCk7XG4gICAgfVxuICB9XG4gIGVuZEJhdGNoKCk7XG59XG5mdW5jdGlvbiBnZXREZXBGcm9tUmVhY3RpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gdGFyZ2V0TWFwLmdldChvYmplY3QpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZ2V0KGtleSk7XG59XG5cbmZ1bmN0aW9uIHJlYWN0aXZlUmVhZEFycmF5KGFycmF5KSB7XG4gIGNvbnN0IHJhdyA9IHRvUmF3KGFycmF5KTtcbiAgaWYgKHJhdyA9PT0gYXJyYXkpIHJldHVybiByYXc7XG4gIHRyYWNrKHJhdywgXCJpdGVyYXRlXCIsIEFSUkFZX0lURVJBVEVfS0VZKTtcbiAgcmV0dXJuIGlzU2hhbGxvdyhhcnJheSkgPyByYXcgOiByYXcubWFwKHRvUmVhY3RpdmUpO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlYWRBcnJheShhcnIpIHtcbiAgdHJhY2soYXJyID0gdG9SYXcoYXJyKSwgXCJpdGVyYXRlXCIsIEFSUkFZX0lURVJBVEVfS0VZKTtcbiAgcmV0dXJuIGFycjtcbn1cbmNvbnN0IGFycmF5SW5zdHJ1bWVudGF0aW9ucyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgU3ltYm9sLml0ZXJhdG9yLCB0b1JlYWN0aXZlKTtcbiAgfSxcbiAgY29uY2F0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykuY29uY2F0KFxuICAgICAgLi4uYXJncy5tYXAoKHgpID0+IHJlYWN0aXZlUmVhZEFycmF5KHgpKVxuICAgICk7XG4gIH0sXG4gIGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yKHRoaXMsIFwiZW50cmllc1wiLCAodmFsdWUpID0+IHtcbiAgICAgIHZhbHVlWzFdID0gdG9SZWFjdGl2ZSh2YWx1ZVsxXSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gIH0sXG4gIGV2ZXJ5KGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZXZlcnlcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgZmlsdGVyKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmlsdGVyXCIsIGZuLCB0aGlzQXJnLCAodikgPT4gdi5tYXAodG9SZWFjdGl2ZSksIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZpbmQoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmaW5kXCIsIGZuLCB0aGlzQXJnLCB0b1JlYWN0aXZlLCBhcmd1bWVudHMpO1xuICB9LFxuICBmaW5kSW5kZXgoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmaW5kSW5kZXhcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgZmluZExhc3QoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmaW5kTGFzdFwiLCBmbiwgdGhpc0FyZywgdG9SZWFjdGl2ZSwgYXJndW1lbnRzKTtcbiAgfSxcbiAgZmluZExhc3RJbmRleChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbmRMYXN0SW5kZXhcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgLy8gZmxhdCwgZmxhdE1hcCBjb3VsZCBiZW5lZml0IGZyb20gQVJSQVlfSVRFUkFURSBidXQgYXJlIG5vdCBzdHJhaWdodC1mb3J3YXJkIHRvIGltcGxlbWVudFxuICBmb3JFYWNoKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZm9yRWFjaFwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICBpbmNsdWRlcyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHNlYXJjaFByb3h5KHRoaXMsIFwiaW5jbHVkZXNcIiwgYXJncyk7XG4gIH0sXG4gIGluZGV4T2YoLi4uYXJncykge1xuICAgIHJldHVybiBzZWFyY2hQcm94eSh0aGlzLCBcImluZGV4T2ZcIiwgYXJncyk7XG4gIH0sXG4gIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlUmVhZEFycmF5KHRoaXMpLmpvaW4oc2VwYXJhdG9yKTtcbiAgfSxcbiAgLy8ga2V5cygpIGl0ZXJhdG9yIG9ubHkgcmVhZHMgYGxlbmd0aGAsIG5vIG9wdGltaXNhdGlvbiByZXF1aXJlZFxuICBsYXN0SW5kZXhPZiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHNlYXJjaFByb3h5KHRoaXMsIFwibGFzdEluZGV4T2ZcIiwgYXJncyk7XG4gIH0sXG4gIG1hcChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcIm1hcFwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICBwb3AoKSB7XG4gICAgcmV0dXJuIG5vVHJhY2tpbmcodGhpcywgXCJwb3BcIik7XG4gIH0sXG4gIHB1c2goLi4uYXJncykge1xuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwicHVzaFwiLCBhcmdzKTtcbiAgfSxcbiAgcmVkdWNlKGZuLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIHJlZHVjZSh0aGlzLCBcInJlZHVjZVwiLCBmbiwgYXJncyk7XG4gIH0sXG4gIHJlZHVjZVJpZ2h0KGZuLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIHJlZHVjZSh0aGlzLCBcInJlZHVjZVJpZ2h0XCIsIGZuLCBhcmdzKTtcbiAgfSxcbiAgc2hpZnQoKSB7XG4gICAgcmV0dXJuIG5vVHJhY2tpbmcodGhpcywgXCJzaGlmdFwiKTtcbiAgfSxcbiAgLy8gc2xpY2UgY291bGQgdXNlIEFSUkFZX0lURVJBVEUgYnV0IGFsc28gc2VlbXMgdG8gYmVnIGZvciByYW5nZSB0cmFja2luZ1xuICBzb21lKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwic29tZVwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICBzcGxpY2UoLi4uYXJncykge1xuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwic3BsaWNlXCIsIGFyZ3MpO1xuICB9LFxuICB0b1JldmVyc2VkKCkge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS50b1JldmVyc2VkKCk7XG4gIH0sXG4gIHRvU29ydGVkKGNvbXBhcmVyKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlUmVhZEFycmF5KHRoaXMpLnRvU29ydGVkKGNvbXBhcmVyKTtcbiAgfSxcbiAgdG9TcGxpY2VkKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykudG9TcGxpY2VkKC4uLmFyZ3MpO1xuICB9LFxuICB1bnNoaWZ0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInVuc2hpZnRcIiwgYXJncyk7XG4gIH0sXG4gIHZhbHVlcygpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgXCJ2YWx1ZXNcIiwgdG9SZWFjdGl2ZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBpdGVyYXRvcihzZWxmLCBtZXRob2QsIHdyYXBWYWx1ZSkge1xuICBjb25zdCBhcnIgPSBzaGFsbG93UmVhZEFycmF5KHNlbGYpO1xuICBjb25zdCBpdGVyID0gYXJyW21ldGhvZF0oKTtcbiAgaWYgKGFyciAhPT0gc2VsZiAmJiAhaXNTaGFsbG93KHNlbGYpKSB7XG4gICAgaXRlci5fbmV4dCA9IGl0ZXIubmV4dDtcbiAgICBpdGVyLm5leHQgPSAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBpdGVyLl9uZXh0KCk7XG4gICAgICBpZiAocmVzdWx0LnZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHdyYXBWYWx1ZShyZXN1bHQudmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG4gIHJldHVybiBpdGVyO1xufVxuY29uc3QgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbmZ1bmN0aW9uIGFwcGx5KHNlbGYsIG1ldGhvZCwgZm4sIHRoaXNBcmcsIHdyYXBwZWRSZXRGbiwgYXJncykge1xuICBjb25zdCBhcnIgPSBzaGFsbG93UmVhZEFycmF5KHNlbGYpO1xuICBjb25zdCBuZWVkc1dyYXAgPSBhcnIgIT09IHNlbGYgJiYgIWlzU2hhbGxvdyhzZWxmKTtcbiAgY29uc3QgbWV0aG9kRm4gPSBhcnJbbWV0aG9kXTtcbiAgaWYgKG1ldGhvZEZuICE9PSBhcnJheVByb3RvW21ldGhvZF0pIHtcbiAgICBjb25zdCByZXN1bHQyID0gbWV0aG9kRm4uYXBwbHkoYXJyLCBhcmdzKTtcbiAgICByZXR1cm4gbmVlZHNXcmFwID8gdG9SZWFjdGl2ZShyZXN1bHQyKSA6IHJlc3VsdDI7XG4gIH1cbiAgbGV0IHdyYXBwZWRGbiA9IGZuO1xuICBpZiAoYXJyICE9PSBzZWxmKSB7XG4gICAgaWYgKG5lZWRzV3JhcCkge1xuICAgICAgd3JhcHBlZEZuID0gZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgdG9SZWFjdGl2ZShpdGVtKSwgaW5kZXgsIHNlbGYpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZuLmxlbmd0aCA+IDIpIHtcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGl0ZW0sIGluZGV4LCBzZWxmKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IG1ldGhvZEZuLmNhbGwoYXJyLCB3cmFwcGVkRm4sIHRoaXNBcmcpO1xuICByZXR1cm4gbmVlZHNXcmFwICYmIHdyYXBwZWRSZXRGbiA/IHdyYXBwZWRSZXRGbihyZXN1bHQpIDogcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVkdWNlKHNlbGYsIG1ldGhvZCwgZm4sIGFyZ3MpIHtcbiAgY29uc3QgYXJyID0gc2hhbGxvd1JlYWRBcnJheShzZWxmKTtcbiAgbGV0IHdyYXBwZWRGbiA9IGZuO1xuICBpZiAoYXJyICE9PSBzZWxmKSB7XG4gICAgaWYgKCFpc1NoYWxsb3coc2VsZikpIHtcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGFjYywgaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYWNjLCB0b1JlYWN0aXZlKGl0ZW0pLCBpbmRleCwgc2VsZik7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZm4ubGVuZ3RoID4gMykge1xuICAgICAgd3JhcHBlZEZuID0gZnVuY3Rpb24oYWNjLCBpdGVtLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhY2MsIGl0ZW0sIGluZGV4LCBzZWxmKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJbbWV0aG9kXSh3cmFwcGVkRm4sIC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gc2VhcmNoUHJveHkoc2VsZiwgbWV0aG9kLCBhcmdzKSB7XG4gIGNvbnN0IGFyciA9IHRvUmF3KHNlbGYpO1xuICB0cmFjayhhcnIsIFwiaXRlcmF0ZVwiLCBBUlJBWV9JVEVSQVRFX0tFWSk7XG4gIGNvbnN0IHJlcyA9IGFyclttZXRob2RdKC4uLmFyZ3MpO1xuICBpZiAoKHJlcyA9PT0gLTEgfHwgcmVzID09PSBmYWxzZSkgJiYgaXNQcm94eShhcmdzWzBdKSkge1xuICAgIGFyZ3NbMF0gPSB0b1JhdyhhcmdzWzBdKTtcbiAgICByZXR1cm4gYXJyW21ldGhvZF0oLi4uYXJncyk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIG5vVHJhY2tpbmcoc2VsZiwgbWV0aG9kLCBhcmdzID0gW10pIHtcbiAgcGF1c2VUcmFja2luZygpO1xuICBzdGFydEJhdGNoKCk7XG4gIGNvbnN0IHJlcyA9IHRvUmF3KHNlbGYpW21ldGhvZF0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVuZEJhdGNoKCk7XG4gIHJlc2V0VHJhY2tpbmcoKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuY29uc3QgaXNOb25UcmFja2FibGVLZXlzID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoYF9fcHJvdG9fXyxfX3ZfaXNSZWYsX19pc1Z1ZWApO1xuY29uc3QgYnVpbHRJblN5bWJvbHMgPSBuZXcgU2V0KFxuICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKS5maWx0ZXIoKGtleSkgPT4ga2V5ICE9PSBcImFyZ3VtZW50c1wiICYmIGtleSAhPT0gXCJjYWxsZXJcIikubWFwKChrZXkpID0+IFN5bWJvbFtrZXldKS5maWx0ZXIoaXNTeW1ib2wpXG4pO1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkoa2V5KSB7XG4gIGlmICghaXNTeW1ib2woa2V5KSkga2V5ID0gU3RyaW5nKGtleSk7XG4gIGNvbnN0IG9iaiA9IHRvUmF3KHRoaXMpO1xuICB0cmFjayhvYmosIFwiaGFzXCIsIGtleSk7XG4gIHJldHVybiBvYmouaGFzT3duUHJvcGVydHkoa2V5KTtcbn1cbmNsYXNzIEJhc2VSZWFjdGl2ZUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihfaXNSZWFkb25seSA9IGZhbHNlLCBfaXNTaGFsbG93ID0gZmFsc2UpIHtcbiAgICB0aGlzLl9pc1JlYWRvbmx5ID0gX2lzUmVhZG9ubHk7XG4gICAgdGhpcy5faXNTaGFsbG93ID0gX2lzU2hhbGxvdztcbiAgfVxuICBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgY29uc3QgaXNSZWFkb25seTIgPSB0aGlzLl9pc1JlYWRvbmx5LCBpc1NoYWxsb3cyID0gdGhpcy5faXNTaGFsbG93O1xuICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIikge1xuICAgICAgcmV0dXJuICFpc1JlYWRvbmx5MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzU2hhbGxvd1wiKSB7XG4gICAgICByZXR1cm4gaXNTaGFsbG93MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIpIHtcbiAgICAgIGlmIChyZWNlaXZlciA9PT0gKGlzUmVhZG9ubHkyID8gaXNTaGFsbG93MiA/IHNoYWxsb3dSZWFkb25seU1hcCA6IHJlYWRvbmx5TWFwIDogaXNTaGFsbG93MiA/IHNoYWxsb3dSZWFjdGl2ZU1hcCA6IHJlYWN0aXZlTWFwKS5nZXQodGFyZ2V0KSB8fCAvLyByZWNlaXZlciBpcyBub3QgdGhlIHJlYWN0aXZlIHByb3h5LCBidXQgaGFzIHRoZSBzYW1lIHByb3RvdHlwZVxuICAgICAgLy8gdGhpcyBtZWFucyB0aGUgcmVjZWl2ZXIgaXMgYSB1c2VyIHByb3h5IG9mIHRoZSByZWFjdGl2ZSBwcm94eVxuICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihyZWNlaXZlcikpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0SXNBcnJheSA9IGlzQXJyYXkodGFyZ2V0KTtcbiAgICBpZiAoIWlzUmVhZG9ubHkyKSB7XG4gICAgICBsZXQgZm47XG4gICAgICBpZiAodGFyZ2V0SXNBcnJheSAmJiAoZm4gPSBhcnJheUluc3RydW1lbnRhdGlvbnNba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gXCJoYXNPd25Qcm9wZXJ0eVwiKSB7XG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzID0gUmVmbGVjdC5nZXQoXG4gICAgICB0YXJnZXQsXG4gICAgICBrZXksXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgcHJveHkgd3JhcHBpbmcgYSByZWYsIHJldHVybiBtZXRob2RzIHVzaW5nIHRoZSByYXcgcmVmXG4gICAgICAvLyBhcyByZWNlaXZlciBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2FsbCBgdG9SYXdgIG9uIHRoZSByZWYgaW4gYWxsXG4gICAgICAvLyBpdHMgY2xhc3MgbWV0aG9kc1xuICAgICAgaXNSZWYodGFyZ2V0KSA/IHRhcmdldCA6IHJlY2VpdmVyXG4gICAgKTtcbiAgICBpZiAoaXNTeW1ib2woa2V5KSA/IGJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpIDogaXNOb25UcmFja2FibGVLZXlzKGtleSkpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmICghaXNSZWFkb25seTIpIHtcbiAgICAgIHRyYWNrKHRhcmdldCwgXCJnZXRcIiwga2V5KTtcbiAgICB9XG4gICAgaWYgKGlzU2hhbGxvdzIpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmIChpc1JlZihyZXMpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0SXNBcnJheSAmJiBpc0ludGVnZXJLZXkoa2V5KSA/IHJlcyA6IHJlcy52YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5MiA/IHJlYWRvbmx5KHJlcykgOiByZWFjdGl2ZShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG59XG5jbGFzcyBNdXRhYmxlUmVhY3RpdmVIYW5kbGVyIGV4dGVuZHMgQmFzZVJlYWN0aXZlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGlzU2hhbGxvdzIgPSBmYWxzZSkge1xuICAgIHN1cGVyKGZhbHNlLCBpc1NoYWxsb3cyKTtcbiAgfVxuICBzZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikge1xuICAgIGxldCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGlmICghdGhpcy5faXNTaGFsbG93KSB7XG4gICAgICBjb25zdCBpc09sZFZhbHVlUmVhZG9ubHkgPSBpc1JlYWRvbmx5KG9sZFZhbHVlKTtcbiAgICAgIGlmICghaXNTaGFsbG93KHZhbHVlKSAmJiAhaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUgPSB0b1JhdyhvbGRWYWx1ZSk7XG4gICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGlzT2xkVmFsdWVSZWFkb25seSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhhZEtleSA9IGlzQXJyYXkodGFyZ2V0KSAmJiBpc0ludGVnZXJLZXkoa2V5KSA/IE51bWJlcihrZXkpIDwgdGFyZ2V0Lmxlbmd0aCA6IGhhc093bih0YXJnZXQsIGtleSk7XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgaWYgKHRhcmdldCA9PT0gdG9SYXcocmVjZWl2ZXIpKSB7XG4gICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwga2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gICAgY29uc3QgaGFkS2V5ID0gaGFzT3duKHRhcmdldCwga2V5KTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xuICAgIGlmIChyZXN1bHQgJiYgaGFkS2V5KSB7XG4gICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSk7XG4gICAgaWYgKCFpc1N5bWJvbChrZXkpIHx8ICFidWlsdEluU3ltYm9scy5oYXMoa2V5KSkge1xuICAgICAgdHJhY2sodGFyZ2V0LCBcImhhc1wiLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIG93bktleXModGFyZ2V0KSB7XG4gICAgdHJhY2soXG4gICAgICB0YXJnZXQsXG4gICAgICBcIml0ZXJhdGVcIixcbiAgICAgIGlzQXJyYXkodGFyZ2V0KSA/IFwibGVuZ3RoXCIgOiBJVEVSQVRFX0tFWVxuICAgICk7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICB9XG59XG5jbGFzcyBSZWFkb25seVJlYWN0aXZlSGFuZGxlciBleHRlbmRzIEJhc2VSZWFjdGl2ZUhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihpc1NoYWxsb3cyID0gZmFsc2UpIHtcbiAgICBzdXBlcih0cnVlLCBpc1NoYWxsb3cyKTtcbiAgfVxuICBzZXQodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgICB0YXJnZXRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBEZWxldGUgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY29uc3QgbXV0YWJsZUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNdXRhYmxlUmVhY3RpdmVIYW5kbGVyKCk7XG5jb25zdCByZWFkb25seUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBSZWFkb25seVJlYWN0aXZlSGFuZGxlcigpO1xuY29uc3Qgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE11dGFibGVSZWFjdGl2ZUhhbmRsZXIodHJ1ZSk7XG5jb25zdCBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVhZG9ubHlSZWFjdGl2ZUhhbmRsZXIodHJ1ZSk7XG5cbmNvbnN0IHRvU2hhbGxvdyA9ICh2YWx1ZSkgPT4gdmFsdWU7XG5jb25zdCBnZXRQcm90byA9ICh2KSA9PiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHYpO1xuZnVuY3Rpb24gZ2V0KHRhcmdldCwga2V5LCBpc1JlYWRvbmx5MiA9IGZhbHNlLCBpc1NoYWxsb3cyID0gZmFsc2UpIHtcbiAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiXTtcbiAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgaWYgKCFpc1JlYWRvbmx5Mikge1xuICAgIGlmIChoYXNDaGFuZ2VkKGtleSwgcmF3S2V5KSkge1xuICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgIH1cbiAgICB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIsIHJhd0tleSk7XG4gIH1cbiAgY29uc3QgeyBoYXM6IGhhczIgfSA9IGdldFByb3RvKHJhd1RhcmdldCk7XG4gIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cyID8gdG9TaGFsbG93IDogaXNSZWFkb25seTIgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgaWYgKGhhczIuY2FsbChyYXdUYXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KGtleSkpO1xuICB9IGVsc2UgaWYgKGhhczIuY2FsbChyYXdUYXJnZXQsIHJhd0tleSkpIHtcbiAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KHJhd0tleSkpO1xuICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gcmF3VGFyZ2V0KSB7XG4gICAgdGFyZ2V0LmdldChrZXkpO1xuICB9XG59XG5mdW5jdGlvbiBoYXMoa2V5LCBpc1JlYWRvbmx5MiA9IGZhbHNlKSB7XG4gIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCJdO1xuICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICBpZiAoIWlzUmVhZG9ubHkyKSB7XG4gICAgaWYgKGhhc0NoYW5nZWQoa2V5LCByYXdLZXkpKSB7XG4gICAgICB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIGtleSk7XG4gICAgfVxuICAgIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiwgcmF3S2V5KTtcbiAgfVxuICByZXR1cm4ga2V5ID09PSByYXdLZXkgPyB0YXJnZXQuaGFzKGtleSkgOiB0YXJnZXQuaGFzKGtleSkgfHwgdGFyZ2V0LmhhcyhyYXdLZXkpO1xufVxuZnVuY3Rpb24gc2l6ZSh0YXJnZXQsIGlzUmVhZG9ubHkyID0gZmFsc2UpIHtcbiAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiXTtcbiAgIWlzUmVhZG9ubHkyICYmIHRyYWNrKHRvUmF3KHRhcmdldCksIFwiaXRlcmF0ZVwiLCBJVEVSQVRFX0tFWSk7XG4gIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIFwic2l6ZVwiLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gYWRkKHZhbHVlLCBfaXNTaGFsbG93ID0gZmFsc2UpIHtcbiAgaWYgKCFfaXNTaGFsbG93ICYmICFpc1NoYWxsb3codmFsdWUpICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICBjb25zdCBwcm90byA9IGdldFByb3RvKHRhcmdldCk7XG4gIGNvbnN0IGhhZEtleSA9IHByb3RvLmhhcy5jYWxsKHRhcmdldCwgdmFsdWUpO1xuICBpZiAoIWhhZEtleSkge1xuICAgIHRhcmdldC5hZGQodmFsdWUpO1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCB2YWx1ZSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUsIF9pc1NoYWxsb3cgPSBmYWxzZSkge1xuICBpZiAoIV9pc1NoYWxsb3cgJiYgIWlzU2hhbGxvdyh2YWx1ZSkgJiYgIWlzUmVhZG9ubHkodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gIGNvbnN0IHsgaGFzOiBoYXMyLCBnZXQ6IGdldDIgfSA9IGdldFByb3RvKHRhcmdldCk7XG4gIGxldCBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICBpZiAoIWhhZEtleSkge1xuICAgIGtleSA9IHRvUmF3KGtleSk7XG4gICAgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMyLCBrZXkpO1xuICB9XG4gIGNvbnN0IG9sZFZhbHVlID0gZ2V0Mi5jYWxsKHRhcmdldCwga2V5KTtcbiAgdGFyZ2V0LnNldChrZXksIHZhbHVlKTtcbiAgaWYgKCFoYWRLZXkpIHtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwga2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIsIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIGRlbGV0ZUVudHJ5KGtleSkge1xuICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgY29uc3QgeyBoYXM6IGhhczIsIGdldDogZ2V0MiB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgbGV0IGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XG4gIGlmICghaGFkS2V5KSB7XG4gICAga2V5ID0gdG9SYXcoa2V5KTtcbiAgICBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhczIsIGtleSk7XG4gIH1cbiAgY29uc3Qgb2xkVmFsdWUgPSBnZXQyID8gZ2V0Mi5jYWxsKHRhcmdldCwga2V5KSA6IHZvaWQgMDtcbiAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmRlbGV0ZShrZXkpO1xuICBpZiAoaGFkS2V5KSB7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIsIGtleSwgdm9pZCAwLCBvbGRWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgY29uc3QgaGFkSXRlbXMgPSB0YXJnZXQuc2l6ZSAhPT0gMDtcbiAgY29uc3Qgb2xkVGFyZ2V0ID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGlzTWFwKHRhcmdldCkgPyBuZXcgTWFwKHRhcmdldCkgOiBuZXcgU2V0KHRhcmdldCkgOiB2b2lkIDA7XG4gIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5jbGVhcigpO1xuICBpZiAoaGFkSXRlbXMpIHtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJjbGVhclwiLCB2b2lkIDAsIHZvaWQgMCwgb2xkVGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlRm9yRWFjaChpc1JlYWRvbmx5MiwgaXNTaGFsbG93Mikge1xuICByZXR1cm4gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGNvbnN0IG9ic2VydmVkID0gdGhpcztcbiAgICBjb25zdCB0YXJnZXQgPSBvYnNlcnZlZFtcIl9fdl9yYXdcIl07XG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93MiA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkyID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgIWlzUmVhZG9ubHkyICYmIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIsIElURVJBVEVfS0VZKTtcbiAgICByZXR1cm4gdGFyZ2V0LmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHdyYXAodmFsdWUpLCB3cmFwKGtleSksIG9ic2VydmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgaXNSZWFkb25seTIsIGlzU2hhbGxvdzIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgIGNvbnN0IHRhcmdldElzTWFwID0gaXNNYXAocmF3VGFyZ2V0KTtcbiAgICBjb25zdCBpc1BhaXIgPSBtZXRob2QgPT09IFwiZW50cmllc1wiIHx8IG1ldGhvZCA9PT0gU3ltYm9sLml0ZXJhdG9yICYmIHRhcmdldElzTWFwO1xuICAgIGNvbnN0IGlzS2V5T25seSA9IG1ldGhvZCA9PT0gXCJrZXlzXCIgJiYgdGFyZ2V0SXNNYXA7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRhcmdldFttZXRob2RdKC4uLmFyZ3MpO1xuICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cyID8gdG9TaGFsbG93IDogaXNSZWFkb25seTIgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAhaXNSZWFkb25seTIgJiYgdHJhY2soXG4gICAgICByYXdUYXJnZXQsXG4gICAgICBcIml0ZXJhdGVcIixcbiAgICAgIGlzS2V5T25seSA/IE1BUF9LRVlfSVRFUkFURV9LRVkgOiBJVEVSQVRFX0tFWVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGl0ZXJhdG9yIHByb3RvY29sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIGRvbmUgPyB7IHZhbHVlLCBkb25lIH0gOiB7XG4gICAgICAgICAgdmFsdWU6IGlzUGFpciA/IFt3cmFwKHZhbHVlWzBdKSwgd3JhcCh2YWx1ZVsxXSldIDogd3JhcCh2YWx1ZSksXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIC8vIGl0ZXJhYmxlIHByb3RvY29sXG4gICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWRvbmx5TWV0aG9kKHR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgY29uc3Qga2V5ID0gYXJnc1swXSA/IGBvbiBrZXkgXCIke2FyZ3NbMF19XCIgYCA6IGBgO1xuICAgICAgd2FybihcbiAgICAgICAgYCR7Y2FwaXRhbGl6ZSh0eXBlKX0gb3BlcmF0aW9uICR7a2V5fWZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsXG4gICAgICAgIHRvUmF3KHRoaXMpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZSA9PT0gXCJkZWxldGVcIiA/IGZhbHNlIDogdHlwZSA9PT0gXCJjbGVhclwiID8gdm9pZCAwIDogdGhpcztcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoKSB7XG4gIGNvbnN0IG11dGFibGVJbnN0cnVtZW50YXRpb25zMiA9IHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSk7XG4gICAgfSxcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBzaXplKHRoaXMpO1xuICAgIH0sXG4gICAgaGFzLFxuICAgIGFkZCxcbiAgICBzZXQsXG4gICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcbiAgICBjbGVhcixcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCBmYWxzZSlcbiAgfTtcbiAgY29uc3Qgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMyID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywga2V5LCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBzaXplKHRoaXMpO1xuICAgIH0sXG4gICAgaGFzLFxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGFkZC5jYWxsKHRoaXMsIHZhbHVlLCB0cnVlKTtcbiAgICB9LFxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gc2V0LmNhbGwodGhpcywga2V5LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxuICAgIGNsZWFyLFxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIHRydWUpXG4gIH07XG4gIGNvbnN0IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczIgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUpO1xuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIGhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xuICAgIH0sXG4gICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiKSxcbiAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIpLFxuICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiksXG4gICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiksXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCBmYWxzZSlcbiAgfTtcbiAgY29uc3Qgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczIgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUsIHRydWUpO1xuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIGhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xuICAgIH0sXG4gICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiKSxcbiAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIpLFxuICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiksXG4gICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiksXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCB0cnVlKVxuICB9O1xuICBjb25zdCBpdGVyYXRvck1ldGhvZHMgPSBbXG4gICAgXCJrZXlzXCIsXG4gICAgXCJ2YWx1ZXNcIixcbiAgICBcImVudHJpZXNcIixcbiAgICBTeW1ib2wuaXRlcmF0b3JcbiAgXTtcbiAgaXRlcmF0b3JNZXRob2RzLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICAgIG11dGFibGVJbnN0cnVtZW50YXRpb25zMlttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xuICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczJbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgdHJ1ZSwgZmFsc2UpO1xuICAgIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zMlttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgdHJ1ZSk7XG4gICAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczJbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKFxuICAgICAgbWV0aG9kLFxuICAgICAgdHJ1ZSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9KTtcbiAgcmV0dXJuIFtcbiAgICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9uczIsXG4gICAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zMixcbiAgICBzaGFsbG93SW5zdHJ1bWVudGF0aW9uczIsXG4gICAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczJcbiAgXTtcbn1cbmNvbnN0IFtcbiAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMsXG4gIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyxcbiAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMsXG4gIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNcbl0gPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9ucygpO1xuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGlzUmVhZG9ubHkyLCBzaGFsbG93KSB7XG4gIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSBzaGFsbG93ID8gaXNSZWFkb25seTIgPyBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zIDogc2hhbGxvd0luc3RydW1lbnRhdGlvbnMgOiBpc1JlYWRvbmx5MiA/IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA6IG11dGFibGVJbnN0cnVtZW50YXRpb25zO1xuICByZXR1cm4gKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4ge1xuICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIikge1xuICAgICAgcmV0dXJuICFpc1JlYWRvbmx5MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gUmVmbGVjdC5nZXQoXG4gICAgICBoYXNPd24oaW5zdHJ1bWVudGF0aW9ucywga2V5KSAmJiBrZXkgaW4gdGFyZ2V0ID8gaW5zdHJ1bWVudGF0aW9ucyA6IHRhcmdldCxcbiAgICAgIGtleSxcbiAgICAgIHJlY2VpdmVyXG4gICAgKTtcbiAgfTtcbn1cbmNvbnN0IG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgZmFsc2UpXG59O1xuY29uc3Qgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCB0cnVlKVxufTtcbmNvbnN0IHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgZmFsc2UpXG59O1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgdHJ1ZSlcbn07XG5mdW5jdGlvbiBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhczIsIGtleSkge1xuICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICBpZiAocmF3S2V5ICE9PSBrZXkgJiYgaGFzMi5jYWxsKHRhcmdldCwgcmF3S2V5KSkge1xuICAgIGNvbnN0IHR5cGUgPSB0b1Jhd1R5cGUodGFyZ2V0KTtcbiAgICB3YXJuKFxuICAgICAgYFJlYWN0aXZlICR7dHlwZX0gY29udGFpbnMgYm90aCB0aGUgcmF3IGFuZCByZWFjdGl2ZSB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBvYmplY3Qke3R5cGUgPT09IGBNYXBgID8gYCBhcyBrZXlzYCA6IGBgfSwgd2hpY2ggY2FuIGxlYWQgdG8gaW5jb25zaXN0ZW5jaWVzLiBBdm9pZCBkaWZmZXJlbnRpYXRpbmcgYmV0d2VlbiB0aGUgcmF3IGFuZCByZWFjdGl2ZSB2ZXJzaW9ucyBvZiBhbiBvYmplY3QgYW5kIG9ubHkgdXNlIHRoZSByZWFjdGl2ZSB2ZXJzaW9uIGlmIHBvc3NpYmxlLmBcbiAgICApO1xuICB9XG59XG5cbmNvbnN0IHJlYWN0aXZlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBzaGFsbG93UmVhY3RpdmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlYWRvbmx5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBzaGFsbG93UmVhZG9ubHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHRhcmdldFR5cGVNYXAocmF3VHlwZSkge1xuICBzd2l0Y2ggKHJhd1R5cGUpIHtcbiAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICByZXR1cm4gMSAvKiBDT01NT04gKi87XG4gICAgY2FzZSBcIk1hcFwiOlxuICAgIGNhc2UgXCJTZXRcIjpcbiAgICBjYXNlIFwiV2Vha01hcFwiOlxuICAgIGNhc2UgXCJXZWFrU2V0XCI6XG4gICAgICByZXR1cm4gMiAvKiBDT0xMRUNUSU9OICovO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMCAvKiBJTlZBTElEICovO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRUeXBlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZVtcIl9fdl9za2lwXCJdIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSA/IDAgLyogSU5WQUxJRCAqLyA6IHRhcmdldFR5cGVNYXAodG9SYXdUeXBlKHZhbHVlKSk7XG59XG5mdW5jdGlvbiByZWFjdGl2ZSh0YXJnZXQpIHtcbiAgaWYgKGlzUmVhZG9ubHkodGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICBmYWxzZSxcbiAgICBtdXRhYmxlSGFuZGxlcnMsXG4gICAgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyxcbiAgICByZWFjdGl2ZU1hcFxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlYWN0aXZlKHRhcmdldCkge1xuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIGZhbHNlLFxuICAgIHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzLFxuICAgIHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgc2hhbGxvd1JlYWN0aXZlTWFwXG4gICk7XG59XG5mdW5jdGlvbiByZWFkb25seSh0YXJnZXQpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICB0cnVlLFxuICAgIHJlYWRvbmx5SGFuZGxlcnMsXG4gICAgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgcmVhZG9ubHlNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWFkb25seSh0YXJnZXQpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICB0cnVlLFxuICAgIHNoYWxsb3dSZWFkb25seUhhbmRsZXJzLFxuICAgIHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyxcbiAgICBzaGFsbG93UmVhZG9ubHlNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgaXNSZWFkb25seTIsIGJhc2VIYW5kbGVycywgY29sbGVjdGlvbkhhbmRsZXJzLCBwcm94eU1hcCkge1xuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYHZhbHVlIGNhbm5vdCBiZSBtYWRlICR7aXNSZWFkb25seTIgPyBcInJlYWRvbmx5XCIgOiBcInJlYWN0aXZlXCJ9OiAke1N0cmluZyhcbiAgICAgICAgICB0YXJnZXRcbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmICh0YXJnZXRbXCJfX3ZfcmF3XCJdICYmICEoaXNSZWFkb25seTIgJiYgdGFyZ2V0W1wiX192X2lzUmVhY3RpdmVcIl0pKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBjb25zdCBleGlzdGluZ1Byb3h5ID0gcHJveHlNYXAuZ2V0KHRhcmdldCk7XG4gIGlmIChleGlzdGluZ1Byb3h5KSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nUHJveHk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0VHlwZSA9IGdldFRhcmdldFR5cGUodGFyZ2V0KTtcbiAgaWYgKHRhcmdldFR5cGUgPT09IDAgLyogSU5WQUxJRCAqLykge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoXG4gICAgdGFyZ2V0LFxuICAgIHRhcmdldFR5cGUgPT09IDIgLyogQ09MTEVDVElPTiAqLyA/IGNvbGxlY3Rpb25IYW5kbGVycyA6IGJhc2VIYW5kbGVyc1xuICApO1xuICBwcm94eU1hcC5zZXQodGFyZ2V0LCBwcm94eSk7XG4gIHJldHVybiBwcm94eTtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RpdmUodmFsdWUpIHtcbiAgaWYgKGlzUmVhZG9ubHkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWVbXCJfX3ZfcmF3XCJdKTtcbiAgfVxuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFjdGl2ZVwiXSk7XG59XG5mdW5jdGlvbiBpc1JlYWRvbmx5KHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWRvbmx5XCJdKTtcbn1cbmZ1bmN0aW9uIGlzU2hhbGxvdyh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNTaGFsbG93XCJdKTtcbn1cbmZ1bmN0aW9uIGlzUHJveHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gISF2YWx1ZVtcIl9fdl9yYXdcIl0gOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHRvUmF3KG9ic2VydmVkKSB7XG4gIGNvbnN0IHJhdyA9IG9ic2VydmVkICYmIG9ic2VydmVkW1wiX192X3Jhd1wiXTtcbiAgcmV0dXJuIHJhdyA/IHRvUmF3KHJhdykgOiBvYnNlcnZlZDtcbn1cbmZ1bmN0aW9uIG1hcmtSYXcodmFsdWUpIHtcbiAgaWYgKE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpKSB7XG4gICAgZGVmKHZhbHVlLCBcIl9fdl9za2lwXCIsIHRydWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IHRvUmVhY3RpdmUgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWN0aXZlKHZhbHVlKSA6IHZhbHVlO1xuY29uc3QgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhZG9ubHkodmFsdWUpIDogdmFsdWU7XG5cbmZ1bmN0aW9uIGlzUmVmKHIpIHtcbiAgcmV0dXJuIHIgPyByW1wiX192X2lzUmVmXCJdID09PSB0cnVlIDogZmFsc2U7XG59XG5mdW5jdGlvbiByZWYodmFsdWUpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgZmFsc2UpO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlZih2YWx1ZSkge1xuICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlZihyYXdWYWx1ZSwgc2hhbGxvdykge1xuICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XG4gICAgcmV0dXJuIHJhd1ZhbHVlO1xuICB9XG4gIHJldHVybiBuZXcgUmVmSW1wbChyYXdWYWx1ZSwgc2hhbGxvdyk7XG59XG5jbGFzcyBSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIGlzU2hhbGxvdzIpIHtcbiAgICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcbiAgICB0aGlzW1wiX192X2lzU2hhbGxvd1wiXSA9IGZhbHNlO1xuICAgIHRoaXMuX3Jhd1ZhbHVlID0gaXNTaGFsbG93MiA/IHZhbHVlIDogdG9SYXcodmFsdWUpO1xuICAgIHRoaXMuX3ZhbHVlID0gaXNTaGFsbG93MiA/IHZhbHVlIDogdG9SZWFjdGl2ZSh2YWx1ZSk7XG4gICAgdGhpc1tcIl9fdl9pc1NoYWxsb3dcIl0gPSBpc1NoYWxsb3cyO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdGhpcy5kZXAudHJhY2soe1xuICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiZ2V0XCIsXG4gICAgICAgIGtleTogXCJ2YWx1ZVwiXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXAudHJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fcmF3VmFsdWU7XG4gICAgY29uc3QgdXNlRGlyZWN0VmFsdWUgPSB0aGlzW1wiX192X2lzU2hhbGxvd1wiXSB8fCBpc1NoYWxsb3cobmV3VmFsdWUpIHx8IGlzUmVhZG9ubHkobmV3VmFsdWUpO1xuICAgIG5ld1ZhbHVlID0gdXNlRGlyZWN0VmFsdWUgPyBuZXdWYWx1ZSA6IHRvUmF3KG5ld1ZhbHVlKTtcbiAgICBpZiAoaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICB0aGlzLl9yYXdWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgdGhpcy5fdmFsdWUgPSB1c2VEaXJlY3RWYWx1ZSA/IG5ld1ZhbHVlIDogdG9SZWFjdGl2ZShuZXdWYWx1ZSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB0aGlzLmRlcC50cmlnZ2VyKHtcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICBrZXk6IFwidmFsdWVcIixcbiAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICBvbGRWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVwLnRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJSZWYocmVmMikge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHJlZjIuZGVwLnRyaWdnZXIoe1xuICAgICAgdGFyZ2V0OiByZWYyLFxuICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgICAgbmV3VmFsdWU6IHJlZjIuX3ZhbHVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVmMi5kZXAudHJpZ2dlcigpO1xuICB9XG59XG5mdW5jdGlvbiB1bnJlZihyZWYyKSB7XG4gIHJldHVybiBpc1JlZihyZWYyKSA/IHJlZjIudmFsdWUgOiByZWYyO1xufVxuZnVuY3Rpb24gdG9WYWx1ZShzb3VyY2UpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oc291cmNlKSA/IHNvdXJjZSgpIDogdW5yZWYoc291cmNlKTtcbn1cbmNvbnN0IHNoYWxsb3dVbndyYXBIYW5kbGVycyA9IHtcbiAgZ2V0OiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB1bnJlZihSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKSxcbiAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikgPT4ge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBwcm94eVJlZnMob2JqZWN0V2l0aFJlZnMpIHtcbiAgcmV0dXJuIGlzUmVhY3RpdmUob2JqZWN0V2l0aFJlZnMpID8gb2JqZWN0V2l0aFJlZnMgOiBuZXcgUHJveHkob2JqZWN0V2l0aFJlZnMsIHNoYWxsb3dVbndyYXBIYW5kbGVycyk7XG59XG5jbGFzcyBDdXN0b21SZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoZmFjdG9yeSkge1xuICAgIHRoaXNbXCJfX3ZfaXNSZWZcIl0gPSB0cnVlO1xuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xuICAgIGNvbnN0IGRlcCA9IHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IGZhY3RvcnkoZGVwLnRyYWNrLmJpbmQoZGVwKSwgZGVwLnRyaWdnZXIuYmluZChkZXApKTtcbiAgICB0aGlzLl9nZXQgPSBnZXQ7XG4gICAgdGhpcy5fc2V0ID0gc2V0O1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB0aGlzLl9nZXQoKTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgdGhpcy5fc2V0KG5ld1ZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGN1c3RvbVJlZihmYWN0b3J5KSB7XG4gIHJldHVybiBuZXcgQ3VzdG9tUmVmSW1wbChmYWN0b3J5KTtcbn1cbmZ1bmN0aW9uIHRvUmVmcyhvYmplY3QpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzUHJveHkob2JqZWN0KSkge1xuICAgIHdhcm4oYHRvUmVmcygpIGV4cGVjdHMgYSByZWFjdGl2ZSBvYmplY3QgYnV0IHJlY2VpdmVkIGEgcGxhaW4gb25lLmApO1xuICB9XG4gIGNvbnN0IHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICByZXRba2V5XSA9IHByb3BlcnR5VG9SZWYob2JqZWN0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5jbGFzcyBPYmplY3RSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoX29iamVjdCwgX2tleSwgX2RlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XG4gICAgdGhpcy5fa2V5ID0gX2tleTtcbiAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBfZGVmYXVsdFZhbHVlO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWZcIl0gPSB0cnVlO1xuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XTtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB2YWwgPT09IHZvaWQgMCA/IHRoaXMuX2RlZmF1bHRWYWx1ZSA6IHZhbDtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgdGhpcy5fb2JqZWN0W3RoaXMuX2tleV0gPSBuZXdWYWw7XG4gIH1cbiAgZ2V0IGRlcCgpIHtcbiAgICByZXR1cm4gZ2V0RGVwRnJvbVJlYWN0aXZlKHRvUmF3KHRoaXMuX29iamVjdCksIHRoaXMuX2tleSk7XG4gIH1cbn1cbmNsYXNzIEdldHRlclJlZkltcGwge1xuICBjb25zdHJ1Y3RvcihfZ2V0dGVyKSB7XG4gICAgdGhpcy5fZ2V0dGVyID0gX2dldHRlcjtcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcbiAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIl0gPSB0cnVlO1xuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB0aGlzLl9nZXR0ZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gdG9SZWYoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAoaXNSZWYoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgcmV0dXJuIG5ldyBHZXR0ZXJSZWZJbXBsKHNvdXJjZSk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qoc291cmNlKSAmJiBhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBwcm9wZXJ0eVRvUmVmKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZWYoc291cmNlKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvcGVydHlUb1JlZihzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIGNvbnN0IHZhbCA9IHNvdXJjZVtrZXldO1xuICByZXR1cm4gaXNSZWYodmFsKSA/IHZhbCA6IG5ldyBPYmplY3RSZWZJbXBsKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xufVxuXG5jbGFzcyBDb21wdXRlZFJlZkltcGwge1xuICBjb25zdHJ1Y3Rvcihmbiwgc2V0dGVyLCBpc1NTUikge1xuICAgIHRoaXMuZm4gPSBmbjtcbiAgICB0aGlzLnNldHRlciA9IHNldHRlcjtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl92YWx1ZSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlcCA9IG5ldyBEZXAodGhpcyk7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIC8vIFRPRE8gaXNvbGF0ZWREZWNsYXJhdGlvbnMgXCJfX3ZfaXNSZWFkb25seVwiXG4gICAgLy8gQSBjb21wdXRlZCBpcyBhbHNvIGEgc3Vic2NyaWJlciB0aGF0IHRyYWNrcyBvdGhlciBkZXBzXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5kZXBzID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwc1RhaWwgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5mbGFncyA9IDE2O1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZ2xvYmFsVmVyc2lvbiA9IGdsb2JhbFZlcnNpb24gLSAxO1xuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAgdGhpcy5lZmZlY3QgPSB0aGlzO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWFkb25seVwiXSA9ICFzZXR0ZXI7XG4gICAgdGhpcy5pc1NTUiA9IGlzU1NSO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG5vdGlmeSgpIHtcbiAgICBpZiAoYWN0aXZlU3ViICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLmZsYWdzIHw9IDE2O1xuICAgICAgdGhpcy5kZXAubm90aWZ5KCk7XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSA7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIGNvbnN0IGxpbmsgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gdGhpcy5kZXAudHJhY2soe1xuICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgdHlwZTogXCJnZXRcIixcbiAgICAgIGtleTogXCJ2YWx1ZVwiXG4gICAgfSkgOiB0aGlzLmRlcC50cmFjaygpO1xuICAgIHJlZnJlc2hDb21wdXRlZCh0aGlzKTtcbiAgICBpZiAobGluaykge1xuICAgICAgbGluay52ZXJzaW9uID0gdGhpcy5kZXAudmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgIGlmICh0aGlzLnNldHRlcikge1xuICAgICAgdGhpcy5zZXR0ZXIobmV3VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcIldyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHZhbHVlIGlzIHJlYWRvbmx5XCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMsIGlzU1NSID0gZmFsc2UpIHtcbiAgbGV0IGdldHRlcjtcbiAgbGV0IHNldHRlcjtcbiAgaWYgKGlzRnVuY3Rpb24oZ2V0dGVyT3JPcHRpb25zKSkge1xuICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucztcbiAgfSBlbHNlIHtcbiAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuZ2V0O1xuICAgIHNldHRlciA9IGdldHRlck9yT3B0aW9ucy5zZXQ7XG4gIH1cbiAgY29uc3QgY1JlZiA9IG5ldyBDb21wdXRlZFJlZkltcGwoZ2V0dGVyLCBzZXR0ZXIsIGlzU1NSKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgZGVidWdPcHRpb25zICYmICFpc1NTUikge1xuICAgIGNSZWYub25UcmFjayA9IGRlYnVnT3B0aW9ucy5vblRyYWNrO1xuICAgIGNSZWYub25UcmlnZ2VyID0gZGVidWdPcHRpb25zLm9uVHJpZ2dlcjtcbiAgfVxuICByZXR1cm4gY1JlZjtcbn1cblxuY29uc3QgVHJhY2tPcFR5cGVzID0ge1xuICBcIkdFVFwiOiBcImdldFwiLFxuICBcIkhBU1wiOiBcImhhc1wiLFxuICBcIklURVJBVEVcIjogXCJpdGVyYXRlXCJcbn07XG5jb25zdCBUcmlnZ2VyT3BUeXBlcyA9IHtcbiAgXCJTRVRcIjogXCJzZXRcIixcbiAgXCJBRERcIjogXCJhZGRcIixcbiAgXCJERUxFVEVcIjogXCJkZWxldGVcIixcbiAgXCJDTEVBUlwiOiBcImNsZWFyXCJcbn07XG5jb25zdCBSZWFjdGl2ZUZsYWdzID0ge1xuICBcIlNLSVBcIjogXCJfX3Zfc2tpcFwiLFxuICBcIklTX1JFQUNUSVZFXCI6IFwiX192X2lzUmVhY3RpdmVcIixcbiAgXCJJU19SRUFET05MWVwiOiBcIl9fdl9pc1JlYWRvbmx5XCIsXG4gIFwiSVNfU0hBTExPV1wiOiBcIl9fdl9pc1NoYWxsb3dcIixcbiAgXCJSQVdcIjogXCJfX3ZfcmF3XCIsXG4gIFwiSVNfUkVGXCI6IFwiX192X2lzUmVmXCJcbn07XG5cbmNvbnN0IFdhdGNoRXJyb3JDb2RlcyA9IHtcbiAgXCJXQVRDSF9HRVRURVJcIjogMixcbiAgXCIyXCI6IFwiV0FUQ0hfR0VUVEVSXCIsXG4gIFwiV0FUQ0hfQ0FMTEJBQ0tcIjogMyxcbiAgXCIzXCI6IFwiV0FUQ0hfQ0FMTEJBQ0tcIixcbiAgXCJXQVRDSF9DTEVBTlVQXCI6IDQsXG4gIFwiNFwiOiBcIldBVENIX0NMRUFOVVBcIlxufTtcbmNvbnN0IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA9IHt9O1xuY29uc3QgY2xlYW51cE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xubGV0IGFjdGl2ZVdhdGNoZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBnZXRDdXJyZW50V2F0Y2hlcigpIHtcbiAgcmV0dXJuIGFjdGl2ZVdhdGNoZXI7XG59XG5mdW5jdGlvbiBvbldhdGNoZXJDbGVhbnVwKGNsZWFudXBGbiwgZmFpbFNpbGVudGx5ID0gZmFsc2UsIG93bmVyID0gYWN0aXZlV2F0Y2hlcikge1xuICBpZiAob3duZXIpIHtcbiAgICBsZXQgY2xlYW51cHMgPSBjbGVhbnVwTWFwLmdldChvd25lcik7XG4gICAgaWYgKCFjbGVhbnVwcykgY2xlYW51cE1hcC5zZXQob3duZXIsIGNsZWFudXBzID0gW10pO1xuICAgIGNsZWFudXBzLnB1c2goY2xlYW51cEZuKTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFmYWlsU2lsZW50bHkpIHtcbiAgICB3YXJuKFxuICAgICAgYG9uV2F0Y2hlckNsZWFudXAoKSB3YXMgY2FsbGVkIHdoZW4gdGhlcmUgd2FzIG5vIGFjdGl2ZSB3YXRjaGVyIHRvIGFzc29jaWF0ZSB3aXRoLmBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zID0gRU1QVFlfT0JKKSB7XG4gIGNvbnN0IHsgaW1tZWRpYXRlLCBkZWVwLCBvbmNlLCBzY2hlZHVsZXIsIGF1Z21lbnRKb2IsIGNhbGwgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHdhcm5JbnZhbGlkU291cmNlID0gKHMpID0+IHtcbiAgICAob3B0aW9ucy5vbldhcm4gfHwgd2FybikoXG4gICAgICBgSW52YWxpZCB3YXRjaCBzb3VyY2U6IGAsXG4gICAgICBzLFxuICAgICAgYEEgd2F0Y2ggc291cmNlIGNhbiBvbmx5IGJlIGEgZ2V0dGVyL2VmZmVjdCBmdW5jdGlvbiwgYSByZWYsIGEgcmVhY3RpdmUgb2JqZWN0LCBvciBhbiBhcnJheSBvZiB0aGVzZSB0eXBlcy5gXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgcmVhY3RpdmVHZXR0ZXIgPSAoc291cmNlMikgPT4ge1xuICAgIGlmIChkZWVwKSByZXR1cm4gc291cmNlMjtcbiAgICBpZiAoaXNTaGFsbG93KHNvdXJjZTIpIHx8IGRlZXAgPT09IGZhbHNlIHx8IGRlZXAgPT09IDApXG4gICAgICByZXR1cm4gdHJhdmVyc2Uoc291cmNlMiwgMSk7XG4gICAgcmV0dXJuIHRyYXZlcnNlKHNvdXJjZTIpO1xuICB9O1xuICBsZXQgZWZmZWN0O1xuICBsZXQgZ2V0dGVyO1xuICBsZXQgY2xlYW51cDtcbiAgbGV0IGJvdW5kQ2xlYW51cDtcbiAgbGV0IGZvcmNlVHJpZ2dlciA9IGZhbHNlO1xuICBsZXQgaXNNdWx0aVNvdXJjZSA9IGZhbHNlO1xuICBpZiAoaXNSZWYoc291cmNlKSkge1xuICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS52YWx1ZTtcbiAgICBmb3JjZVRyaWdnZXIgPSBpc1NoYWxsb3coc291cmNlKTtcbiAgfSBlbHNlIGlmIChpc1JlYWN0aXZlKHNvdXJjZSkpIHtcbiAgICBnZXR0ZXIgPSAoKSA9PiByZWFjdGl2ZUdldHRlcihzb3VyY2UpO1xuICAgIGZvcmNlVHJpZ2dlciA9IHRydWU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgaXNNdWx0aVNvdXJjZSA9IHRydWU7XG4gICAgZm9yY2VUcmlnZ2VyID0gc291cmNlLnNvbWUoKHMpID0+IGlzUmVhY3RpdmUocykgfHwgaXNTaGFsbG93KHMpKTtcbiAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UubWFwKChzKSA9PiB7XG4gICAgICBpZiAoaXNSZWYocykpIHtcbiAgICAgICAgcmV0dXJuIHMudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUocykpIHtcbiAgICAgICAgcmV0dXJuIHJlYWN0aXZlR2V0dGVyKHMpO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHMpKSB7XG4gICAgICAgIHJldHVybiBjYWxsID8gY2FsbChzLCAyKSA6IHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybkludmFsaWRTb3VyY2Uocyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBnZXR0ZXIgPSBjYWxsID8gKCkgPT4gY2FsbChzb3VyY2UsIDIpIDogc291cmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZXR0ZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudEVmZmVjdCA9IGFjdGl2ZVdhdGNoZXI7XG4gICAgICAgIGFjdGl2ZVdhdGNoZXIgPSBlZmZlY3Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGwgPyBjYWxsKHNvdXJjZSwgMywgW2JvdW5kQ2xlYW51cF0pIDogc291cmNlKGJvdW5kQ2xlYW51cCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgYWN0aXZlV2F0Y2hlciA9IGN1cnJlbnRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGdldHRlciA9IE5PT1A7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzb3VyY2UpO1xuICB9XG4gIGlmIChjYiAmJiBkZWVwKSB7XG4gICAgY29uc3QgYmFzZUdldHRlciA9IGdldHRlcjtcbiAgICBjb25zdCBkZXB0aCA9IGRlZXAgPT09IHRydWUgPyBJbmZpbml0eSA6IGRlZXA7XG4gICAgZ2V0dGVyID0gKCkgPT4gdHJhdmVyc2UoYmFzZUdldHRlcigpLCBkZXB0aCk7XG4gIH1cbiAgaWYgKG9uY2UpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNvbnN0IF9jYiA9IGNiO1xuICAgICAgY2IgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICBfY2IoLi4uYXJncyk7XG4gICAgICAgIGVmZmVjdC5zdG9wKCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBfZ2V0dGVyID0gZ2V0dGVyO1xuICAgICAgZ2V0dGVyID0gKCkgPT4ge1xuICAgICAgICBfZ2V0dGVyKCk7XG4gICAgICAgIGVmZmVjdC5zdG9wKCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBsZXQgb2xkVmFsdWUgPSBpc011bHRpU291cmNlID8gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpLmZpbGwoSU5JVElBTF9XQVRDSEVSX1ZBTFVFKSA6IElOSVRJQUxfV0FUQ0hFUl9WQUxVRTtcbiAgY29uc3Qgam9iID0gKGltbWVkaWF0ZUZpcnN0UnVuKSA9PiB7XG4gICAgaWYgKCEoZWZmZWN0LmZsYWdzICYgMSkgfHwgIWVmZmVjdC5kaXJ0eSAmJiAhaW1tZWRpYXRlRmlyc3RSdW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNiKSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcbiAgICAgIGlmIChkZWVwIHx8IGZvcmNlVHJpZ2dlciB8fCAoaXNNdWx0aVNvdXJjZSA/IG5ld1ZhbHVlLnNvbWUoKHYsIGkpID0+IGhhc0NoYW5nZWQodiwgb2xkVmFsdWVbaV0pKSA6IGhhc0NoYW5nZWQobmV3VmFsdWUsIG9sZFZhbHVlKSkpIHtcbiAgICAgICAgaWYgKGNsZWFudXApIHtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFdhdGNoZXIgPSBhY3RpdmVXYXRjaGVyO1xuICAgICAgICBhY3RpdmVXYXRjaGVyID0gZWZmZWN0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgICAgICBvbGRWYWx1ZSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFID8gdm9pZCAwIDogaXNNdWx0aVNvdXJjZSAmJiBvbGRWYWx1ZVswXSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFID8gW10gOiBvbGRWYWx1ZSxcbiAgICAgICAgICAgIGJvdW5kQ2xlYW51cFxuICAgICAgICAgIF07XG4gICAgICAgICAgY2FsbCA/IGNhbGwoY2IsIDMsIGFyZ3MpIDogKFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgY2IoLi4uYXJncylcbiAgICAgICAgICApO1xuICAgICAgICAgIG9sZFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgYWN0aXZlV2F0Y2hlciA9IGN1cnJlbnRXYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVmZmVjdC5ydW4oKTtcbiAgICB9XG4gIH07XG4gIGlmIChhdWdtZW50Sm9iKSB7XG4gICAgYXVnbWVudEpvYihqb2IpO1xuICB9XG4gIGVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIpO1xuICBlZmZlY3Quc2NoZWR1bGVyID0gc2NoZWR1bGVyID8gKCkgPT4gc2NoZWR1bGVyKGpvYiwgZmFsc2UpIDogam9iO1xuICBib3VuZENsZWFudXAgPSAoZm4pID0+IG9uV2F0Y2hlckNsZWFudXAoZm4sIGZhbHNlLCBlZmZlY3QpO1xuICBjbGVhbnVwID0gZWZmZWN0Lm9uU3RvcCA9ICgpID0+IHtcbiAgICBjb25zdCBjbGVhbnVwcyA9IGNsZWFudXBNYXAuZ2V0KGVmZmVjdCk7XG4gICAgaWYgKGNsZWFudXBzKSB7XG4gICAgICBpZiAoY2FsbCkge1xuICAgICAgICBjYWxsKGNsZWFudXBzLCA0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgY2xlYW51cDIgb2YgY2xlYW51cHMpIGNsZWFudXAyKCk7XG4gICAgICB9XG4gICAgICBjbGVhbnVwTWFwLmRlbGV0ZShlZmZlY3QpO1xuICAgIH1cbiAgfTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBlZmZlY3Qub25UcmFjayA9IG9wdGlvbnMub25UcmFjaztcbiAgICBlZmZlY3Qub25UcmlnZ2VyID0gb3B0aW9ucy5vblRyaWdnZXI7XG4gIH1cbiAgaWYgKGNiKSB7XG4gICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgam9iKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGRWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2NoZWR1bGVyKSB7XG4gICAgc2NoZWR1bGVyKGpvYi5iaW5kKG51bGwsIHRydWUpLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBlZmZlY3QucnVuKCk7XG4gIH1cbiAgY29uc3Qgc2NvcGUgPSBnZXRDdXJyZW50U2NvcGUoKTtcbiAgY29uc3Qgd2F0Y2hIYW5kbGUgPSAoKSA9PiB7XG4gICAgZWZmZWN0LnN0b3AoKTtcbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgIHJlbW92ZShzY29wZS5lZmZlY3RzLCBlZmZlY3QpO1xuICAgIH1cbiAgfTtcbiAgd2F0Y2hIYW5kbGUucGF1c2UgPSBlZmZlY3QucGF1c2UuYmluZChlZmZlY3QpO1xuICB3YXRjaEhhbmRsZS5yZXN1bWUgPSBlZmZlY3QucmVzdW1lLmJpbmQoZWZmZWN0KTtcbiAgd2F0Y2hIYW5kbGUuc3RvcCA9IHdhdGNoSGFuZGxlO1xuICByZXR1cm4gd2F0Y2hIYW5kbGU7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWx1ZSwgZGVwdGggPSBJbmZpbml0eSwgc2Vlbikge1xuICBpZiAoZGVwdGggPD0gMCB8fCAhaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlW1wiX192X3NraXBcIl0pIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBzZWVuLmFkZCh2YWx1ZSk7XG4gIGRlcHRoLS07XG4gIGlmIChpc1JlZih2YWx1ZSkpIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZS52YWx1ZSwgZGVwdGgsIHNlZW4pO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdHJhdmVyc2UodmFsdWVbaV0sIGRlcHRoLCBzZWVuKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpIHx8IGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goKHYpID0+IHtcbiAgICAgIHRyYXZlcnNlKHYsIGRlcHRoLCBzZWVuKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZVtrZXldLCBkZXB0aCwgc2Vlbik7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgIHRyYXZlcnNlKHZhbHVlW2tleV0sIGRlcHRoLCBzZWVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgeyBBUlJBWV9JVEVSQVRFX0tFWSwgRWZmZWN0RmxhZ3MsIEVmZmVjdFNjb3BlLCBJVEVSQVRFX0tFWSwgTUFQX0tFWV9JVEVSQVRFX0tFWSwgUmVhY3RpdmVFZmZlY3QsIFJlYWN0aXZlRmxhZ3MsIFRyYWNrT3BUeXBlcywgVHJpZ2dlck9wVHlwZXMsIFdhdGNoRXJyb3JDb2RlcywgY29tcHV0ZWQsIGN1c3RvbVJlZiwgZWZmZWN0LCBlZmZlY3RTY29wZSwgZW5hYmxlVHJhY2tpbmcsIGdldEN1cnJlbnRTY29wZSwgZ2V0Q3VycmVudFdhdGNoZXIsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uRWZmZWN0Q2xlYW51cCwgb25TY29wZURpc3Bvc2UsIG9uV2F0Y2hlckNsZWFudXAsIHBhdXNlVHJhY2tpbmcsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWN0aXZlUmVhZEFycmF5LCByZWFkb25seSwgcmVmLCByZXNldFRyYWNraW5nLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkQXJyYXksIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVhY3RpdmUsIHRvUmVhZG9ubHksIHRvUmVmLCB0b1JlZnMsIHRvVmFsdWUsIHRyYWNrLCB0cmF2ZXJzZSwgdHJpZ2dlciwgdHJpZ2dlclJlZiwgdW5yZWYsIHdhdGNoIH07XG4iLCIvKipcbiogQHZ1ZS9zaGFyZWQgdjMuNS4wLWJldGEuM1xuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWFrZU1hcChzdHIsIGV4cGVjdHNMb3dlckNhc2UpIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldChzdHIuc3BsaXQoXCIsXCIpKTtcbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2UgPyAodmFsKSA9PiBzZXQuaGFzKHZhbC50b0xvd2VyQ2FzZSgpKSA6ICh2YWwpID0+IHNldC5oYXModmFsKTtcbn1cblxuY29uc3QgRU1QVFlfT0JKID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IE9iamVjdC5mcmVlemUoe30pIDoge307XG5jb25zdCBFTVBUWV9BUlIgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcbmNvbnN0IE5PT1AgPSAoKSA9PiB7XG59O1xuY29uc3QgTk8gPSAoKSA9PiBmYWxzZTtcbmNvbnN0IGlzT24gPSAoa2V5KSA9PiBrZXkuY2hhckNvZGVBdCgwKSA9PT0gMTExICYmIGtleS5jaGFyQ29kZUF0KDEpID09PSAxMTAgJiYgLy8gdXBwZXJjYXNlIGxldHRlclxuKGtleS5jaGFyQ29kZUF0KDIpID4gMTIyIHx8IGtleS5jaGFyQ29kZUF0KDIpIDwgOTcpO1xuY29uc3QgaXNNb2RlbExpc3RlbmVyID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoXCJvblVwZGF0ZTpcIik7XG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcbiAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcbiAgaWYgKGkgPiAtMSkge1xuICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gIH1cbn07XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgTWFwXVwiO1xuY29uc3QgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFNldF1cIjtcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbmNvbnN0IGlzUmVnRXhwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiO1xuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN5bWJvbFwiO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIjtcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIChpc09iamVjdCh2YWwpIHx8IGlzRnVuY3Rpb24odmFsKSkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xufTtcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufTtcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiYga2V5ICE9PSBcIk5hTlwiICYmIGtleVswXSAhPT0gXCItXCIgJiYgXCJcIiArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XG5jb25zdCBpc1Jlc2VydmVkUHJvcCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICAvLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXG4gIFwiLGtleSxyZWYscmVmX2ZvcixyZWZfa2V5LG9uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCxvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLG9uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWRcIlxuKTtcbmNvbnN0IGlzQnVpbHRJbkRpcmVjdGl2ZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBcImJpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0LG1lbW9cIlxuKTtcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChzdHIpID0+IHtcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgfTtcbn07XG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIik7XG4gIH1cbik7XG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgXCItJDFcIikudG9Mb3dlckNhc2UoKVxuKTtcbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn0pO1xuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4ge1xuICAgIGNvbnN0IHMgPSBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGA7XG4gICAgcmV0dXJuIHM7XG4gIH1cbik7XG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpO1xuY29uc3QgaW52b2tlQXJyYXlGbnMgPSAoZm5zLCAuLi5hcmcpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBmbnNbaV0oLi4uYXJnKTtcbiAgfVxufTtcbmNvbnN0IGRlZiA9IChvYmosIGtleSwgdmFsdWUsIHdyaXRhYmxlID0gZmFsc2UpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlLFxuICAgIHZhbHVlXG4gIH0pO1xufTtcbmNvbnN0IGxvb3NlVG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBpc1N0cmluZyh2YWwpID8gTnVtYmVyKHZhbCkgOiBOYU47XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xubGV0IF9nbG9iYWxUaGlzO1xuY29uc3QgZ2V0R2xvYmFsVGhpcyA9ICgpID0+IHtcbiAgcmV0dXJuIF9nbG9iYWxUaGlzIHx8IChfZ2xvYmFsVGhpcyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pO1xufTtcbmNvbnN0IGlkZW50UkUgPSAvXltfJGEtekEtWlxceEEwLVxcdUZGRkZdW18kYS16QS1aMC05XFx4QTAtXFx1RkZGRl0qJC87XG5mdW5jdGlvbiBnZW5Qcm9wc0FjY2Vzc0V4cChuYW1lKSB7XG4gIHJldHVybiBpZGVudFJFLnRlc3QobmFtZSkgPyBgX19wcm9wcy4ke25hbWV9YCA6IGBfX3Byb3BzWyR7SlNPTi5zdHJpbmdpZnkobmFtZSl9XWA7XG59XG5cbmNvbnN0IFBhdGNoRmxhZ3MgPSB7XG4gIFwiVEVYVFwiOiAxLFxuICBcIjFcIjogXCJURVhUXCIsXG4gIFwiQ0xBU1NcIjogMixcbiAgXCIyXCI6IFwiQ0xBU1NcIixcbiAgXCJTVFlMRVwiOiA0LFxuICBcIjRcIjogXCJTVFlMRVwiLFxuICBcIlBST1BTXCI6IDgsXG4gIFwiOFwiOiBcIlBST1BTXCIsXG4gIFwiRlVMTF9QUk9QU1wiOiAxNixcbiAgXCIxNlwiOiBcIkZVTExfUFJPUFNcIixcbiAgXCJORUVEX0hZRFJBVElPTlwiOiAzMixcbiAgXCIzMlwiOiBcIk5FRURfSFlEUkFUSU9OXCIsXG4gIFwiU1RBQkxFX0ZSQUdNRU5UXCI6IDY0LFxuICBcIjY0XCI6IFwiU1RBQkxFX0ZSQUdNRU5UXCIsXG4gIFwiS0VZRURfRlJBR01FTlRcIjogMTI4LFxuICBcIjEyOFwiOiBcIktFWUVEX0ZSQUdNRU5UXCIsXG4gIFwiVU5LRVlFRF9GUkFHTUVOVFwiOiAyNTYsXG4gIFwiMjU2XCI6IFwiVU5LRVlFRF9GUkFHTUVOVFwiLFxuICBcIk5FRURfUEFUQ0hcIjogNTEyLFxuICBcIjUxMlwiOiBcIk5FRURfUEFUQ0hcIixcbiAgXCJEWU5BTUlDX1NMT1RTXCI6IDEwMjQsXG4gIFwiMTAyNFwiOiBcIkRZTkFNSUNfU0xPVFNcIixcbiAgXCJERVZfUk9PVF9GUkFHTUVOVFwiOiAyMDQ4LFxuICBcIjIwNDhcIjogXCJERVZfUk9PVF9GUkFHTUVOVFwiLFxuICBcIkNBQ0hFRFwiOiAtMSxcbiAgXCItMVwiOiBcIkNBQ0hFRFwiLFxuICBcIkJBSUxcIjogLTIsXG4gIFwiLTJcIjogXCJCQUlMXCJcbn07XG5jb25zdCBQYXRjaEZsYWdOYW1lcyA9IHtcbiAgWzFdOiBgVEVYVGAsXG4gIFsyXTogYENMQVNTYCxcbiAgWzRdOiBgU1RZTEVgLFxuICBbOF06IGBQUk9QU2AsXG4gIFsxNl06IGBGVUxMX1BST1BTYCxcbiAgWzMyXTogYE5FRURfSFlEUkFUSU9OYCxcbiAgWzY0XTogYFNUQUJMRV9GUkFHTUVOVGAsXG4gIFsxMjhdOiBgS0VZRURfRlJBR01FTlRgLFxuICBbMjU2XTogYFVOS0VZRURfRlJBR01FTlRgLFxuICBbNTEyXTogYE5FRURfUEFUQ0hgLFxuICBbMTAyNF06IGBEWU5BTUlDX1NMT1RTYCxcbiAgWzIwNDhdOiBgREVWX1JPT1RfRlJBR01FTlRgLFxuICBbLTFdOiBgSE9JU1RFRGAsXG4gIFstMl06IGBCQUlMYFxufTtcblxuY29uc3QgU2hhcGVGbGFncyA9IHtcbiAgXCJFTEVNRU5UXCI6IDEsXG4gIFwiMVwiOiBcIkVMRU1FTlRcIixcbiAgXCJGVU5DVElPTkFMX0NPTVBPTkVOVFwiOiAyLFxuICBcIjJcIjogXCJGVU5DVElPTkFMX0NPTVBPTkVOVFwiLFxuICBcIlNUQVRFRlVMX0NPTVBPTkVOVFwiOiA0LFxuICBcIjRcIjogXCJTVEFURUZVTF9DT01QT05FTlRcIixcbiAgXCJURVhUX0NISUxEUkVOXCI6IDgsXG4gIFwiOFwiOiBcIlRFWFRfQ0hJTERSRU5cIixcbiAgXCJBUlJBWV9DSElMRFJFTlwiOiAxNixcbiAgXCIxNlwiOiBcIkFSUkFZX0NISUxEUkVOXCIsXG4gIFwiU0xPVFNfQ0hJTERSRU5cIjogMzIsXG4gIFwiMzJcIjogXCJTTE9UU19DSElMRFJFTlwiLFxuICBcIlRFTEVQT1JUXCI6IDY0LFxuICBcIjY0XCI6IFwiVEVMRVBPUlRcIixcbiAgXCJTVVNQRU5TRVwiOiAxMjgsXG4gIFwiMTI4XCI6IFwiU1VTUEVOU0VcIixcbiAgXCJDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkVcIjogMjU2LFxuICBcIjI1NlwiOiBcIkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRVwiLFxuICBcIkNPTVBPTkVOVF9LRVBUX0FMSVZFXCI6IDUxMixcbiAgXCI1MTJcIjogXCJDT01QT05FTlRfS0VQVF9BTElWRVwiLFxuICBcIkNPTVBPTkVOVFwiOiA2LFxuICBcIjZcIjogXCJDT01QT05FTlRcIlxufTtcblxuY29uc3QgU2xvdEZsYWdzID0ge1xuICBcIlNUQUJMRVwiOiAxLFxuICBcIjFcIjogXCJTVEFCTEVcIixcbiAgXCJEWU5BTUlDXCI6IDIsXG4gIFwiMlwiOiBcIkRZTkFNSUNcIixcbiAgXCJGT1JXQVJERURcIjogMyxcbiAgXCIzXCI6IFwiRk9SV0FSREVEXCJcbn07XG5jb25zdCBzbG90RmxhZ3NUZXh0ID0ge1xuICBbMV06IFwiU1RBQkxFXCIsXG4gIFsyXTogXCJEWU5BTUlDXCIsXG4gIFszXTogXCJGT1JXQVJERURcIlxufTtcblxuY29uc3QgR0xPQkFMU19BTExPV0VEID0gXCJJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLHBhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LE1hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQsY29uc29sZSxFcnJvcixTeW1ib2xcIjtcbmNvbnN0IGlzR2xvYmFsbHlBbGxvd2VkID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoR0xPQkFMU19BTExPV0VEKTtcbmNvbnN0IGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCA9IGlzR2xvYmFsbHlBbGxvd2VkO1xuXG5jb25zdCByYW5nZSA9IDI7XG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZShzb3VyY2UsIHN0YXJ0ID0gMCwgZW5kID0gc291cmNlLmxlbmd0aCkge1xuICBzdGFydCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHN0YXJ0LCBzb3VyY2UubGVuZ3RoKSk7XG4gIGVuZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGVuZCwgc291cmNlLmxlbmd0aCkpO1xuICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBcIlwiO1xuICBsZXQgbGluZXMgPSBzb3VyY2Uuc3BsaXQoLyhcXHI/XFxuKS8pO1xuICBjb25zdCBuZXdsaW5lU2VxdWVuY2VzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDEpO1xuICBsaW5lcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAwKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAobmV3bGluZVNlcXVlbmNlc1tpXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2ldLmxlbmd0aCB8fCAwKTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbGluZSA9IGogKyAxO1xuICAgICAgICByZXMucHVzaChcbiAgICAgICAgICBgJHtsaW5lfSR7XCIgXCIucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5ld0xpbmVTZXFMZW5ndGggPSBuZXdsaW5lU2VxdWVuY2VzW2pdICYmIG5ld2xpbmVTZXF1ZW5jZXNbal0ubGVuZ3RoIHx8IDA7XG4gICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSAobGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGgpKTtcbiAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIiBcIi5yZXBlYXQocGFkKSArIFwiXlwiLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpLCAxKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGlzU3RyaW5nKGl0ZW0pID8gcGFyc2VTdHJpbmdTdHlsZShpdGVtKSA6IG5vcm1hbGl6ZVN0eWxlKGl0ZW0pO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsaXplZCkge1xuICAgICAgICAgIHJlc1trZXldID0gbm9ybWFsaXplZFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuY29uc3QgbGlzdERlbGltaXRlclJFID0gLzsoPyFbXihdKlxcKSkvZztcbmNvbnN0IHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOihbXl0rKS87XG5jb25zdCBzdHlsZUNvbW1lbnRSRSA9IC9cXC9cXCpbXl0qP1xcKlxcLy9nO1xuZnVuY3Rpb24gcGFyc2VTdHJpbmdTdHlsZShjc3NUZXh0KSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBjc3NUZXh0LnJlcGxhY2Uoc3R5bGVDb21tZW50UkUsIFwiXCIpLnNwbGl0KGxpc3REZWxpbWl0ZXJSRSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBjb25zdCB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyUkUpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJldFt0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZShzdHlsZXMpIHtcbiAgbGV0IHJldCA9IFwiXCI7XG4gIGlmICghc3R5bGVzIHx8IGlzU3RyaW5nKHN0eWxlcykpIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xuICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBrZXkuc3RhcnRzV2l0aChgLS1gKSA/IGtleSA6IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgcmV0ICs9IGAke25vcm1hbGl6ZWRLZXl9OiR7dmFsdWV9O2A7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzcyh2YWx1ZSkge1xuICBsZXQgcmVzID0gXCJcIjtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJlcyA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcbiAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgXCIgXCI7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW25hbWVdKSB7XG4gICAgICAgIHJlcyArPSBuYW1lICsgXCIgXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXMudHJpbSgpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMocHJvcHMpIHtcbiAgaWYgKCFwcm9wcykgcmV0dXJuIG51bGw7XG4gIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xuICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xuICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xuICB9XG4gIGlmIChzdHlsZSkge1xuICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICB9XG4gIHJldHVybiBwcm9wcztcbn1cblxuY29uc3QgSFRNTF9UQUdTID0gXCJodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSxhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsaDEsaDIsaDMsaDQsaDUsaDYsbmF2LHNlY3Rpb24sZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdFwiO1xuY29uc3QgU1ZHX1RBR1MgPSBcInN2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSxkZWZzLGRlc2MsZGlzY2FyZCxlbGxpcHNlLGZlQmxlbmQsZmVDb2xvck1hdHJpeCxmZUNvbXBvbmVudFRyYW5zZmVyLGZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsZmVEaXN0YW50TGlnaHQsZmVEcm9wU2hhZG93LGZlRmxvb2QsZmVGdW5jQSxmZUZ1bmNCLGZlRnVuY0csZmVGdW5jUixmZUdhdXNzaWFuQmx1cixmZUltYWdlLGZlTWVyZ2UsZmVNZXJnZU5vZGUsZmVNb3JwaG9sb2d5LGZlT2Zmc2V0LGZlUG9pbnRMaWdodCxmZVNwZWN1bGFyTGlnaHRpbmcsZmVTcG90TGlnaHQsZmVUaWxlLGZlVHVyYnVsZW5jZSxmaWx0ZXIsZm9yZWlnbk9iamVjdCxnLGhhdGNoLGhhdGNocGF0aCxpbWFnZSxsaW5lLGxpbmVhckdyYWRpZW50LG1hcmtlcixtYXNrLG1lc2gsbWVzaGdyYWRpZW50LG1lc2hwYXRjaCxtZXNocm93LG1ldGFkYXRhLG1wYXRoLHBhdGgscGF0dGVybixwb2x5Z29uLHBvbHlsaW5lLHJhZGlhbEdyYWRpZW50LHJlY3Qsc2V0LHNvbGlkY29sb3Isc3RvcCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dFBhdGgsdGl0bGUsdHNwYW4sdW5rbm93bix1c2Usdmlld1wiO1xuY29uc3QgTUFUSF9UQUdTID0gXCJhbm5vdGF0aW9uLGFubm90YXRpb24teG1sLG1hY3Rpb24sbWFsaWduZ3JvdXAsbWFsaWdubWFyayxtYXRoLG1lbmNsb3NlLG1lcnJvcixtZmVuY2VkLG1mcmFjLG1mcmFjdGlvbixtZ2x5cGgsbWksbWxhYmVsZWR0cixtbG9uZ2RpdixtbXVsdGlzY3JpcHRzLG1uLG1vLG1vdmVyLG1wYWRkZWQsbXBoYW50b20sbXByZXNjcmlwdHMsbXJvb3QsbXJvdyxtcyxtc2NhcnJpZXMsbXNjYXJyeSxtc2dyb3VwLG1zbGluZSxtc3BhY2UsbXNxcnQsbXNyb3csbXN0YWNrLG1zdHlsZSxtc3ViLG1zdWJzdXAsbXN1cCxtdGFibGUsbXRkLG10ZXh0LG10cixtdW5kZXIsbXVuZGVyb3Zlcixub25lLHNlbWFudGljc1wiO1xuY29uc3QgVk9JRF9UQUdTID0gXCJhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGhyLGltZyxpbnB1dCxsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdiclwiO1xuY29uc3QgaXNIVE1MVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoSFRNTF9UQUdTKTtcbmNvbnN0IGlzU1ZHVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoU1ZHX1RBR1MpO1xuY29uc3QgaXNNYXRoTUxUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChNQVRIX1RBR1MpO1xuY29uc3QgaXNWb2lkVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoVk9JRF9UQUdTKTtcblxuY29uc3Qgc3BlY2lhbEJvb2xlYW5BdHRycyA9IGBpdGVtc2NvcGUsYWxsb3dmdWxsc2NyZWVuLGZvcm1ub3ZhbGlkYXRlLGlzbWFwLG5vbW9kdWxlLG5vdmFsaWRhdGUscmVhZG9ubHlgO1xuY29uc3QgaXNTcGVjaWFsQm9vbGVhbkF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzKTtcbmNvbnN0IGlzQm9vbGVhbkF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgc3BlY2lhbEJvb2xlYW5BdHRycyArIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGluZXJ0LGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGBcbik7XG5mdW5jdGlvbiBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgfHwgdmFsdWUgPT09IFwiXCI7XG59XG5jb25zdCB1bnNhZmVBdHRyQ2hhclJFID0gL1s+Lz1cIidcXHUwMDA5XFx1MDAwYVxcdTAwMGNcXHUwMDIwXS87XG5jb25zdCBhdHRyVmFsaWRhdGlvbkNhY2hlID0ge307XG5mdW5jdGlvbiBpc1NTUlNhZmVBdHRyTmFtZShuYW1lKSB7XG4gIGlmIChhdHRyVmFsaWRhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV07XG4gIH1cbiAgY29uc3QgaXNVbnNhZmUgPSB1bnNhZmVBdHRyQ2hhclJFLnRlc3QobmFtZSk7XG4gIGlmIChpc1Vuc2FmZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYHVuc2FmZSBhdHRyaWJ1dGUgbmFtZTogJHtuYW1lfWApO1xuICB9XG4gIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdID0gIWlzVW5zYWZlO1xufVxuY29uc3QgcHJvcHNUb0F0dHJNYXAgPSB7XG4gIGFjY2VwdENoYXJzZXQ6IFwiYWNjZXB0LWNoYXJzZXRcIixcbiAgY2xhc3NOYW1lOiBcImNsYXNzXCIsXG4gIGh0bWxGb3I6IFwiZm9yXCIsXG4gIGh0dHBFcXVpdjogXCJodHRwLWVxdWl2XCJcbn07XG5jb25zdCBpc0tub3duSHRtbEF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYGFjY2VwdCxhY2NlcHQtY2hhcnNldCxhY2Nlc3NrZXksYWN0aW9uLGFsaWduLGFsbG93LGFsdCxhc3luYyxhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsYXV0b2ZvY3VzLGF1dG9wbGF5LGJhY2tncm91bmQsYmdjb2xvcixib3JkZXIsYnVmZmVyZWQsY2FwdHVyZSxjaGFsbGVuZ2UsY2hhcnNldCxjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxjb2RlYmFzZSxjb2xvcixjb2xzLGNvbHNwYW4sY29udGVudCxjb250ZW50ZWRpdGFibGUsY29udGV4dG1lbnUsY29udHJvbHMsY29vcmRzLGNyb3Nzb3JpZ2luLGNzcCxkYXRhLGRhdGV0aW1lLGRlY29kaW5nLGRlZmF1bHQsZGVmZXIsZGlyLGRpcm5hbWUsZGlzYWJsZWQsZG93bmxvYWQsZHJhZ2dhYmxlLGRyb3B6b25lLGVuY3R5cGUsZW50ZXJrZXloaW50LGZvcixmb3JtLGZvcm1hY3Rpb24sZm9ybWVuY3R5cGUsZm9ybW1ldGhvZCxmb3Jtbm92YWxpZGF0ZSxmb3JtdGFyZ2V0LGhlYWRlcnMsaGVpZ2h0LGhpZGRlbixoaWdoLGhyZWYsaHJlZmxhbmcsaHR0cC1lcXVpdixpY29uLGlkLGltcG9ydGFuY2UsaW5lcnQsaW50ZWdyaXR5LGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvYWRpbmcsbGlzdCxsb29wLGxvdyxtYW5pZmVzdCxtYXgsbWF4bGVuZ3RoLG1pbmxlbmd0aCxtZWRpYSxtaW4sbXVsdGlwbGUsbXV0ZWQsbmFtZSxub3ZhbGlkYXRlLG9wZW4sb3B0aW11bSxwYXR0ZXJuLHBpbmcscGxhY2Vob2xkZXIscG9zdGVyLHByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxyZWZlcnJlcnBvbGljeSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsc2NvcGUsc2NvcGVkLHNlbGVjdGVkLHNoYXBlLHNpemUsc2l6ZXMsc2xvdCxzcGFuLHNwZWxsY2hlY2ssc3JjLHNyY2RvYyxzcmNsYW5nLHNyY3NldCxzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCx2YWx1ZSx3aWR0aCx3cmFwYFxuKTtcbmNvbnN0IGlzS25vd25TdmdBdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIGB4bWxucyxhY2NlbnQtaGVpZ2h0LGFjY3VtdWxhdGUsYWRkaXRpdmUsYWxpZ25tZW50LWJhc2VsaW5lLGFscGhhYmV0aWMsYW1wbGl0dWRlLGFyYWJpYy1mb3JtLGFzY2VudCxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVR5cGUsYXppbXV0aCxiYXNlRnJlcXVlbmN5LGJhc2VsaW5lLXNoaWZ0LGJhc2VQcm9maWxlLGJib3gsYmVnaW4sYmlhcyxieSxjYWxjTW9kZSxjYXAtaGVpZ2h0LGNsYXNzLGNsaXAsY2xpcFBhdGhVbml0cyxjbGlwLXBhdGgsY2xpcC1ydWxlLGNvbG9yLGNvbG9yLWludGVycG9sYXRpb24sY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzLGNvbG9yLXByb2ZpbGUsY29sb3ItcmVuZGVyaW5nLGNvbnRlbnRTY3JpcHRUeXBlLGNvbnRlbnRTdHlsZVR5cGUsY3Jvc3NvcmlnaW4sY3Vyc29yLGN4LGN5LGQsZGVjZWxlcmF0ZSxkZXNjZW50LGRpZmZ1c2VDb25zdGFudCxkaXJlY3Rpb24sZGlzcGxheSxkaXZpc29yLGRvbWluYW50LWJhc2VsaW5lLGR1cixkeCxkeSxlZGdlTW9kZSxlbGV2YXRpb24sZW5hYmxlLWJhY2tncm91bmQsZW5kLGV4cG9uZW50LGZpbGwsZmlsbC1vcGFjaXR5LGZpbGwtcnVsZSxmaWx0ZXIsZmlsdGVyUmVzLGZpbHRlclVuaXRzLGZsb29kLWNvbG9yLGZsb29kLW9wYWNpdHksZm9udC1mYW1pbHksZm9udC1zaXplLGZvbnQtc2l6ZS1hZGp1c3QsZm9udC1zdHJldGNoLGZvbnQtc3R5bGUsZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZvcm1hdCxmcm9tLGZyLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCxnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCxnbHlwaFJlZixncmFkaWVudFRyYW5zZm9ybSxncmFkaWVudFVuaXRzLGhhbmdpbmcsaGVpZ2h0LGhyZWYsaHJlZmxhbmcsaG9yaXotYWR2LXgsaG9yaXotb3JpZ2luLXgsaWQsaWRlb2dyYXBoaWMsaW1hZ2UtcmVuZGVyaW5nLGluLGluMixpbnRlcmNlcHQsayxrMSxrMixrMyxrNCxrZXJuZWxNYXRyaXgsa2VybmVsVW5pdExlbmd0aCxrZXJuaW5nLGtleVBvaW50cyxrZXlTcGxpbmVzLGtleVRpbWVzLGxhbmcsbGVuZ3RoQWRqdXN0LGxldHRlci1zcGFjaW5nLGxpZ2h0aW5nLWNvbG9yLGxpbWl0aW5nQ29uZUFuZ2xlLGxvY2FsLG1hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLG1hc2ssbWFza0NvbnRlbnRVbml0cyxtYXNrVW5pdHMsbWF0aGVtYXRpY2FsLG1heCxtZWRpYSxtZXRob2QsbWluLG1vZGUsbmFtZSxudW1PY3RhdmVzLG9mZnNldCxvcGFjaXR5LG9wZXJhdG9yLG9yZGVyLG9yaWVudCxvcmllbnRhdGlvbixvcmlnaW4sb3ZlcmZsb3csb3ZlcmxpbmUtcG9zaXRpb24sb3ZlcmxpbmUtdGhpY2tuZXNzLHBhbm9zZS0xLHBhaW50LW9yZGVyLHBhdGgscGF0aExlbmd0aCxwYXR0ZXJuQ29udGVudFVuaXRzLHBhdHRlcm5UcmFuc2Zvcm0scGF0dGVyblVuaXRzLHBpbmcscG9pbnRlci1ldmVudHMscG9pbnRzLHBvaW50c0F0WCxwb2ludHNBdFkscG9pbnRzQXRaLHByZXNlcnZlQWxwaGEscHJlc2VydmVBc3BlY3RSYXRpbyxwcmltaXRpdmVVbml0cyxyLHJhZGl1cyxyZWZlcnJlclBvbGljeSxyZWZYLHJlZlkscmVsLHJlbmRlcmluZy1pbnRlbnQscmVwZWF0Q291bnQscmVwZWF0RHVyLHJlcXVpcmVkRXh0ZW5zaW9ucyxyZXF1aXJlZEZlYXR1cmVzLHJlc3RhcnQscmVzdWx0LHJvdGF0ZSxyeCxyeSxzY2FsZSxzZWVkLHNoYXBlLXJlbmRlcmluZyxzbG9wZSxzcGFjaW5nLHNwZWN1bGFyQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxzcGVlZCxzcHJlYWRNZXRob2Qsc3RhcnRPZmZzZXQsc3RkRGV2aWF0aW9uLHN0ZW1oLHN0ZW12LHN0aXRjaFRpbGVzLHN0b3AtY29sb3Isc3RvcC1vcGFjaXR5LHN0cmlrZXRocm91Z2gtcG9zaXRpb24sc3RyaWtldGhyb3VnaC10aGlja25lc3Msc3RyaW5nLHN0cm9rZSxzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSxzdHJva2Utd2lkdGgsc3R5bGUsc3VyZmFjZVNjYWxlLHN5c3RlbUxhbmd1YWdlLHRhYmluZGV4LHRhYmxlVmFsdWVzLHRhcmdldCx0YXJnZXRYLHRhcmdldFksdGV4dC1hbmNob3IsdGV4dC1kZWNvcmF0aW9uLHRleHQtcmVuZGVyaW5nLHRleHRMZW5ndGgsdG8sdHJhbnNmb3JtLHRyYW5zZm9ybS1vcmlnaW4sdHlwZSx1MSx1Mix1bmRlcmxpbmUtcG9zaXRpb24sdW5kZXJsaW5lLXRoaWNrbmVzcyx1bmljb2RlLHVuaWNvZGUtYmlkaSx1bmljb2RlLXJhbmdlLHVuaXRzLXBlci1lbSx2LWFscGhhYmV0aWMsdi1oYW5naW5nLHYtaWRlb2dyYXBoaWMsdi1tYXRoZW1hdGljYWwsdmFsdWVzLHZlY3Rvci1lZmZlY3QsdmVyc2lvbix2ZXJ0LWFkdi15LHZlcnQtb3JpZ2luLXgsdmVydC1vcmlnaW4teSx2aWV3Qm94LHZpZXdUYXJnZXQsdmlzaWJpbGl0eSx3aWR0aCx3aWR0aHMsd29yZC1zcGFjaW5nLHdyaXRpbmctbW9kZSx4LHgtaGVpZ2h0LHgxLHgyLHhDaGFubmVsU2VsZWN0b3IseGxpbms6YWN0dWF0ZSx4bGluazphcmNyb2xlLHhsaW5rOmhyZWYseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLHhsaW5rOnR5cGUseG1sbnM6eGxpbmsseG1sOmJhc2UseG1sOmxhbmcseG1sOnNwYWNlLHkseTEseTIseUNoYW5uZWxTZWxlY3Rvcix6LHpvb21BbmRQYW5gXG4pO1xuZnVuY3Rpb24gaXNSZW5kZXJhYmxlQXR0clZhbHVlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCI7XG59XG5cbmNvbnN0IGVzY2FwZVJFID0gL1tcIicmPD5dLztcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gIGNvbnN0IHN0ciA9IFwiXCIgKyBzdHJpbmc7XG4gIGNvbnN0IG1hdGNoID0gZXNjYXBlUkUuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBsZXQgaHRtbCA9IFwiXCI7XG4gIGxldCBlc2NhcGVkO1xuICBsZXQgaW5kZXg7XG4gIGxldCBsYXN0SW5kZXggPSAwO1xuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICBlc2NhcGVkID0gXCImcXVvdDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM4OlxuICAgICAgICBlc2NhcGVkID0gXCImYW1wO1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIGVzY2FwZWQgPSBcIiYjMzk7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmx0O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZndDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGVkO1xuICB9XG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG59XG5jb25zdCBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XG4gIHJldHVybiBzcmMucmVwbGFjZShjb21tZW50U3RyaXBSRSwgXCJcIik7XG59XG5cbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGVxdWFsICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgZXF1YWwgPSBsb29zZUVxdWFsKGFbaV0sIGJbaV0pO1xuICB9XG4gIHJldHVybiBlcXVhbDtcbn1cbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xuICBsZXQgYlZhbGlkVHlwZSA9IGlzRGF0ZShiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCkgOiBmYWxzZTtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNTeW1ib2woYSk7XG4gIGJWYWxpZFR5cGUgPSBpc1N5bWJvbChiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xuICBiVmFsaWRUeXBlID0gaXNBcnJheShiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikgOiBmYWxzZTtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XG4gIGJWYWxpZFR5cGUgPSBpc09iamVjdChiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIGlmICghYVZhbGlkVHlwZSB8fCAhYlZhbGlkVHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYSkubGVuZ3RoO1xuICAgIGNvbnN0IGJLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhiKS5sZW5ndGg7XG4gICAgaWYgKGFLZXlzQ291bnQgIT09IGJLZXlzQ291bnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgY29uc3QgYUhhc0tleSA9IGEuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGNvbnN0IGJIYXNLZXkgPSBiLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBpZiAoYUhhc0tleSAmJiAhYkhhc0tleSB8fCAhYUhhc0tleSAmJiBiSGFzS2V5IHx8ICFsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbn1cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xuICByZXR1cm4gYXJyLmZpbmRJbmRleCgoaXRlbSkgPT4gbG9vc2VFcXVhbChpdGVtLCB2YWwpKTtcbn1cblxuY29uc3QgaXNSZWYgPSAodmFsKSA9PiB7XG4gIHJldHVybiAhISh2YWwgJiYgdmFsW1wiX192X2lzUmVmXCJdID09PSB0cnVlKTtcbn07XG5jb25zdCB0b0Rpc3BsYXlTdHJpbmcgPSAodmFsKSA9PiB7XG4gIHJldHVybiBpc1N0cmluZyh2YWwpID8gdmFsIDogdmFsID09IG51bGwgPyBcIlwiIDogaXNBcnJheSh2YWwpIHx8IGlzT2JqZWN0KHZhbCkgJiYgKHZhbC50b1N0cmluZyA9PT0gb2JqZWN0VG9TdHJpbmcgfHwgIWlzRnVuY3Rpb24odmFsLnRvU3RyaW5nKSkgPyBpc1JlZih2YWwpID8gdG9EaXNwbGF5U3RyaW5nKHZhbC52YWx1ZSkgOiBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKSA6IFN0cmluZyh2YWwpO1xufTtcbmNvbnN0IHJlcGxhY2VyID0gKF9rZXksIHZhbCkgPT4ge1xuICBpZiAoaXNSZWYodmFsKSkge1xuICAgIHJldHVybiByZXBsYWNlcihfa2V5LCB2YWwudmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoXG4gICAgICAgIChlbnRyaWVzLCBba2V5LCB2YWwyXSwgaSkgPT4ge1xuICAgICAgICAgIGVudHJpZXNbc3RyaW5naWZ5U3ltYm9sKGtleSwgaSkgKyBcIiA9PlwiXSA9IHZhbDI7XG4gICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHt9XG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgU2V0KCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLnZhbHVlcygpXS5tYXAoKHYpID0+IHN0cmluZ2lmeVN5bWJvbCh2KSlcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzU3ltYm9sKHZhbCkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5U3ltYm9sKHZhbCk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSAmJiAhaXNBcnJheSh2YWwpICYmICFpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5jb25zdCBzdHJpbmdpZnlTeW1ib2wgPSAodiwgaSA9IFwiXCIpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKFxuICAgIC8vIFN5bWJvbC5kZXNjcmlwdGlvbiBpbiBlczIwMTkrIHNvIHdlIG5lZWQgdG8gY2FzdCBoZXJlIHRvIHBhc3NcbiAgICAvLyB0aGUgbGliOiBlczIwMTYgY2hlY2tcbiAgICBpc1N5bWJvbCh2KSA/IGBTeW1ib2woJHsoX2EgPSB2LmRlc2NyaXB0aW9uKSAhPSBudWxsID8gX2EgOiBpfSlgIDogdlxuICApO1xufTtcblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgUGF0Y2hGbGFncywgU2hhcGVGbGFncywgU2xvdEZsYWdzLCBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgZGVmLCBlc2NhcGVIdG1sLCBlc2NhcGVIdG1sQ29tbWVudCwgZXh0ZW5kLCBnZW5Qcm9wc0FjY2Vzc0V4cCwgZ2VuZXJhdGVDb2RlRnJhbWUsIGdldEdsb2JhbFRoaXMsIGhhc0NoYW5nZWQsIGhhc093biwgaHlwaGVuYXRlLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGludm9rZUFycmF5Rm5zLCBpc0FycmF5LCBpc0Jvb2xlYW5BdHRyLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGlzRGF0ZSwgaXNGdW5jdGlvbiwgaXNHbG9iYWxseUFsbG93ZWQsIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25IdG1sQXR0ciwgaXNLbm93blN2Z0F0dHIsIGlzTWFwLCBpc01hdGhNTFRhZywgaXNNb2RlbExpc3RlbmVyLCBpc09iamVjdCwgaXNPbiwgaXNQbGFpbk9iamVjdCwgaXNQcm9taXNlLCBpc1JlZ0V4cCwgaXNSZW5kZXJhYmxlQXR0clZhbHVlLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIGxvb3NlVG9OdW1iZXIsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIG9iamVjdFRvU3RyaW5nLCBwYXJzZVN0cmluZ1N0eWxlLCBwcm9wc1RvQXR0ck1hcCwgcmVtb3ZlLCBzbG90RmxhZ3NUZXh0LCBzdHJpbmdpZnlTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCB0b1Jhd1R5cGUsIHRvVHlwZVN0cmluZyB9O1xuIiwiLyoqXG4qIEB2dWUvcnVudGltZS1jb3JlIHYzLjUuMC1iZXRhLjNcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbmltcG9ydCB7IHBhdXNlVHJhY2tpbmcsIHJlc2V0VHJhY2tpbmcsIGlzUmVmLCB0b1JhdywgdHJhdmVyc2UsIGlzUmVhY3RpdmUsIHJlZiwgc2hhbGxvd1JlYWRBcnJheSwgdG9SZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCB0cmFjaywgcmVhY3RpdmUsIHNoYWxsb3dSZWFjdGl2ZSwgdHJpZ2dlciwgUmVhY3RpdmVFZmZlY3QsIHdhdGNoIGFzIHdhdGNoJDEsIGN1c3RvbVJlZiwgaXNQcm94eSwgcHJveHlSZWZzLCBtYXJrUmF3LCBFZmZlY3RTY29wZSwgY29tcHV0ZWQgYXMgY29tcHV0ZWQkMSwgc2hhbGxvd1JlZiwgcmVhZG9ubHksIGlzU2hhbGxvdywgaXNSZWFkb25seSB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5leHBvcnQgeyBFZmZlY3RTY29wZSwgUmVhY3RpdmVFZmZlY3QsIFRyYWNrT3BUeXBlcywgVHJpZ2dlck9wVHlwZXMsIGN1c3RvbVJlZiwgZWZmZWN0LCBlZmZlY3RTY29wZSwgZ2V0Q3VycmVudFNjb3BlLCBnZXRDdXJyZW50V2F0Y2hlciwgaXNQcm94eSwgaXNSZWFjdGl2ZSwgaXNSZWFkb25seSwgaXNSZWYsIGlzU2hhbGxvdywgbWFya1Jhdywgb25TY29wZURpc3Bvc2UsIG9uV2F0Y2hlckNsZWFudXAsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWRvbmx5LCByZWYsIHNoYWxsb3dSZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCBzaGFsbG93UmVmLCBzdG9wLCB0b1JhdywgdG9SZWYsIHRvUmVmcywgdG9WYWx1ZSwgdHJpZ2dlclJlZiwgdW5yZWYgfSBmcm9tICdAdnVlL3JlYWN0aXZpdHknO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzRnVuY3Rpb24sIGlzUHJvbWlzZSwgaXNBcnJheSwgRU1QVFlfT0JKLCBOT09QLCBnZXRHbG9iYWxUaGlzLCBleHRlbmQsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaGFzT3duLCByZW1vdmUsIGRlZiwgaXNPbiwgaXNSZXNlcnZlZFByb3AsIG5vcm1hbGl6ZUNsYXNzLCBzdHJpbmdpZnlTdHlsZSwgbm9ybWFsaXplU3R5bGUsIGlzS25vd25TdmdBdHRyLCBpc0Jvb2xlYW5BdHRyLCBpc0tub3duSHRtbEF0dHIsIGluY2x1ZGVCb29sZWFuQXR0ciwgaXNSZW5kZXJhYmxlQXR0clZhbHVlLCBpc09iamVjdCwgaXNSZWdFeHAsIGludm9rZUFycmF5Rm5zLCB0b0hhbmRsZXJLZXksIGNhcGl0YWxpemUsIGNhbWVsaXplLCBpc0dsb2JhbGx5QWxsb3dlZCwgTk8sIGh5cGhlbmF0ZSwgRU1QVFlfQVJSLCB0b1Jhd1R5cGUsIG1ha2VNYXAsIGhhc0NoYW5nZWQsIGxvb3NlVG9OdW1iZXIsIGlzTW9kZWxMaXN0ZW5lciwgdG9OdW1iZXIgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5leHBvcnQgeyBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXkgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IHN0YWNrID0gW107XG5mdW5jdGlvbiBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUpIHtcbiAgc3RhY2sucHVzaCh2bm9kZSk7XG59XG5mdW5jdGlvbiBwb3BXYXJuaW5nQ29udGV4dCgpIHtcbiAgc3RhY2sucG9wKCk7XG59XG5sZXQgaXNXYXJuaW5nID0gZmFsc2U7XG5mdW5jdGlvbiB3YXJuJDEobXNnLCAuLi5hcmdzKSB7XG4gIGlmIChpc1dhcm5pbmcpIHJldHVybjtcbiAgaXNXYXJuaW5nID0gdHJ1ZTtcbiAgcGF1c2VUcmFja2luZygpO1xuICBjb25zdCBpbnN0YW5jZSA9IHN0YWNrLmxlbmd0aCA/IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmNvbXBvbmVudCA6IG51bGw7XG4gIGNvbnN0IGFwcFdhcm5IYW5kbGVyID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcud2FybkhhbmRsZXI7XG4gIGNvbnN0IHRyYWNlID0gZ2V0Q29tcG9uZW50VHJhY2UoKTtcbiAgaWYgKGFwcFdhcm5IYW5kbGVyKSB7XG4gICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKFxuICAgICAgYXBwV2FybkhhbmRsZXIsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDExLFxuICAgICAgW1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgbXNnICsgYXJncy5tYXAoKGEpID0+IHtcbiAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBhLnRvU3RyaW5nKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChhKSkgIT0gbnVsbCA/IF9iIDogSlNPTi5zdHJpbmdpZnkoYSk7XG4gICAgICAgIH0pLmpvaW4oXCJcIiksXG4gICAgICAgIGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5LFxuICAgICAgICB0cmFjZS5tYXAoXG4gICAgICAgICAgKHsgdm5vZGUgfSkgPT4gYGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIHZub2RlLnR5cGUpfT5gXG4gICAgICAgICkuam9pbihcIlxcblwiKSxcbiAgICAgICAgdHJhY2VcbiAgICAgIF1cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHdhcm5BcmdzID0gW2BbVnVlIHdhcm5dOiAke21zZ31gLCAuLi5hcmdzXTtcbiAgICBpZiAodHJhY2UubGVuZ3RoICYmIC8vIGF2b2lkIHNwYW1taW5nIGNvbnNvbGUgZHVyaW5nIHRlc3RzXG4gICAgdHJ1ZSkge1xuICAgICAgd2FybkFyZ3MucHVzaChgXG5gLCAuLi5mb3JtYXRUcmFjZSh0cmFjZSkpO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oLi4ud2FybkFyZ3MpO1xuICB9XG4gIHJlc2V0VHJhY2tpbmcoKTtcbiAgaXNXYXJuaW5nID0gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRUcmFjZSgpIHtcbiAgbGV0IGN1cnJlbnRWTm9kZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICBpZiAoIWN1cnJlbnRWTm9kZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkU3RhY2sgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnRWTm9kZSkge1xuICAgIGNvbnN0IGxhc3QgPSBub3JtYWxpemVkU3RhY2tbMF07XG4gICAgaWYgKGxhc3QgJiYgbGFzdC52bm9kZSA9PT0gY3VycmVudFZOb2RlKSB7XG4gICAgICBsYXN0LnJlY3Vyc2VDb3VudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxpemVkU3RhY2sucHVzaCh7XG4gICAgICAgIHZub2RlOiBjdXJyZW50Vk5vZGUsXG4gICAgICAgIHJlY3Vyc2VDb3VudDogMFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudEluc3RhbmNlID0gY3VycmVudFZOb2RlLmNvbXBvbmVudCAmJiBjdXJyZW50Vk5vZGUuY29tcG9uZW50LnBhcmVudDtcbiAgICBjdXJyZW50Vk5vZGUgPSBwYXJlbnRJbnN0YW5jZSAmJiBwYXJlbnRJbnN0YW5jZS52bm9kZTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFN0YWNrO1xufVxuZnVuY3Rpb24gZm9ybWF0VHJhY2UodHJhY2UpIHtcbiAgY29uc3QgbG9ncyA9IFtdO1xuICB0cmFjZS5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xuICAgIGxvZ3MucHVzaCguLi5pID09PSAwID8gW10gOiBbYFxuYF0sIC4uLmZvcm1hdFRyYWNlRW50cnkoZW50cnkpKTtcbiAgfSk7XG4gIHJldHVybiBsb2dzO1xufVxuZnVuY3Rpb24gZm9ybWF0VHJhY2VFbnRyeSh7IHZub2RlLCByZWN1cnNlQ291bnQgfSkge1xuICBjb25zdCBwb3N0Zml4ID0gcmVjdXJzZUNvdW50ID4gMCA/IGAuLi4gKCR7cmVjdXJzZUNvdW50fSByZWN1cnNpdmUgY2FsbHMpYCA6IGBgO1xuICBjb25zdCBpc1Jvb3QgPSB2bm9kZS5jb21wb25lbnQgPyB2bm9kZS5jb21wb25lbnQucGFyZW50ID09IG51bGwgOiBmYWxzZTtcbiAgY29uc3Qgb3BlbiA9IGAgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShcbiAgICB2bm9kZS5jb21wb25lbnQsXG4gICAgdm5vZGUudHlwZSxcbiAgICBpc1Jvb3RcbiAgKX1gO1xuICBjb25zdCBjbG9zZSA9IGA+YCArIHBvc3RmaXg7XG4gIHJldHVybiB2bm9kZS5wcm9wcyA/IFtvcGVuLCAuLi5mb3JtYXRQcm9wcyh2bm9kZS5wcm9wcyksIGNsb3NlXSA6IFtvcGVuICsgY2xvc2VdO1xufVxuZnVuY3Rpb24gZm9ybWF0UHJvcHMocHJvcHMpIHtcbiAgY29uc3QgcmVzID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG4gIGtleXMuc2xpY2UoMCwgMykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgcmVzLnB1c2goLi4uZm9ybWF0UHJvcChrZXksIHByb3BzW2tleV0pKTtcbiAgfSk7XG4gIGlmIChrZXlzLmxlbmd0aCA+IDMpIHtcbiAgICByZXMucHVzaChgIC4uLmApO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBmb3JtYXRQcm9wKGtleSwgdmFsdWUsIHJhdykge1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcbiAgfSBlbHNlIGlmIChpc1JlZih2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IGZvcm1hdFByb3Aoa2V5LCB0b1Jhdyh2YWx1ZS52YWx1ZSksIHRydWUpO1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PVJlZjxgLCB2YWx1ZSwgYD5gXTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiBbYCR7a2V5fT1mbiR7dmFsdWUubmFtZSA/IGA8JHt2YWx1ZS5uYW1lfT5gIDogYGB9YF07XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09YCwgdmFsdWVdO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnROdW1iZXIodmFsLCB0eXBlKSB7XG4gIGlmICghISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkgcmV0dXJuO1xuICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCAhPT0gXCJudW1iZXJcIikge1xuICAgIHdhcm4kMShgJHt0eXBlfSBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybiQxKGAke3R5cGV9IGlzIE5hTiAtIHRoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC5gKTtcbiAgfVxufVxuXG5jb25zdCBFcnJvckNvZGVzID0ge1xuICBcIlNFVFVQX0ZVTkNUSU9OXCI6IDAsXG4gIFwiMFwiOiBcIlNFVFVQX0ZVTkNUSU9OXCIsXG4gIFwiUkVOREVSX0ZVTkNUSU9OXCI6IDEsXG4gIFwiMVwiOiBcIlJFTkRFUl9GVU5DVElPTlwiLFxuICBcIk5BVElWRV9FVkVOVF9IQU5ETEVSXCI6IDUsXG4gIFwiNVwiOiBcIk5BVElWRV9FVkVOVF9IQU5ETEVSXCIsXG4gIFwiQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVJcIjogNixcbiAgXCI2XCI6IFwiQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVJcIixcbiAgXCJWTk9ERV9IT09LXCI6IDcsXG4gIFwiN1wiOiBcIlZOT0RFX0hPT0tcIixcbiAgXCJESVJFQ1RJVkVfSE9PS1wiOiA4LFxuICBcIjhcIjogXCJESVJFQ1RJVkVfSE9PS1wiLFxuICBcIlRSQU5TSVRJT05fSE9PS1wiOiA5LFxuICBcIjlcIjogXCJUUkFOU0lUSU9OX0hPT0tcIixcbiAgXCJBUFBfRVJST1JfSEFORExFUlwiOiAxMCxcbiAgXCIxMFwiOiBcIkFQUF9FUlJPUl9IQU5ETEVSXCIsXG4gIFwiQVBQX1dBUk5fSEFORExFUlwiOiAxMSxcbiAgXCIxMVwiOiBcIkFQUF9XQVJOX0hBTkRMRVJcIixcbiAgXCJGVU5DVElPTl9SRUZcIjogMTIsXG4gIFwiMTJcIjogXCJGVU5DVElPTl9SRUZcIixcbiAgXCJBU1lOQ19DT01QT05FTlRfTE9BREVSXCI6IDEzLFxuICBcIjEzXCI6IFwiQVNZTkNfQ09NUE9ORU5UX0xPQURFUlwiLFxuICBcIlNDSEVEVUxFUlwiOiAxNCxcbiAgXCIxNFwiOiBcIlNDSEVEVUxFUlwiLFxuICBcIkNPTVBPTkVOVF9VUERBVEVcIjogMTUsXG4gIFwiMTVcIjogXCJDT01QT05FTlRfVVBEQVRFXCIsXG4gIFwiQVBQX1VOTU9VTlRfQ0xFQU5VUFwiOiAxNixcbiAgXCIxNlwiOiBcIkFQUF9VTk1PVU5UX0NMRUFOVVBcIlxufTtcbmNvbnN0IEVycm9yVHlwZVN0cmluZ3MkMSA9IHtcbiAgW1wic3BcIl06IFwic2VydmVyUHJlZmV0Y2ggaG9va1wiLFxuICBbXCJiY1wiXTogXCJiZWZvcmVDcmVhdGUgaG9va1wiLFxuICBbXCJjXCJdOiBcImNyZWF0ZWQgaG9va1wiLFxuICBbXCJibVwiXTogXCJiZWZvcmVNb3VudCBob29rXCIsXG4gIFtcIm1cIl06IFwibW91bnRlZCBob29rXCIsXG4gIFtcImJ1XCJdOiBcImJlZm9yZVVwZGF0ZSBob29rXCIsXG4gIFtcInVcIl06IFwidXBkYXRlZFwiLFxuICBbXCJidW1cIl06IFwiYmVmb3JlVW5tb3VudCBob29rXCIsXG4gIFtcInVtXCJdOiBcInVubW91bnRlZCBob29rXCIsXG4gIFtcImFcIl06IFwiYWN0aXZhdGVkIGhvb2tcIixcbiAgW1wiZGFcIl06IFwiZGVhY3RpdmF0ZWQgaG9va1wiLFxuICBbXCJlY1wiXTogXCJlcnJvckNhcHR1cmVkIGhvb2tcIixcbiAgW1wicnRjXCJdOiBcInJlbmRlclRyYWNrZWQgaG9va1wiLFxuICBbXCJydGdcIl06IFwicmVuZGVyVHJpZ2dlcmVkIGhvb2tcIixcbiAgWzBdOiBcInNldHVwIGZ1bmN0aW9uXCIsXG4gIFsxXTogXCJyZW5kZXIgZnVuY3Rpb25cIixcbiAgWzJdOiBcIndhdGNoZXIgZ2V0dGVyXCIsXG4gIFszXTogXCJ3YXRjaGVyIGNhbGxiYWNrXCIsXG4gIFs0XTogXCJ3YXRjaGVyIGNsZWFudXAgZnVuY3Rpb25cIixcbiAgWzVdOiBcIm5hdGl2ZSBldmVudCBoYW5kbGVyXCIsXG4gIFs2XTogXCJjb21wb25lbnQgZXZlbnQgaGFuZGxlclwiLFxuICBbN106IFwidm5vZGUgaG9va1wiLFxuICBbOF06IFwiZGlyZWN0aXZlIGhvb2tcIixcbiAgWzldOiBcInRyYW5zaXRpb24gaG9va1wiLFxuICBbMTBdOiBcImFwcCBlcnJvckhhbmRsZXJcIixcbiAgWzExXTogXCJhcHAgd2FybkhhbmRsZXJcIixcbiAgWzEyXTogXCJyZWYgZnVuY3Rpb25cIixcbiAgWzEzXTogXCJhc3luYyBjb21wb25lbnQgbG9hZGVyXCIsXG4gIFsxNF06IFwic2NoZWR1bGVyIGZsdXNoXCIsXG4gIFsxNV06IFwiY29tcG9uZW50IHVwZGF0ZVwiLFxuICBbMTZdOiBcImFwcCB1bm1vdW50IGNsZWFudXAgZnVuY3Rpb25cIlxufTtcbmZ1bmN0aW9uIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXJncyA/IGZuKC4uLmFyZ3MpIDogZm4oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xuICBpZiAoaXNGdW5jdGlvbihmbikpIHtcbiAgICBjb25zdCByZXMgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKTtcbiAgICBpZiAocmVzICYmIGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICByZXMuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmIChpc0FycmF5KGZuKSkge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlcy5wdXNoKGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuW2ldLCBpbnN0YW5jZSwgdHlwZSwgYXJncykpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgSW52YWxpZCB2YWx1ZSB0eXBlIHBhc3NlZCB0byBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZygpOiAke3R5cGVvZiBmbn1gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSwgdGhyb3dJbkRldiA9IHRydWUpIHtcbiAgY29uc3QgY29udGV4dFZOb2RlID0gaW5zdGFuY2UgPyBpbnN0YW5jZS52bm9kZSA6IG51bGw7XG4gIGNvbnN0IHsgZXJyb3JIYW5kbGVyLCB0aHJvd1VuaGFuZGxlZEVycm9ySW5Qcm9kdWN0aW9uIH0gPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyB8fCBFTVBUWV9PQko7XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGxldCBjdXIgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gICAgY29uc3QgZXhwb3NlZEluc3RhbmNlID0gaW5zdGFuY2UucHJveHk7XG4gICAgY29uc3QgZXJyb3JJbmZvID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IEVycm9yVHlwZVN0cmluZ3MkMVt0eXBlXSA6IGBodHRwczovL3Z1ZWpzLm9yZy9lcnJvci1yZWZlcmVuY2UvI3J1bnRpbWUtJHt0eXBlfWA7XG4gICAgd2hpbGUgKGN1cikge1xuICAgICAgY29uc3QgZXJyb3JDYXB0dXJlZEhvb2tzID0gY3VyLmVjO1xuICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9yQ2FwdHVyZWRIb29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3NbaV0oZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mbykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXIgPSBjdXIucGFyZW50O1xuICAgIH1cbiAgICBpZiAoZXJyb3JIYW5kbGVyKSB7XG4gICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZXJyb3JIYW5kbGVyLCBudWxsLCAxMCwgW1xuICAgICAgICBlcnIsXG4gICAgICAgIGV4cG9zZWRJbnN0YW5jZSxcbiAgICAgICAgZXJyb3JJbmZvXG4gICAgICBdKTtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYsIHRocm93VW5oYW5kbGVkRXJyb3JJblByb2R1Y3Rpb24pO1xufVxuZnVuY3Rpb24gbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYgPSB0cnVlLCB0aHJvd0luUHJvZCA9IGZhbHNlKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgaW5mbyA9IEVycm9yVHlwZVN0cmluZ3MkMVt0eXBlXTtcbiAgICBpZiAoY29udGV4dFZOb2RlKSB7XG4gICAgICBwdXNoV2FybmluZ0NvbnRleHQoY29udGV4dFZOb2RlKTtcbiAgICB9XG4gICAgd2FybiQxKGBVbmhhbmRsZWQgZXJyb3Ike2luZm8gPyBgIGR1cmluZyBleGVjdXRpb24gb2YgJHtpbmZvfWAgOiBgYH1gKTtcbiAgICBpZiAoY29udGV4dFZOb2RlKSB7XG4gICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgIH1cbiAgICBpZiAodGhyb3dJbkRldikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRocm93SW5Qcm9kKSB7XG4gICAgdGhyb3cgZXJyO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5sZXQgaXNGbHVzaGluZyA9IGZhbHNlO1xubGV0IGlzRmx1c2hQZW5kaW5nID0gZmFsc2U7XG5jb25zdCBxdWV1ZSA9IFtdO1xubGV0IGZsdXNoSW5kZXggPSAwO1xuY29uc3QgcGVuZGluZ1Bvc3RGbHVzaENicyA9IFtdO1xubGV0IGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XG5sZXQgcG9zdEZsdXNoSW5kZXggPSAwO1xuY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xubGV0IGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xuY29uc3QgUkVDVVJTSU9OX0xJTUlUID0gMTAwO1xuZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgY29uc3QgcCA9IGN1cnJlbnRGbHVzaFByb21pc2UgfHwgcmVzb2x2ZWRQcm9taXNlO1xuICByZXR1cm4gZm4gPyBwLnRoZW4odGhpcyA/IGZuLmJpbmQodGhpcykgOiBmbikgOiBwO1xufVxuZnVuY3Rpb24gZmluZEluc2VydGlvbkluZGV4KGlkKSB7XG4gIGxldCBzdGFydCA9IGlzRmx1c2hpbmcgPyBmbHVzaEluZGV4ICsgMSA6IDA7XG4gIGxldCBlbmQgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgIGNvbnN0IG1pZGRsZSA9IHN0YXJ0ICsgZW5kID4+PiAxO1xuICAgIGNvbnN0IG1pZGRsZUpvYiA9IHF1ZXVlW21pZGRsZV07XG4gICAgY29uc3QgbWlkZGxlSm9iSWQgPSBnZXRJZChtaWRkbGVKb2IpO1xuICAgIGlmIChtaWRkbGVKb2JJZCA8IGlkIHx8IG1pZGRsZUpvYklkID09PSBpZCAmJiBtaWRkbGVKb2IuZmxhZ3MgJiAyKSB7XG4gICAgICBzdGFydCA9IG1pZGRsZSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCA9IG1pZGRsZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXJ0O1xufVxuZnVuY3Rpb24gcXVldWVKb2Ioam9iKSB7XG4gIGlmICghKGpvYi5mbGFncyAmIDEpKSB7XG4gICAgY29uc3Qgam9iSWQgPSBnZXRJZChqb2IpO1xuICAgIGNvbnN0IGxhc3RKb2IgPSBxdWV1ZVtxdWV1ZS5sZW5ndGggLSAxXTtcbiAgICBpZiAoIWxhc3RKb2IgfHwgLy8gZmFzdCBwYXRoIHdoZW4gdGhlIGpvYiBpZCBpcyBsYXJnZXIgdGhhbiB0aGUgdGFpbFxuICAgICEoam9iLmZsYWdzICYgMikgJiYgam9iSWQgPj0gZ2V0SWQobGFzdEpvYikpIHtcbiAgICAgIHF1ZXVlLnB1c2goam9iKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWUuc3BsaWNlKGZpbmRJbnNlcnRpb25JbmRleChqb2JJZCksIDAsIGpvYik7XG4gICAgfVxuICAgIGlmICghKGpvYi5mbGFncyAmIDQpKSB7XG4gICAgICBqb2IuZmxhZ3MgfD0gMTtcbiAgICB9XG4gICAgcXVldWVGbHVzaCgpO1xuICB9XG59XG5mdW5jdGlvbiBxdWV1ZUZsdXNoKCkge1xuICBpZiAoIWlzRmx1c2hpbmcgJiYgIWlzRmx1c2hQZW5kaW5nKSB7XG4gICAgaXNGbHVzaFBlbmRpbmcgPSB0cnVlO1xuICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSByZXNvbHZlZFByb21pc2UudGhlbihmbHVzaEpvYnMpO1xuICB9XG59XG5mdW5jdGlvbiBxdWV1ZVBvc3RGbHVzaENiKGNiKSB7XG4gIGlmICghaXNBcnJheShjYikpIHtcbiAgICBpZiAoYWN0aXZlUG9zdEZsdXNoQ2JzICYmIGNiLmlkID09PSAtMSkge1xuICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnNwbGljZShwb3N0Rmx1c2hJbmRleCArIDEsIDAsIGNiKTtcbiAgICB9IGVsc2UgaWYgKCEoY2IuZmxhZ3MgJiAxKSkge1xuICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5wdXNoKGNiKTtcbiAgICAgIGlmICghKGNiLmZsYWdzICYgNCkpIHtcbiAgICAgICAgY2IuZmxhZ3MgfD0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGVuZGluZ1Bvc3RGbHVzaENicy5wdXNoKC4uLmNiKTtcbiAgfVxuICBxdWV1ZUZsdXNoKCk7XG59XG5mdW5jdGlvbiBmbHVzaFByZUZsdXNoQ2JzKGluc3RhbmNlLCBzZWVuLCBpID0gaXNGbHVzaGluZyA/IGZsdXNoSW5kZXggKyAxIDogMCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgZm9yICg7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNiID0gcXVldWVbaV07XG4gICAgaWYgKGNiICYmIGNiLmZsYWdzICYgMikge1xuICAgICAgaWYgKGluc3RhbmNlICYmIGNiLmlkICE9PSBpbnN0YW5jZS51aWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgY2IpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgaS0tO1xuICAgICAgY2IoKTtcbiAgICAgIGNiLmZsYWdzICY9IH4xO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbikge1xuICBpZiAocGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcbiAgICBjb25zdCBkZWR1cGVkID0gWy4uLm5ldyBTZXQocGVuZGluZ1Bvc3RGbHVzaENicyldLnNvcnQoXG4gICAgICAoYSwgYikgPT4gZ2V0SWQoYSkgLSBnZXRJZChiKVxuICAgICk7XG4gICAgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGggPSAwO1xuICAgIGlmIChhY3RpdmVQb3N0Rmx1c2hDYnMpIHtcbiAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5wdXNoKC4uLmRlZHVwZWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBkZWR1cGVkO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBmb3IgKHBvc3RGbHVzaEluZGV4ID0gMDsgcG9zdEZsdXNoSW5kZXggPCBhY3RpdmVQb3N0Rmx1c2hDYnMubGVuZ3RoOyBwb3N0Rmx1c2hJbmRleCsrKSB7XG4gICAgICBjb25zdCBjYiA9IGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF07XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgY2IpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCEoY2IuZmxhZ3MgJiA4KSkgY2IoKTtcbiAgICAgIGNiLmZsYWdzICY9IH4xO1xuICAgIH1cbiAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xuICAgIHBvc3RGbHVzaEluZGV4ID0gMDtcbiAgfVxufVxuY29uc3QgZ2V0SWQgPSAoam9iKSA9PiBqb2IuaWQgPT0gbnVsbCA/IGpvYi5mbGFncyAmIDIgPyAtMSA6IEluZmluaXR5IDogam9iLmlkO1xuZnVuY3Rpb24gZmx1c2hKb2JzKHNlZW4pIHtcbiAgaXNGbHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgaXNGbHVzaGluZyA9IHRydWU7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBjb25zdCBjaGVjayA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyAoam9iKSA9PiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2Vlbiwgam9iKSA6IE5PT1A7XG4gIHRyeSB7XG4gICAgZm9yIChmbHVzaEluZGV4ID0gMDsgZmx1c2hJbmRleCA8IHF1ZXVlLmxlbmd0aDsgZmx1c2hJbmRleCsrKSB7XG4gICAgICBjb25zdCBqb2IgPSBxdWV1ZVtmbHVzaEluZGV4XTtcbiAgICAgIGlmIChqb2IgJiYgIShqb2IuZmxhZ3MgJiA4KSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVjayhqb2IpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKFxuICAgICAgICAgIGpvYixcbiAgICAgICAgICBqb2IuaSxcbiAgICAgICAgICBqb2IuaSA/IDE1IDogMTRcbiAgICAgICAgKTtcbiAgICAgICAgam9iLmZsYWdzICY9IH4xO1xuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBmbHVzaEluZGV4ID0gMDtcbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pO1xuICAgIGlzRmx1c2hpbmcgPSBmYWxzZTtcbiAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcbiAgICBpZiAocXVldWUubGVuZ3RoIHx8IHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XG4gICAgICBmbHVzaEpvYnMoc2Vlbik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgZm4pIHtcbiAgaWYgKCFzZWVuLmhhcyhmbikpIHtcbiAgICBzZWVuLnNldChmbiwgMSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY291bnQgPSBzZWVuLmdldChmbik7XG4gICAgaWYgKGNvdW50ID4gUkVDVVJTSU9OX0xJTUlUKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGZuLmk7XG4gICAgICBjb25zdCBjb21wb25lbnROYW1lID0gaW5zdGFuY2UgJiYgZ2V0Q29tcG9uZW50TmFtZShpbnN0YW5jZS50eXBlKTtcbiAgICAgIGhhbmRsZUVycm9yKFxuICAgICAgICBgTWF4aW11bSByZWN1cnNpdmUgdXBkYXRlcyBleGNlZWRlZCR7Y29tcG9uZW50TmFtZSA/IGAgaW4gY29tcG9uZW50IDwke2NvbXBvbmVudE5hbWV9PmAgOiBgYH0uIFRoaXMgbWVhbnMgeW91IGhhdmUgYSByZWFjdGl2ZSBlZmZlY3QgdGhhdCBpcyBtdXRhdGluZyBpdHMgb3duIGRlcGVuZGVuY2llcyBhbmQgdGh1cyByZWN1cnNpdmVseSB0cmlnZ2VyaW5nIGl0c2VsZi4gUG9zc2libGUgc291cmNlcyBpbmNsdWRlIGNvbXBvbmVudCB0ZW1wbGF0ZSwgcmVuZGVyIGZ1bmN0aW9uLCB1cGRhdGVkIGhvb2sgb3Igd2F0Y2hlciBzb3VyY2UgZnVuY3Rpb24uYCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMTBcbiAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vlbi5zZXQoZm4sIGNvdW50ICsgMSk7XG4gICAgfVxuICB9XG59XG5cbmxldCBpc0htclVwZGF0aW5nID0gZmFsc2U7XG5jb25zdCBobXJEaXJ0eUNvbXBvbmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX0hNUl9SVU5USU1FX18gPSB7XG4gICAgY3JlYXRlUmVjb3JkOiB0cnlXcmFwKGNyZWF0ZVJlY29yZCksXG4gICAgcmVyZW5kZXI6IHRyeVdyYXAocmVyZW5kZXIpLFxuICAgIHJlbG9hZDogdHJ5V3JhcChyZWxvYWQpXG4gIH07XG59XG5jb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gcmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcbiAgY29uc3QgaWQgPSBpbnN0YW5jZS50eXBlLl9faG1ySWQ7XG4gIGxldCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgaWYgKCFyZWNvcmQpIHtcbiAgICBjcmVhdGVSZWNvcmQoaWQsIGluc3RhbmNlLnR5cGUpO1xuICAgIHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICB9XG4gIHJlY29yZC5pbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcbiAgbWFwLmdldChpbnN0YW5jZS50eXBlLl9faG1ySWQpLmluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVjb3JkKGlkLCBpbml0aWFsRGVmKSB7XG4gIGlmIChtYXAuaGFzKGlkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYXAuc2V0KGlkLCB7XG4gICAgaW5pdGlhbERlZjogbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5pdGlhbERlZiksXG4gICAgaW5zdGFuY2VzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gIH0pO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpID8gY29tcG9uZW50Ll9fdmNjT3B0cyA6IGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIHJlcmVuZGVyKGlkLCBuZXdSZW5kZXIpIHtcbiAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIGlmICghcmVjb3JkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlY29yZC5pbml0aWFsRGVmLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgWy4uLnJlY29yZC5pbnN0YW5jZXNdLmZvckVhY2goKGluc3RhbmNlKSA9PiB7XG4gICAgaWYgKG5ld1JlbmRlcikge1xuICAgICAgaW5zdGFuY2UucmVuZGVyID0gbmV3UmVuZGVyO1xuICAgICAgbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSkucmVuZGVyID0gbmV3UmVuZGVyO1xuICAgIH1cbiAgICBpbnN0YW5jZS5yZW5kZXJDYWNoZSA9IFtdO1xuICAgIGlzSG1yVXBkYXRpbmcgPSB0cnVlO1xuICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgIGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZWxvYWQoaWQsIG5ld0NvbXApIHtcbiAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIGlmICghcmVjb3JkKSByZXR1cm47XG4gIG5ld0NvbXAgPSBub3JtYWxpemVDbGFzc0NvbXBvbmVudChuZXdDb21wKTtcbiAgdXBkYXRlQ29tcG9uZW50RGVmKHJlY29yZC5pbml0aWFsRGVmLCBuZXdDb21wKTtcbiAgY29uc3QgaW5zdGFuY2VzID0gWy4uLnJlY29yZC5pbnN0YW5jZXNdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzW2ldO1xuICAgIGNvbnN0IG9sZENvbXAgPSBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKTtcbiAgICBsZXQgZGlydHlJbnN0YW5jZXMgPSBobXJEaXJ0eUNvbXBvbmVudHMuZ2V0KG9sZENvbXApO1xuICAgIGlmICghZGlydHlJbnN0YW5jZXMpIHtcbiAgICAgIGlmIChvbGRDb21wICE9PSByZWNvcmQuaW5pdGlhbERlZikge1xuICAgICAgICB1cGRhdGVDb21wb25lbnREZWYob2xkQ29tcCwgbmV3Q29tcCk7XG4gICAgICB9XG4gICAgICBobXJEaXJ0eUNvbXBvbmVudHMuc2V0KG9sZENvbXAsIGRpcnR5SW5zdGFuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgfVxuICAgIGRpcnR5SW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7XG4gICAgaW5zdGFuY2UuYXBwQ29udGV4dC5wcm9wc0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcbiAgICBpbnN0YW5jZS5hcHBDb250ZXh0LmVtaXRzQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xuICAgIGluc3RhbmNlLmFwcENvbnRleHQub3B0aW9uc0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcbiAgICBpZiAoaW5zdGFuY2UuY2VSZWxvYWQpIHtcbiAgICAgIGRpcnR5SW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7XG4gICAgICBpbnN0YW5jZS5jZVJlbG9hZChuZXdDb21wLnN0eWxlcyk7XG4gICAgICBkaXJ0eUluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UucGFyZW50KSB7XG4gICAgICBxdWV1ZUpvYigoKSA9PiB7XG4gICAgICAgIGluc3RhbmNlLnBhcmVudC51cGRhdGUoKTtcbiAgICAgICAgZGlydHlJbnN0YW5jZXMuZGVsZXRlKGluc3RhbmNlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQpIHtcbiAgICAgIGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJbSE1SXSBSb290IG9yIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UgbW9kaWZpZWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2Uucm9vdC5jZSAmJiBpbnN0YW5jZSAhPT0gaW5zdGFuY2Uucm9vdCkge1xuICAgICAgaW5zdGFuY2Uucm9vdC5jZS5fcmVtb3ZlQ2hpbGRTdHlsZShvbGRDb21wKTtcbiAgICB9XG4gIH1cbiAgcXVldWVQb3N0Rmx1c2hDYigoKSA9PiB7XG4gICAgaG1yRGlydHlDb21wb25lbnRzLmNsZWFyKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50RGVmKG9sZENvbXAsIG5ld0NvbXApIHtcbiAgZXh0ZW5kKG9sZENvbXAsIG5ld0NvbXApO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvbGRDb21wKSB7XG4gICAgaWYgKGtleSAhPT0gXCJfX2ZpbGVcIiAmJiAhKGtleSBpbiBuZXdDb21wKSkge1xuICAgICAgZGVsZXRlIG9sZENvbXBba2V5XTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcbiAgcmV0dXJuIChpZCwgYXJnKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihpZCwgYXJnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW0hNUl0gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIFZ1ZSBjb21wb25lbnQgaG90LXJlbG9hZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbmxldCBkZXZ0b29scyQxO1xubGV0IGJ1ZmZlciA9IFtdO1xubGV0IGRldnRvb2xzTm90SW5zdGFsbGVkID0gZmFsc2U7XG5mdW5jdGlvbiBlbWl0JDEoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgaWYgKGRldnRvb2xzJDEpIHtcbiAgICBkZXZ0b29scyQxLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICB9IGVsc2UgaWYgKCFkZXZ0b29sc05vdEluc3RhbGxlZCkge1xuICAgIGJ1ZmZlci5wdXNoKHsgZXZlbnQsIGFyZ3MgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldERldnRvb2xzSG9vayQxKGhvb2ssIHRhcmdldCkge1xuICB2YXIgX2EsIF9iO1xuICBkZXZ0b29scyQxID0gaG9vaztcbiAgaWYgKGRldnRvb2xzJDEpIHtcbiAgICBkZXZ0b29scyQxLmVuYWJsZWQgPSB0cnVlO1xuICAgIGJ1ZmZlci5mb3JFYWNoKCh7IGV2ZW50LCBhcmdzIH0pID0+IGRldnRvb2xzJDEuZW1pdChldmVudCwgLi4uYXJncykpO1xuICAgIGJ1ZmZlciA9IFtdO1xuICB9IGVsc2UgaWYgKFxuICAgIC8vIGhhbmRsZSBsYXRlIGRldnRvb2xzIGluamVjdGlvbiAtIG9ubHkgZG8gdGhpcyBpZiB3ZSBhcmUgaW4gYW4gYWN0dWFsXG4gICAgLy8gYnJvd3NlciBlbnZpcm9ubWVudCB0byBhdm9pZCB0aGUgdGltZXIgaGFuZGxlIHN0YWxsaW5nIHRlc3QgcnVubmVyIGV4aXRcbiAgICAvLyAoIzQ4MTUpXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvLyBzb21lIGVudnMgbW9jayB3aW5kb3cgYnV0IG5vdCBmdWxseVxuICAgIHdpbmRvdy5IVE1MRWxlbWVudCAmJiAvLyBhbHNvIGV4Y2x1ZGUganNkb21cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAhKChfYiA9IChfYSA9IHdpbmRvdy5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYS51c2VyQWdlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5pbmNsdWRlcyhcImpzZG9tXCIpKVxuICApIHtcbiAgICBjb25zdCByZXBsYXkgPSB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyA9IHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fIHx8IFtdO1xuICAgIHJlcGxheS5wdXNoKChuZXdIb29rKSA9PiB7XG4gICAgICBzZXREZXZ0b29sc0hvb2skMShuZXdIb29rLCB0YXJnZXQpO1xuICAgIH0pO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFkZXZ0b29scyQxKSB7XG4gICAgICAgIHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID0gbnVsbDtcbiAgICAgICAgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgIH1cbiAgICB9LCAzZTMpO1xuICB9IGVsc2Uge1xuICAgIGRldnRvb2xzTm90SW5zdGFsbGVkID0gdHJ1ZTtcbiAgICBidWZmZXIgPSBbXTtcbiAgfVxufVxuZnVuY3Rpb24gZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbikge1xuICBlbWl0JDEoXCJhcHA6aW5pdFwiIC8qIEFQUF9JTklUICovLCBhcHAsIHZlcnNpb24sIHtcbiAgICBGcmFnbWVudCxcbiAgICBUZXh0LFxuICAgIENvbW1lbnQsXG4gICAgU3RhdGljXG4gIH0pO1xufVxuZnVuY3Rpb24gZGV2dG9vbHNVbm1vdW50QXBwKGFwcCkge1xuICBlbWl0JDEoXCJhcHA6dW5tb3VudFwiIC8qIEFQUF9VTk1PVU5UICovLCBhcHApO1xufVxuY29uc3QgZGV2dG9vbHNDb21wb25lbnRBZGRlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6YWRkZWRcIiAvKiBDT01QT05FTlRfQURERUQgKi8pO1xuY29uc3QgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDp1cGRhdGVkXCIgLyogQ09NUE9ORU5UX1VQREFURUQgKi8pO1xuY29uc3QgX2RldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXG4gIFwiY29tcG9uZW50OnJlbW92ZWRcIiAvKiBDT01QT05FTlRfUkVNT1ZFRCAqL1xuKTtcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IChjb21wb25lbnQpID0+IHtcbiAgaWYgKGRldnRvb2xzJDEgJiYgdHlwZW9mIGRldnRvb2xzJDEuY2xlYW51cEJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIC8vIHJlbW92ZSB0aGUgY29tcG9uZW50IGlmIGl0IHdhc24ndCBidWZmZXJlZFxuICAhZGV2dG9vbHMkMS5jbGVhbnVwQnVmZmVyKGNvbXBvbmVudCkpIHtcbiAgICBfZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkKGNvbXBvbmVudCk7XG4gIH1cbn07XG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soaG9vaykge1xuICByZXR1cm4gKGNvbXBvbmVudCkgPT4ge1xuICAgIGVtaXQkMShcbiAgICAgIGhvb2ssXG4gICAgICBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsXG4gICAgICBjb21wb25lbnQudWlkLFxuICAgICAgY29tcG9uZW50LnBhcmVudCA/IGNvbXBvbmVudC5wYXJlbnQudWlkIDogdm9pZCAwLFxuICAgICAgY29tcG9uZW50XG4gICAgKTtcbiAgfTtcbn1cbmNvbnN0IGRldnRvb2xzUGVyZlN0YXJ0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFwicGVyZjpzdGFydFwiIC8qIFBFUkZPUk1BTkNFX1NUQVJUICovKTtcbmNvbnN0IGRldnRvb2xzUGVyZkVuZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhcInBlcmY6ZW5kXCIgLyogUEVSRk9STUFOQ0VfRU5EICovKTtcbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKGhvb2spIHtcbiAgcmV0dXJuIChjb21wb25lbnQsIHR5cGUsIHRpbWUpID0+IHtcbiAgICBlbWl0JDEoaG9vaywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQudWlkLCBjb21wb25lbnQsIHR5cGUsIHRpbWUpO1xuICB9O1xufVxuZnVuY3Rpb24gZGV2dG9vbHNDb21wb25lbnRFbWl0KGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcykge1xuICBlbWl0JDEoXG4gICAgXCJjb21wb25lbnQ6ZW1pdFwiIC8qIENPTVBPTkVOVF9FTUlUICovLFxuICAgIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCxcbiAgICBjb21wb25lbnQsXG4gICAgZXZlbnQsXG4gICAgcGFyYW1zXG4gICk7XG59XG5cbmxldCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xubGV0IGN1cnJlbnRTY29wZUlkID0gbnVsbDtcbmZ1bmN0aW9uIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSkge1xuICBjb25zdCBwcmV2ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgY3VycmVudFNjb3BlSWQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS50eXBlLl9fc2NvcGVJZCB8fCBudWxsO1xuICByZXR1cm4gcHJldjtcbn1cbmZ1bmN0aW9uIHB1c2hTY29wZUlkKGlkKSB7XG4gIGN1cnJlbnRTY29wZUlkID0gaWQ7XG59XG5mdW5jdGlvbiBwb3BTY29wZUlkKCkge1xuICBjdXJyZW50U2NvcGVJZCA9IG51bGw7XG59XG5jb25zdCB3aXRoU2NvcGVJZCA9IChfaWQpID0+IHdpdGhDdHg7XG5mdW5jdGlvbiB3aXRoQ3R4KGZuLCBjdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIGlzTm9uU2NvcGVkU2xvdCkge1xuICBpZiAoIWN0eCkgcmV0dXJuIGZuO1xuICBpZiAoZm4uX24pIHtcbiAgICByZXR1cm4gZm47XG4gIH1cbiAgY29uc3QgcmVuZGVyRm5XaXRoQ29udGV4dCA9ICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcbiAgICAgIHNldEJsb2NrVHJhY2tpbmcoLTEpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2SW5zdGFuY2UgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoY3R4KTtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBmbiguLi5hcmdzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXZJbnN0YW5jZSk7XG4gICAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xuICAgICAgICBzZXRCbG9ja1RyYWNraW5nKDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICByZW5kZXJGbldpdGhDb250ZXh0Ll9uID0gdHJ1ZTtcbiAgcmVuZGVyRm5XaXRoQ29udGV4dC5fYyA9IHRydWU7XG4gIHJlbmRlckZuV2l0aENvbnRleHQuX2QgPSB0cnVlO1xuICByZXR1cm4gcmVuZGVyRm5XaXRoQ29udGV4dDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpIHtcbiAgaWYgKGlzQnVpbHRJbkRpcmVjdGl2ZShuYW1lKSkge1xuICAgIHdhcm4kMShcIkRvIG5vdCB1c2UgYnVpbHQtaW4gZGlyZWN0aXZlIGlkcyBhcyBjdXN0b20gZGlyZWN0aXZlIGlkOiBcIiArIG5hbWUpO1xuICB9XG59XG5mdW5jdGlvbiB3aXRoRGlyZWN0aXZlcyh2bm9kZSwgZGlyZWN0aXZlcykge1xuICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID09PSBudWxsKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYHdpdGhEaXJlY3RpdmVzIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHJlbmRlciBmdW5jdGlvbnMuYCk7XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2UoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKTtcbiAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzIHx8ICh2bm9kZS5kaXJzID0gW10pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgW2RpciwgdmFsdWUsIGFyZywgbW9kaWZpZXJzID0gRU1QVFlfT0JKXSA9IGRpcmVjdGl2ZXNbaV07XG4gICAgaWYgKGRpcikge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oZGlyKSkge1xuICAgICAgICBkaXIgPSB7XG4gICAgICAgICAgbW91bnRlZDogZGlyLFxuICAgICAgICAgIHVwZGF0ZWQ6IGRpclxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGRpci5kZWVwKSB7XG4gICAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGJpbmRpbmdzLnB1c2goe1xuICAgICAgICBkaXIsXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb2xkVmFsdWU6IHZvaWQgMCxcbiAgICAgICAgYXJnLFxuICAgICAgICBtb2RpZmllcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBwcmV2Vk5vZGUsIGluc3RhbmNlLCBuYW1lKSB7XG4gIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycztcbiAgY29uc3Qgb2xkQmluZGluZ3MgPSBwcmV2Vk5vZGUgJiYgcHJldlZOb2RlLmRpcnM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgaWYgKG9sZEJpbmRpbmdzKSB7XG4gICAgICBiaW5kaW5nLm9sZFZhbHVlID0gb2xkQmluZGluZ3NbaV0udmFsdWU7XG4gICAgfVxuICAgIGxldCBob29rID0gYmluZGluZy5kaXJbbmFtZV07XG4gICAgaWYgKGhvb2spIHtcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA4LCBbXG4gICAgICAgIHZub2RlLmVsLFxuICAgICAgICBiaW5kaW5nLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgcHJldlZOb2RlXG4gICAgICBdKTtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgVGVsZXBvcnRFbmRLZXkgPSBTeW1ib2woXCJfdnRlXCIpO1xuY29uc3QgaXNUZWxlcG9ydCA9ICh0eXBlKSA9PiB0eXBlLl9faXNUZWxlcG9ydDtcbmNvbnN0IGlzVGVsZXBvcnREaXNhYmxlZCA9IChwcm9wcykgPT4gcHJvcHMgJiYgKHByb3BzLmRpc2FibGVkIHx8IHByb3BzLmRpc2FibGVkID09PSBcIlwiKTtcbmNvbnN0IGlzVGVsZXBvcnREZWZlcnJlZCA9IChwcm9wcykgPT4gcHJvcHMgJiYgKHByb3BzLmRlZmVyIHx8IHByb3BzLmRlZmVyID09PSBcIlwiKTtcbmNvbnN0IGlzVGFyZ2V0U1ZHID0gKHRhcmdldCkgPT4gdHlwZW9mIFNWR0VsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcbmNvbnN0IGlzVGFyZ2V0TWF0aE1MID0gKHRhcmdldCkgPT4gdHlwZW9mIE1hdGhNTEVsZW1lbnQgPT09IFwiZnVuY3Rpb25cIiAmJiB0YXJnZXQgaW5zdGFuY2VvZiBNYXRoTUxFbGVtZW50O1xuY29uc3QgcmVzb2x2ZVRhcmdldCA9IChwcm9wcywgc2VsZWN0KSA9PiB7XG4gIGNvbnN0IHRhcmdldFNlbGVjdG9yID0gcHJvcHMgJiYgcHJvcHMudG87XG4gIGlmIChpc1N0cmluZyh0YXJnZXRTZWxlY3RvcikpIHtcbiAgICBpZiAoIXNlbGVjdCkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoXG4gICAgICAgIGBDdXJyZW50IHJlbmRlcmVyIGRvZXMgbm90IHN1cHBvcnQgc3RyaW5nIHRhcmdldCBmb3IgVGVsZXBvcnRzLiAobWlzc2luZyBxdWVyeVNlbGVjdG9yIHJlbmRlcmVyIG9wdGlvbilgXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHNlbGVjdCh0YXJnZXRTZWxlY3Rvcik7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhdGFyZ2V0ICYmICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgRmFpbGVkIHRvIGxvY2F0ZSBUZWxlcG9ydCB0YXJnZXQgd2l0aCBzZWxlY3RvciBcIiR7dGFyZ2V0U2VsZWN0b3J9XCIuIE5vdGUgdGhlIHRhcmdldCBlbGVtZW50IG11c3QgZXhpc3QgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCAtIGkuZS4gdGhlIHRhcmdldCBjYW5ub3QgYmUgcmVuZGVyZWQgYnkgdGhlIGNvbXBvbmVudCBpdHNlbGYsIGFuZCBpZGVhbGx5IHNob3VsZCBiZSBvdXRzaWRlIG9mIHRoZSBlbnRpcmUgVnVlIGNvbXBvbmVudCB0cmVlLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICF0YXJnZXRTZWxlY3RvciAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgICAgd2FybiQxKGBJbnZhbGlkIFRlbGVwb3J0IHRhcmdldDogJHt0YXJnZXRTZWxlY3Rvcn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFNlbGVjdG9yO1xuICB9XG59O1xuY29uc3QgVGVsZXBvcnRJbXBsID0ge1xuICBuYW1lOiBcIlRlbGVwb3J0XCIsXG4gIF9faXNUZWxlcG9ydDogdHJ1ZSxcbiAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBtYzogbW91bnRDaGlsZHJlbixcbiAgICAgIHBjOiBwYXRjaENoaWxkcmVuLFxuICAgICAgcGJjOiBwYXRjaEJsb2NrQ2hpbGRyZW4sXG4gICAgICBvOiB7IGluc2VydCwgcXVlcnlTZWxlY3RvciwgY3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudCB9XG4gICAgfSA9IGludGVybmFscztcbiAgICBjb25zdCBkaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZChuMi5wcm9wcyk7XG4gICAgbGV0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuIH0gPSBuMjtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBjb25zdCBwbGFjZWhvbGRlciA9IG4yLmVsID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZUNvbW1lbnQoXCJ0ZWxlcG9ydCBzdGFydFwiKSA6IGNyZWF0ZVRleHQoXCJcIik7XG4gICAgICBjb25zdCBtYWluQW5jaG9yID0gbjIuYW5jaG9yID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZUNvbW1lbnQoXCJ0ZWxlcG9ydCBlbmRcIikgOiBjcmVhdGVUZXh0KFwiXCIpO1xuICAgICAgaW5zZXJ0KHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBpbnNlcnQobWFpbkFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgY29uc3QgbW91bnQgPSAoY29udGFpbmVyMiwgYW5jaG9yMikgPT4ge1xuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBjb250YWluZXIyLFxuICAgICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1vdW50VG9UYXJnZXQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpO1xuICAgICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSBwcmVwYXJlQW5jaG9yKHRhcmdldCwgbjIsIGNyZWF0ZVRleHQsIGluc2VydCk7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICBpZiAobmFtZXNwYWNlICE9PSBcInN2Z1wiICYmIGlzVGFyZ2V0U1ZHKHRhcmdldCkpIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IFwic3ZnXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lc3BhY2UgIT09IFwibWF0aG1sXCIgJiYgaXNUYXJnZXRNYXRoTUwodGFyZ2V0KSkge1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gXCJtYXRobWxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAgICAgbW91bnQodGFyZ2V0LCB0YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgdXBkYXRlQ3NzVmFycyhuMik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWRpc2FibGVkKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgXCJJbnZhbGlkIFRlbGVwb3J0IHRhcmdldCBvbiBtb3VudDpcIixcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIGAoJHt0eXBlb2YgdGFyZ2V0fSlgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICBtb3VudChjb250YWluZXIsIG1haW5BbmNob3IpO1xuICAgICAgICB1cGRhdGVDc3NWYXJzKG4yKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RlbGVwb3J0RGVmZXJyZWQobjIucHJvcHMpKSB7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChtb3VudFRvVGFyZ2V0LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3VudFRvVGFyZ2V0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICBuMi50YXJnZXRTdGFydCA9IG4xLnRhcmdldFN0YXJ0O1xuICAgICAgY29uc3QgbWFpbkFuY2hvciA9IG4yLmFuY2hvciA9IG4xLmFuY2hvcjtcbiAgICAgIGNvbnN0IHRhcmdldCA9IG4yLnRhcmdldCA9IG4xLnRhcmdldDtcbiAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IG4yLnRhcmdldEFuY2hvciA9IG4xLnRhcmdldEFuY2hvcjtcbiAgICAgIGNvbnN0IHdhc0Rpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4xLnByb3BzKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb250YWluZXIgPSB3YXNEaXNhYmxlZCA/IGNvbnRhaW5lciA6IHRhcmdldDtcbiAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3IgPSB3YXNEaXNhYmxlZCA/IG1haW5BbmNob3IgOiB0YXJnZXRBbmNob3I7XG4gICAgICBpZiAobmFtZXNwYWNlID09PSBcInN2Z1wiIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCkpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gXCJzdmdcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlID09PSBcIm1hdGhtbFwiIHx8IGlzVGFyZ2V0TWF0aE1MKHRhcmdldCkpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gXCJtYXRobWxcIjtcbiAgICAgIH1cbiAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKFxuICAgICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgY3VycmVudENvbnRhaW5lcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcbiAgICAgICAgcGF0Y2hDaGlsZHJlbihcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjdXJyZW50Q29udGFpbmVyLFxuICAgICAgICAgIGN1cnJlbnRBbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICBpZiAoIXdhc0Rpc2FibGVkKSB7XG4gICAgICAgICAgbW92ZVRlbGVwb3J0KFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBtYWluQW5jaG9yLFxuICAgICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG4yLnByb3BzICYmIG4xLnByb3BzICYmIG4yLnByb3BzLnRvICE9PSBuMS5wcm9wcy50bykge1xuICAgICAgICAgICAgbjIucHJvcHMudG8gPSBuMS5wcm9wcy50bztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgobjIucHJvcHMgJiYgbjIucHJvcHMudG8pICE9PSAobjEucHJvcHMgJiYgbjEucHJvcHMudG8pKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFRhcmdldCA9IG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQoXG4gICAgICAgICAgICBuMi5wcm9wcyxcbiAgICAgICAgICAgIHF1ZXJ5U2VsZWN0b3JcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXh0VGFyZ2V0KSB7XG4gICAgICAgICAgICBtb3ZlVGVsZXBvcnQoXG4gICAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgICBuZXh0VGFyZ2V0LFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gdXBkYXRlOlwiLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIGAoJHt0eXBlb2YgdGFyZ2V0fSlgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh3YXNEaXNhYmxlZCkge1xuICAgICAgICAgIG1vdmVUZWxlcG9ydChcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgdGFyZ2V0QW5jaG9yLFxuICAgICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHVwZGF0ZUNzc1ZhcnMobjIpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB7IHVtOiB1bm1vdW50LCBvOiB7IHJlbW92ZTogaG9zdFJlbW92ZSB9IH0sIGRvUmVtb3ZlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2hhcGVGbGFnLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBhbmNob3IsXG4gICAgICB0YXJnZXRTdGFydCxcbiAgICAgIHRhcmdldEFuY2hvcixcbiAgICAgIHRhcmdldCxcbiAgICAgIHByb3BzXG4gICAgfSA9IHZub2RlO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGhvc3RSZW1vdmUodGFyZ2V0U3RhcnQpO1xuICAgICAgaG9zdFJlbW92ZSh0YXJnZXRBbmNob3IpO1xuICAgIH1cbiAgICBkb1JlbW92ZSAmJiBob3N0UmVtb3ZlKGFuY2hvcik7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICBjb25zdCBzaG91bGRSZW1vdmUgPSBkb1JlbW92ZSB8fCAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgdW5tb3VudChcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2hvdWxkUmVtb3ZlLFxuICAgICAgICAgICEhY2hpbGQuZHluYW1pY0NoaWxkcmVuXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3ZlOiBtb3ZlVGVsZXBvcnQsXG4gIGh5ZHJhdGU6IGh5ZHJhdGVUZWxlcG9ydFxufTtcbmZ1bmN0aW9uIG1vdmVUZWxlcG9ydCh2bm9kZSwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHsgbzogeyBpbnNlcnQgfSwgbTogbW92ZSB9LCBtb3ZlVHlwZSA9IDIpIHtcbiAgaWYgKG1vdmVUeXBlID09PSAwKSB7XG4gICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG4gIGNvbnN0IHsgZWwsIGFuY2hvciwgc2hhcGVGbGFnLCBjaGlsZHJlbiwgcHJvcHMgfSA9IHZub2RlO1xuICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMjtcbiAgaWYgKGlzUmVvcmRlcikge1xuICAgIGluc2VydChlbCwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG4gIGlmICghaXNSZW9yZGVyIHx8IGlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW92ZShcbiAgICAgICAgICBjaGlsZHJlbltpXSxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgcGFyZW50QW5jaG9yLFxuICAgICAgICAgIDJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGlzUmVvcmRlcikge1xuICAgIGluc2VydChhbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gaHlkcmF0ZVRlbGVwb3J0KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwge1xuICBvOiB7IG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCBxdWVyeVNlbGVjdG9yLCBpbnNlcnQsIGNyZWF0ZVRleHQgfVxufSwgaHlkcmF0ZUNoaWxkcmVuKSB7XG4gIGNvbnN0IHRhcmdldCA9IHZub2RlLnRhcmdldCA9IHJlc29sdmVUYXJnZXQoXG4gICAgdm5vZGUucHJvcHMsXG4gICAgcXVlcnlTZWxlY3RvclxuICApO1xuICBpZiAodGFyZ2V0KSB7XG4gICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRhcmdldC5fbHBhIHx8IHRhcmdldC5maXJzdENoaWxkO1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxNikge1xuICAgICAgaWYgKGlzVGVsZXBvcnREaXNhYmxlZCh2bm9kZS5wcm9wcykpIHtcbiAgICAgICAgdm5vZGUuYW5jaG9yID0gaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgICAgIG5leHRTaWJsaW5nKG5vZGUpLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHBhcmVudE5vZGUobm9kZSksXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgdm5vZGUudGFyZ2V0U3RhcnQgPSB0YXJnZXROb2RlO1xuICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXROb2RlICYmIG5leHRTaWJsaW5nKHRhcmdldE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgIGxldCB0YXJnZXRBbmNob3IgPSB0YXJnZXROb2RlO1xuICAgICAgICB3aGlsZSAodGFyZ2V0QW5jaG9yKSB7XG4gICAgICAgICAgaWYgKHRhcmdldEFuY2hvciAmJiB0YXJnZXRBbmNob3Iubm9kZVR5cGUgPT09IDgpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRBbmNob3IuZGF0YSA9PT0gXCJ0ZWxlcG9ydCBzdGFydCBhbmNob3JcIikge1xuICAgICAgICAgICAgICB2bm9kZS50YXJnZXRTdGFydCA9IHRhcmdldEFuY2hvcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0QW5jaG9yLmRhdGEgPT09IFwidGVsZXBvcnQgYW5jaG9yXCIpIHtcbiAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0QW5jaG9yO1xuICAgICAgICAgICAgICB0YXJnZXQuX2xwYSA9IHZub2RlLnRhcmdldEFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS50YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0QW5jaG9yID0gbmV4dFNpYmxpbmcodGFyZ2V0QW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZub2RlLnRhcmdldEFuY2hvcikge1xuICAgICAgICAgIHByZXBhcmVBbmNob3IodGFyZ2V0LCB2bm9kZSwgY3JlYXRlVGV4dCwgaW5zZXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICAgICAgdGFyZ2V0Tm9kZSAmJiBuZXh0U2libGluZyh0YXJnZXROb2RlKSxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQ3NzVmFycyh2bm9kZSk7XG4gIH1cbiAgcmV0dXJuIHZub2RlLmFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS5hbmNob3IpO1xufVxuY29uc3QgVGVsZXBvcnQgPSBUZWxlcG9ydEltcGw7XG5mdW5jdGlvbiB1cGRhdGVDc3NWYXJzKHZub2RlKSB7XG4gIGNvbnN0IGN0eCA9IHZub2RlLmN0eDtcbiAgaWYgKGN0eCAmJiBjdHgudXQpIHtcbiAgICBsZXQgbm9kZSA9IHZub2RlLnRhcmdldFN0YXJ0O1xuICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IHZub2RlLnRhcmdldEFuY2hvcikge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS12LW93bmVyXCIsIGN0eC51aWQpO1xuICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIGN0eC51dCgpO1xuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlQW5jaG9yKHRhcmdldCwgdm5vZGUsIGNyZWF0ZVRleHQsIGluc2VydCkge1xuICBjb25zdCB0YXJnZXRTdGFydCA9IHZub2RlLnRhcmdldFN0YXJ0ID0gY3JlYXRlVGV4dChcIlwiKTtcbiAgY29uc3QgdGFyZ2V0QW5jaG9yID0gdm5vZGUudGFyZ2V0QW5jaG9yID0gY3JlYXRlVGV4dChcIlwiKTtcbiAgdGFyZ2V0U3RhcnRbVGVsZXBvcnRFbmRLZXldID0gdGFyZ2V0QW5jaG9yO1xuICBpZiAodGFyZ2V0KSB7XG4gICAgaW5zZXJ0KHRhcmdldFN0YXJ0LCB0YXJnZXQpO1xuICAgIGluc2VydCh0YXJnZXRBbmNob3IsIHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldEFuY2hvcjtcbn1cblxuY29uc3QgbGVhdmVDYktleSA9IFN5bWJvbChcIl9sZWF2ZUNiXCIpO1xuY29uc3QgZW50ZXJDYktleSA9IFN5bWJvbChcIl9lbnRlckNiXCIpO1xuZnVuY3Rpb24gdXNlVHJhbnNpdGlvblN0YXRlKCkge1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIGlzTGVhdmluZzogZmFsc2UsXG4gICAgaXNVbm1vdW50aW5nOiBmYWxzZSxcbiAgICBsZWF2aW5nVk5vZGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gIH07XG4gIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgc3RhdGUuaXNNb3VudGVkID0gdHJ1ZTtcbiAgfSk7XG4gIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XG4gICAgc3RhdGUuaXNVbm1vdW50aW5nID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmNvbnN0IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yID0gW0Z1bmN0aW9uLCBBcnJheV07XG5jb25zdCBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IHtcbiAgbW9kZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIHBlcnNpc3RlZDogQm9vbGVhbixcbiAgLy8gZW50ZXJcbiAgb25CZWZvcmVFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkVudGVyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgLy8gbGVhdmVcbiAgb25CZWZvcmVMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkxlYXZlQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgLy8gYXBwZWFyXG4gIG9uQmVmb3JlQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BcHBlYXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yXG59O1xuY29uc3QgcmVjdXJzaXZlR2V0U3VidHJlZSA9IChpbnN0YW5jZSkgPT4ge1xuICBjb25zdCBzdWJUcmVlID0gaW5zdGFuY2Uuc3ViVHJlZTtcbiAgcmV0dXJuIHN1YlRyZWUuY29tcG9uZW50ID8gcmVjdXJzaXZlR2V0U3VidHJlZShzdWJUcmVlLmNvbXBvbmVudCkgOiBzdWJUcmVlO1xufTtcbmNvbnN0IEJhc2VUcmFuc2l0aW9uSW1wbCA9IHtcbiAgbmFtZTogYEJhc2VUcmFuc2l0aW9uYCxcbiAgcHJvcHM6IEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLFxuICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSwgdHJ1ZSk7XG4gICAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGQgPSBmaW5kTm9uQ29tbWVudENoaWxkKGNoaWxkcmVuKTtcbiAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xuICAgICAgY29uc3QgeyBtb2RlIH0gPSByYXdQcm9wcztcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG1vZGUgJiYgbW9kZSAhPT0gXCJpbi1vdXRcIiAmJiBtb2RlICE9PSBcIm91dC1pblwiICYmIG1vZGUgIT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgIHdhcm4kMShgaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJHttb2RlfWApO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmlzTGVhdmluZykge1xuICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbm5lckNoaWxkID0gZ2V0SW5uZXJDaGlsZCQxKGNoaWxkKTtcbiAgICAgIGlmICghaW5uZXJDaGlsZCkge1xuICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICB9XG4gICAgICBsZXQgZW50ZXJIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgIGlubmVyQ2hpbGQsXG4gICAgICAgIHJhd1Byb3BzLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIC8vICMxMTA2MSwgZW5zdXJlIGVudGVySG9va3MgaXMgZnJlc2ggYWZ0ZXIgY2xvbmVcbiAgICAgICAgKGhvb2tzKSA9PiBlbnRlckhvb2tzID0gaG9va3NcbiAgICAgICk7XG4gICAgICBzZXRUcmFuc2l0aW9uSG9va3MoaW5uZXJDaGlsZCwgZW50ZXJIb29rcyk7XG4gICAgICBjb25zdCBvbGRDaGlsZCA9IGluc3RhbmNlLnN1YlRyZWU7XG4gICAgICBjb25zdCBvbGRJbm5lckNoaWxkID0gb2xkQ2hpbGQgJiYgZ2V0SW5uZXJDaGlsZCQxKG9sZENoaWxkKTtcbiAgICAgIGlmIChvbGRJbm5lckNoaWxkICYmIG9sZElubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCAmJiAhaXNTYW1lVk5vZGVUeXBlKGlubmVyQ2hpbGQsIG9sZElubmVyQ2hpbGQpICYmIHJlY3Vyc2l2ZUdldFN1YnRyZWUoaW5zdGFuY2UpLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgY29uc3QgbGVhdmluZ0hvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICBvbGRJbm5lckNoaWxkLFxuICAgICAgICAgIHJhd1Byb3BzLFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICk7XG4gICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhvbGRJbm5lckNoaWxkLCBsZWF2aW5nSG9va3MpO1xuICAgICAgICBpZiAobW9kZSA9PT0gXCJvdXQtaW5cIiAmJiBpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgIGxlYXZpbmdIb29rcy5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIShpbnN0YW5jZS5qb2IuZmxhZ3MgJiA4KSkge1xuICAgICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBcImluLW91dFwiICYmIGlubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICAgIGxlYXZpbmdIb29rcy5kZWxheUxlYXZlID0gKGVsLCBlYXJseVJlbW92ZSwgZGVsYXllZExlYXZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgb2xkSW5uZXJDaGlsZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtTdHJpbmcob2xkSW5uZXJDaGlsZC5rZXkpXSA9IG9sZElubmVyQ2hpbGQ7XG4gICAgICAgICAgICBlbFtsZWF2ZUNiS2V5XSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgZWFybHlSZW1vdmUoKTtcbiAgICAgICAgICAgICAgZWxbbGVhdmVDYktleV0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGRlbGV0ZSBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZSA9IGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZpbmROb25Db21tZW50Q2hpbGQoY2hpbGRyZW4pIHtcbiAgbGV0IGNoaWxkID0gY2hpbGRyZW5bMF07XG4gIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgbGV0IGhhc0ZvdW5kID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBjIG9mIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoYy50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGhhc0ZvdW5kKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgXCI8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50IG9yIGNvbXBvbmVudC4gVXNlIDx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gYztcbiAgICAgICAgaGFzRm91bmQgPSB0cnVlO1xuICAgICAgICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGQ7XG59XG5jb25zdCBCYXNlVHJhbnNpdGlvbiA9IEJhc2VUcmFuc2l0aW9uSW1wbDtcbmZ1bmN0aW9uIGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKSB7XG4gIGNvbnN0IHsgbGVhdmluZ1ZOb2RlcyB9ID0gc3RhdGU7XG4gIGxldCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBsZWF2aW5nVk5vZGVzLmdldCh2bm9kZS50eXBlKTtcbiAgaWYgKCFsZWF2aW5nVk5vZGVzQ2FjaGUpIHtcbiAgICBsZWF2aW5nVk5vZGVzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZWF2aW5nVk5vZGVzLnNldCh2bm9kZS50eXBlLCBsZWF2aW5nVk5vZGVzQ2FjaGUpO1xuICB9XG4gIHJldHVybiBsZWF2aW5nVk5vZGVzQ2FjaGU7XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlLCBwb3N0Q2xvbmUpIHtcbiAgY29uc3Qge1xuICAgIGFwcGVhcixcbiAgICBtb2RlLFxuICAgIHBlcnNpc3RlZCA9IGZhbHNlLFxuICAgIG9uQmVmb3JlRW50ZXIsXG4gICAgb25FbnRlcixcbiAgICBvbkFmdGVyRW50ZXIsXG4gICAgb25FbnRlckNhbmNlbGxlZCxcbiAgICBvbkJlZm9yZUxlYXZlLFxuICAgIG9uTGVhdmUsXG4gICAgb25BZnRlckxlYXZlLFxuICAgIG9uTGVhdmVDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVBcHBlYXIsXG4gICAgb25BcHBlYXIsXG4gICAgb25BZnRlckFwcGVhcixcbiAgICBvbkFwcGVhckNhbmNlbGxlZFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGtleSA9IFN0cmluZyh2bm9kZS5rZXkpO1xuICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSk7XG4gIGNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcbiAgICBob29rICYmIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgaG9vayxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgOSxcbiAgICAgIGFyZ3NcbiAgICApO1xuICB9O1xuICBjb25zdCBjYWxsQXN5bmNIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcbiAgICBjb25zdCBkb25lID0gYXJnc1sxXTtcbiAgICBjYWxsSG9vayhob29rLCBhcmdzKTtcbiAgICBpZiAoaXNBcnJheShob29rKSkge1xuICAgICAgaWYgKGhvb2suZXZlcnkoKGhvb2syKSA9PiBob29rMi5sZW5ndGggPD0gMSkpIGRvbmUoKTtcbiAgICB9IGVsc2UgaWYgKGhvb2subGVuZ3RoIDw9IDEpIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhvb2tzID0ge1xuICAgIG1vZGUsXG4gICAgcGVyc2lzdGVkLFxuICAgIGJlZm9yZUVudGVyKGVsKSB7XG4gICAgICBsZXQgaG9vayA9IG9uQmVmb3JlRW50ZXI7XG4gICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgICAgaG9vayA9IG9uQmVmb3JlQXBwZWFyIHx8IG9uQmVmb3JlRW50ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWxbbGVhdmVDYktleV0pIHtcbiAgICAgICAgZWxbbGVhdmVDYktleV0oXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICAgIC8qIGNhbmNlbGxlZCAqL1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgbGVhdmluZ1ZOb2RlID0gbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV07XG4gICAgICBpZiAobGVhdmluZ1ZOb2RlICYmIGlzU2FtZVZOb2RlVHlwZSh2bm9kZSwgbGVhdmluZ1ZOb2RlKSAmJiBsZWF2aW5nVk5vZGUuZWxbbGVhdmVDYktleV0pIHtcbiAgICAgICAgbGVhdmluZ1ZOb2RlLmVsW2xlYXZlQ2JLZXldKCk7XG4gICAgICB9XG4gICAgICBjYWxsSG9vayhob29rLCBbZWxdKTtcbiAgICB9LFxuICAgIGVudGVyKGVsKSB7XG4gICAgICBsZXQgaG9vayA9IG9uRW50ZXI7XG4gICAgICBsZXQgYWZ0ZXJIb29rID0gb25BZnRlckVudGVyO1xuICAgICAgbGV0IGNhbmNlbEhvb2sgPSBvbkVudGVyQ2FuY2VsbGVkO1xuICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgaWYgKGFwcGVhcikge1xuICAgICAgICAgIGhvb2sgPSBvbkFwcGVhciB8fCBvbkVudGVyO1xuICAgICAgICAgIGFmdGVySG9vayA9IG9uQWZ0ZXJBcHBlYXIgfHwgb25BZnRlckVudGVyO1xuICAgICAgICAgIGNhbmNlbEhvb2sgPSBvbkFwcGVhckNhbmNlbGxlZCB8fCBvbkVudGVyQ2FuY2VsbGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgZG9uZSA9IGVsW2VudGVyQ2JLZXldID0gKGNhbmNlbGxlZCkgPT4ge1xuICAgICAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICBjYWxsSG9vayhjYW5jZWxIb29rLCBbZWxdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsSG9vayhhZnRlckhvb2ssIFtlbF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5kZWxheWVkTGVhdmUpIHtcbiAgICAgICAgICBob29rcy5kZWxheWVkTGVhdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbFtlbnRlckNiS2V5XSA9IHZvaWQgMDtcbiAgICAgIH07XG4gICAgICBpZiAoaG9vaykge1xuICAgICAgICBjYWxsQXN5bmNIb29rKGhvb2ssIFtlbCwgZG9uZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGVhdmUoZWwsIHJlbW92ZSkge1xuICAgICAgY29uc3Qga2V5MiA9IFN0cmluZyh2bm9kZS5rZXkpO1xuICAgICAgaWYgKGVsW2VudGVyQ2JLZXldKSB7XG4gICAgICAgIGVsW2VudGVyQ2JLZXldKFxuICAgICAgICAgIHRydWVcbiAgICAgICAgICAvKiBjYW5jZWxsZWQgKi9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5pc1VubW91bnRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2sob25CZWZvcmVMZWF2ZSwgW2VsXSk7XG4gICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBkb25lID0gZWxbbGVhdmVDYktleV0gPSAoY2FuY2VsbGVkKSA9PiB7XG4gICAgICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsSG9vayhvbkFmdGVyTGVhdmUsIFtlbF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsW2xlYXZlQ2JLZXldID0gdm9pZCAwO1xuICAgICAgICBpZiAobGVhdmluZ1ZOb2Rlc0NhY2hlW2tleTJdID09PSB2bm9kZSkge1xuICAgICAgICAgIGRlbGV0ZSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5Ml07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5Ml0gPSB2bm9kZTtcbiAgICAgIGlmIChvbkxlYXZlKSB7XG4gICAgICAgIGNhbGxBc3luY0hvb2sob25MZWF2ZSwgW2VsLCBkb25lXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9uZSh2bm9kZTIpIHtcbiAgICAgIGNvbnN0IGhvb2tzMiA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgIHZub2RlMixcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgcG9zdENsb25lXG4gICAgICApO1xuICAgICAgaWYgKHBvc3RDbG9uZSkgcG9zdENsb25lKGhvb2tzMik7XG4gICAgICByZXR1cm4gaG9va3MyO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhvb2tzO1xufVxuZnVuY3Rpb24gZW1wdHlQbGFjZWhvbGRlcih2bm9kZSkge1xuICBpZiAoaXNLZWVwQWxpdmUodm5vZGUpKSB7XG4gICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB2bm9kZS5jaGlsZHJlbiA9IG51bGw7XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRJbm5lckNoaWxkJDEodm5vZGUpIHtcbiAgaWYgKCFpc0tlZXBBbGl2ZSh2bm9kZSkpIHtcbiAgICBpZiAoaXNUZWxlcG9ydCh2bm9kZS50eXBlKSAmJiB2bm9kZS5jaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGZpbmROb25Db21tZW50Q2hpbGQodm5vZGUuY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdm5vZGUuY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlO1xuICB9XG4gIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgMzIgJiYgaXNGdW5jdGlvbihjaGlsZHJlbi5kZWZhdWx0KSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuLmRlZmF1bHQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgaG9va3MpIHtcbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgJiYgdm5vZGUuY29tcG9uZW50KSB7XG4gICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBob29rcyk7XG4gIH0gZWxzZSBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgdm5vZGUuc3NDb250ZW50LnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0NvbnRlbnQpO1xuICAgIHZub2RlLnNzRmFsbGJhY2sudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzRmFsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHZub2RlLnRyYW5zaXRpb24gPSBob29rcztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkcmVuLCBrZWVwQ29tbWVudCA9IGZhbHNlLCBwYXJlbnRLZXkpIHtcbiAgbGV0IHJldCA9IFtdO1xuICBsZXQga2V5ZWRGcmFnbWVudENvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IGtleSA9IHBhcmVudEtleSA9PSBudWxsID8gY2hpbGQua2V5IDogU3RyaW5nKHBhcmVudEtleSkgKyBTdHJpbmcoY2hpbGQua2V5ICE9IG51bGwgPyBjaGlsZC5rZXkgOiBpKTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGlmIChjaGlsZC5wYXRjaEZsYWcgJiAxMjgpIGtleWVkRnJhZ21lbnRDb3VudCsrO1xuICAgICAgcmV0ID0gcmV0LmNvbmNhdChcbiAgICAgICAgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkLmNoaWxkcmVuLCBrZWVwQ29tbWVudCwga2V5KVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGtlZXBDb21tZW50IHx8IGNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgIHJldC5wdXNoKGtleSAhPSBudWxsID8gY2xvbmVWTm9kZShjaGlsZCwgeyBrZXkgfSkgOiBjaGlsZCk7XG4gICAgfVxuICB9XG4gIGlmIChrZXllZEZyYWdtZW50Q291bnQgPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldFtpXS5wYXRjaEZsYWcgPSAtMjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucykge1xuICByZXR1cm4gaXNGdW5jdGlvbihvcHRpb25zKSA/IChcbiAgICAvLyAjODMyNjogZXh0ZW5kIGNhbGwgYW5kIG9wdGlvbnMubmFtZSBhY2Nlc3MgYXJlIGNvbnNpZGVyZWQgc2lkZS1lZmZlY3RzXG4gICAgLy8gYnkgUm9sbHVwLCBzbyB3ZSBoYXZlIHRvIHdyYXAgaXQgaW4gYSBwdXJlLWFubm90YXRlZCBJSUZFLlxuICAgIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZXh0ZW5kKHsgbmFtZTogb3B0aW9ucy5uYW1lIH0sIGV4dHJhT3B0aW9ucywgeyBzZXR1cDogb3B0aW9ucyB9KSkoKVxuICApIDogb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gdXNlSWQoKSB7XG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKGkpIHtcbiAgICByZXR1cm4gKGkuYXBwQ29udGV4dC5jb25maWcuaWRQcmVmaXggfHwgXCJ2XCIpICsgXCI6XCIgKyBpLmlkc1swXSArIGkuaWRzWzFdKys7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShcbiAgICAgIGB1c2VJZCgpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLmBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrQXN5bmNCb3VuZGFyeShpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5pZHMgPSBbaW5zdGFuY2UuaWRzWzBdICsgaW5zdGFuY2UuaWRzWzJdKysgKyBcIi1cIiwgMCwgMF07XG59XG5cbmZ1bmN0aW9uIHNldFJlZihyYXdSZWYsIG9sZFJhd1JlZiwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCBpc1VubW91bnQgPSBmYWxzZSkge1xuICBpZiAoaXNBcnJheShyYXdSZWYpKSB7XG4gICAgcmF3UmVmLmZvckVhY2goXG4gICAgICAociwgaSkgPT4gc2V0UmVmKFxuICAgICAgICByLFxuICAgICAgICBvbGRSYXdSZWYgJiYgKGlzQXJyYXkob2xkUmF3UmVmKSA/IG9sZFJhd1JlZltpXSA6IG9sZFJhd1JlZiksXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgaXNVbm1vdW50XG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSAmJiAhaXNVbm1vdW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlZlZhbHVlID0gdm5vZGUuc2hhcGVGbGFnICYgNCA/IGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKHZub2RlLmNvbXBvbmVudCkgOiB2bm9kZS5lbDtcbiAgY29uc3QgdmFsdWUgPSBpc1VubW91bnQgPyBudWxsIDogcmVmVmFsdWU7XG4gIGNvbnN0IHsgaTogb3duZXIsIHI6IHJlZiB9ID0gcmF3UmVmO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhb3duZXIpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgTWlzc2luZyByZWYgb3duZXIgY29udGV4dC4gcmVmIGNhbm5vdCBiZSB1c2VkIG9uIGhvaXN0ZWQgdm5vZGVzLiBBIHZub2RlIHdpdGggcmVmIG11c3QgYmUgY3JlYXRlZCBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbi5gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb2xkUmVmID0gb2xkUmF3UmVmICYmIG9sZFJhd1JlZi5yO1xuICBjb25zdCByZWZzID0gb3duZXIucmVmcyA9PT0gRU1QVFlfT0JKID8gb3duZXIucmVmcyA9IHt9IDogb3duZXIucmVmcztcbiAgY29uc3Qgc2V0dXBTdGF0ZSA9IG93bmVyLnNldHVwU3RhdGU7XG4gIGlmIChvbGRSZWYgIT0gbnVsbCAmJiBvbGRSZWYgIT09IHJlZikge1xuICAgIGlmIChpc1N0cmluZyhvbGRSZWYpKSB7XG4gICAgICByZWZzW29sZFJlZl0gPSBudWxsO1xuICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCBvbGRSZWYpKSB7XG4gICAgICAgIHNldHVwU3RhdGVbb2xkUmVmXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1JlZihvbGRSZWYpKSB7XG4gICAgICBvbGRSZWYudmFsdWUgPSBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAoaXNGdW5jdGlvbihyZWYpKSB7XG4gICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKHJlZiwgb3duZXIsIDEyLCBbdmFsdWUsIHJlZnNdKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBfaXNTdHJpbmcgPSBpc1N0cmluZyhyZWYpO1xuICAgIGNvbnN0IF9pc1JlZiA9IGlzUmVmKHJlZik7XG4gICAgaWYgKF9pc1N0cmluZyB8fCBfaXNSZWYpIHtcbiAgICAgIGNvbnN0IGRvU2V0ID0gKCkgPT4ge1xuICAgICAgICBpZiAocmF3UmVmLmYpIHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IF9pc1N0cmluZyA/IGhhc093bihzZXR1cFN0YXRlLCByZWYpID8gc2V0dXBTdGF0ZVtyZWZdIDogcmVmc1tyZWZdIDogcmVmLnZhbHVlO1xuICAgICAgICAgIGlmIChpc1VubW91bnQpIHtcbiAgICAgICAgICAgIGlzQXJyYXkoZXhpc3RpbmcpICYmIHJlbW92ZShleGlzdGluZywgcmVmVmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkoZXhpc3RpbmcpKSB7XG4gICAgICAgICAgICAgIGlmIChfaXNTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZWZzW3JlZl0gPSBbcmVmVmFsdWVdO1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd24oc2V0dXBTdGF0ZSwgcmVmKSkge1xuICAgICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gcmVmc1tyZWZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWYudmFsdWUgPSBbcmVmVmFsdWVdO1xuICAgICAgICAgICAgICAgIGlmIChyYXdSZWYuaykgcmVmc1tyYXdSZWYua10gPSByZWYudmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWV4aXN0aW5nLmluY2x1ZGVzKHJlZlZhbHVlKSkge1xuICAgICAgICAgICAgICBleGlzdGluZy5wdXNoKHJlZlZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX2lzU3RyaW5nKSB7XG4gICAgICAgICAgcmVmc1tyZWZdID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCByZWYpKSB7XG4gICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX2lzUmVmKSB7XG4gICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKHJhd1JlZi5rKSByZWZzW3Jhd1JlZi5rXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXCJJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOlwiLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkb1NldC5pZCA9IC0xO1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZG9TZXQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvU2V0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuJDEoXCJJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOlwiLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcbiAgICB9XG4gIH1cbn1cblxubGV0IGhhc0xvZ2dlZE1pc21hdGNoRXJyb3IgPSBmYWxzZTtcbmNvbnN0IGxvZ01pc21hdGNoRXJyb3IgPSAoKSA9PiB7XG4gIGlmIChoYXNMb2dnZWRNaXNtYXRjaEVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUuZXJyb3IoXCJIeWRyYXRpb24gY29tcGxldGVkIGJ1dCBjb250YWlucyBtaXNtYXRjaGVzLlwiKTtcbiAgaGFzTG9nZ2VkTWlzbWF0Y2hFcnJvciA9IHRydWU7XG59O1xuY29uc3QgaXNTVkdDb250YWluZXIgPSAoY29udGFpbmVyKSA9PiBjb250YWluZXIubmFtZXNwYWNlVVJJLmluY2x1ZGVzKFwic3ZnXCIpICYmIGNvbnRhaW5lci50YWdOYW1lICE9PSBcImZvcmVpZ25PYmplY3RcIjtcbmNvbnN0IGlzTWF0aE1MQ29udGFpbmVyID0gKGNvbnRhaW5lcikgPT4gY29udGFpbmVyLm5hbWVzcGFjZVVSSS5pbmNsdWRlcyhcIk1hdGhNTFwiKTtcbmNvbnN0IGdldENvbnRhaW5lclR5cGUgPSAoY29udGFpbmVyKSA9PiB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgIT09IDEpIHJldHVybiB2b2lkIDA7XG4gIGlmIChpc1NWR0NvbnRhaW5lcihjb250YWluZXIpKSByZXR1cm4gXCJzdmdcIjtcbiAgaWYgKGlzTWF0aE1MQ29udGFpbmVyKGNvbnRhaW5lcikpIHJldHVybiBcIm1hdGhtbFwiO1xuICByZXR1cm4gdm9pZCAwO1xufTtcbmNvbnN0IGlzQ29tbWVudCA9IChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4O1xuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gIGNvbnN0IHtcbiAgICBtdDogbW91bnRDb21wb25lbnQsXG4gICAgcDogcGF0Y2gsXG4gICAgbzoge1xuICAgICAgcGF0Y2hQcm9wLFxuICAgICAgY3JlYXRlVGV4dCxcbiAgICAgIG5leHRTaWJsaW5nLFxuICAgICAgcGFyZW50Tm9kZSxcbiAgICAgIHJlbW92ZSxcbiAgICAgIGluc2VydCxcbiAgICAgIGNyZWF0ZUNvbW1lbnRcbiAgICB9XG4gIH0gPSByZW5kZXJlckludGVybmFscztcbiAgY29uc3QgaHlkcmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyKSA9PiB7XG4gICAgaWYgKCFjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIHdhcm4kMShcbiAgICAgICAgYEF0dGVtcHRpbmcgdG8gaHlkcmF0ZSBleGlzdGluZyBtYXJrdXAgYnV0IGNvbnRhaW5lciBpcyBlbXB0eS4gUGVyZm9ybWluZyBmdWxsIG1vdW50IGluc3RlYWQuYFxuICAgICAgKTtcbiAgICAgIHBhdGNoKG51bGwsIHZub2RlLCBjb250YWluZXIpO1xuICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaHlkcmF0ZU5vZGUoY29udGFpbmVyLmZpcnN0Q2hpbGQsIHZub2RlLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZU5vZGUgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISF2bm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgY29uc3QgaXNGcmFnbWVudFN0YXJ0ID0gaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gXCJbXCI7XG4gICAgY29uc3Qgb25NaXNtYXRjaCA9ICgpID0+IGhhbmRsZU1pc21hdGNoKFxuICAgICAgbm9kZSxcbiAgICAgIHZub2RlLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBzbG90U2NvcGVJZHMsXG4gICAgICBpc0ZyYWdtZW50U3RhcnRcbiAgICApO1xuICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcsIHBhdGNoRmxhZyB9ID0gdm5vZGU7XG4gICAgbGV0IGRvbVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgIHZub2RlLmVsID0gbm9kZTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRlZihub2RlLCBcIl9fdm5vZGVcIiwgdm5vZGUsIHRydWUpO1xuICAgICAgZGVmKG5vZGUsIFwiX192dWVQYXJlbnRDb21wb25lbnRcIiwgcGFyZW50Q29tcG9uZW50LCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHBhdGNoRmxhZyA9PT0gLTIpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IG5leHROb2RlID0gbnVsbDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgVGV4dDpcbiAgICAgICAgaWYgKGRvbVR5cGUgIT09IDMpIHtcbiAgICAgICAgICBpZiAodm5vZGUuY2hpbGRyZW4gPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGluc2VydCh2bm9kZS5lbCA9IGNyZWF0ZVRleHQoXCJcIiksIHBhcmVudE5vZGUobm9kZSksIG5vZGUpO1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBub2RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG5vZGUuZGF0YSAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgd2FybiQxKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIHRleHQgbWlzbWF0Y2ggaW5gLFxuICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgIGBcbiAgLSByZW5kZXJlZCBvbiBzZXJ2ZXI6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhXG4gICAgICAgICAgICAgICl9XG4gIC0gZXhwZWN0ZWQgb24gY2xpZW50OiAke0pTT04uc3RyaW5naWZ5KHZub2RlLmNoaWxkcmVuKX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbW1lbnQ6XG4gICAgICAgIGlmIChpc1RlbXBsYXRlTm9kZShub2RlKSkge1xuICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgcmVwbGFjZU5vZGUoXG4gICAgICAgICAgICB2bm9kZS5lbCA9IG5vZGUuY29udGVudC5maXJzdENoaWxkLFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoZG9tVHlwZSAhPT0gOCB8fCBpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0aWM6XG4gICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBub2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgZG9tVHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbVR5cGUgPT09IDEgfHwgZG9tVHlwZSA9PT0gMykge1xuICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcbiAgICAgICAgICBjb25zdCBuZWVkVG9BZG9wdENvbnRlbnQgPSAhdm5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuc3RhdGljQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5lZWRUb0Fkb3B0Q29udGVudClcbiAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4gKz0gbmV4dE5vZGUubm9kZVR5cGUgPT09IDEgPyBuZXh0Tm9kZS5vdXRlckhUTUwgOiBuZXh0Tm9kZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGkgPT09IHZub2RlLnN0YXRpY0NvdW50IC0gMSkge1xuICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobmV4dE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXNGcmFnbWVudFN0YXJ0ID8gbmV4dFNpYmxpbmcobmV4dE5vZGUpIDogbmV4dE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25NaXNtYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgaWYgKCFpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVGcmFnbWVudChcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxKSB7XG4gICAgICAgICAgaWYgKChkb21UeXBlICE9PSAxIHx8IHZub2RlLnR5cGUudG9Mb3dlckNhc2UoKSAhPT0gbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmICFpc1RlbXBsYXRlTm9kZShub2RlKSkge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgICAgIHZub2RlLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcbiAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gbG9jYXRlQ2xvc2luZ0FuY2hvcihub2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwidGVsZXBvcnQgc3RhcnRcIikge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBsb2NhdGVDbG9zaW5nQW5jaG9yKG5vZGUsIG5vZGUuZGF0YSwgXCJ0ZWxlcG9ydCBlbmRcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vdW50Q29tcG9uZW50KFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBnZXRDb250YWluZXJUeXBlKGNvbnRhaW5lciksXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkpIHtcbiAgICAgICAgICAgIGxldCBzdWJUcmVlO1xuICAgICAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgICAgICBzdWJUcmVlID0gY3JlYXRlVk5vZGUoRnJhZ21lbnQpO1xuICAgICAgICAgICAgICBzdWJUcmVlLmFuY2hvciA9IG5leHROb2RlID8gbmV4dE5vZGUucHJldmlvdXNTaWJsaW5nIDogY29udGFpbmVyLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1YlRyZWUgPSBub2RlLm5vZGVUeXBlID09PSAzID8gY3JlYXRlVGV4dFZOb2RlKFwiXCIpIDogY3JlYXRlVk5vZGUoXCJkaXZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJUcmVlLmVsID0gbm9kZTtcbiAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlID0gc3ViVHJlZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCkge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKFxuICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICAgIHJlbmRlcmVySW50ZXJuYWxzLFxuICAgICAgICAgICAgICBoeWRyYXRlQ2hpbGRyZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBnZXRDb250YWluZXJUeXBlKHBhcmVudE5vZGUobm9kZSkpLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgICAgICAgICBoeWRyYXRlTm9kZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pIHtcbiAgICAgICAgICB3YXJuJDEoXCJJbnZhbGlkIEhvc3RWTm9kZSB0eXBlOlwiLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHROb2RlO1xuICB9O1xuICBjb25zdCBoeWRyYXRlRWxlbWVudCA9IChlbCwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHBhdGNoRmxhZywgc2hhcGVGbGFnLCBkaXJzLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcbiAgICBjb25zdCBmb3JjZVBhdGNoID0gdHlwZSA9PT0gXCJpbnB1dFwiIHx8IHR5cGUgPT09IFwib3B0aW9uXCI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgZm9yY2VQYXRjaCB8fCBwYXRjaEZsYWcgIT09IC0xKSB7XG4gICAgICBpZiAoZGlycykge1xuICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiY3JlYXRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyA9IGZhbHNlO1xuICAgICAgaWYgKGlzVGVtcGxhdGVOb2RlKGVsKSkge1xuICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyA9IG5lZWRUcmFuc2l0aW9uKHBhcmVudFN1c3BlbnNlLCB0cmFuc2l0aW9uKSAmJiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnZub2RlLnByb3BzICYmIHBhcmVudENvbXBvbmVudC52bm9kZS5wcm9wcy5hcHBlYXI7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlbC5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xuICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZU5vZGUoY29udGVudCwgZWwsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgIHZub2RlLmVsID0gZWwgPSBjb250ZW50O1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2ICYmIC8vIHNraXAgaWYgZWxlbWVudCBoYXMgaW5uZXJIVE1MIC8gdGV4dENvbnRlbnRcbiAgICAgICEocHJvcHMgJiYgKHByb3BzLmlubmVySFRNTCB8fCBwcm9wcy50ZXh0Q29udGVudCkpKSB7XG4gICAgICAgIGxldCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgICAgIGVsLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICAgIGlmICghaXNNaXNtYXRjaEFsbG93ZWQoZWwsIDEgLyogQ0hJTERSRU4gKi8pKSB7XG4gICAgICAgICAgICBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiAhaGFzV2FybmVkKSB7XG4gICAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgICBgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIG9uYCxcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICBgXG5TZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBtb3JlIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjdXIgPSBuZXh0O1xuICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgIHJlbW92ZShjdXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgICAgaWYgKGVsLnRleHRDb250ZW50ICE9PSB2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIGlmICghaXNNaXNtYXRjaEFsbG93ZWQoZWwsIDAgLyogVEVYVCAqLykpIHtcbiAgICAgICAgICAgICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgd2FybiQxKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIHRleHQgY29udGVudCBtaXNtYXRjaCBvbmAsXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICBgXG4gIC0gcmVuZGVyZWQgb24gc2VydmVyOiAke2VsLnRleHRDb250ZW50fVxuICAtIGV4cGVjdGVkIG9uIGNsaWVudDogJHt2bm9kZS5jaGlsZHJlbn1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fIHx8IGZvcmNlUGF0Y2ggfHwgIW9wdGltaXplZCB8fCBwYXRjaEZsYWcgJiAoMTYgfCAzMikpIHtcbiAgICAgICAgICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBlbC50YWdOYW1lLmluY2x1ZGVzKFwiLVwiKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgLy8gIzExMTg5IHNraXAgaWYgdGhpcyBub2RlIGhhcyBkaXJlY3RpdmVzIHRoYXQgaGF2ZSBjcmVhdGVkIGhvb2tzXG4gICAgICAgICAgICAvLyBhcyBpdCBjb3VsZCBoYXZlIG11dGF0ZWQgdGhlIERPTSBpbiBhbnkgcG9zc2libGUgd2F5XG4gICAgICAgICAgICAhKGRpcnMgJiYgZGlycy5zb21lKChkKSA9PiBkLmRpci5jcmVhdGVkKSkgJiYgcHJvcEhhc01pc21hdGNoKGVsLCBrZXksIHByb3BzW2tleV0sIHZub2RlLCBwYXJlbnRDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JjZVBhdGNoICYmIChrZXkuZW5kc1dpdGgoXCJ2YWx1ZVwiKSB8fCBrZXkgPT09IFwiaW5kZXRlcm1pbmF0ZVwiKSB8fCBpc09uKGtleSkgJiYgIWlzUmVzZXJ2ZWRQcm9wKGtleSkgfHwgLy8gZm9yY2UgaHlkcmF0ZSB2LWJpbmQgd2l0aCAucHJvcCBtb2RpZmllcnNcbiAgICAgICAgICAgIGtleVswXSA9PT0gXCIuXCIgfHwgaXNDdXN0b21FbGVtZW50KSB7XG4gICAgICAgICAgICAgIHBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCB2b2lkIDAsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLm9uQ2xpY2spIHtcbiAgICAgICAgICBwYXRjaFByb3AoXG4gICAgICAgICAgICBlbCxcbiAgICAgICAgICAgIFwib25DbGlja1wiLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHByb3BzLm9uQ2xpY2ssXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHBhdGNoRmxhZyAmIDQgJiYgaXNSZWFjdGl2ZShwcm9wcy5zdHlsZSkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcy5zdHlsZSkgcHJvcHMuc3R5bGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHZub2RlSG9va3M7XG4gICAgICBpZiAodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkge1xuICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoZGlycykge1xuICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlTW91bnRcIik7XG4gICAgICB9XG4gICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHwgZGlycyB8fCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xuICAgICAgICBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZSgoKSA9PiB7XG4gICAgICAgICAgdm5vZGVIb29rcyAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgJiYgdHJhbnNpdGlvbi5lbnRlcihlbCk7XG4gICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwibW91bnRlZFwiKTtcbiAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWwubmV4dFNpYmxpbmc7XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVDaGlsZHJlbiA9IChub2RlLCBwYXJlbnRWTm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXBhcmVudFZOb2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFZOb2RlLmNoaWxkcmVuO1xuICAgIGNvbnN0IGwgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCB2bm9kZSA9IG9wdGltaXplZCA/IGNoaWxkcmVuW2ldIDogY2hpbGRyZW5baV0gPSBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSk7XG4gICAgICBjb25zdCBpc1RleHQgPSB2bm9kZS50eXBlID09PSBUZXh0O1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKGlzVGV4dCAmJiAhb3B0aW1pemVkKSB7XG4gICAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbltpICsgMV07XG4gICAgICAgICAgaWYgKG5leHQgJiYgKG5leHQgPSBub3JtYWxpemVWTm9kZShuZXh0KSkudHlwZSA9PT0gVGV4dCkge1xuICAgICAgICAgICAgaW5zZXJ0KFxuICAgICAgICAgICAgICBjcmVhdGVUZXh0KFxuICAgICAgICAgICAgICAgIG5vZGUuZGF0YS5zbGljZSh2bm9kZS5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgbmV4dFNpYmxpbmcobm9kZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IGh5ZHJhdGVOb2RlKFxuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNUZXh0ICYmICF2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICBpbnNlcnQodm5vZGUuZWwgPSBjcmVhdGVUZXh0KFwiXCIpLCBjb250YWluZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFpc01pc21hdGNoQWxsb3dlZChjb250YWluZXIsIDEgLyogQ0hJTERSRU4gKi8pKSB7XG4gICAgICAgICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgIWhhc1dhcm5lZCkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIG9uYCxcbiAgICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgICBgXG5TZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBmZXdlciBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgZ2V0Q29udGFpbmVyVHlwZShjb250YWluZXIpLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZUZyYWdtZW50ID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IHsgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gdm5vZGU7XG4gICAgaWYgKGZyYWdtZW50U2xvdFNjb3BlSWRzKSB7XG4gICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHMgPyBzbG90U2NvcGVJZHMuY29uY2F0KGZyYWdtZW50U2xvdFNjb3BlSWRzKSA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xuICAgIH1cbiAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgIGNvbnN0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICBuZXh0U2libGluZyhub2RlKSxcbiAgICAgIHZub2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBzbG90U2NvcGVJZHMsXG4gICAgICBvcHRpbWl6ZWRcbiAgICApO1xuICAgIGlmIChuZXh0ICYmIGlzQ29tbWVudChuZXh0KSAmJiBuZXh0LmRhdGEgPT09IFwiXVwiKSB7XG4gICAgICByZXR1cm4gbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yID0gbmV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgIGluc2VydCh2bm9kZS5hbmNob3IgPSBjcmVhdGVDb21tZW50KGBdYCksIGNvbnRhaW5lciwgbmV4dCk7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhhbmRsZU1pc21hdGNoID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnQpID0+IHtcbiAgICBpZiAoIWlzTWlzbWF0Y2hBbGxvd2VkKG5vZGUucGFyZW50RWxlbWVudCwgMSAvKiBDSElMRFJFTiAqLykpIHtcbiAgICAgICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgd2FybiQxKFxuICAgICAgICBgSHlkcmF0aW9uIG5vZGUgbWlzbWF0Y2g6XG4tIHJlbmRlcmVkIG9uIHNlcnZlcjpgLFxuICAgICAgICBub2RlLFxuICAgICAgICBub2RlLm5vZGVUeXBlID09PSAzID8gYCh0ZXh0KWAgOiBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcIltcIiA/IGAoc3RhcnQgb2YgZnJhZ21lbnQpYCA6IGBgLFxuICAgICAgICBgXG4tIGV4cGVjdGVkIG9uIGNsaWVudDpgLFxuICAgICAgICB2bm9kZS50eXBlXG4gICAgICApO1xuICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgIH1cbiAgICB2bm9kZS5lbCA9IG51bGw7XG4gICAgaWYgKGlzRnJhZ21lbnQpIHtcbiAgICAgIGNvbnN0IGVuZCA9IGxvY2F0ZUNsb3NpbmdBbmNob3Iobm9kZSk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBuZXh0MiA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICBpZiAobmV4dDIgJiYgbmV4dDIgIT09IGVuZCkge1xuICAgICAgICAgIHJlbW92ZShuZXh0Mik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgcmVtb3ZlKG5vZGUpO1xuICAgIHBhdGNoKFxuICAgICAgbnVsbCxcbiAgICAgIHZub2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgbmV4dCxcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgZ2V0Q29udGFpbmVyVHlwZShjb250YWluZXIpLFxuICAgICAgc2xvdFNjb3BlSWRzXG4gICAgKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfTtcbiAgY29uc3QgbG9jYXRlQ2xvc2luZ0FuY2hvciA9IChub2RlLCBvcGVuID0gXCJbXCIsIGNsb3NlID0gXCJdXCIpID0+IHtcbiAgICBsZXQgbWF0Y2ggPSAwO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBub2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICBpZiAobm9kZSAmJiBpc0NvbW1lbnQobm9kZSkpIHtcbiAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gb3BlbikgbWF0Y2grKztcbiAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gY2xvc2UpIHtcbiAgICAgICAgICBpZiAobWF0Y2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2gtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG4gIGNvbnN0IHJlcGxhY2VOb2RlID0gKG5ld05vZGUsIG9sZE5vZGUsIHBhcmVudENvbXBvbmVudCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudE5vZGUyID0gb2xkTm9kZS5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnROb2RlMikge1xuICAgICAgcGFyZW50Tm9kZTIucmVwbGFjZUNoaWxkKG5ld05vZGUsIG9sZE5vZGUpO1xuICAgIH1cbiAgICBsZXQgcGFyZW50ID0gcGFyZW50Q29tcG9uZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQudm5vZGUuZWwgPT09IG9sZE5vZGUpIHtcbiAgICAgICAgcGFyZW50LnZub2RlLmVsID0gcGFyZW50LnN1YlRyZWUuZWwgPSBuZXdOb2RlO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGlzVGVtcGxhdGVOb2RlID0gKG5vZGUpID0+IHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZW1wbGF0ZVwiO1xuICB9O1xuICByZXR1cm4gW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXTtcbn1cbmZ1bmN0aW9uIHByb3BIYXNNaXNtYXRjaChlbCwga2V5LCBjbGllbnRWYWx1ZSwgdm5vZGUsIGluc3RhbmNlKSB7XG4gIGxldCBtaXNtYXRjaFR5cGU7XG4gIGxldCBtaXNtYXRjaEtleTtcbiAgbGV0IGFjdHVhbDtcbiAgbGV0IGV4cGVjdGVkO1xuICBpZiAoa2V5ID09PSBcImNsYXNzXCIpIHtcbiAgICBhY3R1YWwgPSBlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICBleHBlY3RlZCA9IG5vcm1hbGl6ZUNsYXNzKGNsaWVudFZhbHVlKTtcbiAgICBpZiAoIWlzU2V0RXF1YWwodG9DbGFzc1NldChhY3R1YWwgfHwgXCJcIiksIHRvQ2xhc3NTZXQoZXhwZWN0ZWQpKSkge1xuICAgICAgbWlzbWF0Y2hUeXBlID0gMiAvKiBDTEFTUyAqLztcbiAgICAgIG1pc21hdGNoS2V5ID0gYGNsYXNzYDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICBhY3R1YWwgPSBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSB8fCBcIlwiO1xuICAgIGV4cGVjdGVkID0gaXNTdHJpbmcoY2xpZW50VmFsdWUpID8gY2xpZW50VmFsdWUgOiBzdHJpbmdpZnlTdHlsZShub3JtYWxpemVTdHlsZShjbGllbnRWYWx1ZSkpO1xuICAgIGNvbnN0IGFjdHVhbE1hcCA9IHRvU3R5bGVNYXAoYWN0dWFsKTtcbiAgICBjb25zdCBleHBlY3RlZE1hcCA9IHRvU3R5bGVNYXAoZXhwZWN0ZWQpO1xuICAgIGlmICh2bm9kZS5kaXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IHsgZGlyLCB2YWx1ZSB9IG9mIHZub2RlLmRpcnMpIHtcbiAgICAgICAgaWYgKGRpci5uYW1lID09PSBcInNob3dcIiAmJiAhdmFsdWUpIHtcbiAgICAgICAgICBleHBlY3RlZE1hcC5zZXQoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIHJlc29sdmVDc3NWYXJzKGluc3RhbmNlLCB2bm9kZSwgZXhwZWN0ZWRNYXApO1xuICAgIH1cbiAgICBpZiAoIWlzTWFwRXF1YWwoYWN0dWFsTWFwLCBleHBlY3RlZE1hcCkpIHtcbiAgICAgIG1pc21hdGNoVHlwZSA9IDMgLyogU1RZTEUgKi87XG4gICAgICBtaXNtYXRjaEtleSA9IFwic3R5bGVcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZWwgaW5zdGFuY2VvZiBTVkdFbGVtZW50ICYmIGlzS25vd25TdmdBdHRyKGtleSkgfHwgZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiAoaXNCb29sZWFuQXR0cihrZXkpIHx8IGlzS25vd25IdG1sQXR0cihrZXkpKSkge1xuICAgIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAgIGFjdHVhbCA9IGVsLmhhc0F0dHJpYnV0ZShrZXkpO1xuICAgICAgZXhwZWN0ZWQgPSBpbmNsdWRlQm9vbGVhbkF0dHIoY2xpZW50VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoY2xpZW50VmFsdWUgPT0gbnVsbCkge1xuICAgICAgYWN0dWFsID0gZWwuaGFzQXR0cmlidXRlKGtleSk7XG4gICAgICBleHBlY3RlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgYWN0dWFsID0gZWwuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJ2YWx1ZVwiICYmIGVsLnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgICBhY3R1YWwgPSBlbC52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdHVhbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZXhwZWN0ZWQgPSBpc1JlbmRlcmFibGVBdHRyVmFsdWUoY2xpZW50VmFsdWUpID8gU3RyaW5nKGNsaWVudFZhbHVlKSA6IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgICAgbWlzbWF0Y2hUeXBlID0gNCAvKiBBVFRSSUJVVEUgKi87XG4gICAgICBtaXNtYXRjaEtleSA9IGtleTtcbiAgICB9XG4gIH1cbiAgaWYgKG1pc21hdGNoVHlwZSAhPSBudWxsICYmICFpc01pc21hdGNoQWxsb3dlZChlbCwgbWlzbWF0Y2hUeXBlKSkge1xuICAgIGNvbnN0IGZvcm1hdCA9ICh2KSA9PiB2ID09PSBmYWxzZSA/IGAobm90IHJlbmRlcmVkKWAgOiBgJHttaXNtYXRjaEtleX09XCIke3Z9XCJgO1xuICAgIGNvbnN0IHByZVNlZ21lbnQgPSBgSHlkcmF0aW9uICR7TWlzbWF0Y2hUeXBlU3RyaW5nW21pc21hdGNoVHlwZV19IG1pc21hdGNoIG9uYDtcbiAgICBjb25zdCBwb3N0U2VnbWVudCA9IGBcbiAgLSByZW5kZXJlZCBvbiBzZXJ2ZXI6ICR7Zm9ybWF0KGFjdHVhbCl9XG4gIC0gZXhwZWN0ZWQgb24gY2xpZW50OiAke2Zvcm1hdChleHBlY3RlZCl9XG4gIE5vdGU6IHRoaXMgbWlzbWF0Y2ggaXMgY2hlY2stb25seS4gVGhlIERPTSB3aWxsIG5vdCBiZSByZWN0aWZpZWQgaW4gcHJvZHVjdGlvbiBkdWUgdG8gcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuXG4gIFlvdSBzaG91bGQgZml4IHRoZSBzb3VyY2Ugb2YgdGhlIG1pc21hdGNoLmA7XG4gICAge1xuICAgICAgd2FybiQxKHByZVNlZ21lbnQsIGVsLCBwb3N0U2VnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHRvQ2xhc3NTZXQoc3RyKSB7XG4gIHJldHVybiBuZXcgU2V0KHN0ci50cmltKCkuc3BsaXQoL1xccysvKSk7XG59XG5mdW5jdGlvbiBpc1NldEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgcyBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyhzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRvU3R5bGVNYXAoc3RyKSB7XG4gIGNvbnN0IHN0eWxlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIHN0ci5zcGxpdChcIjtcIikpIHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gaXRlbS5zcGxpdChcIjpcIik7XG4gICAga2V5ID0ga2V5LnRyaW0oKTtcbiAgICB2YWx1ZSA9IHZhbHVlICYmIHZhbHVlLnRyaW0oKTtcbiAgICBpZiAoa2V5ICYmIHZhbHVlKSB7XG4gICAgICBzdHlsZU1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZU1hcDtcbn1cbmZ1bmN0aW9uIGlzTWFwRXF1YWwoYSwgYikge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYSkge1xuICAgIGlmICh2YWx1ZSAhPT0gYi5nZXQoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVDc3NWYXJzKGluc3RhbmNlLCB2bm9kZSwgZXhwZWN0ZWRNYXApIHtcbiAgY29uc3Qgcm9vdCA9IGluc3RhbmNlLnN1YlRyZWU7XG4gIGlmIChpbnN0YW5jZS5nZXRDc3NWYXJzICYmICh2bm9kZSA9PT0gcm9vdCB8fCByb290ICYmIHJvb3QudHlwZSA9PT0gRnJhZ21lbnQgJiYgcm9vdC5jaGlsZHJlbi5pbmNsdWRlcyh2bm9kZSkpKSB7XG4gICAgY29uc3QgY3NzVmFycyA9IGluc3RhbmNlLmdldENzc1ZhcnMoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjc3NWYXJzKSB7XG4gICAgICBleHBlY3RlZE1hcC5zZXQoYC0tJHtrZXl9YCwgU3RyaW5nKGNzc1ZhcnNba2V5XSkpO1xuICAgIH1cbiAgfVxuICBpZiAodm5vZGUgPT09IHJvb3QgJiYgaW5zdGFuY2UucGFyZW50KSB7XG4gICAgcmVzb2x2ZUNzc1ZhcnMoaW5zdGFuY2UucGFyZW50LCBpbnN0YW5jZS52bm9kZSwgZXhwZWN0ZWRNYXApO1xuICB9XG59XG5jb25zdCBhbGxvd01pc21hdGNoQXR0ciA9IFwiZGF0YS1hbGxvdy1taXNtYXRjaFwiO1xuY29uc3QgTWlzbWF0Y2hUeXBlU3RyaW5nID0ge1xuICBbMCAvKiBURVhUICovXTogXCJ0ZXh0XCIsXG4gIFsxIC8qIENISUxEUkVOICovXTogXCJjaGlsZHJlblwiLFxuICBbMiAvKiBDTEFTUyAqL106IFwiY2xhc3NcIixcbiAgWzMgLyogU1RZTEUgKi9dOiBcInN0eWxlXCIsXG4gIFs0IC8qIEFUVFJJQlVURSAqL106IFwiYXR0cmlidXRlXCJcbn07XG5mdW5jdGlvbiBpc01pc21hdGNoQWxsb3dlZChlbCwgYWxsb3dlZFR5cGUpIHtcbiAgaWYgKGFsbG93ZWRUeXBlID09PSAwIC8qIFRFWFQgKi8gfHwgYWxsb3dlZFR5cGUgPT09IDEgLyogQ0hJTERSRU4gKi8pIHtcbiAgICB3aGlsZSAoZWwgJiYgIWVsLmhhc0F0dHJpYnV0ZShhbGxvd01pc21hdGNoQXR0cikpIHtcbiAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgICB9XG4gIH1cbiAgY29uc3QgYWxsb3dlZEF0dHIgPSBlbCAmJiBlbC5nZXRBdHRyaWJ1dGUoYWxsb3dNaXNtYXRjaEF0dHIpO1xuICBpZiAoYWxsb3dlZEF0dHIgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChhbGxvd2VkQXR0ciA9PT0gXCJcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxpc3QgPSBhbGxvd2VkQXR0ci5zcGxpdChcIixcIik7XG4gICAgaWYgKGFsbG93ZWRUeXBlID09PSAwIC8qIFRFWFQgKi8gJiYgbGlzdC5pbmNsdWRlcyhcImNoaWxkcmVuXCIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbG93ZWRBdHRyLnNwbGl0KFwiLFwiKS5pbmNsdWRlcyhNaXNtYXRjaFR5cGVTdHJpbmdbYWxsb3dlZFR5cGVdKTtcbiAgfVxufVxuXG5jb25zdCBoeWRyYXRlT25JZGxlID0gKHRpbWVvdXQgPSAxZTQpID0+IChoeWRyYXRlKSA9PiB7XG4gIGNvbnN0IGlkID0gcmVxdWVzdElkbGVDYWxsYmFjayhoeWRyYXRlLCB7IHRpbWVvdXQgfSk7XG4gIHJldHVybiAoKSA9PiBjYW5jZWxJZGxlQ2FsbGJhY2soaWQpO1xufTtcbmNvbnN0IGh5ZHJhdGVPblZpc2libGUgPSAob3B0cykgPT4gKGh5ZHJhdGUsIGZvckVhY2gpID0+IHtcbiAgY29uc3Qgb2IgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICBmb3IgKGNvbnN0IGUgb2YgZW50cmllcykge1xuICAgICAgaWYgKCFlLmlzSW50ZXJzZWN0aW5nKSBjb250aW51ZTtcbiAgICAgIG9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGh5ZHJhdGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSwgb3B0cyk7XG4gIGZvckVhY2goKGVsKSA9PiBvYi5vYnNlcnZlKGVsKSk7XG4gIHJldHVybiAoKSA9PiBvYi5kaXNjb25uZWN0KCk7XG59O1xuY29uc3QgaHlkcmF0ZU9uTWVkaWFRdWVyeSA9IChxdWVyeSkgPT4gKGh5ZHJhdGUpID0+IHtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgY29uc3QgbXFsID0gbWF0Y2hNZWRpYShxdWVyeSk7XG4gICAgaWYgKG1xbC5tYXRjaGVzKSB7XG4gICAgICBoeWRyYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1xbC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGh5ZHJhdGUsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgIHJldHVybiAoKSA9PiBtcWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoeWRyYXRlKTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBoeWRyYXRlT25JbnRlcmFjdGlvbiA9IChpbnRlcmFjdGlvbnMgPSBbXSkgPT4gKGh5ZHJhdGUsIGZvckVhY2gpID0+IHtcbiAgaWYgKGlzU3RyaW5nKGludGVyYWN0aW9ucykpIGludGVyYWN0aW9ucyA9IFtpbnRlcmFjdGlvbnNdO1xuICBsZXQgaGFzSHlkcmF0ZWQgPSBmYWxzZTtcbiAgY29uc3QgZG9IeWRyYXRlID0gKGUpID0+IHtcbiAgICBpZiAoIWhhc0h5ZHJhdGVkKSB7XG4gICAgICBoYXNIeWRyYXRlZCA9IHRydWU7XG4gICAgICB0ZWFyZG93bigpO1xuICAgICAgaHlkcmF0ZSgpO1xuICAgICAgZS50YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgZS5jb25zdHJ1Y3RvcihlLnR5cGUsIGUpKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHRlYXJkb3duID0gKCkgPT4ge1xuICAgIGZvckVhY2goKGVsKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGkgb2YgaW50ZXJhY3Rpb25zKSB7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoaSwgZG9IeWRyYXRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yRWFjaCgoZWwpID0+IHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgaW50ZXJhY3Rpb25zKSB7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGksIGRvSHlkcmF0ZSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0ZWFyZG93bjtcbn07XG5mdW5jdGlvbiBmb3JFYWNoRWxlbWVudChub2RlLCBjYikge1xuICBpZiAoaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gXCJbXCIpIHtcbiAgICBsZXQgZGVwdGggPSAxO1xuICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgY2IobmV4dCk7XG4gICAgICB9IGVsc2UgaWYgKGlzQ29tbWVudChuZXh0KSkge1xuICAgICAgICBpZiAobmV4dC5kYXRhID09PSBcIl1cIikge1xuICAgICAgICAgIGlmICgtLWRlcHRoID09PSAwKSBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0LmRhdGEgPT09IFwiW1wiKSB7XG4gICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNiKG5vZGUpO1xuICB9XG59XG5cbmNvbnN0IGlzQXN5bmNXcmFwcGVyID0gKGkpID0+ICEhaS50eXBlLl9fYXN5bmNMb2FkZXI7XG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBkZWZpbmVBc3luY0NvbXBvbmVudChzb3VyY2UpIHtcbiAgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgIHNvdXJjZSA9IHsgbG9hZGVyOiBzb3VyY2UgfTtcbiAgfVxuICBjb25zdCB7XG4gICAgbG9hZGVyLFxuICAgIGxvYWRpbmdDb21wb25lbnQsXG4gICAgZXJyb3JDb21wb25lbnQsXG4gICAgZGVsYXkgPSAyMDAsXG4gICAgaHlkcmF0ZTogaHlkcmF0ZVN0cmF0ZWd5LFxuICAgIHRpbWVvdXQsXG4gICAgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XG4gICAgc3VzcGVuc2libGUgPSB0cnVlLFxuICAgIG9uRXJyb3I6IHVzZXJPbkVycm9yXG4gIH0gPSBzb3VyY2U7XG4gIGxldCBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gIGxldCByZXNvbHZlZENvbXA7XG4gIGxldCByZXRyaWVzID0gMDtcbiAgY29uc3QgcmV0cnkgPSAoKSA9PiB7XG4gICAgcmV0cmllcysrO1xuICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICByZXR1cm4gbG9hZCgpO1xuICB9O1xuICBjb25zdCBsb2FkID0gKCkgPT4ge1xuICAgIGxldCB0aGlzUmVxdWVzdDtcbiAgICByZXR1cm4gcGVuZGluZ1JlcXVlc3QgfHwgKHRoaXNSZXF1ZXN0ID0gcGVuZGluZ1JlcXVlc3QgPSBsb2FkZXIoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBlcnIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XG4gICAgICBpZiAodXNlck9uRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25zdCB1c2VyUmV0cnkgPSAoKSA9PiByZXNvbHZlKHJldHJ5KCkpO1xuICAgICAgICAgIGNvbnN0IHVzZXJGYWlsID0gKCkgPT4gcmVqZWN0KGVycik7XG4gICAgICAgICAgdXNlck9uRXJyb3IoZXJyLCB1c2VyUmV0cnksIHVzZXJGYWlsLCByZXRyaWVzICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0pLnRoZW4oKGNvbXApID0+IHtcbiAgICAgIGlmICh0aGlzUmVxdWVzdCAhPT0gcGVuZGluZ1JlcXVlc3QgJiYgcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWNvbXApIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBBc3luYyBjb21wb25lbnQgbG9hZGVyIHJlc29sdmVkIHRvIHVuZGVmaW5lZC4gSWYgeW91IGFyZSB1c2luZyByZXRyeSgpLCBtYWtlIHN1cmUgdG8gcmV0dXJuIGl0cyByZXR1cm4gdmFsdWUuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXAgJiYgKGNvbXAuX19lc01vZHVsZSB8fCBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09IFwiTW9kdWxlXCIpKSB7XG4gICAgICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjb21wICYmICFpc09iamVjdChjb21wKSAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXN5bmMgY29tcG9uZW50IGxvYWQgcmVzdWx0OiAke2NvbXB9YCk7XG4gICAgICB9XG4gICAgICByZXNvbHZlZENvbXAgPSBjb21wO1xuICAgICAgcmV0dXJuIGNvbXA7XG4gICAgfSkpO1xuICB9O1xuICByZXR1cm4gZGVmaW5lQ29tcG9uZW50KHtcbiAgICBuYW1lOiBcIkFzeW5jQ29tcG9uZW50V3JhcHBlclwiLFxuICAgIF9fYXN5bmNMb2FkZXI6IGxvYWQsXG4gICAgX19hc3luY0h5ZHJhdGUoZWwsIGluc3RhbmNlLCBoeWRyYXRlKSB7XG4gICAgICBjb25zdCBkb0h5ZHJhdGUgPSBoeWRyYXRlU3RyYXRlZ3kgPyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlYXJkb3duID0gaHlkcmF0ZVN0cmF0ZWd5KFxuICAgICAgICAgIGh5ZHJhdGUsXG4gICAgICAgICAgKGNiKSA9PiBmb3JFYWNoRWxlbWVudChlbCwgY2IpXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0ZWFyZG93bikge1xuICAgICAgICAgIChpbnN0YW5jZS5idW0gfHwgKGluc3RhbmNlLmJ1bSA9IFtdKSkucHVzaCh0ZWFyZG93bik7XG4gICAgICAgIH1cbiAgICAgIH0gOiBoeWRyYXRlO1xuICAgICAgaWYgKHJlc29sdmVkQ29tcCkge1xuICAgICAgICBkb0h5ZHJhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWQoKS50aGVuKCgpID0+ICFpbnN0YW5jZS5pc1VubW91bnRlZCAmJiBkb0h5ZHJhdGUoKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQgX19hc3luY1Jlc29sdmVkKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVkQ29tcDtcbiAgICB9LFxuICAgIHNldHVwKCkge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICBtYXJrQXN5bmNCb3VuZGFyeShpbnN0YW5jZSk7XG4gICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBjcmVhdGVJbm5lckNvbXAocmVzb2x2ZWRDb21wLCBpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgICAgIGhhbmRsZUVycm9yKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAxMyxcbiAgICAgICAgICAhZXJyb3JDb21wb25lbnRcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBpZiAoc3VzcGVuc2libGUgJiYgaW5zdGFuY2Uuc3VzcGVuc2UgfHwgaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XG4gICAgICAgIHJldHVybiBsb2FkKCkudGhlbigoY29tcCkgPT4ge1xuICAgICAgICAgIHJldHVybiAoKSA9PiBjcmVhdGVJbm5lckNvbXAoY29tcCwgaW5zdGFuY2UpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybiAoKSA9PiBlcnJvckNvbXBvbmVudCA/IGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgfSkgOiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYWRlZCA9IHJlZihmYWxzZSk7XG4gICAgICBjb25zdCBlcnJvciA9IHJlZigpO1xuICAgICAgY29uc3QgZGVsYXllZCA9IHJlZighIWRlbGF5KTtcbiAgICAgIGlmIChkZWxheSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBkZWxheWVkLnZhbHVlID0gZmFsc2U7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFsb2FkZWQudmFsdWUgJiYgIWVycm9yLnZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBBc3luYyBjb21wb25lbnQgdGltZWQgb3V0IGFmdGVyICR7dGltZW91dH1tcy5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGxvYWQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgbG9hZGVkLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluc3RhbmNlLnBhcmVudCAmJiBpc0tlZXBBbGl2ZShpbnN0YW5jZS5wYXJlbnQudm5vZGUpKSB7XG4gICAgICAgICAgcXVldWVKb2IoaW5zdGFuY2UucGFyZW50LnVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGxvYWRlZC52YWx1ZSAmJiByZXNvbHZlZENvbXApIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnZhbHVlICYmIGVycm9yQ29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3IudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2FkaW5nQ29tcG9uZW50ICYmICFkZWxheWVkLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGxvYWRpbmdDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbm5lckNvbXAoY29tcCwgcGFyZW50KSB7XG4gIGNvbnN0IHsgcmVmOiByZWYyLCBwcm9wcywgY2hpbGRyZW4sIGNlIH0gPSBwYXJlbnQudm5vZGU7XG4gIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoY29tcCwgcHJvcHMsIGNoaWxkcmVuKTtcbiAgdm5vZGUucmVmID0gcmVmMjtcbiAgdm5vZGUuY2UgPSBjZTtcbiAgZGVsZXRlIHBhcmVudC52bm9kZS5jZTtcbiAgcmV0dXJuIHZub2RlO1xufVxuXG5jb25zdCBpc0tlZXBBbGl2ZSA9ICh2bm9kZSkgPT4gdm5vZGUudHlwZS5fX2lzS2VlcEFsaXZlO1xuY29uc3QgS2VlcEFsaXZlSW1wbCA9IHtcbiAgbmFtZTogYEtlZXBBbGl2ZWAsXG4gIC8vIE1hcmtlciBmb3Igc3BlY2lhbCBoYW5kbGluZyBpbnNpZGUgdGhlIHJlbmRlcmVyLiBXZSBhcmUgbm90IHVzaW5nIGEgPT09XG4gIC8vIGNoZWNrIGRpcmVjdGx5IG9uIEtlZXBBbGl2ZSBpbiB0aGUgcmVuZGVyZXIsIGJlY2F1c2UgaW1wb3J0aW5nIGl0IGRpcmVjdGx5XG4gIC8vIHdvdWxkIHByZXZlbnQgaXQgZnJvbSBiZWluZyB0cmVlLXNoYWtlbi5cbiAgX19pc0tlZXBBbGl2ZTogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcbiAgICBleGNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgY29uc3Qgc2hhcmVkQ29udGV4dCA9IGluc3RhbmNlLmN0eDtcbiAgICBpZiAoIXNoYXJlZENvbnRleHQucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCAmJiBzbG90cy5kZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgPyBjaGlsZHJlblswXSA6IGNoaWxkcmVuO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxldCBjdXJyZW50ID0gbnVsbDtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGluc3RhbmNlLl9fdl9jYWNoZSA9IGNhY2hlO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRTdXNwZW5zZSA9IGluc3RhbmNlLnN1c3BlbnNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlcmVyOiB7XG4gICAgICAgIHA6IHBhdGNoLFxuICAgICAgICBtOiBtb3ZlLFxuICAgICAgICB1bTogX3VubW91bnQsXG4gICAgICAgIG86IHsgY3JlYXRlRWxlbWVudCB9XG4gICAgICB9XG4gICAgfSA9IHNoYXJlZENvbnRleHQ7XG4gICAgY29uc3Qgc3RvcmFnZUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgc2hhcmVkQ29udGV4dC5hY3RpdmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIG5hbWVzcGFjZSwgb3B0aW1pemVkKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZTIgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICBtb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgMCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgcGF0Y2goXG4gICAgICAgIGluc3RhbmNlMi52bm9kZSxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBpbnN0YW5jZTIsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHZub2RlLnNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaW5zdGFuY2UyLmlzRGVhY3RpdmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGluc3RhbmNlMi5hKSB7XG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UyLmEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVNb3VudGVkO1xuICAgICAgICBpZiAodm5vZGVIb29rKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UyLnBhcmVudCwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZTIpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2hhcmVkQ29udGV4dC5kZWFjdGl2YXRlID0gKHZub2RlKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZTIgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICBpbnZhbGlkYXRlTW91bnQoaW5zdGFuY2UyLm0pO1xuICAgICAgaW52YWxpZGF0ZU1vdW50KGluc3RhbmNlMi5hKTtcbiAgICAgIG1vdmUodm5vZGUsIHN0b3JhZ2VDb250YWluZXIsIG51bGwsIDEsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpbnN0YW5jZTIuZGEpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZTIuZGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVVbm1vdW50ZWQ7XG4gICAgICAgIGlmICh2bm9kZUhvb2spIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZTIucGFyZW50LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UyLmlzRGVhY3RpdmF0ZWQgPSB0cnVlO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHVubW91bnQodm5vZGUpIHtcbiAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcbiAgICAgIF91bm1vdW50KHZub2RlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcnVuZUNhY2hlKGZpbHRlcikge1xuICAgICAgY2FjaGUuZm9yRWFjaCgodm5vZGUsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh2bm9kZS50eXBlKTtcbiAgICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5KGtleSkge1xuICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAoY2FjaGVkICYmICghY3VycmVudCB8fCAhaXNTYW1lVk5vZGVUeXBlKGNhY2hlZCwgY3VycmVudCkpKSB7XG4gICAgICAgIHVubW91bnQoY2FjaGVkKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudCkge1xuICAgICAgICByZXNldFNoYXBlRmxhZyhjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAga2V5cy5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgd2F0Y2goXG4gICAgICAoKSA9PiBbcHJvcHMuaW5jbHVkZSwgcHJvcHMuZXhjbHVkZV0sXG4gICAgICAoW2luY2x1ZGUsIGV4Y2x1ZGVdKSA9PiB7XG4gICAgICAgIGluY2x1ZGUgJiYgcHJ1bmVDYWNoZSgobmFtZSkgPT4gbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSk7XG4gICAgICAgIGV4Y2x1ZGUgJiYgcHJ1bmVDYWNoZSgobmFtZSkgPT4gIW1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpO1xuICAgICAgfSxcbiAgICAgIC8vIHBydW5lIHBvc3QtcmVuZGVyIGFmdGVyIGBjdXJyZW50YCBoYXMgYmVlbiB1cGRhdGVkXG4gICAgICB7IGZsdXNoOiBcInBvc3RcIiwgZGVlcDogdHJ1ZSB9XG4gICAgKTtcbiAgICBsZXQgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcbiAgICBjb25zdCBjYWNoZVN1YnRyZWUgPSAoKSA9PiB7XG4gICAgICBpZiAocGVuZGluZ0NhY2hlS2V5ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGlzU3VzcGVuc2UoaW5zdGFuY2Uuc3ViVHJlZS50eXBlKSkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBjYWNoZS5zZXQocGVuZGluZ0NhY2hlS2V5LCBnZXRJbm5lckNoaWxkKGluc3RhbmNlLnN1YlRyZWUpKTtcbiAgICAgICAgICB9LCBpbnN0YW5jZS5zdWJUcmVlLnN1c3BlbnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZS5zZXQocGVuZGluZ0NhY2hlS2V5LCBnZXRJbm5lckNoaWxkKGluc3RhbmNlLnN1YlRyZWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgb25Nb3VudGVkKGNhY2hlU3VidHJlZSk7XG4gICAgb25VcGRhdGVkKGNhY2hlU3VidHJlZSk7XG4gICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICAgIGNhY2hlLmZvckVhY2goKGNhY2hlZCkgPT4ge1xuICAgICAgICBjb25zdCB7IHN1YlRyZWUsIHN1c3BlbnNlIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgY29uc3Qgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHN1YlRyZWUpO1xuICAgICAgICBpZiAoY2FjaGVkLnR5cGUgPT09IHZub2RlLnR5cGUgJiYgY2FjaGVkLmtleSA9PT0gdm5vZGUua2V5KSB7XG4gICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xuICAgICAgICAgIGNvbnN0IGRhID0gdm5vZGUuY29tcG9uZW50LmRhO1xuICAgICAgICAgIGRhICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkYSwgc3VzcGVuc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcbiAgICAgIGlmICghc2xvdHMuZGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCgpO1xuICAgICAgY29uc3QgcmF3Vk5vZGUgPSBjaGlsZHJlblswXTtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKGBLZWVwQWxpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgY29tcG9uZW50IGNoaWxkLmApO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICB9IGVsc2UgaWYgKCFpc1ZOb2RlKHJhd1ZOb2RlKSB8fCAhKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDQpICYmICEocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4KSkge1xuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xuICAgICAgfVxuICAgICAgbGV0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChyYXdWTm9kZSk7XG4gICAgICBpZiAodm5vZGUudHlwZSA9PT0gQ29tbWVudCkge1xuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZub2RlO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tcCA9IHZub2RlLnR5cGU7XG4gICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShcbiAgICAgICAgaXNBc3luY1dyYXBwZXIodm5vZGUpID8gdm5vZGUudHlwZS5fX2FzeW5jUmVzb2x2ZWQgfHwge30gOiBjb21wXG4gICAgICApO1xuICAgICAgY29uc3QgeyBpbmNsdWRlLCBleGNsdWRlLCBtYXggfSA9IHByb3BzO1xuICAgICAgaWYgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSB8fCBleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSkge1xuICAgICAgICBjdXJyZW50ID0gdm5vZGU7XG4gICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsID8gY29tcCA6IHZub2RlLmtleTtcbiAgICAgIGNvbnN0IGNhY2hlZFZOb2RlID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAodm5vZGUuZWwpIHtcbiAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgICAgaWYgKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICAgIHJhd1ZOb2RlLnNzQ29udGVudCA9IHZub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZW5kaW5nQ2FjaGVLZXkgPSBrZXk7XG4gICAgICBpZiAoY2FjaGVkVk5vZGUpIHtcbiAgICAgICAgdm5vZGUuZWwgPSBjYWNoZWRWTm9kZS5lbDtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50ID0gY2FjaGVkVk5vZGUuY29tcG9uZW50O1xuICAgICAgICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xuICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgdm5vZGUudHJhbnNpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDUxMjtcbiAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgIGlmIChtYXggJiYga2V5cy5zaXplID4gcGFyc2VJbnQobWF4LCAxMCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5cy52YWx1ZXMoKS5uZXh0KCkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gMjU2O1xuICAgICAgY3VycmVudCA9IHZub2RlO1xuICAgICAgcmV0dXJuIGlzU3VzcGVuc2UocmF3Vk5vZGUudHlwZSkgPyByYXdWTm9kZSA6IHZub2RlO1xuICAgIH07XG4gIH1cbn07XG5jb25zdCBLZWVwQWxpdmUgPSBLZWVwQWxpdmVJbXBsO1xuZnVuY3Rpb24gbWF0Y2hlcyhwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChpc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc29tZSgocCkgPT4gbWF0Y2hlcyhwLCBuYW1lKSk7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdChcIixcIikuaW5jbHVkZXMobmFtZSk7XG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBvbkFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcbiAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiYVwiLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gb25EZWFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcbiAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiZGFcIiwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCB0eXBlLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcbiAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2RjIHx8IChob29rLl9fd2RjID0gKCkgPT4ge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICBpZiAoY3VycmVudC5pc0RlYWN0aXZhdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGhvb2soKTtcbiAgfSk7XG4gIGluamVjdEhvb2sodHlwZSwgd3JhcHBlZEhvb2ssIHRhcmdldCk7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBsZXQgY3VycmVudCA9IHRhcmdldC5wYXJlbnQ7XG4gICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC5wYXJlbnQpIHtcbiAgICAgIGlmIChpc0tlZXBBbGl2ZShjdXJyZW50LnBhcmVudC52bm9kZSkpIHtcbiAgICAgICAgaW5qZWN0VG9LZWVwQWxpdmVSb290KHdyYXBwZWRIb29rLCB0eXBlLCB0YXJnZXQsIGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW5qZWN0VG9LZWVwQWxpdmVSb290KGhvb2ssIHR5cGUsIHRhcmdldCwga2VlcEFsaXZlUm9vdCkge1xuICBjb25zdCBpbmplY3RlZCA9IGluamVjdEhvb2soXG4gICAgdHlwZSxcbiAgICBob29rLFxuICAgIGtlZXBBbGl2ZVJvb3QsXG4gICAgdHJ1ZVxuICAgIC8qIHByZXBlbmQgKi9cbiAgKTtcbiAgb25Vbm1vdW50ZWQoKCkgPT4ge1xuICAgIHJlbW92ZShrZWVwQWxpdmVSb290W3R5cGVdLCBpbmplY3RlZCk7XG4gIH0sIHRhcmdldCk7XG59XG5mdW5jdGlvbiByZXNldFNoYXBlRmxhZyh2bm9kZSkge1xuICB2bm9kZS5zaGFwZUZsYWcgJj0gfjI1NjtcbiAgdm5vZGUuc2hhcGVGbGFnICY9IH41MTI7XG59XG5mdW5jdGlvbiBnZXRJbm5lckNoaWxkKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5zaGFwZUZsYWcgJiAxMjggPyB2bm9kZS5zc0NvbnRlbnQgOiB2bm9kZTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SG9vayh0eXBlLCBob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UsIHByZXBlbmQgPSBmYWxzZSkge1xuICBpZiAodGFyZ2V0KSB7XG4gICAgY29uc3QgaG9va3MgPSB0YXJnZXRbdHlwZV0gfHwgKHRhcmdldFt0eXBlXSA9IFtdKTtcbiAgICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZWggfHwgKGhvb2suX193ZWggPSAoLi4uYXJncykgPT4ge1xuICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UodGFyZ2V0KTtcbiAgICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIHRhcmdldCwgdHlwZSwgYXJncyk7XG4gICAgICByZXNldCgpO1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgICBpZiAocHJlcGVuZCkge1xuICAgICAgaG9va3MudW5zaGlmdCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tzLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcHBlZEhvb2s7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGFwaU5hbWUgPSB0b0hhbmRsZXJLZXkoRXJyb3JUeXBlU3RyaW5ncyQxW3R5cGVdLnJlcGxhY2UoLyBob29rJC8sIFwiXCIpKTtcbiAgICB3YXJuJDEoXG4gICAgICBgJHthcGlOYW1lfSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC4gTGlmZWN5Y2xlIGluamVjdGlvbiBBUElzIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiBzZXR1cCgpLmAgKyAoYCBJZiB5b3UgYXJlIHVzaW5nIGFzeW5jIHNldHVwKCksIG1ha2Ugc3VyZSB0byByZWdpc3RlciBsaWZlY3ljbGUgaG9va3MgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdCBzdGF0ZW1lbnQuYCApXG4gICAgKTtcbiAgfVxufVxuY29uc3QgY3JlYXRlSG9vayA9IChsaWZlY3ljbGUpID0+IChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpID0+IHtcbiAgaWYgKCFpc0luU1NSQ29tcG9uZW50U2V0dXAgfHwgbGlmZWN5Y2xlID09PSBcInNwXCIpIHtcbiAgICBpbmplY3RIb29rKGxpZmVjeWNsZSwgKC4uLmFyZ3MpID0+IGhvb2soLi4uYXJncyksIHRhcmdldCk7XG4gIH1cbn07XG5jb25zdCBvbkJlZm9yZU1vdW50ID0gY3JlYXRlSG9vayhcImJtXCIpO1xuY29uc3Qgb25Nb3VudGVkID0gY3JlYXRlSG9vayhcIm1cIik7XG5jb25zdCBvbkJlZm9yZVVwZGF0ZSA9IGNyZWF0ZUhvb2soXG4gIFwiYnVcIlxuKTtcbmNvbnN0IG9uVXBkYXRlZCA9IGNyZWF0ZUhvb2soXCJ1XCIpO1xuY29uc3Qgb25CZWZvcmVVbm1vdW50ID0gY3JlYXRlSG9vayhcbiAgXCJidW1cIlxuKTtcbmNvbnN0IG9uVW5tb3VudGVkID0gY3JlYXRlSG9vayhcInVtXCIpO1xuY29uc3Qgb25TZXJ2ZXJQcmVmZXRjaCA9IGNyZWF0ZUhvb2soXG4gIFwic3BcIlxuKTtcbmNvbnN0IG9uUmVuZGVyVHJpZ2dlcmVkID0gY3JlYXRlSG9vayhcInJ0Z1wiKTtcbmNvbnN0IG9uUmVuZGVyVHJhY2tlZCA9IGNyZWF0ZUhvb2soXCJydGNcIik7XG5mdW5jdGlvbiBvbkVycm9yQ2FwdHVyZWQoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSB7XG4gIGluamVjdEhvb2soXCJlY1wiLCBob29rLCB0YXJnZXQpO1xufVxuXG5jb25zdCBDT01QT05FTlRTID0gXCJjb21wb25lbnRzXCI7XG5jb25zdCBESVJFQ1RJVkVTID0gXCJkaXJlY3RpdmVzXCI7XG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KG5hbWUsIG1heWJlU2VsZlJlZmVyZW5jZSkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIG5hbWUsIHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSkgfHwgbmFtZTtcbn1cbmNvbnN0IE5VTExfRFlOQU1JQ19DT01QT05FTlQgPSBTeW1ib2wuZm9yKFwidi1uZGNcIik7XG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgaWYgKGlzU3RyaW5nKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIGNvbXBvbmVudCwgZmFsc2UpIHx8IGNvbXBvbmVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29tcG9uZW50IHx8IE5VTExfRFlOQU1JQ19DT01QT05FTlQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVEaXJlY3RpdmUobmFtZSkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KERJUkVDVElWRVMsIG5hbWUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0KHR5cGUsIG5hbWUsIHdhcm5NaXNzaW5nID0gdHJ1ZSwgbWF5YmVTZWxmUmVmZXJlbmNlID0gZmFsc2UpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEluc3RhbmNlO1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICAgIGlmICh0eXBlID09PSBDT01QT05FTlRTKSB7XG4gICAgICBjb25zdCBzZWxmTmFtZSA9IGdldENvbXBvbmVudE5hbWUoXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgICBpZiAoc2VsZk5hbWUgJiYgKHNlbGZOYW1lID09PSBuYW1lIHx8IHNlbGZOYW1lID09PSBjYW1lbGl6ZShuYW1lKSB8fCBzZWxmTmFtZSA9PT0gY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSkpKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IChcbiAgICAgIC8vIGxvY2FsIHJlZ2lzdHJhdGlvblxuICAgICAgLy8gY2hlY2sgaW5zdGFuY2VbdHlwZV0gZmlyc3Qgd2hpY2ggaXMgcmVzb2x2ZWQgZm9yIG9wdGlvbnMgQVBJXG4gICAgICByZXNvbHZlKGluc3RhbmNlW3R5cGVdIHx8IENvbXBvbmVudFt0eXBlXSwgbmFtZSkgfHwgLy8gZ2xvYmFsIHJlZ2lzdHJhdGlvblxuICAgICAgcmVzb2x2ZShpbnN0YW5jZS5hcHBDb250ZXh0W3R5cGVdLCBuYW1lKVxuICAgICk7XG4gICAgaWYgKCFyZXMgJiYgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XG4gICAgICByZXR1cm4gQ29tcG9uZW50O1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgICBjb25zdCBleHRyYSA9IHR5cGUgPT09IENPTVBPTkVOVFMgPyBgXG5JZiB0aGlzIGlzIGEgbmF0aXZlIGN1c3RvbSBlbGVtZW50LCBtYWtlIHN1cmUgdG8gZXhjbHVkZSBpdCBmcm9tIGNvbXBvbmVudCByZXNvbHV0aW9uIHZpYSBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50LmAgOiBgYDtcbiAgICAgIHdhcm4kMShgRmFpbGVkIHRvIHJlc29sdmUgJHt0eXBlLnNsaWNlKDAsIC0xKX06ICR7bmFtZX0ke2V4dHJhfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgcmVzb2x2ZSR7Y2FwaXRhbGl6ZSh0eXBlLnNsaWNlKDAsIC0xKSl9IGNhbiBvbmx5IGJlIHVzZWQgaW4gcmVuZGVyKCkgb3Igc2V0dXAoKS5gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZShyZWdpc3RyeSwgbmFtZSkge1xuICByZXR1cm4gcmVnaXN0cnkgJiYgKHJlZ2lzdHJ5W25hbWVdIHx8IHJlZ2lzdHJ5W2NhbWVsaXplKG5hbWUpXSB8fCByZWdpc3RyeVtjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKV0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJMaXN0KHNvdXJjZSwgcmVuZGVySXRlbSwgY2FjaGUsIGluZGV4KSB7XG4gIGxldCByZXQ7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlICYmIGNhY2hlW2luZGV4XTtcbiAgY29uc3Qgc291cmNlSXNBcnJheSA9IGlzQXJyYXkoc291cmNlKTtcbiAgaWYgKHNvdXJjZUlzQXJyYXkgfHwgaXNTdHJpbmcoc291cmNlKSkge1xuICAgIGNvbnN0IHNvdXJjZUlzUmVhY3RpdmVBcnJheSA9IHNvdXJjZUlzQXJyYXkgJiYgaXNSZWFjdGl2ZShzb3VyY2UpO1xuICAgIGlmIChzb3VyY2VJc1JlYWN0aXZlQXJyYXkpIHtcbiAgICAgIHNvdXJjZSA9IHNoYWxsb3dSZWFkQXJyYXkoc291cmNlKTtcbiAgICB9XG4gICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gc291cmNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShcbiAgICAgICAgc291cmNlSXNSZWFjdGl2ZUFycmF5ID8gdG9SZWFjdGl2ZShzb3VyY2VbaV0pIDogc291cmNlW2ldLFxuICAgICAgICBpLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIGNhY2hlZCAmJiBjYWNoZWRbaV1cbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhTnVtYmVyLmlzSW50ZWdlcihzb3VyY2UpKSB7XG4gICAgICB3YXJuJDEoYFRoZSB2LWZvciByYW5nZSBleHBlY3QgYW4gaW50ZWdlciB2YWx1ZSBidXQgZ290ICR7c291cmNlfS5gKTtcbiAgICB9XG4gICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2U7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShpICsgMSwgaSwgdm9pZCAwLCBjYWNoZWQgJiYgY2FjaGVkW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGlmIChzb3VyY2VbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgcmV0ID0gQXJyYXkuZnJvbShcbiAgICAgICAgc291cmNlLFxuICAgICAgICAoaXRlbSwgaSkgPT4gcmVuZGVySXRlbShpdGVtLCBpLCB2b2lkIDAsIGNhY2hlZCAmJiBjYWNoZWRbaV0pXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2tleV0sIGtleSwgaSwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldCA9IFtdO1xuICB9XG4gIGlmIChjYWNoZSkge1xuICAgIGNhY2hlW2luZGV4XSA9IHJldDtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTbG90cyhzbG90cywgZHluYW1pY1Nsb3RzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2xvdCA9IGR5bmFtaWNTbG90c1tpXTtcbiAgICBpZiAoaXNBcnJheShzbG90KSkge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzbG90Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNsb3RzW3Nsb3Rbal0ubmFtZV0gPSBzbG90W2pdLmZuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgc2xvdHNbc2xvdC5uYW1lXSA9IHNsb3Qua2V5ID8gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgcmVzID0gc2xvdC5mbiguLi5hcmdzKTtcbiAgICAgICAgaWYgKHJlcykgcmVzLmtleSA9IHNsb3Qua2V5O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSA6IHNsb3QuZm47XG4gICAgfVxuICB9XG4gIHJldHVybiBzbG90cztcbn1cblxuZnVuY3Rpb24gcmVuZGVyU2xvdChzbG90cywgbmFtZSwgcHJvcHMgPSB7fSwgZmFsbGJhY2ssIG5vU2xvdHRlZCkge1xuICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQgJiYgaXNBc3luY1dyYXBwZXIoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudCkgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudC5jZSkge1xuICAgIGlmIChuYW1lICE9PSBcImRlZmF1bHRcIikgcHJvcHMubmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIG9wZW5CbG9jaygpLCBjcmVhdGVCbG9jayhcbiAgICAgIEZyYWdtZW50LFxuICAgICAgbnVsbCxcbiAgICAgIFtjcmVhdGVWTm9kZShcInNsb3RcIiwgcHJvcHMsIGZhbGxiYWNrICYmIGZhbGxiYWNrKCkpXSxcbiAgICAgIDY0XG4gICAgKTtcbiAgfVxuICBsZXQgc2xvdCA9IHNsb3RzW25hbWVdO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzbG90ICYmIHNsb3QubGVuZ3RoID4gMSkge1xuICAgIHdhcm4kMShcbiAgICAgIGBTU1Itb3B0aW1pemVkIHNsb3QgZnVuY3Rpb24gZGV0ZWN0ZWQgaW4gYSBub24tU1NSLW9wdGltaXplZCByZW5kZXIgZnVuY3Rpb24uIFlvdSBuZWVkIHRvIG1hcmsgdGhpcyBjb21wb25lbnQgd2l0aCAkZHluYW1pYy1zbG90cyBpbiB0aGUgcGFyZW50IHRlbXBsYXRlLmBcbiAgICApO1xuICAgIHNsb3QgPSAoKSA9PiBbXTtcbiAgfVxuICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XG4gICAgc2xvdC5fZCA9IGZhbHNlO1xuICB9XG4gIG9wZW5CbG9jaygpO1xuICBjb25zdCB2YWxpZFNsb3RDb250ZW50ID0gc2xvdCAmJiBlbnN1cmVWYWxpZFZOb2RlKHNsb3QocHJvcHMpKTtcbiAgY29uc3QgcmVuZGVyZWQgPSBjcmVhdGVCbG9jayhcbiAgICBGcmFnbWVudCxcbiAgICB7XG4gICAgICBrZXk6IChwcm9wcy5rZXkgfHwgLy8gc2xvdCBjb250ZW50IGFycmF5IG9mIGEgZHluYW1pYyBjb25kaXRpb25hbCBzbG90IG1heSBoYXZlIGEgYnJhbmNoXG4gICAgICAvLyBrZXkgYXR0YWNoZWQgaW4gdGhlIGBjcmVhdGVTbG90c2AgaGVscGVyLCByZXNwZWN0IHRoYXRcbiAgICAgIHZhbGlkU2xvdENvbnRlbnQgJiYgdmFsaWRTbG90Q29udGVudC5rZXkgfHwgYF8ke25hbWV9YCkgKyAvLyAjNzI1NiBmb3JjZSBkaWZmZXJlbnRpYXRlIGZhbGxiYWNrIGNvbnRlbnQgZnJvbSBhY3R1YWwgY29udGVudFxuICAgICAgKCF2YWxpZFNsb3RDb250ZW50ICYmIGZhbGxiYWNrID8gXCJfZmJcIiA6IFwiXCIpXG4gICAgfSxcbiAgICB2YWxpZFNsb3RDb250ZW50IHx8IChmYWxsYmFjayA/IGZhbGxiYWNrKCkgOiBbXSksXG4gICAgdmFsaWRTbG90Q29udGVudCAmJiBzbG90cy5fID09PSAxID8gNjQgOiAtMlxuICApO1xuICBpZiAoIW5vU2xvdHRlZCAmJiByZW5kZXJlZC5zY29wZUlkKSB7XG4gICAgcmVuZGVyZWQuc2xvdFNjb3BlSWRzID0gW3JlbmRlcmVkLnNjb3BlSWQgKyBcIi1zXCJdO1xuICB9XG4gIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcbiAgICBzbG90Ll9kID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVuZGVyZWQ7XG59XG5mdW5jdGlvbiBlbnN1cmVWYWxpZFZOb2RlKHZub2Rlcykge1xuICByZXR1cm4gdm5vZGVzLnNvbWUoKGNoaWxkKSA9PiB7XG4gICAgaWYgKCFpc1ZOb2RlKGNoaWxkKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQgJiYgIWVuc3VyZVZhbGlkVk5vZGUoY2hpbGQuY2hpbGRyZW4pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9KSA/IHZub2RlcyA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHRvSGFuZGxlcnMob2JqLCBwcmVzZXJ2ZUNhc2VJZk5lY2Vzc2FyeSkge1xuICBjb25zdCByZXQgPSB7fTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzT2JqZWN0KG9iaikpIHtcbiAgICB3YXJuJDEoYHYtb24gd2l0aCBubyBhcmd1bWVudCBleHBlY3RzIGFuIG9iamVjdCB2YWx1ZS5gKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHJldFtwcmVzZXJ2ZUNhc2VJZk5lY2Vzc2FyeSAmJiAvW0EtWl0vLnRlc3Qoa2V5KSA/IGBvbjoke2tleX1gIDogdG9IYW5kbGVyS2V5KGtleSldID0gb2JqW2tleV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuY29uc3QgZ2V0UHVibGljSW5zdGFuY2UgPSAoaSkgPT4ge1xuICBpZiAoIWkpIHJldHVybiBudWxsO1xuICBpZiAoaXNTdGF0ZWZ1bENvbXBvbmVudChpKSkgcmV0dXJuIGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKGkpO1xuICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpO1xufTtcbmNvbnN0IHB1YmxpY1Byb3BlcnRpZXNNYXAgPSAoXG4gIC8vIE1vdmUgUFVSRSBtYXJrZXIgdG8gbmV3IGxpbmUgdG8gd29ya2Fyb3VuZCBjb21waWxlciBkaXNjYXJkaW5nIGl0XG4gIC8vIGR1ZSB0byB0eXBlIGFubm90YXRpb25cbiAgLyogQF9fUFVSRV9fICovIGV4dGVuZCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICQ6IChpKSA9PiBpLFxuICAgICRlbDogKGkpID0+IGkudm5vZGUuZWwsXG4gICAgJGRhdGE6IChpKSA9PiBpLmRhdGEsXG4gICAgJHByb3BzOiAoaSkgPT4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpLnByb3BzKSA6IGkucHJvcHMsXG4gICAgJGF0dHJzOiAoaSkgPT4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpLmF0dHJzKSA6IGkuYXR0cnMsXG4gICAgJHNsb3RzOiAoaSkgPT4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpLnNsb3RzKSA6IGkuc2xvdHMsXG4gICAgJHJlZnM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkucmVmcykgOiBpLnJlZnMsXG4gICAgJHBhcmVudDogKGkpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KSxcbiAgICAkcm9vdDogKGkpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucm9vdCksXG4gICAgJGhvc3Q6IChpKSA9PiBpLmNlLFxuICAgICRlbWl0OiAoaSkgPT4gaS5lbWl0LFxuICAgICRvcHRpb25zOiAoaSkgPT4gX19WVUVfT1BUSU9OU19BUElfXyA/IHJlc29sdmVNZXJnZWRPcHRpb25zKGkpIDogaS50eXBlLFxuICAgICRmb3JjZVVwZGF0ZTogKGkpID0+IGkuZiB8fCAoaS5mID0gKCkgPT4ge1xuICAgICAgcXVldWVKb2IoaS51cGRhdGUpO1xuICAgIH0pLFxuICAgICRuZXh0VGljazogKGkpID0+IGkubiB8fCAoaS5uID0gbmV4dFRpY2suYmluZChpLnByb3h5KSksXG4gICAgJHdhdGNoOiAoaSkgPT4gX19WVUVfT1BUSU9OU19BUElfXyA/IGluc3RhbmNlV2F0Y2guYmluZChpKSA6IE5PT1BcbiAgfSlcbik7XG5jb25zdCBpc1Jlc2VydmVkUHJlZml4ID0gKGtleSkgPT4ga2V5ID09PSBcIl9cIiB8fCBrZXkgPT09IFwiJFwiO1xuY29uc3QgaGFzU2V0dXBCaW5kaW5nID0gKHN0YXRlLCBrZXkpID0+IHN0YXRlICE9PSBFTVBUWV9PQkogJiYgIXN0YXRlLl9faXNTY3JpcHRTZXR1cCAmJiBoYXNPd24oc3RhdGUsIGtleSk7XG5jb25zdCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSB7XG4gIGdldCh7IF86IGluc3RhbmNlIH0sIGtleSkge1xuICAgIGlmIChrZXkgPT09IFwiX192X3NraXBcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlLCBkYXRhLCBwcm9wcywgYWNjZXNzQ2FjaGUsIHR5cGUsIGFwcENvbnRleHQgfSA9IGluc3RhbmNlO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleSA9PT0gXCJfX2lzVnVlXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgbm9ybWFsaXplZFByb3BzO1xuICAgIGlmIChrZXlbMF0gIT09IFwiJFwiKSB7XG4gICAgICBjb25zdCBuID0gYWNjZXNzQ2FjaGVba2V5XTtcbiAgICAgIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgY2FzZSAxIC8qIFNFVFVQICovOlxuICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcbiAgICAgICAgICBjYXNlIDIgLyogREFUQSAqLzpcbiAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICAgICAgY2FzZSA0IC8qIENPTlRFWFQgKi86XG4gICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgICAgICAgY2FzZSAzIC8qIFBST1BTICovOlxuICAgICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDEgLyogU0VUVVAgKi87XG4gICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMiAvKiBEQVRBICovO1xuICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgLy8gb25seSBjYWNoZSBvdGhlciBwcm9wZXJ0aWVzIHdoZW4gaW5zdGFuY2UgaGFzIGRlY2xhcmVkICh0aHVzIHN0YWJsZSlcbiAgICAgICAgLy8gcHJvcHNcbiAgICAgICAgKG5vcm1hbGl6ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkgJiYgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KVxuICAgICAgKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAzIC8qIFBST1BTICovO1xuICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBDT05URVhUICovO1xuICAgICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgICB9IGVsc2UgaWYgKCFfX1ZVRV9PUFRJT05TX0FQSV9fIHx8IHNob3VsZENhY2hlQWNjZXNzKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAwIC8qIE9USEVSICovO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwdWJsaWNHZXR0ZXIgPSBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV07XG4gICAgbGV0IGNzc01vZHVsZSwgZ2xvYmFsUHJvcGVydGllcztcbiAgICBpZiAocHVibGljR2V0dGVyKSB7XG4gICAgICBpZiAoa2V5ID09PSBcIiRhdHRyc1wiKSB7XG4gICAgICAgIHRyYWNrKGluc3RhbmNlLmF0dHJzLCBcImdldFwiLCBcIlwiKTtcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleSA9PT0gXCIkc2xvdHNcIikge1xuICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwdWJsaWNHZXR0ZXIoaW5zdGFuY2UpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBjc3MgbW9kdWxlIChpbmplY3RlZCBieSB2dWUtbG9hZGVyKVxuICAgICAgKGNzc01vZHVsZSA9IHR5cGUuX19jc3NNb2R1bGVzKSAmJiAoY3NzTW9kdWxlID0gY3NzTW9kdWxlW2tleV0pXG4gICAgKSB7XG4gICAgICByZXR1cm4gY3NzTW9kdWxlO1xuICAgIH0gZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xuICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDQgLyogQ09OVEVYVCAqLztcbiAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gZ2xvYmFsIHByb3BlcnRpZXNcbiAgICAgIGdsb2JhbFByb3BlcnRpZXMgPSBhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCBoYXNPd24oZ2xvYmFsUHJvcGVydGllcywga2V5KVxuICAgICkge1xuICAgICAge1xuICAgICAgICByZXR1cm4gZ2xvYmFsUHJvcGVydGllc1trZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgJiYgKCFpc1N0cmluZyhrZXkpIHx8IC8vICMxMDkxIGF2b2lkIGludGVybmFsIGlzUmVmL2lzVk5vZGUgY2hlY2tzIG9uIGNvbXBvbmVudCBpbnN0YW5jZSBsZWFkaW5nXG4gICAgLy8gdG8gaW5maW5pdGUgd2FybmluZyBsb29wXG4gICAga2V5LmluZGV4T2YoXCJfX3ZcIikgIT09IDApKSB7XG4gICAgICBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgICApfSBtdXN0IGJlIGFjY2Vzc2VkIHZpYSAkZGF0YSBiZWNhdXNlIGl0IHN0YXJ0cyB3aXRoIGEgcmVzZXJ2ZWQgY2hhcmFjdGVyIChcIiRcIiBvciBcIl9cIikgYW5kIGlzIG5vdCBwcm94aWVkIG9uIHRoZSByZW5kZXIgY29udGV4dC5gXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGluc3RhbmNlID09PSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHdhcyBhY2Nlc3NlZCBkdXJpbmcgcmVuZGVyIGJ1dCBpcyBub3QgZGVmaW5lZCBvbiBpbnN0YW5jZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBzZXR1cFN0YXRlLCBjdHggfSA9IGluc3RhbmNlO1xuICAgIGlmIChoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgc2V0dXBTdGF0ZVtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgIHdhcm4kMShgQ2Fubm90IG11dGF0ZSA8c2NyaXB0IHNldHVwPiBiaW5kaW5nIFwiJHtrZXl9XCIgZnJvbSBPcHRpb25zIEFQSS5gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xuICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGhhc093bihpbnN0YW5jZS5wcm9wcywga2V5KSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHByb3AgXCIke2tleX1cIi4gUHJvcHMgYXJlIHJlYWRvbmx5LmApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoa2V5WzBdID09PSBcIiRcIiAmJiBrZXkuc2xpY2UoMSkgaW4gaW5zdGFuY2UpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKFxuICAgICAgICBgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHVibGljIHByb3BlcnR5IFwiJHtrZXl9XCIuIFByb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCAkIGFyZSByZXNlcnZlZCBhbmQgcmVhZG9ubHkuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5IGluIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHhba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgaGFzKHtcbiAgICBfOiB7IGRhdGEsIHNldHVwU3RhdGUsIGFjY2Vzc0NhY2hlLCBjdHgsIGFwcENvbnRleHQsIHByb3BzT3B0aW9ucyB9XG4gIH0sIGtleSkge1xuICAgIGxldCBub3JtYWxpemVkUHJvcHM7XG4gICAgcmV0dXJuICEhYWNjZXNzQ2FjaGVba2V5XSB8fCBkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkgfHwgaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkgfHwgKG5vcm1hbGl6ZWRQcm9wcyA9IHByb3BzT3B0aW9uc1swXSkgJiYgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KSB8fCBoYXNPd24oY3R4LCBrZXkpIHx8IGhhc093bihwdWJsaWNQcm9wZXJ0aWVzTWFwLCBrZXkpIHx8IGhhc093bihhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCBrZXkpO1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIGlmIChkZXNjcmlwdG9yLmdldCAhPSBudWxsKSB7XG4gICAgICB0YXJnZXQuXy5hY2Nlc3NDYWNoZVtrZXldID0gMDtcbiAgICB9IGVsc2UgaWYgKGhhc093bihkZXNjcmlwdG9yLCBcInZhbHVlXCIpKSB7XG4gICAgICB0aGlzLnNldCh0YXJnZXQsIGtleSwgZGVzY3JpcHRvci52YWx1ZSwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufTtcbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUpIHtcbiAgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLm93bktleXMgPSAodGFyZ2V0KSA9PiB7XG4gICAgd2FybiQxKFxuICAgICAgYEF2b2lkIGFwcCBsb2dpYyB0aGF0IHJlbGllcyBvbiBlbnVtZXJhdGluZyBrZXlzIG9uIGEgY29tcG9uZW50IGluc3RhbmNlLiBUaGUga2V5cyB3aWxsIGJlIGVtcHR5IGluIHByb2R1Y3Rpb24gbW9kZSB0byBhdm9pZCBwZXJmb3JtYW5jZSBvdmVyaGVhZC5gXG4gICAgKTtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gIH07XG59XG5jb25zdCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKHt9LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMsIHtcbiAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgaWYgKGtleSA9PT0gU3ltYm9sLnVuc2NvcGFibGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuZ2V0KHRhcmdldCwga2V5LCB0YXJnZXQpO1xuICB9LFxuICBoYXMoXywga2V5KSB7XG4gICAgY29uc3QgaGFzID0ga2V5WzBdICE9PSBcIl9cIiAmJiAhaXNHbG9iYWxseUFsbG93ZWQoa2V5KTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaGFzICYmIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5oYXMoXywga2V5KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBrZXlcbiAgICAgICAgKX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIF8gd2hpY2ggaXMgYSByZXNlcnZlZCBwcmVmaXggZm9yIFZ1ZSBpbnRlcm5hbHMuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhcztcbiAgfVxufSk7XG5mdW5jdGlvbiBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IHRhcmdldCA9IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBgX2AsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiAoKSA9PiBpbnN0YW5jZVxuICB9KTtcbiAgT2JqZWN0LmtleXMocHVibGljUHJvcGVydGllc01hcCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogKCkgPT4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKSxcbiAgICAgIC8vIGludGVyY2VwdGVkIGJ5IHRoZSBwcm94eSBzbyBubyBuZWVkIGZvciBpbXBsZW1lbnRhdGlvbixcbiAgICAgIC8vIGJ1dCBuZWVkZWQgdG8gcHJldmVudCBzZXQgZXJyb3JzXG4gICAgICBzZXQ6IE5PT1BcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCB7XG4gICAgY3R4LFxuICAgIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc11cbiAgfSA9IGluc3RhbmNlO1xuICBpZiAocHJvcHNPcHRpb25zKSB7XG4gICAgT2JqZWN0LmtleXMocHJvcHNPcHRpb25zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gaW5zdGFuY2UucHJvcHNba2V5XSxcbiAgICAgICAgc2V0OiBOT09QXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSB9ID0gaW5zdGFuY2U7XG4gIE9iamVjdC5rZXlzKHRvUmF3KHNldHVwU3RhdGUpKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoIXNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgc2V0dXAoKSByZXR1cm4gcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBcIiRcIiBvciBcIl9cIiB3aGljaCBhcmUgcmVzZXJ2ZWQgcHJlZml4ZXMgZm9yIFZ1ZSBpbnRlcm5hbHMuYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHNldHVwU3RhdGVba2V5XSxcbiAgICAgICAgc2V0OiBOT09QXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCB3YXJuUnVudGltZVVzYWdlID0gKG1ldGhvZCkgPT4gd2FybiQxKFxuICBgJHttZXRob2R9KCkgaXMgYSBjb21waWxlci1oaW50IGhlbHBlciB0aGF0IGlzIG9ubHkgdXNhYmxlIGluc2lkZSA8c2NyaXB0IHNldHVwPiBvZiBhIHNpbmdsZSBmaWxlIGNvbXBvbmVudC4gSXRzIGFyZ3VtZW50cyBzaG91bGQgYmUgY29tcGlsZWQgYXdheSBhbmQgcGFzc2luZyBpdCBhdCBydW50aW1lIGhhcyBubyBlZmZlY3QuYFxuKTtcbmZ1bmN0aW9uIGRlZmluZVByb3BzKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVByb3BzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkZWZpbmVFbWl0cygpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFbWl0c2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGVmaW5lRXhwb3NlKGV4cG9zZWQpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFeHBvc2VgKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lT3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lT3B0aW9uc2ApO1xuICB9XG59XG5mdW5jdGlvbiBkZWZpbmVTbG90cygpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVTbG90c2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGVmaW5lTW9kZWwoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShcImRlZmluZU1vZGVsXCIpO1xuICB9XG59XG5mdW5jdGlvbiB3aXRoRGVmYXVsdHMocHJvcHMsIGRlZmF1bHRzKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgd2l0aERlZmF1bHRzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1c2VTbG90cygpIHtcbiAgcmV0dXJuIGdldENvbnRleHQoKS5zbG90cztcbn1cbmZ1bmN0aW9uIHVzZUF0dHJzKCkge1xuICByZXR1cm4gZ2V0Q29udGV4dCgpLmF0dHJzO1xufVxuZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaSkge1xuICAgIHdhcm4kMShgdXNlQ29udGV4dCgpIGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBpbnN0YW5jZS5gKTtcbiAgfVxuICByZXR1cm4gaS5zZXR1cENvbnRleHQgfHwgKGkuc2V0dXBDb250ZXh0ID0gY3JlYXRlU2V0dXBDb250ZXh0KGkpKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhwcm9wcykge1xuICByZXR1cm4gaXNBcnJheShwcm9wcykgPyBwcm9wcy5yZWR1Y2UoXG4gICAgKG5vcm1hbGl6ZWQsIHApID0+IChub3JtYWxpemVkW3BdID0gbnVsbCwgbm9ybWFsaXplZCksXG4gICAge31cbiAgKSA6IHByb3BzO1xufVxuZnVuY3Rpb24gbWVyZ2VEZWZhdWx0cyhyYXcsIGRlZmF1bHRzKSB7XG4gIGNvbnN0IHByb3BzID0gbm9ybWFsaXplUHJvcHNPckVtaXRzKHJhdyk7XG4gIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKFwiX19za2lwXCIpKSBjb250aW51ZTtcbiAgICBsZXQgb3B0ID0gcHJvcHNba2V5XTtcbiAgICBpZiAob3B0KSB7XG4gICAgICBpZiAoaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSkge1xuICAgICAgICBvcHQgPSBwcm9wc1trZXldID0geyB0eXBlOiBvcHQsIGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdC5kZWZhdWx0ID0gZGVmYXVsdHNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdCA9PT0gbnVsbCkge1xuICAgICAgb3B0ID0gcHJvcHNba2V5XSA9IHsgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKGBwcm9wcyBkZWZhdWx0IGtleSBcIiR7a2V5fVwiIGhhcyBubyBjb3JyZXNwb25kaW5nIGRlY2xhcmF0aW9uLmApO1xuICAgIH1cbiAgICBpZiAob3B0ICYmIGRlZmF1bHRzW2BfX3NraXBfJHtrZXl9YF0pIHtcbiAgICAgIG9wdC5za2lwRmFjdG9yeSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlTW9kZWxzKGEsIGIpIHtcbiAgaWYgKCFhIHx8ICFiKSByZXR1cm4gYSB8fCBiO1xuICBpZiAoaXNBcnJheShhKSAmJiBpc0FycmF5KGIpKSByZXR1cm4gYS5jb25jYXQoYik7XG4gIHJldHVybiBleHRlbmQoe30sIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhhKSwgbm9ybWFsaXplUHJvcHNPckVtaXRzKGIpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb3BzUmVzdFByb3h5KHByb3BzLCBleGNsdWRlZEtleXMpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgaWYgKCFleGNsdWRlZEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJldCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gcHJvcHNba2V5XVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiB3aXRoQXN5bmNDb250ZXh0KGdldEF3YWl0YWJsZSkge1xuICBjb25zdCBjdHggPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWN0eCkge1xuICAgIHdhcm4kMShcbiAgICAgIGB3aXRoQXN5bmNDb250ZXh0IGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBjdXJyZW50IGluc3RhbmNlLiBUaGlzIGlzIGxpa2VseSBhIGJ1Zy5gXG4gICAgKTtcbiAgfVxuICBsZXQgYXdhaXRhYmxlID0gZ2V0QXdhaXRhYmxlKCk7XG4gIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmIChpc1Byb21pc2UoYXdhaXRhYmxlKSkge1xuICAgIGF3YWl0YWJsZSA9IGF3YWl0YWJsZS5jYXRjaCgoZSkgPT4ge1xuICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGN0eCk7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBbYXdhaXRhYmxlLCAoKSA9PiBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KV07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSB7XG4gIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAodHlwZSwga2V5KSA9PiB7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHdhcm4kMShgJHt0eXBlfSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiAke2NhY2hlW2tleV19LmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZVtrZXldID0gdHlwZTtcbiAgICB9XG4gIH07XG59XG5sZXQgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xuZnVuY3Rpb24gYXBwbHlPcHRpb25zKGluc3RhbmNlKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSk7XG4gIGNvbnN0IHB1YmxpY1RoaXMgPSBpbnN0YW5jZS5wcm94eTtcbiAgY29uc3QgY3R4ID0gaW5zdGFuY2UuY3R4O1xuICBzaG91bGRDYWNoZUFjY2VzcyA9IGZhbHNlO1xuICBpZiAob3B0aW9ucy5iZWZvcmVDcmVhdGUpIHtcbiAgICBjYWxsSG9vayhvcHRpb25zLmJlZm9yZUNyZWF0ZSwgaW5zdGFuY2UsIFwiYmNcIik7XG4gIH1cbiAgY29uc3Qge1xuICAgIC8vIHN0YXRlXG4gICAgZGF0YTogZGF0YU9wdGlvbnMsXG4gICAgY29tcHV0ZWQ6IGNvbXB1dGVkT3B0aW9ucyxcbiAgICBtZXRob2RzLFxuICAgIHdhdGNoOiB3YXRjaE9wdGlvbnMsXG4gICAgcHJvdmlkZTogcHJvdmlkZU9wdGlvbnMsXG4gICAgaW5qZWN0OiBpbmplY3RPcHRpb25zLFxuICAgIC8vIGxpZmVjeWNsZVxuICAgIGNyZWF0ZWQsXG4gICAgYmVmb3JlTW91bnQsXG4gICAgbW91bnRlZCxcbiAgICBiZWZvcmVVcGRhdGUsXG4gICAgdXBkYXRlZCxcbiAgICBhY3RpdmF0ZWQsXG4gICAgZGVhY3RpdmF0ZWQsXG4gICAgYmVmb3JlRGVzdHJveSxcbiAgICBiZWZvcmVVbm1vdW50LFxuICAgIGRlc3Ryb3llZCxcbiAgICB1bm1vdW50ZWQsXG4gICAgcmVuZGVyLFxuICAgIHJlbmRlclRyYWNrZWQsXG4gICAgcmVuZGVyVHJpZ2dlcmVkLFxuICAgIGVycm9yQ2FwdHVyZWQsXG4gICAgc2VydmVyUHJlZmV0Y2gsXG4gICAgLy8gcHVibGljIEFQSVxuICAgIGV4cG9zZSxcbiAgICBpbmhlcml0QXR0cnMsXG4gICAgLy8gYXNzZXRzXG4gICAgY29tcG9uZW50cyxcbiAgICBkaXJlY3RpdmVzLFxuICAgIGZpbHRlcnNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkgOiBudWxsO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IFtwcm9wc09wdGlvbnNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xuICAgIGlmIChwcm9wc09wdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzT3B0aW9ucykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJQcm9wc1wiIC8qIFBST1BTICovLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaW5qZWN0T3B0aW9ucykge1xuICAgIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKTtcbiAgfVxuICBpZiAobWV0aG9kcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGNvbnN0IG1ldGhvZEhhbmRsZXIgPSBtZXRob2RzW2tleV07XG4gICAgICBpZiAoaXNGdW5jdGlvbihtZXRob2RIYW5kbGVyKSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eFtrZXldID0gbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiTWV0aG9kc1wiIC8qIE1FVEhPRFMgKi8sIGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyB0eXBlIFwiJHt0eXBlb2YgbWV0aG9kSGFuZGxlcn1cIiBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIERpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZGF0YU9wdGlvbnMpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNGdW5jdGlvbihkYXRhT3B0aW9ucykpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYFRoZSBkYXRhIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24uIFBsYWluIG9iamVjdCB1c2FnZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBkYXRhT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzUHJvbWlzZShkYXRhKSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgZGF0YSgpIHJldHVybmVkIGEgUHJvbWlzZSAtIG5vdGUgZGF0YSgpIGNhbm5vdCBiZSBhc3luYzsgSWYgeW91IGludGVuZCB0byBwZXJmb3JtIGRhdGEgZmV0Y2hpbmcgYmVmb3JlIGNvbXBvbmVudCByZW5kZXJzLCB1c2UgYXN5bmMgc2V0dXAoKSArIDxTdXNwZW5zZT4uYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYGRhdGEoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UuZGF0YSA9IHJlYWN0aXZlKGRhdGEpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkRhdGFcIiAvKiBEQVRBICovLCBrZXkpO1xuICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICBnZXQ6ICgpID0+IGRhdGFba2V5XSxcbiAgICAgICAgICAgICAgc2V0OiBOT09QXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xuICBpZiAoY29tcHV0ZWRPcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY29tcHV0ZWRPcHRpb25zKSB7XG4gICAgICBjb25zdCBvcHQgPSBjb21wdXRlZE9wdGlvbnNba2V5XTtcbiAgICAgIGNvbnN0IGdldCA9IGlzRnVuY3Rpb24ob3B0KSA/IG9wdC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpIDogaXNGdW5jdGlvbihvcHQuZ2V0KSA/IG9wdC5nZXQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKSA6IE5PT1A7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBnZXQgPT09IE5PT1ApIHtcbiAgICAgICAgd2FybiQxKGBDb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGhhcyBubyBnZXR0ZXIuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzZXQgPSAhaXNGdW5jdGlvbihvcHQpICYmIGlzRnVuY3Rpb24ob3B0LnNldCkgPyBvcHQuc2V0LmJpbmQocHVibGljVGhpcykgOiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gKCkgPT4ge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYFdyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgcmVhZG9ubHkuYFxuICAgICAgICApO1xuICAgICAgfSA6IE5PT1A7XG4gICAgICBjb25zdCBjID0gY29tcHV0ZWQoe1xuICAgICAgICBnZXQsXG4gICAgICAgIHNldFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGMudmFsdWUsXG4gICAgICAgIHNldDogKHYpID0+IGMudmFsdWUgPSB2XG4gICAgICB9KTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkNvbXB1dGVkXCIgLyogQ09NUFVURUQgKi8sIGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh3YXRjaE9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB3YXRjaE9wdGlvbnMpIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIod2F0Y2hPcHRpb25zW2tleV0sIGN0eCwgcHVibGljVGhpcywga2V5KTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3ZpZGVPcHRpb25zKSB7XG4gICAgY29uc3QgcHJvdmlkZXMgPSBpc0Z1bmN0aW9uKHByb3ZpZGVPcHRpb25zKSA/IHByb3ZpZGVPcHRpb25zLmNhbGwocHVibGljVGhpcykgOiBwcm92aWRlT3B0aW9ucztcbiAgICBSZWZsZWN0Lm93bktleXMocHJvdmlkZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgcHJvdmlkZShrZXksIHByb3ZpZGVzW2tleV0pO1xuICAgIH0pO1xuICB9XG4gIGlmIChjcmVhdGVkKSB7XG4gICAgY2FsbEhvb2soY3JlYXRlZCwgaW5zdGFuY2UsIFwiY1wiKTtcbiAgfVxuICBmdW5jdGlvbiByZWdpc3RlckxpZmVjeWNsZUhvb2socmVnaXN0ZXIsIGhvb2spIHtcbiAgICBpZiAoaXNBcnJheShob29rKSkge1xuICAgICAgaG9vay5mb3JFYWNoKChfaG9vaykgPT4gcmVnaXN0ZXIoX2hvb2suYmluZChwdWJsaWNUaGlzKSkpO1xuICAgIH0gZWxzZSBpZiAoaG9vaykge1xuICAgICAgcmVnaXN0ZXIoaG9vay5iaW5kKHB1YmxpY1RoaXMpKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlTW91bnQsIGJlZm9yZU1vdW50KTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uTW91bnRlZCwgbW91bnRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVwZGF0ZSwgYmVmb3JlVXBkYXRlKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uVXBkYXRlZCwgdXBkYXRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkFjdGl2YXRlZCwgYWN0aXZhdGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRGVhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRXJyb3JDYXB0dXJlZCwgZXJyb3JDYXB0dXJlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyYWNrZWQsIHJlbmRlclRyYWNrZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmlnZ2VyZWQsIHJlbmRlclRyaWdnZXJlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVubW91bnQsIGJlZm9yZVVubW91bnQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Vbm1vdW50ZWQsIHVubW91bnRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblNlcnZlclByZWZldGNoLCBzZXJ2ZXJQcmVmZXRjaCk7XG4gIGlmIChpc0FycmF5KGV4cG9zZSkpIHtcbiAgICBpZiAoZXhwb3NlLmxlbmd0aCkge1xuICAgICAgY29uc3QgZXhwb3NlZCA9IGluc3RhbmNlLmV4cG9zZWQgfHwgKGluc3RhbmNlLmV4cG9zZWQgPSB7fSk7XG4gICAgICBleHBvc2UuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvc2VkLCBrZXksIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IHB1YmxpY1RoaXNba2V5XSxcbiAgICAgICAgICBzZXQ6ICh2YWwpID0+IHB1YmxpY1RoaXNba2V5XSA9IHZhbFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIWluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICAgIGluc3RhbmNlLmV4cG9zZWQgPSB7fTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1ApIHtcbiAgICBpbnN0YW5jZS5yZW5kZXIgPSByZW5kZXI7XG4gIH1cbiAgaWYgKGluaGVyaXRBdHRycyAhPSBudWxsKSB7XG4gICAgaW5zdGFuY2UuaW5oZXJpdEF0dHJzID0gaW5oZXJpdEF0dHJzO1xuICB9XG4gIGlmIChjb21wb25lbnRzKSBpbnN0YW5jZS5jb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgaWYgKGRpcmVjdGl2ZXMpIGluc3RhbmNlLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICBpZiAoc2VydmVyUHJlZmV0Y2gpIHtcbiAgICBtYXJrQXN5bmNCb3VuZGFyeShpbnN0YW5jZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gTk9PUCkge1xuICBpZiAoaXNBcnJheShpbmplY3RPcHRpb25zKSkge1xuICAgIGluamVjdE9wdGlvbnMgPSBub3JtYWxpemVJbmplY3QoaW5qZWN0T3B0aW9ucyk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gaW5qZWN0T3B0aW9ucykge1xuICAgIGNvbnN0IG9wdCA9IGluamVjdE9wdGlvbnNba2V5XTtcbiAgICBsZXQgaW5qZWN0ZWQ7XG4gICAgaWYgKGlzT2JqZWN0KG9wdCkpIHtcbiAgICAgIGlmIChcImRlZmF1bHRcIiBpbiBvcHQpIHtcbiAgICAgICAgaW5qZWN0ZWQgPSBpbmplY3QoXG4gICAgICAgICAgb3B0LmZyb20gfHwga2V5LFxuICAgICAgICAgIG9wdC5kZWZhdWx0LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdCk7XG4gICAgfVxuICAgIGlmIChpc1JlZihpbmplY3RlZCkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gaW5qZWN0ZWQudmFsdWUsXG4gICAgICAgIHNldDogKHYpID0+IGluamVjdGVkLnZhbHVlID0gdlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eFtrZXldID0gaW5qZWN0ZWQ7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJJbmplY3RcIiAvKiBJTkpFQ1QgKi8sIGtleSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjYWxsSG9vayhob29rLCBpbnN0YW5jZSwgdHlwZSkge1xuICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICBpc0FycmF5KGhvb2spID8gaG9vay5tYXAoKGgpID0+IGguYmluZChpbnN0YW5jZS5wcm94eSkpIDogaG9vay5iaW5kKGluc3RhbmNlLnByb3h5KSxcbiAgICBpbnN0YW5jZSxcbiAgICB0eXBlXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyKHJhdywgY3R4LCBwdWJsaWNUaGlzLCBrZXkpIHtcbiAgbGV0IGdldHRlciA9IGtleS5pbmNsdWRlcyhcIi5cIikgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIGtleSkgOiAoKSA9PiBwdWJsaWNUaGlzW2tleV07XG4gIGlmIChpc1N0cmluZyhyYXcpKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IGN0eFtyYXddO1xuICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICB7XG4gICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuJDEoYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXd9XCJgLCBoYW5kbGVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihyYXcpKSB7XG4gICAge1xuICAgICAgd2F0Y2goZ2V0dGVyLCByYXcuYmluZChwdWJsaWNUaGlzKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJhdykpIHtcbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgICByYXcuZm9yRWFjaCgocikgPT4gY3JlYXRlV2F0Y2hlcihyLCBjdHgsIHB1YmxpY1RoaXMsIGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gaXNGdW5jdGlvbihyYXcuaGFuZGxlcikgPyByYXcuaGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpIDogY3R4W3Jhdy5oYW5kbGVyXTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlciwgcmF3KTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB3YXJuJDEoYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXcuaGFuZGxlcn1cImAsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKGBJbnZhbGlkIHdhdGNoIG9wdGlvbjogXCIke2tleX1cImAsIHJhdyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKSB7XG4gIGNvbnN0IGJhc2UgPSBpbnN0YW5jZS50eXBlO1xuICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGJhc2U7XG4gIGNvbnN0IHtcbiAgICBtaXhpbnM6IGdsb2JhbE1peGlucyxcbiAgICBvcHRpb25zQ2FjaGU6IGNhY2hlLFxuICAgIGNvbmZpZzogeyBvcHRpb25NZXJnZVN0cmF0ZWdpZXMgfVxuICB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dDtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGJhc2UpO1xuICBsZXQgcmVzb2x2ZWQ7XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXNvbHZlZCA9IGNhY2hlZDtcbiAgfSBlbHNlIGlmICghZ2xvYmFsTWl4aW5zLmxlbmd0aCAmJiAhbWl4aW5zICYmICFleHRlbmRzT3B0aW9ucykge1xuICAgIHtcbiAgICAgIHJlc29sdmVkID0gYmFzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWQgPSB7fTtcbiAgICBpZiAoZ2xvYmFsTWl4aW5zLmxlbmd0aCkge1xuICAgICAgZ2xvYmFsTWl4aW5zLmZvckVhY2goXG4gICAgICAgIChtKSA9PiBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIG0sIG9wdGlvbk1lcmdlU3RyYXRlZ2llcywgdHJ1ZSlcbiAgICAgICk7XG4gICAgfVxuICAgIG1lcmdlT3B0aW9ucyhyZXNvbHZlZCwgYmFzZSwgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoYmFzZSkpIHtcbiAgICBjYWNoZS5zZXQoYmFzZSwgcmVzb2x2ZWQpO1xuICB9XG4gIHJldHVybiByZXNvbHZlZDtcbn1cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyh0bywgZnJvbSwgc3RyYXRzLCBhc01peGluID0gZmFsc2UpIHtcbiAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBmcm9tO1xuICBpZiAoZXh0ZW5kc09wdGlvbnMpIHtcbiAgICBtZXJnZU9wdGlvbnModG8sIGV4dGVuZHNPcHRpb25zLCBzdHJhdHMsIHRydWUpO1xuICB9XG4gIGlmIChtaXhpbnMpIHtcbiAgICBtaXhpbnMuZm9yRWFjaChcbiAgICAgIChtKSA9PiBtZXJnZU9wdGlvbnModG8sIG0sIHN0cmF0cywgdHJ1ZSlcbiAgICApO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcbiAgICBpZiAoYXNNaXhpbiAmJiBrZXkgPT09IFwiZXhwb3NlXCIpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKFxuICAgICAgICBgXCJleHBvc2VcIiBvcHRpb24gaXMgaWdub3JlZCB3aGVuIGRlY2xhcmVkIGluIG1peGlucyBvciBleHRlbmRzLiBJdCBzaG91bGQgb25seSBiZSBkZWNsYXJlZCBpbiB0aGUgYmFzZSBjb21wb25lbnQgaXRzZWxmLmBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0cmF0ID0gaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0c1trZXldIHx8IHN0cmF0cyAmJiBzdHJhdHNba2V5XTtcbiAgICAgIHRvW2tleV0gPSBzdHJhdCA/IHN0cmF0KHRvW2tleV0sIGZyb21ba2V5XSkgOiBmcm9tW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cbmNvbnN0IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHMgPSB7XG4gIGRhdGE6IG1lcmdlRGF0YUZuLFxuICBwcm9wczogbWVyZ2VFbWl0c09yUHJvcHNPcHRpb25zLFxuICBlbWl0czogbWVyZ2VFbWl0c09yUHJvcHNPcHRpb25zLFxuICAvLyBvYmplY3RzXG4gIG1ldGhvZHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgY29tcHV0ZWQ6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgLy8gbGlmZWN5Y2xlXG4gIGJlZm9yZUNyZWF0ZTogbWVyZ2VBc0FycmF5LFxuICBjcmVhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZU1vdW50OiBtZXJnZUFzQXJyYXksXG4gIG1vdW50ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlVXBkYXRlOiBtZXJnZUFzQXJyYXksXG4gIHVwZGF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlRGVzdHJveTogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVVbm1vdW50OiBtZXJnZUFzQXJyYXksXG4gIGRlc3Ryb3llZDogbWVyZ2VBc0FycmF5LFxuICB1bm1vdW50ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGRlYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGVycm9yQ2FwdHVyZWQ6IG1lcmdlQXNBcnJheSxcbiAgc2VydmVyUHJlZmV0Y2g6IG1lcmdlQXNBcnJheSxcbiAgLy8gYXNzZXRzXG4gIGNvbXBvbmVudHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgZGlyZWN0aXZlczogbWVyZ2VPYmplY3RPcHRpb25zLFxuICAvLyB3YXRjaFxuICB3YXRjaDogbWVyZ2VXYXRjaE9wdGlvbnMsXG4gIC8vIHByb3ZpZGUgLyBpbmplY3RcbiAgcHJvdmlkZTogbWVyZ2VEYXRhRm4sXG4gIGluamVjdDogbWVyZ2VJbmplY3Rcbn07XG5mdW5jdGlvbiBtZXJnZURhdGFGbih0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHtcbiAgICByZXR1cm4gdG87XG4gIH1cbiAgaWYgKCF0bykge1xuICAgIHJldHVybiBmcm9tO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4oKSB7XG4gICAgcmV0dXJuIChleHRlbmQpKFxuICAgICAgaXNGdW5jdGlvbih0bykgPyB0by5jYWxsKHRoaXMsIHRoaXMpIDogdG8sXG4gICAgICBpc0Z1bmN0aW9uKGZyb20pID8gZnJvbS5jYWxsKHRoaXMsIHRoaXMpIDogZnJvbVxuICAgICk7XG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZUluamVjdCh0bywgZnJvbSkge1xuICByZXR1cm4gbWVyZ2VPYmplY3RPcHRpb25zKG5vcm1hbGl6ZUluamVjdCh0byksIG5vcm1hbGl6ZUluamVjdChmcm9tKSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QocmF3KSB7XG4gIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzW3Jhd1tpXV0gPSByYXdbaV07XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgcmV0dXJuIHJhdztcbn1cbmZ1bmN0aW9uIG1lcmdlQXNBcnJheSh0bywgZnJvbSkge1xuICByZXR1cm4gdG8gPyBbLi4ubmV3IFNldChbXS5jb25jYXQodG8sIGZyb20pKV0gOiBmcm9tO1xufVxuZnVuY3Rpb24gbWVyZ2VPYmplY3RPcHRpb25zKHRvLCBmcm9tKSB7XG4gIHJldHVybiB0byA/IGV4dGVuZCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8sIGZyb20pIDogZnJvbTtcbn1cbmZ1bmN0aW9uIG1lcmdlRW1pdHNPclByb3BzT3B0aW9ucyh0bywgZnJvbSkge1xuICBpZiAodG8pIHtcbiAgICBpZiAoaXNBcnJheSh0bykgJiYgaXNBcnJheShmcm9tKSkge1xuICAgICAgcmV0dXJuIFsuLi4vKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4udG8sIC4uLmZyb21dKV07XG4gICAgfVxuICAgIHJldHVybiBleHRlbmQoXG4gICAgICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyh0byksXG4gICAgICBub3JtYWxpemVQcm9wc09yRW1pdHMoZnJvbSAhPSBudWxsID8gZnJvbSA6IHt9KVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZyb207XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlV2F0Y2hPcHRpb25zKHRvLCBmcm9tKSB7XG4gIGlmICghdG8pIHJldHVybiBmcm9tO1xuICBpZiAoIWZyb20pIHJldHVybiB0bztcbiAgY29uc3QgbWVyZ2VkID0gZXh0ZW5kKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB0byk7XG4gIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcbiAgICBtZXJnZWRba2V5XSA9IG1lcmdlQXNBcnJheSh0b1trZXldLCBmcm9tW2tleV0pO1xuICB9XG4gIHJldHVybiBtZXJnZWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFwcENvbnRleHQoKSB7XG4gIHJldHVybiB7XG4gICAgYXBwOiBudWxsLFxuICAgIGNvbmZpZzoge1xuICAgICAgaXNOYXRpdmVUYWc6IE5PLFxuICAgICAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuICAgICAgZ2xvYmFsUHJvcGVydGllczoge30sXG4gICAgICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IHt9LFxuICAgICAgZXJyb3JIYW5kbGVyOiB2b2lkIDAsXG4gICAgICB3YXJuSGFuZGxlcjogdm9pZCAwLFxuICAgICAgY29tcGlsZXJPcHRpb25zOiB7fVxuICAgIH0sXG4gICAgbWl4aW5zOiBbXSxcbiAgICBjb21wb25lbnRzOiB7fSxcbiAgICBkaXJlY3RpdmVzOiB7fSxcbiAgICBwcm92aWRlczogLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgb3B0aW9uc0NhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSxcbiAgICBwcm9wc0NhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSxcbiAgICBlbWl0c0NhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKVxuICB9O1xufVxubGV0IHVpZCQxID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFwcChyb290Q29tcG9uZW50LCByb290UHJvcHMgPSBudWxsKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKHJvb3RDb21wb25lbnQpKSB7XG4gICAgICByb290Q29tcG9uZW50ID0gZXh0ZW5kKHt9LCByb290Q29tcG9uZW50KTtcbiAgICB9XG4gICAgaWYgKHJvb3RQcm9wcyAhPSBudWxsICYmICFpc09iamVjdChyb290UHJvcHMpKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgcm9vdCBwcm9wcyBwYXNzZWQgdG8gYXBwLm1vdW50KCkgbXVzdCBiZSBhbiBvYmplY3QuYCk7XG4gICAgICByb290UHJvcHMgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xuICAgIGNvbnN0IGluc3RhbGxlZFBsdWdpbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICBjb25zdCBwbHVnaW5DbGVhbnVwRm5zID0gW107XG4gICAgbGV0IGlzTW91bnRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGFwcCA9IGNvbnRleHQuYXBwID0ge1xuICAgICAgX3VpZDogdWlkJDErKyxcbiAgICAgIF9jb21wb25lbnQ6IHJvb3RDb21wb25lbnQsXG4gICAgICBfcHJvcHM6IHJvb3RQcm9wcyxcbiAgICAgIF9jb250YWluZXI6IG51bGwsXG4gICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgIF9pbnN0YW5jZTogbnVsbCxcbiAgICAgIHZlcnNpb24sXG4gICAgICBnZXQgY29uZmlnKCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jb25maWc7XG4gICAgICB9LFxuICAgICAgc2V0IGNvbmZpZyh2KSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYGFwcC5jb25maWcgY2Fubm90IGJlIHJlcGxhY2VkLiBNb2RpZnkgaW5kaXZpZHVhbCBvcHRpb25zIGluc3RlYWQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2UocGx1Z2luLCAuLi5vcHRpb25zKSB7XG4gICAgICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmhhcyhwbHVnaW4pKSB7XG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYFBsdWdpbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGFyZ2V0IGFwcC5gKTtcbiAgICAgICAgfSBlbHNlIGlmIChwbHVnaW4gJiYgaXNGdW5jdGlvbihwbHVnaW4uaW5zdGFsbCkpIHtcbiAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLmFkZChwbHVnaW4pO1xuICAgICAgICAgIHBsdWdpbi5pbnN0YWxsKGFwcCwgLi4ub3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihwbHVnaW4pKSB7XG4gICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcbiAgICAgICAgICBwbHVnaW4oYXBwLCAuLi5vcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEEgcGx1Z2luIG11c3QgZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IHdpdGggYW4gXCJpbnN0YWxsXCIgZnVuY3Rpb24uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBtaXhpbihtaXhpbikge1xuICAgICAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXykge1xuICAgICAgICAgIGlmICghY29udGV4dC5taXhpbnMuaW5jbHVkZXMobWl4aW4pKSB7XG4gICAgICAgICAgICBjb250ZXh0Lm1peGlucy5wdXNoKG1peGluKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgXCJNaXhpbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGFyZ2V0IGFwcFwiICsgKG1peGluLm5hbWUgPyBgOiAke21peGluLm5hbWV9YCA6IFwiXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFwiTWl4aW5zIGFyZSBvbmx5IGF2YWlsYWJsZSBpbiBidWlsZHMgc3VwcG9ydGluZyBPcHRpb25zIEFQSVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIGNvbXBvbmVudChuYW1lLCBjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29udGV4dC5jb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0pIHtcbiAgICAgICAgICB3YXJuJDEoYENvbXBvbmVudCBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0gPSBjb21wb25lbnQ7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgZGlyZWN0aXZlKG5hbWUsIGRpcmVjdGl2ZSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRpcmVjdGl2ZSkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdKSB7XG4gICAgICAgICAgd2FybiQxKGBEaXJlY3RpdmUgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdID0gZGlyZWN0aXZlO1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIG1vdW50KHJvb3RDb250YWluZXIsIGlzSHlkcmF0ZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIGlmICghaXNNb3VudGVkKSB7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcm9vdENvbnRhaW5lci5fX3Z1ZV9hcHBfXykge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgVGhlcmUgaXMgYWxyZWFkeSBhbiBhcHAgaW5zdGFuY2UgbW91bnRlZCBvbiB0aGUgaG9zdCBjb250YWluZXIuXG4gSWYgeW91IHdhbnQgdG8gbW91bnQgYW5vdGhlciBhcHAgb24gdGhlIHNhbWUgaG9zdCBjb250YWluZXIsIHlvdSBuZWVkIHRvIHVubW91bnQgdGhlIHByZXZpb3VzIGFwcCBieSBjYWxsaW5nIFxcYGFwcC51bm1vdW50KClcXGAgZmlyc3QuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgdm5vZGUgPSBhcHAuX2NlVk5vZGUgfHwgY3JlYXRlVk5vZGUocm9vdENvbXBvbmVudCwgcm9vdFByb3BzKTtcbiAgICAgICAgICB2bm9kZS5hcHBDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICBpZiAobmFtZXNwYWNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBcInN2Z1wiO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgY29udGV4dC5yZWxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlbmRlcihcbiAgICAgICAgICAgICAgICBjbG9uZVZOb2RlKHZub2RlKSxcbiAgICAgICAgICAgICAgICByb290Q29udGFpbmVyLFxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzSHlkcmF0ZSAmJiBoeWRyYXRlKSB7XG4gICAgICAgICAgICBoeWRyYXRlKHZub2RlLCByb290Q29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyKHZub2RlLCByb290Q29udGFpbmVyLCBuYW1lc3BhY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgIGFwcC5fY29udGFpbmVyID0gcm9vdENvbnRhaW5lcjtcbiAgICAgICAgICByb290Q29udGFpbmVyLl9fdnVlX2FwcF9fID0gYXBwO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2Uodm5vZGUuY29tcG9uZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEFwcCBoYXMgYWxyZWFkeSBiZWVuIG1vdW50ZWQuXG5JZiB5b3Ugd2FudCB0byByZW1vdW50IHRoZSBzYW1lIGFwcCwgbW92ZSB5b3VyIGFwcCBjcmVhdGlvbiBsb2dpYyBpbnRvIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgY3JlYXRlIGZyZXNoIGFwcCBpbnN0YW5jZXMgZm9yIGVhY2ggbW91bnQgLSBlLmcuIFxcYGNvbnN0IGNyZWF0ZU15QXBwID0gKCkgPT4gY3JlYXRlQXBwKEFwcClcXGBgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uVW5tb3VudChjbGVhbnVwRm4pIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHlwZW9mIGNsZWFudXBGbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEV4cGVjdGVkIGZ1bmN0aW9uIGFzIGZpcnN0IGFyZ3VtZW50IHRvIGFwcC5vblVubW91bnQoKSwgYnV0IGdvdCAke3R5cGVvZiBjbGVhbnVwRm59YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcGx1Z2luQ2xlYW51cEZucy5wdXNoKGNsZWFudXBGbik7XG4gICAgICB9LFxuICAgICAgdW5tb3VudCgpIHtcbiAgICAgICAgaWYgKGlzTW91bnRlZCkge1xuICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgICAgICAgcGx1Z2luQ2xlYW51cEZucyxcbiAgICAgICAgICAgIGFwcC5faW5zdGFuY2UsXG4gICAgICAgICAgICAxNlxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVuZGVyKG51bGwsIGFwcC5fY29udGFpbmVyKTtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgIGFwcC5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgZGV2dG9vbHNVbm1vdW50QXBwKGFwcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBhcHAuX2NvbnRhaW5lci5fX3Z1ZV9hcHBfXztcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKGBDYW5ub3QgdW5tb3VudCBhbiBhcHAgdGhhdCBpcyBub3QgbW91bnRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgaW4gY29udGV4dC5wcm92aWRlcykge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBBcHAgYWxyZWFkeSBwcm92aWRlcyBwcm9wZXJ0eSB3aXRoIGtleSBcIiR7U3RyaW5nKGtleSl9XCIuIEl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgbmV3IHZhbHVlLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucHJvdmlkZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIHJ1bldpdGhDb250ZXh0KGZuKSB7XG4gICAgICAgIGNvbnN0IGxhc3RBcHAgPSBjdXJyZW50QXBwO1xuICAgICAgICBjdXJyZW50QXBwID0gYXBwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGN1cnJlbnRBcHAgPSBsYXN0QXBwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXBwO1xuICB9O1xufVxubGV0IGN1cnJlbnRBcHAgPSBudWxsO1xuXG5mdW5jdGlvbiBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKGBwcm92aWRlKCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKS5gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzO1xuICAgIGNvbnN0IHBhcmVudFByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnBhcmVudCAmJiBjdXJyZW50SW5zdGFuY2UucGFyZW50LnByb3ZpZGVzO1xuICAgIGlmIChwYXJlbnRQcm92aWRlcyA9PT0gcHJvdmlkZXMpIHtcbiAgICAgIHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm92aWRlcyk7XG4gICAgfVxuICAgIHByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gaW5qZWN0KGtleSwgZGVmYXVsdFZhbHVlLCB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgPSBmYWxzZSkge1xuICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gIGlmIChpbnN0YW5jZSB8fCBjdXJyZW50QXBwKSB7XG4gICAgY29uc3QgcHJvdmlkZXMgPSBjdXJyZW50QXBwID8gY3VycmVudEFwcC5fY29udGV4dC5wcm92aWRlcyA6IGluc3RhbmNlID8gaW5zdGFuY2UucGFyZW50ID09IG51bGwgPyBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0ICYmIGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQucHJvdmlkZXMgOiBpbnN0YW5jZS5wYXJlbnQucHJvdmlkZXMgOiB2b2lkIDA7XG4gICAgaWYgKHByb3ZpZGVzICYmIGtleSBpbiBwcm92aWRlcykge1xuICAgICAgcmV0dXJuIHByb3ZpZGVzW2tleV07XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkgPyBkZWZhdWx0VmFsdWUuY2FsbChpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eSkgOiBkZWZhdWx0VmFsdWU7XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuJDEoYGluamVjdGlvbiBcIiR7U3RyaW5nKGtleSl9XCIgbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKGBpbmplY3QoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cy5gKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzSW5qZWN0aW9uQ29udGV4dCgpIHtcbiAgcmV0dXJuICEhKGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEFwcCk7XG59XG5cbmNvbnN0IGludGVybmFsT2JqZWN0UHJvdG8gPSB7fTtcbmNvbnN0IGNyZWF0ZUludGVybmFsT2JqZWN0ID0gKCkgPT4gT2JqZWN0LmNyZWF0ZShpbnRlcm5hbE9iamVjdFByb3RvKTtcbmNvbnN0IGlzSW50ZXJuYWxPYmplY3QgPSAob2JqKSA9PiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gaW50ZXJuYWxPYmplY3RQcm90bztcblxuZnVuY3Rpb24gaW5pdFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgaXNTdGF0ZWZ1bCwgaXNTU1IgPSBmYWxzZSkge1xuICBjb25zdCBwcm9wcyA9IHt9O1xuICBjb25zdCBhdHRycyA9IGNyZWF0ZUludGVybmFsT2JqZWN0KCk7XG4gIGluc3RhbmNlLnByb3BzRGVmYXVsdHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSB7XG4gICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xuICAgICAgcHJvcHNba2V5XSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xuICB9XG4gIGlmIChpc1N0YXRlZnVsKSB7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBpc1NTUiA/IHByb3BzIDogc2hhbGxvd1JlYWN0aXZlKHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWluc3RhbmNlLnR5cGUucHJvcHMpIHtcbiAgICAgIGluc3RhbmNlLnByb3BzID0gYXR0cnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnByb3BzID0gcHJvcHM7XG4gICAgfVxuICB9XG4gIGluc3RhbmNlLmF0dHJzID0gYXR0cnM7XG59XG5mdW5jdGlvbiBpc0luSG1yQ29udGV4dChpbnN0YW5jZSkge1xuICB3aGlsZSAoaW5zdGFuY2UpIHtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5fX2htcklkKSByZXR1cm4gdHJ1ZTtcbiAgICBpbnN0YW5jZSA9IGluc3RhbmNlLnBhcmVudDtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCByYXdQcmV2UHJvcHMsIG9wdGltaXplZCkge1xuICBjb25zdCB7XG4gICAgcHJvcHMsXG4gICAgYXR0cnMsXG4gICAgdm5vZGU6IHsgcGF0Y2hGbGFnIH1cbiAgfSA9IGluc3RhbmNlO1xuICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gIGNvbnN0IFtvcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xuICBpZiAoXG4gICAgLy8gYWx3YXlzIGZvcmNlIGZ1bGwgZGlmZiBpbiBkZXZcbiAgICAvLyAtICMxOTQyIGlmIGhtciBpcyBlbmFibGVkIHdpdGggc2ZjIGNvbXBvbmVudFxuICAgIC8vIC0gdml0ZSM4NzIgbm9uLXNmYyBjb21wb25lbnQgdXNlZCBieSBzZmMgY29tcG9uZW50XG4gICAgISghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSW5IbXJDb250ZXh0KGluc3RhbmNlKSkgJiYgKG9wdGltaXplZCB8fCBwYXRjaEZsYWcgPiAwKSAmJiAhKHBhdGNoRmxhZyAmIDE2KVxuICApIHtcbiAgICBpZiAocGF0Y2hGbGFnICYgOCkge1xuICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IGluc3RhbmNlLnZub2RlLmR5bmFtaWNQcm9wcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcbiAgICAgICAgaWYgKGlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoaGFzT3duKGF0dHJzLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICAgICAgcHJvcHNbY2FtZWxpemVkS2V5XSA9IHJlc29sdmVQcm9wVmFsdWUoXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIHJhd0N1cnJlbnRQcm9wcyxcbiAgICAgICAgICAgICAgY2FtZWxpemVkS2V5LFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpKSB7XG4gICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQga2ViYWJLZXk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3Q3VycmVudFByb3BzKSB7XG4gICAgICBpZiAoIXJhd1Byb3BzIHx8IC8vIGZvciBjYW1lbENhc2VcbiAgICAgICFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiYgLy8gaXQncyBwb3NzaWJsZSB0aGUgb3JpZ2luYWwgcHJvcHMgd2FzIHBhc3NlZCBpbiBhcyBrZWJhYi1jYXNlXG4gICAgICAvLyBhbmQgY29udmVydGVkIHRvIGNhbWVsQ2FzZSAoIzk1NSlcbiAgICAgICgoa2ViYWJLZXkgPSBoeXBoZW5hdGUoa2V5KSkgPT09IGtleSB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZWJhYktleSkpKSB7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKHJhd1ByZXZQcm9wcyAmJiAvLyBmb3IgY2FtZWxDYXNlXG4gICAgICAgICAgKHJhd1ByZXZQcm9wc1trZXldICE9PSB2b2lkIDAgfHwgLy8gZm9yIGtlYmFiLWNhc2VcbiAgICAgICAgICByYXdQcmV2UHJvcHNba2ViYWJLZXldICE9PSB2b2lkIDApKSB7XG4gICAgICAgICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShcbiAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgcmF3Q3VycmVudFByb3BzLFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRycyAhPT0gcmF3Q3VycmVudFByb3BzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAgICBpZiAoIXJhd1Byb3BzIHx8ICFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiYgdHJ1ZSkge1xuICAgICAgICAgIGRlbGV0ZSBhdHRyc1trZXldO1xuICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGhhc0F0dHJzQ2hhbmdlZCkge1xuICAgIHRyaWdnZXIoaW5zdGFuY2UuYXR0cnMsIFwic2V0XCIsIFwiXCIpO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSB7XG4gIGNvbnN0IFtvcHRpb25zLCBuZWVkQ2FzdEtleXNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xuICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XG4gIGxldCByYXdDYXN0VmFsdWVzO1xuICBpZiAocmF3UHJvcHMpIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gcmF3UHJvcHMpIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xuICAgICAgbGV0IGNhbWVsS2V5O1xuICAgICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsIGNhbWVsS2V5ID0gY2FtZWxpemUoa2V5KSkpIHtcbiAgICAgICAgaWYgKCFuZWVkQ2FzdEtleXMgfHwgIW5lZWRDYXN0S2V5cy5pbmNsdWRlcyhjYW1lbEtleSkpIHtcbiAgICAgICAgICBwcm9wc1tjYW1lbEtleV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAocmF3Q2FzdFZhbHVlcyB8fCAocmF3Q2FzdFZhbHVlcyA9IHt9KSlbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gYXR0cnMpIHx8IHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5lZWRDYXN0S2V5cykge1xuICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICBjb25zdCBjYXN0VmFsdWVzID0gcmF3Q2FzdFZhbHVlcyB8fCBFTVBUWV9PQko7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWVkQ2FzdEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IG5lZWRDYXN0S2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICByYXdDdXJyZW50UHJvcHMsXG4gICAgICAgIGtleSxcbiAgICAgICAgY2FzdFZhbHVlc1trZXldLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgIWhhc093bihjYXN0VmFsdWVzLCBrZXkpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzQXR0cnNDaGFuZ2VkO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCBwcm9wcywga2V5LCB2YWx1ZSwgaW5zdGFuY2UsIGlzQWJzZW50KSB7XG4gIGNvbnN0IG9wdCA9IG9wdGlvbnNba2V5XTtcbiAgaWYgKG9wdCAhPSBudWxsKSB7XG4gICAgY29uc3QgaGFzRGVmYXVsdCA9IGhhc093bihvcHQsIFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoaGFzRGVmYXVsdCAmJiB2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBvcHQuZGVmYXVsdDtcbiAgICAgIGlmIChvcHQudHlwZSAhPT0gRnVuY3Rpb24gJiYgIW9wdC5za2lwRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wc0RlZmF1bHRzIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgaWYgKGtleSBpbiBwcm9wc0RlZmF1bHRzKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldID0gZGVmYXVsdFZhbHVlLmNhbGwoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGluc3RhbmNlLmNlKSB7XG4gICAgICAgIGluc3RhbmNlLmNlLl9zZXRQcm9wKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0WzAgLyogc2hvdWxkQ2FzdCAqL10pIHtcbiAgICAgIGlmIChpc0Fic2VudCAmJiAhaGFzRGVmYXVsdCkge1xuICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChvcHRbMSAvKiBzaG91bGRDYXN0VHJ1ZSAqL10gJiYgKHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBtaXhpblByb3BzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcbiAgY29uc3QgY2FjaGUgPSBfX1ZVRV9PUFRJT05TX0FQSV9fICYmIGFzTWl4aW4gPyBtaXhpblByb3BzQ2FjaGUgOiBhcHBDb250ZXh0LnByb3BzQ2FjaGU7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgcmF3ID0gY29tcC5wcm9wcztcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xuICBjb25zdCBuZWVkQ2FzdEtleXMgPSBbXTtcbiAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcbiAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICBjb25zdCBleHRlbmRQcm9wcyA9IChyYXcyKSA9PiB7XG4gICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcbiAgICAgIGNvbnN0IFtwcm9wcywga2V5c10gPSBub3JtYWxpemVQcm9wc09wdGlvbnMocmF3MiwgYXBwQ29udGV4dCwgdHJ1ZSk7XG4gICAgICBleHRlbmQobm9ybWFsaXplZCwgcHJvcHMpO1xuICAgICAgaWYgKGtleXMpIG5lZWRDYXN0S2V5cy5wdXNoKC4uLmtleXMpO1xuICAgIH07XG4gICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xuICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgfVxuICAgIGlmIChjb21wLmV4dGVuZHMpIHtcbiAgICAgIGV4dGVuZFByb3BzKGNvbXAuZXh0ZW5kcyk7XG4gICAgfVxuICAgIGlmIChjb21wLm1peGlucykge1xuICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgfVxuICB9XG4gIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XG4gICAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgICBjYWNoZS5zZXQoY29tcCwgRU1QVFlfQVJSKTtcbiAgICB9XG4gICAgcmV0dXJuIEVNUFRZX0FSUjtcbiAgfVxuICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc1N0cmluZyhyYXdbaV0pKSB7XG4gICAgICAgIHdhcm4kMShgcHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LmAsIHJhd1tpXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUocmF3W2ldKTtcbiAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBFTVBUWV9PQko7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHJhdykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc09iamVjdChyYXcpKSB7XG4gICAgICB3YXJuJDEoYGludmFsaWQgcHJvcHMgb3B0aW9uc2AsIHJhdyk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHJhdykge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xuICAgICAgICBjb25zdCBvcHQgPSByYXdba2V5XTtcbiAgICAgICAgY29uc3QgcHJvcCA9IG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpID8geyB0eXBlOiBvcHQgfSA6IGV4dGVuZCh7fSwgb3B0KTtcbiAgICAgICAgY29uc3QgcHJvcFR5cGUgPSBwcm9wLnR5cGU7XG4gICAgICAgIGxldCBzaG91bGRDYXN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBzaG91bGRDYXN0VHJ1ZSA9IHRydWU7XG4gICAgICAgIGlmIChpc0FycmF5KHByb3BUeXBlKSkge1xuICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwcm9wVHlwZS5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBwcm9wVHlwZVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCB0eXBlTmFtZSA9IGlzRnVuY3Rpb24odHlwZSkgJiYgdHlwZS5uYW1lO1xuICAgICAgICAgICAgaWYgKHR5cGVOYW1lID09PSBcIkJvb2xlYW5cIikge1xuICAgICAgICAgICAgICBzaG91bGRDYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSBcIlN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHNob3VsZENhc3RUcnVlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNob3VsZENhc3QgPSBpc0Z1bmN0aW9uKHByb3BUeXBlKSAmJiBwcm9wVHlwZS5uYW1lID09PSBcIkJvb2xlYW5cIjtcbiAgICAgICAgfVxuICAgICAgICBwcm9wWzAgLyogc2hvdWxkQ2FzdCAqL10gPSBzaG91bGRDYXN0O1xuICAgICAgICBwcm9wWzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dID0gc2hvdWxkQ2FzdFRydWU7XG4gICAgICAgIGlmIChzaG91bGRDYXN0IHx8IGhhc093bihwcm9wLCBcImRlZmF1bHRcIikpIHtcbiAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaChub3JtYWxpemVkS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCByZXMgPSBbbm9ybWFsaXplZCwgbmVlZENhc3RLZXlzXTtcbiAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgY2FjaGUuc2V0KGNvbXAsIHJlcyk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcE5hbWUoa2V5KSB7XG4gIGlmIChrZXlbMF0gIT09IFwiJFwiICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShgSW52YWxpZCBwcm9wIG5hbWU6IFwiJHtrZXl9XCIgaXMgYSByZXNlcnZlZCBwcm9wZXJ0eS5gKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRUeXBlKGN0b3IpIHtcbiAgaWYgKGN0b3IgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBjdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gY3Rvci5uYW1lIHx8IFwiXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGN0b3IgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCBuYW1lID0gY3Rvci5jb25zdHJ1Y3RvciAmJiBjdG9yLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgfHwgXCJcIjtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMsIHByb3BzLCBpbnN0YW5jZSkge1xuICBjb25zdCByZXNvbHZlZFZhbHVlcyA9IHRvUmF3KHByb3BzKTtcbiAgY29uc3Qgb3B0aW9ucyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgIGxldCBvcHQgPSBvcHRpb25zW2tleV07XG4gICAgaWYgKG9wdCA9PSBudWxsKSBjb250aW51ZTtcbiAgICB2YWxpZGF0ZVByb3AoXG4gICAgICBrZXksXG4gICAgICByZXNvbHZlZFZhbHVlc1trZXldLFxuICAgICAgb3B0LFxuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShyZXNvbHZlZFZhbHVlcykgOiByZXNvbHZlZFZhbHVlcyxcbiAgICAgICFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiYgIWhhc093bihyYXdQcm9wcywgaHlwaGVuYXRlKGtleSkpXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKG5hbWUsIHZhbHVlLCBwcm9wLCBwcm9wcywgaXNBYnNlbnQpIHtcbiAgY29uc3QgeyB0eXBlLCByZXF1aXJlZCwgdmFsaWRhdG9yLCBza2lwQ2hlY2sgfSA9IHByb3A7XG4gIGlmIChyZXF1aXJlZCAmJiBpc0Fic2VudCkge1xuICAgIHdhcm4kMSgnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFyZXF1aXJlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZSAhPSBudWxsICYmIHR5cGUgIT09IHRydWUgJiYgIXNraXBDaGVjaykge1xuICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XG4gICAgY29uc3QgdHlwZXMgPSBpc0FycmF5KHR5cGUpID8gdHlwZSA6IFt0eXBlXTtcbiAgICBjb25zdCBleHBlY3RlZFR5cGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGggJiYgIWlzVmFsaWQ7IGkrKykge1xuICAgICAgY29uc3QgeyB2YWxpZCwgZXhwZWN0ZWRUeXBlIH0gPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlc1tpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goZXhwZWN0ZWRUeXBlIHx8IFwiXCIpO1xuICAgICAgaXNWYWxpZCA9IHZhbGlkO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHdhcm4kMShnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKHZhbGlkYXRvciAmJiAhdmFsaWRhdG9yKHZhbHVlLCBwcm9wcykpIHtcbiAgICB3YXJuJDEoJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nKTtcbiAgfVxufVxuY29uc3QgaXNTaW1wbGVUeXBlID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIFwiU3RyaW5nLE51bWJlcixCb29sZWFuLEZ1bmN0aW9uLFN5bWJvbCxCaWdJbnRcIlxuKTtcbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUpIHtcbiAgbGV0IHZhbGlkO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIm51bGxcIikge1xuICAgIHZhbGlkID0gdmFsdWUgPT09IG51bGw7XG4gIH0gZWxzZSBpZiAoaXNTaW1wbGVUeXBlKGV4cGVjdGVkVHlwZSkpIHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIk9iamVjdFwiKSB7XG4gICAgdmFsaWQgPSBpc09iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIkFycmF5XCIpIHtcbiAgICB2YWxpZCA9IGlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGBQcm9wIHR5cGUgW10gZm9yIHByb3AgXCIke25hbWV9XCIgd29uJ3QgbWF0Y2ggYW55dGhpbmcuIERpZCB5b3UgbWVhbiB0byB1c2UgdHlwZSBBcnJheSBpbnN0ZWFkP2A7XG4gIH1cbiAgbGV0IG1lc3NhZ2UgPSBgSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIiR7bmFtZX1cIi4gRXhwZWN0ZWQgJHtleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKFwiIHwgXCIpfWA7XG4gIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XG4gIGNvbnN0IHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XG4gIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xuICBjb25zdCByZWNlaXZlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKTtcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBgIHdpdGggdmFsdWUgJHtleHBlY3RlZFZhbHVlfWA7XG4gIH1cbiAgbWVzc2FnZSArPSBgLCBnb3QgJHtyZWNlaXZlZFR5cGV9IGA7XG4gIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYHdpdGggdmFsdWUgJHtyZWNlaXZlZFZhbHVlfS5gO1xuICB9XG4gIHJldHVybiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gc3R5bGVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gXCJTdHJpbmdcIikge1xuICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcIk51bWJlclwiKSB7XG4gICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYCR7dmFsdWV9YDtcbiAgfVxufVxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlKHR5cGUpIHtcbiAgY29uc3QgZXhwbGljaXRUeXBlcyA9IFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl07XG4gIHJldHVybiBleHBsaWNpdFR5cGVzLnNvbWUoKGVsZW0pID0+IHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbSk7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4oLi4uYXJncykge1xuICByZXR1cm4gYXJncy5zb21lKChlbGVtKSA9PiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09IFwiYm9vbGVhblwiKTtcbn1cblxuY29uc3QgaXNJbnRlcm5hbEtleSA9IChrZXkpID0+IGtleVswXSA9PT0gXCJfXCIgfHwga2V5ID09PSBcIiRzdGFibGVcIjtcbmNvbnN0IG5vcm1hbGl6ZVNsb3RWYWx1ZSA9ICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAobm9ybWFsaXplVk5vZGUpIDogW25vcm1hbGl6ZVZOb2RlKHZhbHVlKV07XG5jb25zdCBub3JtYWxpemVTbG90ID0gKGtleSwgcmF3U2xvdCwgY3R4KSA9PiB7XG4gIGlmIChyYXdTbG90Ll9uKSB7XG4gICAgcmV0dXJuIHJhd1Nsb3Q7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZCA9IHdpdGhDdHgoKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjdXJyZW50SW5zdGFuY2UgJiYgKCFjdHggfHwgY3R4LnJvb3QgPT09IGN1cnJlbnRJbnN0YW5jZS5yb290KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgU2xvdCBcIiR7a2V5fVwiIGludm9rZWQgb3V0c2lkZSBvZiB0aGUgcmVuZGVyIGZ1bmN0aW9uOiB0aGlzIHdpbGwgbm90IHRyYWNrIGRlcGVuZGVuY2llcyB1c2VkIGluIHRoZSBzbG90LiBJbnZva2UgdGhlIHNsb3QgZnVuY3Rpb24gaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplU2xvdFZhbHVlKHJhd1Nsb3QoLi4uYXJncykpO1xuICB9LCBjdHgpO1xuICBub3JtYWxpemVkLl9jID0gZmFsc2U7XG4gIHJldHVybiBub3JtYWxpemVkO1xufTtcbmNvbnN0IG5vcm1hbGl6ZU9iamVjdFNsb3RzID0gKHJhd1Nsb3RzLCBzbG90cywgaW5zdGFuY2UpID0+IHtcbiAgY29uc3QgY3R4ID0gcmF3U2xvdHMuX2N0eDtcbiAgZm9yIChjb25zdCBrZXkgaW4gcmF3U2xvdHMpIHtcbiAgICBpZiAoaXNJbnRlcm5hbEtleShrZXkpKSBjb250aW51ZTtcbiAgICBjb25zdCB2YWx1ZSA9IHJhd1Nsb3RzW2tleV07XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICBzbG90c1trZXldID0gbm9ybWFsaXplU2xvdChrZXksIHZhbHVlLCBjdHgpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3Igc2xvdCBcIiR7a2V5fVwiLiBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKHZhbHVlKTtcbiAgICAgIHNsb3RzW2tleV0gPSAoKSA9PiBub3JtYWxpemVkO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IG5vcm1hbGl6ZVZOb2RlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuKSA9PiB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0tlZXBBbGl2ZShpbnN0YW5jZS52bm9kZSkgJiYgdHJ1ZSkge1xuICAgIHdhcm4kMShcbiAgICAgIGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIGRlZmF1bHQgc2xvdC4gUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYFxuICAgICk7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZShjaGlsZHJlbik7XG4gIGluc3RhbmNlLnNsb3RzLmRlZmF1bHQgPSAoKSA9PiBub3JtYWxpemVkO1xufTtcbmNvbnN0IGFzc2lnblNsb3RzID0gKHNsb3RzLCBjaGlsZHJlbiwgb3B0aW1pemVkKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIGNoaWxkcmVuKSB7XG4gICAgaWYgKG9wdGltaXplZCB8fCBrZXkgIT09IFwiX1wiKSB7XG4gICAgICBzbG90c1trZXldID0gY2hpbGRyZW5ba2V5XTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBpbml0U2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpID0+IHtcbiAgY29uc3Qgc2xvdHMgPSBpbnN0YW5jZS5zbG90cyA9IGNyZWF0ZUludGVybmFsT2JqZWN0KCk7XG4gIGlmIChpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiAzMikge1xuICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBhc3NpZ25TbG90cyhzbG90cywgY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gICAgICBpZiAob3B0aW1pemVkKSB7XG4gICAgICAgIGRlZihzbG90cywgXCJfXCIsIHR5cGUsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgfVxufTtcbmNvbnN0IHVwZGF0ZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbiwgb3B0aW1pemVkKSA9PiB7XG4gIGNvbnN0IHsgdm5vZGUsIHNsb3RzIH0gPSBpbnN0YW5jZTtcbiAgbGV0IG5lZWREZWxldGlvbkNoZWNrID0gdHJ1ZTtcbiAgbGV0IGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IEVNUFRZX09CSjtcbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDMyKSB7XG4gICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgICAgYXNzaWduU2xvdHMoc2xvdHMsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICAgICAgICB0cmlnZ2VyKGluc3RhbmNlLCBcInNldFwiLCBcIiRzbG90c1wiKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW1pemVkICYmIHR5cGUgPT09IDEpIHtcbiAgICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2lnblNsb3RzKHNsb3RzLCBjaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSAhY2hpbGRyZW4uJHN0YWJsZTtcbiAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKGNoaWxkcmVuLCBzbG90cyk7XG4gICAgfVxuICAgIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xuICAgIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IHsgZGVmYXVsdDogMSB9O1xuICB9XG4gIGlmIChuZWVkRGVsZXRpb25DaGVjaykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XG4gICAgICBpZiAoIWlzSW50ZXJuYWxLZXkoa2V5KSAmJiBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBzbG90c1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubGV0IHN1cHBvcnRlZDtcbmxldCBwZXJmO1xuZnVuY3Rpb24gc3RhcnRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XG4gIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XG4gICAgcGVyZi5tYXJrKGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc1BlcmZTdGFydChpbnN0YW5jZSwgdHlwZSwgaXNTdXBwb3J0ZWQoKSA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5kTWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xuICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xuICAgIGNvbnN0IHN0YXJ0VGFnID0gYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWA7XG4gICAgY29uc3QgZW5kVGFnID0gc3RhcnRUYWcgKyBgOmVuZGA7XG4gICAgcGVyZi5tYXJrKGVuZFRhZyk7XG4gICAgcGVyZi5tZWFzdXJlKFxuICAgICAgYDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIGluc3RhbmNlLnR5cGUpfT4gJHt0eXBlfWAsXG4gICAgICBzdGFydFRhZyxcbiAgICAgIGVuZFRhZ1xuICAgICk7XG4gICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc1BlcmZFbmQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICBpZiAoc3VwcG9ydGVkICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc3VwcG9ydGVkO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgcGVyZiA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgfSBlbHNlIHtcbiAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gc3VwcG9ydGVkO1xufVxuXG5mdW5jdGlvbiBpbml0RmVhdHVyZUZsYWdzKCkge1xuICBjb25zdCBuZWVkV2FybiA9IFtdO1xuICBpZiAodHlwZW9mIF9fVlVFX09QVElPTlNfQVBJX18gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9PUFRJT05TX0FQSV9fYCk7XG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX09QVElPTlNfQVBJX18gPSB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSBcImJvb2xlYW5cIikge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfUFJPRF9ERVZUT09MU19fYCk7XG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX1BST0RfREVWVE9PTFNfXyA9IGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fICE9PSBcImJvb2xlYW5cIikge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fYCk7XG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXyA9IGZhbHNlO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLmxlbmd0aCkge1xuICAgIGNvbnN0IG11bHRpID0gbmVlZFdhcm4ubGVuZ3RoID4gMTtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgRmVhdHVyZSBmbGFnJHttdWx0aSA/IGBzYCA6IGBgfSAke25lZWRXYXJuLmpvaW4oXCIsIFwiKX0gJHttdWx0aSA/IGBhcmVgIDogYGlzYH0gbm90IGV4cGxpY2l0bHkgZGVmaW5lZC4gWW91IGFyZSBydW5uaW5nIHRoZSBlc20tYnVuZGxlciBidWlsZCBvZiBWdWUsIHdoaWNoIGV4cGVjdHMgdGhlc2UgY29tcGlsZS10aW1lIGZlYXR1cmUgZmxhZ3MgdG8gYmUgZ2xvYmFsbHkgaW5qZWN0ZWQgdmlhIHRoZSBidW5kbGVyIGNvbmZpZyBpbiBvcmRlciB0byBnZXQgYmV0dGVyIHRyZWUtc2hha2luZyBpbiB0aGUgcHJvZHVjdGlvbiBidW5kbGUuXG5cbkZvciBtb3JlIGRldGFpbHMsIHNlZSBodHRwczovL2xpbmsudnVlanMub3JnL2ZlYXR1cmUtZmxhZ3MuYFxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgcXVldWVQb3N0UmVuZGVyRWZmZWN0ID0gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UgO1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIob3B0aW9ucykge1xuICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIob3B0aW9ucykge1xuICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyk7XG59XG5mdW5jdGlvbiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRm5zKSB7XG4gIHtcbiAgICBpbml0RmVhdHVyZUZsYWdzKCk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0ID0gZ2V0R2xvYmFsVGhpcygpO1xuICB0YXJnZXQuX19WVUVfXyA9IHRydWU7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgIHNldERldnRvb2xzSG9vayQxKHRhcmdldC5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fLCB0YXJnZXQpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpbnNlcnQ6IGhvc3RJbnNlcnQsXG4gICAgcmVtb3ZlOiBob3N0UmVtb3ZlLFxuICAgIHBhdGNoUHJvcDogaG9zdFBhdGNoUHJvcCxcbiAgICBjcmVhdGVFbGVtZW50OiBob3N0Q3JlYXRlRWxlbWVudCxcbiAgICBjcmVhdGVUZXh0OiBob3N0Q3JlYXRlVGV4dCxcbiAgICBjcmVhdGVDb21tZW50OiBob3N0Q3JlYXRlQ29tbWVudCxcbiAgICBzZXRUZXh0OiBob3N0U2V0VGV4dCxcbiAgICBzZXRFbGVtZW50VGV4dDogaG9zdFNldEVsZW1lbnRUZXh0LFxuICAgIHBhcmVudE5vZGU6IGhvc3RQYXJlbnROb2RlLFxuICAgIG5leHRTaWJsaW5nOiBob3N0TmV4dFNpYmxpbmcsXG4gICAgc2V0U2NvcGVJZDogaG9zdFNldFNjb3BlSWQgPSBOT09QLFxuICAgIGluc2VydFN0YXRpY0NvbnRlbnQ6IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBwYXRjaCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yID0gbnVsbCwgcGFyZW50Q29tcG9uZW50ID0gbnVsbCwgcGFyZW50U3VzcGVuc2UgPSBudWxsLCBuYW1lc3BhY2UgPSB2b2lkIDAsIHNsb3RTY29wZUlkcyA9IG51bGwsIG9wdGltaXplZCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZyA/IGZhbHNlIDogISFuMi5keW5hbWljQ2hpbGRyZW4pID0+IHtcbiAgICBpZiAobjEgPT09IG4yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuMSAmJiAhaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgIGFuY2hvciA9IGdldE5leHRIb3N0Tm9kZShuMSk7XG4gICAgICB1bm1vdW50KG4xLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgIG4xID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG4yLnBhdGNoRmxhZyA9PT0gLTIpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgbjIuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZyB9ID0gbjI7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFRleHQ6XG4gICAgICAgIHByb2Nlc3NUZXh0KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29tbWVudDpcbiAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGljOlxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgICAgIG1vdW50U3RhdGljTm9kZShuMiwgY29udGFpbmVyLCBhbmNob3IsIG5hbWVzcGFjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHBhdGNoU3RhdGljTm9kZShuMSwgbjIsIGNvbnRhaW5lciwgbmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHByb2Nlc3NGcmFnbWVudChcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxKSB7XG4gICAgICAgICAgcHJvY2Vzc0VsZW1lbnQoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgICAgICBwcm9jZXNzQ29tcG9uZW50KFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgICAgIHR5cGUucHJvY2VzcyhcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIGludGVybmFsc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgICAgdHlwZS5wcm9jZXNzKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgaW50ZXJuYWxzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFwiSW52YWxpZCBWTm9kZSB0eXBlOlwiLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZWYgIT0gbnVsbCAmJiBwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIHNldFJlZihyZWYsIG4xICYmIG4xLnJlZiwgcGFyZW50U3VzcGVuc2UsIG4yIHx8IG4xLCAhbjIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc1RleHQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBob3N0SW5zZXJ0KFxuICAgICAgICBuMi5lbCA9IGhvc3RDcmVhdGVUZXh0KG4yLmNoaWxkcmVuKSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVsID0gbjIuZWwgPSBuMS5lbDtcbiAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcbiAgICAgICAgaG9zdFNldFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NDb21tZW50Tm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGhvc3RJbnNlcnQoXG4gICAgICAgIG4yLmVsID0gaG9zdENyZWF0ZUNvbW1lbnQobjIuY2hpbGRyZW4gfHwgXCJcIiksXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRTdGF0aWNOb2RlID0gKG4yLCBjb250YWluZXIsIGFuY2hvciwgbmFtZXNwYWNlKSA9PiB7XG4gICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQoXG4gICAgICBuMi5jaGlsZHJlbixcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGFuY2hvcixcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIG4yLmVsLFxuICAgICAgbjIuYW5jaG9yXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgcGF0Y2hTdGF0aWNOb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBuYW1lc3BhY2UpID0+IHtcbiAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBhbmNob3IgPSBob3N0TmV4dFNpYmxpbmcobjEuYW5jaG9yKTtcbiAgICAgIHJlbW92ZVN0YXRpY05vZGUobjEpO1xuICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQoXG4gICAgICAgIG4yLmNoaWxkcmVuLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgbjIuYW5jaG9yID0gbjEuYW5jaG9yO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0sIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpID0+IHtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xuICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XG4gICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcbiAgICAgIGVsID0gbmV4dDtcbiAgICB9XG4gICAgaG9zdEluc2VydChhbmNob3IsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xuICB9O1xuICBjb25zdCByZW1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9KSA9PiB7XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xuICAgICAgaG9zdFJlbW92ZShlbCk7XG4gICAgICBlbCA9IG5leHQ7XG4gICAgfVxuICAgIGhvc3RSZW1vdmUoYW5jaG9yKTtcbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0VsZW1lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGlmIChuMi50eXBlID09PSBcInN2Z1wiKSB7XG4gICAgICBuYW1lc3BhY2UgPSBcInN2Z1wiO1xuICAgIH0gZWxzZSBpZiAobjIudHlwZSA9PT0gXCJtYXRoXCIpIHtcbiAgICAgIG5hbWVzcGFjZSA9IFwibWF0aG1sXCI7XG4gICAgfVxuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBtb3VudEVsZW1lbnQoXG4gICAgICAgIG4yLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2hFbGVtZW50KFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudEVsZW1lbnQgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgbGV0IGVsO1xuICAgIGxldCB2bm9kZUhvb2s7XG4gICAgY29uc3QgeyBwcm9wcywgc2hhcGVGbGFnLCB0cmFuc2l0aW9uLCBkaXJzIH0gPSB2bm9kZTtcbiAgICBlbCA9IHZub2RlLmVsID0gaG9zdENyZWF0ZUVsZW1lbnQoXG4gICAgICB2bm9kZS50eXBlLFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgcHJvcHMgJiYgcHJvcHMuaXMsXG4gICAgICBwcm9wc1xuICAgICk7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgdm5vZGUuY2hpbGRyZW4pO1xuICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgIHZub2RlLmNoaWxkcmVuLFxuICAgICAgICBlbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgcmVzb2x2ZUNoaWxkcmVuTmFtZXNwYWNlKHZub2RlLCBuYW1lc3BhY2UpLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJjcmVhdGVkXCIpO1xuICAgIH1cbiAgICBzZXRTY29wZUlkKGVsLCB2bm9kZSwgdm5vZGUuc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gXCJ2YWx1ZVwiICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCBuYW1lc3BhY2UsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChcInZhbHVlXCIgaW4gcHJvcHMpIHtcbiAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJ2YWx1ZVwiLCBudWxsLCBwcm9wcy52YWx1ZSwgbmFtZXNwYWNlKTtcbiAgICAgIH1cbiAgICAgIGlmICh2bm9kZUhvb2sgPSBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpIHtcbiAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZGVmKGVsLCBcIl9fdm5vZGVcIiwgdm5vZGUsIHRydWUpO1xuICAgICAgZGVmKGVsLCBcIl9fdnVlUGFyZW50Q29tcG9uZW50XCIsIHBhcmVudENvbXBvbmVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChkaXJzKSB7XG4gICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlTW91bnRcIik7XG4gICAgfVxuICAgIGNvbnN0IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gbmVlZFRyYW5zaXRpb24ocGFyZW50U3VzcGVuc2UsIHRyYW5zaXRpb24pO1xuICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xuICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgfVxuICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyB8fCBkaXJzKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJtb3VudGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0U2NvcGVJZCA9IChlbCwgdm5vZGUsIHNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KSA9PiB7XG4gICAgaWYgKHNjb3BlSWQpIHtcbiAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzY29wZUlkKTtcbiAgICB9XG4gICAgaWYgKHNsb3RTY29wZUlkcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbG90U2NvcGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNsb3RTY29wZUlkc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIGxldCBzdWJUcmVlID0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWU7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzdWJUcmVlLnBhdGNoRmxhZyA+IDAgJiYgc3ViVHJlZS5wYXRjaEZsYWcgJiAyMDQ4KSB7XG4gICAgICAgIHN1YlRyZWUgPSBmaWx0ZXJTaW5nbGVSb290KHN1YlRyZWUuY2hpbGRyZW4pIHx8IHN1YlRyZWU7XG4gICAgICB9XG4gICAgICBpZiAodm5vZGUgPT09IHN1YlRyZWUgfHwgaXNTdXNwZW5zZShzdWJUcmVlLnR5cGUpICYmIChzdWJUcmVlLnNzQ29udGVudCA9PT0gdm5vZGUgfHwgc3ViVHJlZS5zc0ZhbGxiYWNrID09PSB2bm9kZSkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50Vk5vZGUgPSBwYXJlbnRDb21wb25lbnQudm5vZGU7XG4gICAgICAgIHNldFNjb3BlSWQoXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgcGFyZW50Vk5vZGUsXG4gICAgICAgICAgcGFyZW50Vk5vZGUuc2NvcGVJZCxcbiAgICAgICAgICBwYXJlbnRWTm9kZS5zbG90U2NvcGVJZHMsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LnBhcmVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHN0YXJ0ID0gMCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoY2hpbGRyZW5baV0pIDogbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pO1xuICAgICAgcGF0Y2goXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoRWxlbWVudCA9IChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBlbCA9IG4yLmVsID0gbjEuZWw7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBlbC5fX3Zub2RlID0gbjI7XG4gICAgfVxuICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBkaXJzIH0gPSBuMjtcbiAgICBwYXRjaEZsYWcgfD0gbjEucGF0Y2hGbGFnICYgMTY7XG4gICAgY29uc3Qgb2xkUHJvcHMgPSBuMS5wcm9wcyB8fCBFTVBUWV9PQko7XG4gICAgY29uc3QgbmV3UHJvcHMgPSBuMi5wcm9wcyB8fCBFTVBUWV9PQko7XG4gICAgbGV0IHZub2RlSG9vaztcbiAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIGZhbHNlKTtcbiAgICBpZiAodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkge1xuICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xuICAgIH1cbiAgICBpZiAoZGlycykge1xuICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVVcGRhdGVcIik7XG4gICAgfVxuICAgIHBhcmVudENvbXBvbmVudCAmJiB0b2dnbGVSZWN1cnNlKHBhcmVudENvbXBvbmVudCwgdHJ1ZSk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgcGF0Y2hGbGFnID0gMDtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG9sZFByb3BzLmlubmVySFRNTCAmJiBuZXdQcm9wcy5pbm5lckhUTUwgPT0gbnVsbCB8fCBvbGRQcm9wcy50ZXh0Q29udGVudCAmJiBuZXdQcm9wcy50ZXh0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIFwiXCIpO1xuICAgIH1cbiAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4oXG4gICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICBlbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgcmVzb2x2ZUNoaWxkcmVuTmFtZXNwYWNlKG4yLCBuYW1lc3BhY2UpLFxuICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghb3B0aW1pemVkKSB7XG4gICAgICBwYXRjaENoaWxkcmVuKFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIGVsLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICByZXNvbHZlQ2hpbGRyZW5OYW1lc3BhY2UobjIsIG5hbWVzcGFjZSksXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMTYpIHtcbiAgICAgICAgcGF0Y2hQcm9wcyhlbCwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMikge1xuICAgICAgICAgIGlmIChvbGRQcm9wcy5jbGFzcyAhPT0gbmV3UHJvcHMuY2xhc3MpIHtcbiAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwiY2xhc3NcIiwgbnVsbCwgbmV3UHJvcHMuY2xhc3MsIG5hbWVzcGFjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiA0KSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJzdHlsZVwiLCBvbGRQcm9wcy5zdHlsZSwgbmV3UHJvcHMuc3R5bGUsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gbjIuZHluYW1pY1Byb3BzO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiB8fCBrZXkgPT09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIG5hbWVzcGFjZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXRjaEZsYWcgJiAxKSB7XG4gICAgICAgIGlmIChuMS5jaGlsZHJlbiAhPT0gbjIuY2hpbGRyZW4pIHtcbiAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW9wdGltaXplZCAmJiBkeW5hbWljQ2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgcGF0Y2hQcm9wcyhlbCwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSk7XG4gICAgfVxuICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZVVwZGF0ZWQpIHx8IGRpcnMpIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XG4gICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgXCJ1cGRhdGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hCbG9ja0NoaWxkcmVuID0gKG9sZENoaWxkcmVuLCBuZXdDaGlsZHJlbiwgZmFsbGJhY2tDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgb2xkVk5vZGUgPSBvbGRDaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IG5ld1ZOb2RlID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICBjb25zdCBjb250YWluZXIgPSAoXG4gICAgICAgIC8vIG9sZFZOb2RlIG1heSBiZSBhbiBlcnJvcmVkIGFzeW5jIHNldHVwKCkgY29tcG9uZW50IGluc2lkZSBTdXNwZW5zZVxuICAgICAgICAvLyB3aGljaCB3aWxsIG5vdCBoYXZlIGEgbW91bnRlZCBlbGVtZW50XG4gICAgICAgIG9sZFZOb2RlLmVsICYmIC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBGcmFnbWVudCwgd2UgbmVlZCB0byBwcm92aWRlIHRoZSBhY3R1YWwgcGFyZW50XG4gICAgICAgIC8vIG9mIHRoZSBGcmFnbWVudCBpdHNlbGYgc28gaXQgY2FuIG1vdmUgaXRzIGNoaWxkcmVuLlxuICAgICAgICAob2xkVk5vZGUudHlwZSA9PT0gRnJhZ21lbnQgfHwgLy8gLSBJbiB0aGUgY2FzZSBvZiBkaWZmZXJlbnQgbm9kZXMsIHRoZXJlIGlzIGdvaW5nIHRvIGJlIGEgcmVwbGFjZW1lbnRcbiAgICAgICAgLy8gd2hpY2ggYWxzbyByZXF1aXJlcyB0aGUgY29ycmVjdCBwYXJlbnQgY29udGFpbmVyXG4gICAgICAgICFpc1NhbWVWTm9kZVR5cGUob2xkVk5vZGUsIG5ld1ZOb2RlKSB8fCAvLyAtIEluIHRoZSBjYXNlIG9mIGEgY29tcG9uZW50LCBpdCBjb3VsZCBjb250YWluIGFueXRoaW5nLlxuICAgICAgICBvbGRWTm9kZS5zaGFwZUZsYWcgJiAoNiB8IDY0KSkgPyBob3N0UGFyZW50Tm9kZShvbGRWTm9kZS5lbCkgOiAoXG4gICAgICAgICAgLy8gSW4gb3RoZXIgY2FzZXMsIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIG5vdCBhY3R1YWxseSB1c2VkIHNvIHdlXG4gICAgICAgICAgLy8ganVzdCBwYXNzIHRoZSBibG9jayBlbGVtZW50IGhlcmUgdG8gYXZvaWQgYSBET00gcGFyZW50Tm9kZSBjYWxsLlxuICAgICAgICAgIGZhbGxiYWNrQ29udGFpbmVyXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBwYXRjaChcbiAgICAgICAgb2xkVk5vZGUsXG4gICAgICAgIG5ld1ZOb2RlLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hQcm9wcyA9IChlbCwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSkgPT4ge1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMpIHtcbiAgICAgIGlmIChvbGRQcm9wcyAhPT0gRU1QVFlfT0JKKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJvcChrZXkpICYmICEoa2V5IGluIG5ld1Byb3BzKSkge1xuICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgb2xkUHJvcHNba2V5XSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdQcm9wcykge1xuICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xuICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcbiAgICAgICAgaWYgKG5leHQgIT09IHByZXYgJiYga2V5ICE9PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIG5hbWVzcGFjZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFwidmFsdWVcIiBpbiBuZXdQcm9wcykge1xuICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBcInZhbHVlXCIsIG9sZFByb3BzLnZhbHVlLCBuZXdQcm9wcy52YWx1ZSwgbmFtZXNwYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NGcmFnbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgZnJhZ21lbnRTdGFydEFuY2hvciA9IG4yLmVsID0gbjEgPyBuMS5lbCA6IGhvc3RDcmVhdGVUZXh0KFwiXCIpO1xuICAgIGNvbnN0IGZyYWdtZW50RW5kQW5jaG9yID0gbjIuYW5jaG9yID0gbjEgPyBuMS5hbmNob3IgOiBob3N0Q3JlYXRlVGV4dChcIlwiKTtcbiAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gbjI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgLy8gIzU1MjMgZGV2IHJvb3QgZnJhZ21lbnQgbWF5IGluaGVyaXQgZGlyZWN0aXZlc1xuICAgIChpc0htclVwZGF0aW5nIHx8IHBhdGNoRmxhZyAmIDIwNDgpKSB7XG4gICAgICBwYXRjaEZsYWcgPSAwO1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcbiAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcyA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XG4gICAgfVxuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBob3N0SW5zZXJ0KGZyYWdtZW50U3RhcnRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRFbmRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgIC8vICMxMDAwN1xuICAgICAgICAvLyBzdWNoIGZyYWdtZW50IGxpa2UgYDw+PC8+YCB3aWxsIGJlIGNvbXBpbGVkIGludG9cbiAgICAgICAgLy8gYSBmcmFnbWVudCB3aGljaCBkb2Vzbid0IGhhdmUgYSBjaGlsZHJlbi5cbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlIGZhbGxiYWNrIHRvIGFuIGVtcHR5IGFycmF5XG4gICAgICAgIG4yLmNoaWxkcmVuIHx8IFtdLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGZyYWdtZW50RW5kQW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCAmJiBkeW5hbWljQ2hpbGRyZW4gJiYgLy8gIzI3MTUgdGhlIHByZXZpb3VzIGZyYWdtZW50IGNvdWxkJ3ZlIGJlZW4gYSBCQUlMZWQgb25lIGFzIGEgcmVzdWx0XG4gICAgICAvLyBvZiByZW5kZXJTbG90KCkgd2l0aCBubyB2YWxpZCBjaGlsZHJlblxuICAgICAgbjEuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihcbiAgICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAvLyAjMjA4MCBpZiB0aGUgc3RhYmxlIGZyYWdtZW50IGhhcyBhIGtleSwgaXQncyBhIDx0ZW1wbGF0ZSB2LWZvcj4gdGhhdCBtYXlcbiAgICAgICAgICAvLyAgZ2V0IG1vdmVkIGFyb3VuZC4gTWFrZSBzdXJlIGFsbCByb290IGxldmVsIHZub2RlcyBpbmhlcml0IGVsLlxuICAgICAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxuICAgICAgICAgIC8vIGFzIHRoZSBjb21wb25lbnQgaXMgYmVpbmcgbW92ZWQuXG4gICAgICAgICAgbjIua2V5ICE9IG51bGwgfHwgcGFyZW50Q29tcG9uZW50ICYmIG4yID09PSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZVxuICAgICAgICApIHtcbiAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgIC8qIHNoYWxsb3cgKi9cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRjaENoaWxkcmVuKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBmcmFnbWVudEVuZEFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NDb21wb25lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIG4yLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaWYgKG4yLnNoYXBlRmxhZyAmIDUxMikge1xuICAgICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmFjdGl2YXRlKFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRDb21wb25lbnQoXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRDb21wb25lbnQgPSAoaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IChpbml0aWFsVk5vZGUuY29tcG9uZW50ID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UoXG4gICAgICBpbml0aWFsVk5vZGUsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZVxuICAgICkpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xuICAgICAgcmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGluaXRpYWxWTm9kZSk7XG4gICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xuICAgIH1cbiAgICBpZiAoaXNLZWVwQWxpdmUoaW5pdGlhbFZOb2RlKSkge1xuICAgICAgaW5zdGFuY2UuY3R4LnJlbmRlcmVyID0gaW50ZXJuYWxzO1xuICAgIH1cbiAgICB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XG4gICAgICB9XG4gICAgICBzZXR1cENvbXBvbmVudChpbnN0YW5jZSwgZmFsc2UsIG9wdGltaXplZCk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXApIHtcbiAgICAgIHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCwgb3B0aW1pemVkKTtcbiAgICAgIGlmICghaW5pdGlhbFZOb2RlLmVsKSB7XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gaW5zdGFuY2Uuc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobnVsbCwgcGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICBpbml0aWFsVk5vZGUsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYG1vdW50YCk7XG4gICAgfVxuICB9O1xuICBjb25zdCB1cGRhdGVDb21wb25lbnQgPSAobjEsIG4yLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IG4yLmNvbXBvbmVudCA9IG4xLmNvbXBvbmVudDtcbiAgICBpZiAoc2hvdWxkVXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKSkge1xuICAgICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwICYmICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG4yKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG4yLCBvcHRpbWl6ZWQpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2UubmV4dCA9IG4yO1xuICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICAgIGluc3RhbmNlLnZub2RlID0gbjI7XG4gICAgfVxuICB9O1xuICBjb25zdCBzZXR1cFJlbmRlckVmZmVjdCA9IChpbnN0YW5jZSwgaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgY29tcG9uZW50VXBkYXRlRm4gPSAoKSA9PiB7XG4gICAgICBpZiAoIWluc3RhbmNlLmlzTW91bnRlZCkge1xuICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICBjb25zdCB7IGVsLCBwcm9wcyB9ID0gaW5pdGlhbFZOb2RlO1xuICAgICAgICBjb25zdCB7IGJtLCBtLCBwYXJlbnQsIHJvb3QsIHR5cGUgfSA9IGluc3RhbmNlO1xuICAgICAgICBjb25zdCBpc0FzeW5jV3JhcHBlclZOb2RlID0gaXNBc3luY1dyYXBwZXIoaW5pdGlhbFZOb2RlKTtcbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgZmFsc2UpO1xuICAgICAgICBpZiAoYm0pIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhibSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FzeW5jV3JhcHBlclZOb2RlICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBpbml0aWFsVk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgICAgICBpZiAoZWwgJiYgaHlkcmF0ZU5vZGUpIHtcbiAgICAgICAgICBjb25zdCBoeWRyYXRlU3ViVHJlZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHlkcmF0ZU5vZGUoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlLFxuICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGlzQXN5bmNXcmFwcGVyVk5vZGUpIHtcbiAgICAgICAgICAgIHR5cGUuX19hc3luY0h5ZHJhdGUoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgaHlkcmF0ZVN1YlRyZWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh5ZHJhdGVTdWJUcmVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyb290LmNlKSB7XG4gICAgICAgICAgICByb290LmNlLl9pbmplY3RDaGlsZFN0eWxlKHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN1YlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHN1YlRyZWUsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluaXRpYWxWTm9kZS5lbCA9IHN1YlRyZWUuZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QobSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBc3luY1dyYXBwZXJWTm9kZSAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpKSB7XG4gICAgICAgICAgY29uc3Qgc2NvcGVkSW5pdGlhbFZOb2RlID0gaW5pdGlhbFZOb2RlO1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChcbiAgICAgICAgICAgICgpID0+IGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgc2NvcGVkSW5pdGlhbFZOb2RlKSxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdGlhbFZOb2RlLnNoYXBlRmxhZyAmIDI1NiB8fCBwYXJlbnQgJiYgaXNBc3luY1dyYXBwZXIocGFyZW50LnZub2RlKSAmJiBwYXJlbnQudm5vZGUuc2hhcGVGbGFnICYgMjU2KSB7XG4gICAgICAgICAgaW5zdGFuY2UuYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoaW5zdGFuY2UuYSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLmlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGluaXRpYWxWTm9kZSA9IGNvbnRhaW5lciA9IGFuY2hvciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgeyBuZXh0LCBidSwgdSwgcGFyZW50LCB2bm9kZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBub25IeWRyYXRlZEFzeW5jUm9vdCA9IGxvY2F0ZU5vbkh5ZHJhdGVkQXN5bmNSb290KGluc3RhbmNlKTtcbiAgICAgICAgICBpZiAobm9uSHlkcmF0ZWRBc3luY1Jvb3QpIHtcbiAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgIG5leHQuZWwgPSB2bm9kZS5lbDtcbiAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuZXh0LCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9uSHlkcmF0ZWRBc3luY1Jvb3QuYXN5bmNEZXAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghaW5zdGFuY2UuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRVcGRhdGVGbigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9yaWdpbk5leHQgPSBuZXh0O1xuICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChuZXh0IHx8IGluc3RhbmNlLnZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgbmV4dC5lbCA9IHZub2RlLmVsO1xuICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbmV4dCwgb3B0aW1pemVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ID0gdm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1KSB7XG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoYnUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZUhvb2sgPSBuZXh0LnByb3BzICYmIG5leHQucHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkge1xuICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZUcmVlID0gaW5zdGFuY2Uuc3ViVHJlZTtcbiAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IG5leHRUcmVlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgcHJldlRyZWUsXG4gICAgICAgICAgbmV4dFRyZWUsXG4gICAgICAgICAgLy8gcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIHRlbGVwb3J0XG4gICAgICAgICAgaG9zdFBhcmVudE5vZGUocHJldlRyZWUuZWwpLFxuICAgICAgICAgIC8vIGFuY2hvciBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSBmcmFnbWVudFxuICAgICAgICAgIGdldE5leHRIb3N0Tm9kZShwcmV2VHJlZSksXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlXG4gICAgICAgICk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5lbCA9IG5leHRUcmVlLmVsO1xuICAgICAgICBpZiAob3JpZ2luTmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgbmV4dFRyZWUuZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1KSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHUsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVVcGRhdGVkKSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KFxuICAgICAgICAgICAgKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSksXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGluc3RhbmNlLnNjb3BlLm9uKCk7XG4gICAgY29uc3QgZWZmZWN0ID0gaW5zdGFuY2UuZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGNvbXBvbmVudFVwZGF0ZUZuKTtcbiAgICBpbnN0YW5jZS5zY29wZS5vZmYoKTtcbiAgICBjb25zdCB1cGRhdGUgPSBpbnN0YW5jZS51cGRhdGUgPSBlZmZlY3QucnVuLmJpbmQoZWZmZWN0KTtcbiAgICBjb25zdCBqb2IgPSBpbnN0YW5jZS5qb2IgPSBlZmZlY3QucnVuSWZEaXJ0eS5iaW5kKGVmZmVjdCk7XG4gICAgam9iLmkgPSBpbnN0YW5jZTtcbiAgICBqb2IuaWQgPSBpbnN0YW5jZS51aWQ7XG4gICAgZWZmZWN0LnNjaGVkdWxlciA9ICgpID0+IHF1ZXVlSm9iKGpvYik7XG4gICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGVmZmVjdC5vblRyYWNrID0gaW5zdGFuY2UucnRjID8gKGUpID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0YywgZSkgOiB2b2lkIDA7XG4gICAgICBlZmZlY3Qub25UcmlnZ2VyID0gaW5zdGFuY2UucnRnID8gKGUpID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0ZywgZSkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHVwZGF0ZSgpO1xuICB9O1xuICBjb25zdCB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIgPSAoaW5zdGFuY2UsIG5leHRWTm9kZSwgb3B0aW1pemVkKSA9PiB7XG4gICAgbmV4dFZOb2RlLmNvbXBvbmVudCA9IGluc3RhbmNlO1xuICAgIGNvbnN0IHByZXZQcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzO1xuICAgIGluc3RhbmNlLnZub2RlID0gbmV4dFZOb2RlO1xuICAgIGluc3RhbmNlLm5leHQgPSBudWxsO1xuICAgIHVwZGF0ZVByb3BzKGluc3RhbmNlLCBuZXh0Vk5vZGUucHJvcHMsIHByZXZQcm9wcywgb3B0aW1pemVkKTtcbiAgICB1cGRhdGVTbG90cyhpbnN0YW5jZSwgbmV4dFZOb2RlLmNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICBmbHVzaFByZUZsdXNoQ2JzKGluc3RhbmNlKTtcbiAgICByZXNldFRyYWNraW5nKCk7XG4gIH07XG4gIGNvbnN0IHBhdGNoQ2hpbGRyZW4gPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgYzEgPSBuMSAmJiBuMS5jaGlsZHJlbjtcbiAgICBjb25zdCBwcmV2U2hhcGVGbGFnID0gbjEgPyBuMS5zaGFwZUZsYWcgOiAwO1xuICAgIGNvbnN0IGMyID0gbjIuY2hpbGRyZW47XG4gICAgY29uc3QgeyBwYXRjaEZsYWcsIHNoYXBlRmxhZyB9ID0gbjI7XG4gICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcbiAgICAgIGlmIChwYXRjaEZsYWcgJiAxMjgpIHtcbiAgICAgICAgcGF0Y2hLZXllZENoaWxkcmVuKFxuICAgICAgICAgIGMxLFxuICAgICAgICAgIGMyLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAocGF0Y2hGbGFnICYgMjU2KSB7XG4gICAgICAgIHBhdGNoVW5rZXllZENoaWxkcmVuKFxuICAgICAgICAgIGMxLFxuICAgICAgICAgIGMyLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjMiAhPT0gYzEpIHtcbiAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGNvbnRhaW5lciwgYzIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICAgIGMxLFxuICAgICAgICAgICAgYzIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiA4KSB7XG4gICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGNvbnRhaW5lciwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgICAgIGMyLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaFVua2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgYzEgPSBjMSB8fCBFTVBUWV9BUlI7XG4gICAgYzIgPSBjMiB8fCBFTVBUWV9BUlI7XG4gICAgY29uc3Qgb2xkTGVuZ3RoID0gYzEubGVuZ3RoO1xuICAgIGNvbnN0IG5ld0xlbmd0aCA9IGMyLmxlbmd0aDtcbiAgICBjb25zdCBjb21tb25MZW5ndGggPSBNYXRoLm1pbihvbGRMZW5ndGgsIG5ld0xlbmd0aCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvbW1vbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBjMVtpXSxcbiAgICAgICAgbmV4dENoaWxkLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvbGRMZW5ndGggPiBuZXdMZW5ndGgpIHtcbiAgICAgIHVubW91bnRDaGlsZHJlbihcbiAgICAgICAgYzEsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIHRydWUsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBjb21tb25MZW5ndGhcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgIGMyLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgY29tbW9uTGVuZ3RoXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hLZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgbDIgPSBjMi5sZW5ndGg7XG4gICAgbGV0IGUxID0gYzEubGVuZ3RoIC0gMTtcbiAgICBsZXQgZTIgPSBsMiAtIDE7XG4gICAgd2hpbGUgKGkgPD0gZTEgJiYgaSA8PSBlMikge1xuICAgICAgY29uc3QgbjEgPSBjMVtpXTtcbiAgICAgIGNvbnN0IG4yID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgd2hpbGUgKGkgPD0gZTEgJiYgaSA8PSBlMikge1xuICAgICAgY29uc3QgbjEgPSBjMVtlMV07XG4gICAgICBjb25zdCBuMiA9IGMyW2UyXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2UyXSkgOiBub3JtYWxpemVWTm9kZShjMltlMl0pO1xuICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlMS0tO1xuICAgICAgZTItLTtcbiAgICB9XG4gICAgaWYgKGkgPiBlMSkge1xuICAgICAgaWYgKGkgPD0gZTIpIHtcbiAgICAgICAgY29uc3QgbmV4dFBvcyA9IGUyICsgMTtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dFBvcyA8IGwyID8gYzJbbmV4dFBvc10uZWwgOiBwYXJlbnRBbmNob3I7XG4gICAgICAgIHdoaWxlIChpIDw9IGUyKSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSksXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpID4gZTIpIHtcbiAgICAgIHdoaWxlIChpIDw9IGUxKSB7XG4gICAgICAgIHVubW91bnQoYzFbaV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHMxID0gaTtcbiAgICAgIGNvbnN0IHMyID0gaTtcbiAgICAgIGNvbnN0IGtleVRvTmV3SW5kZXhNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChpID0gczI7IGkgPD0gZTI7IGkrKykge1xuICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcbiAgICAgICAgaWYgKG5leHRDaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleVRvTmV3SW5kZXhNYXAuaGFzKG5leHRDaGlsZC5rZXkpKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIGBEdXBsaWNhdGUga2V5cyBmb3VuZCBkdXJpbmcgdXBkYXRlOmAsXG4gICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG5leHRDaGlsZC5rZXkpLFxuICAgICAgICAgICAgICBgTWFrZSBzdXJlIGtleXMgYXJlIHVuaXF1ZS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlUb05ld0luZGV4TWFwLnNldChuZXh0Q2hpbGQua2V5LCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGo7XG4gICAgICBsZXQgcGF0Y2hlZCA9IDA7XG4gICAgICBjb25zdCB0b0JlUGF0Y2hlZCA9IGUyIC0gczIgKyAxO1xuICAgICAgbGV0IG1vdmVkID0gZmFsc2U7XG4gICAgICBsZXQgbWF4TmV3SW5kZXhTb0ZhciA9IDA7XG4gICAgICBjb25zdCBuZXdJbmRleFRvT2xkSW5kZXhNYXAgPSBuZXcgQXJyYXkodG9CZVBhdGNoZWQpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRvQmVQYXRjaGVkOyBpKyspIG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9IDA7XG4gICAgICBmb3IgKGkgPSBzMTsgaSA8PSBlMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByZXZDaGlsZCA9IGMxW2ldO1xuICAgICAgICBpZiAocGF0Y2hlZCA+PSB0b0JlUGF0Y2hlZCkge1xuICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3SW5kZXg7XG4gICAgICAgIGlmIChwcmV2Q2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdJbmRleCA9IGtleVRvTmV3SW5kZXhNYXAuZ2V0KHByZXZDaGlsZC5rZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaiA9IHMyOyBqIDw9IGUyOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaiAtIHMyXSA9PT0gMCAmJiBpc1NhbWVWTm9kZVR5cGUocHJldkNoaWxkLCBjMltqXSkpIHtcbiAgICAgICAgICAgICAgbmV3SW5kZXggPSBqO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0luZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3SW5kZXhUb09sZEluZGV4TWFwW25ld0luZGV4IC0gczJdID0gaSArIDE7XG4gICAgICAgICAgaWYgKG5ld0luZGV4ID49IG1heE5ld0luZGV4U29GYXIpIHtcbiAgICAgICAgICAgIG1heE5ld0luZGV4U29GYXIgPSBuZXdJbmRleDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIHByZXZDaGlsZCxcbiAgICAgICAgICAgIGMyW25ld0luZGV4XSxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgcGF0Y2hlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZSA9IG1vdmVkID8gZ2V0U2VxdWVuY2UobmV3SW5kZXhUb09sZEluZGV4TWFwKSA6IEVNUFRZX0FSUjtcbiAgICAgIGogPSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZS5sZW5ndGggLSAxO1xuICAgICAgZm9yIChpID0gdG9CZVBhdGNoZWQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBzMiArIGk7XG4gICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW25leHRJbmRleF07XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRJbmRleCArIDEgPCBsMiA/IGMyW25leHRJbmRleCArIDFdLmVsIDogcGFyZW50QW5jaG9yO1xuICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID09PSAwKSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbmV4dENoaWxkLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKG1vdmVkKSB7XG4gICAgICAgICAgaWYgKGogPCAwIHx8IGkgIT09IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlW2pdKSB7XG4gICAgICAgICAgICBtb3ZlKG5leHRDaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIDIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3ZlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUsIHBhcmVudFN1c3BlbnNlID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IHsgZWwsIHR5cGUsIHRyYW5zaXRpb24sIGNoaWxkcmVuLCBzaGFwZUZsYWcgfSA9IHZub2RlO1xuICAgIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICBtb3ZlKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICB2bm9kZS5zdXNwZW5zZS5tb3ZlKGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgdHlwZS5tb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaW50ZXJuYWxzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1vdmUoY2hpbGRyZW5baV0sIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICB9XG4gICAgICBob3N0SW5zZXJ0KHZub2RlLmFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gU3RhdGljKSB7XG4gICAgICBtb3ZlU3RhdGljTm9kZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZWVkVHJhbnNpdGlvbjIgPSBtb3ZlVHlwZSAhPT0gMiAmJiBzaGFwZUZsYWcgJiAxICYmIHRyYW5zaXRpb247XG4gICAgaWYgKG5lZWRUcmFuc2l0aW9uMikge1xuICAgICAgaWYgKG1vdmVUeXBlID09PSAwKSB7XG4gICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB0cmFuc2l0aW9uLmVudGVyKGVsKSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSwgYWZ0ZXJMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcbiAgICAgICAgY29uc3QgcmVtb3ZlMiA9ICgpID0+IGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgIGxlYXZlKGVsLCAoKSA9PiB7XG4gICAgICAgICAgICByZW1vdmUyKCk7XG4gICAgICAgICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICAgICAgICBkZWxheUxlYXZlKGVsLCByZW1vdmUyLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVubW91bnQgPSAodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgcmVmLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICBzaGFwZUZsYWcsXG4gICAgICBwYXRjaEZsYWcsXG4gICAgICBkaXJzLFxuICAgICAgY2FjaGVJbmRleFxuICAgIH0gPSB2bm9kZTtcbiAgICBpZiAocGF0Y2hGbGFnID09PSAtMikge1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGNhY2hlSW5kZXggIT0gbnVsbCkge1xuICAgICAgcGFyZW50Q29tcG9uZW50LnJlbmRlckNhY2hlW2NhY2hlSW5kZXhdID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgMjU2KSB7XG4gICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmRlYWN0aXZhdGUodm5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGRJbnZva2VEaXJzID0gc2hhcGVGbGFnICYgMSAmJiBkaXJzO1xuICAgIGNvbnN0IHNob3VsZEludm9rZVZub2RlSG9vayA9ICFpc0FzeW5jV3JhcHBlcih2bm9kZSk7XG4gICAgbGV0IHZub2RlSG9vaztcbiAgICBpZiAoc2hvdWxkSW52b2tlVm5vZGVIb29rICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlVW5tb3VudCkpIHtcbiAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgdW5tb3VudENvbXBvbmVudCh2bm9kZS5jb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgdm5vZGUuc3VzcGVuc2UudW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkSW52b2tlRGlycykge1xuICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlVW5tb3VudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgICB2bm9kZS50eXBlLnJlbW92ZShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgIGRvUmVtb3ZlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGR5bmFtaWNDaGlsZHJlbiAmJiAvLyAjNTE1NFxuICAgICAgLy8gd2hlbiB2LW9uY2UgaXMgdXNlZCBpbnNpZGUgYSBibG9jaywgc2V0QmxvY2tUcmFja2luZygtMSkgbWFya3MgdGhlXG4gICAgICAvLyBwYXJlbnQgYmxvY2sgd2l0aCBoYXNPbmNlOiB0cnVlXG4gICAgICAvLyBzbyB0aGF0IGl0IGRvZXNuJ3QgdGFrZSB0aGUgZmFzdCBwYXRoIGR1cmluZyB1bm1vdW50IC0gb3RoZXJ3aXNlXG4gICAgICAvLyBjb21wb25lbnRzIG5lc3RlZCBpbiB2LW9uY2UgYXJlIG5ldmVyIHVubW91bnRlZC5cbiAgICAgICFkeW5hbWljQ2hpbGRyZW4uaGFzT25jZSAmJiAvLyAjMTE1MzogZmFzdCBwYXRoIHNob3VsZCBub3QgYmUgdGFrZW4gZm9yIG5vbi1zdGFibGUgKHYtZm9yKSBmcmFnbWVudHNcbiAgICAgICh0eXBlICE9PSBGcmFnbWVudCB8fCBwYXRjaEZsYWcgPiAwICYmIHBhdGNoRmxhZyAmIDY0KSkge1xuICAgICAgICB1bm1vdW50Q2hpbGRyZW4oXG4gICAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEZyYWdtZW50ICYmIHBhdGNoRmxhZyAmICgxMjggfCAyNTYpIHx8ICFvcHRpbWl6ZWQgJiYgc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChkb1JlbW92ZSkge1xuICAgICAgICByZW1vdmUodm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hvdWxkSW52b2tlVm5vZGVIb29rICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlVW5tb3VudGVkKSB8fCBzaG91bGRJbnZva2VEaXJzKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgIHNob3VsZEludm9rZURpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcInVubW91bnRlZFwiKTtcbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlbW92ZSA9ICh2bm9kZSkgPT4ge1xuICAgIGNvbnN0IHsgdHlwZSwgZWwsIGFuY2hvciwgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XG4gICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB2bm9kZS5wYXRjaEZsYWcgPiAwICYmIHZub2RlLnBhdGNoRmxhZyAmIDIwNDggJiYgdHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudCkge1xuICAgICAgICAgICAgaG9zdFJlbW92ZShjaGlsZC5lbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyYWdtZW50KGVsLCBhbmNob3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gU3RhdGljKSB7XG4gICAgICByZW1vdmVTdGF0aWNOb2RlKHZub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGVyZm9ybVJlbW92ZSA9ICgpID0+IHtcbiAgICAgIGhvc3RSZW1vdmUoZWwpO1xuICAgICAgaWYgKHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkICYmIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSkge1xuICAgICAgICB0cmFuc2l0aW9uLmFmdGVyTGVhdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XG4gICAgICBjb25zdCB7IGxlYXZlLCBkZWxheUxlYXZlIH0gPSB0cmFuc2l0aW9uO1xuICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4gbGVhdmUoZWwsIHBlcmZvcm1SZW1vdmUpO1xuICAgICAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICAgICAgZGVsYXlMZWF2ZSh2bm9kZS5lbCwgcGVyZm9ybVJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZXJmb3JtUmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmVGcmFnbWVudCA9IChjdXIsIGVuZCkgPT4ge1xuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlIChjdXIgIT09IGVuZCkge1xuICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhjdXIpO1xuICAgICAgaG9zdFJlbW92ZShjdXIpO1xuICAgICAgY3VyID0gbmV4dDtcbiAgICB9XG4gICAgaG9zdFJlbW92ZShlbmQpO1xuICB9O1xuICBjb25zdCB1bm1vdW50Q29tcG9uZW50ID0gKGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcbiAgICAgIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xuICAgIH1cbiAgICBjb25zdCB7IGJ1bSwgc2NvcGUsIGpvYiwgc3ViVHJlZSwgdW0sIG0sIGEgfSA9IGluc3RhbmNlO1xuICAgIGludmFsaWRhdGVNb3VudChtKTtcbiAgICBpbnZhbGlkYXRlTW91bnQoYSk7XG4gICAgaWYgKGJ1bSkge1xuICAgICAgaW52b2tlQXJyYXlGbnMoYnVtKTtcbiAgICB9XG4gICAgc2NvcGUuc3RvcCgpO1xuICAgIGlmIChqb2IpIHtcbiAgICAgIGpvYi5mbGFncyB8PSA4O1xuICAgICAgdW5tb3VudChzdWJUcmVlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICB9XG4gICAgaWYgKHVtKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodW0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgIGluc3RhbmNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgIXBhcmVudFN1c3BlbnNlLmlzVW5tb3VudGVkICYmIGluc3RhbmNlLmFzeW5jRGVwICYmICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkICYmIGluc3RhbmNlLnN1c3BlbnNlSWQgPT09IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdJZCkge1xuICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xuICAgICAgaWYgKHBhcmVudFN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChpbnN0YW5jZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCB1bm1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlLCBzdGFydCA9IDApID0+IHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdW5tb3VudChjaGlsZHJlbltpXSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUsIG9wdGltaXplZCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBnZXROZXh0SG9zdE5vZGUgPSAodm5vZGUpID0+IHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNikge1xuICAgICAgcmV0dXJuIGdldE5leHRIb3N0Tm9kZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XG4gICAgfVxuICAgIGNvbnN0IGVsID0gaG9zdE5leHRTaWJsaW5nKHZub2RlLmFuY2hvciB8fCB2bm9kZS5lbCk7XG4gICAgY29uc3QgdGVsZXBvcnRFbmQgPSBlbCAmJiBlbFtUZWxlcG9ydEVuZEtleV07XG4gICAgcmV0dXJuIHRlbGVwb3J0RW5kID8gaG9zdE5leHRTaWJsaW5nKHRlbGVwb3J0RW5kKSA6IGVsO1xuICB9O1xuICBsZXQgaXNGbHVzaGluZyA9IGZhbHNlO1xuICBjb25zdCByZW5kZXIgPSAodm5vZGUsIGNvbnRhaW5lciwgbmFtZXNwYWNlKSA9PiB7XG4gICAgaWYgKHZub2RlID09IG51bGwpIHtcbiAgICAgIGlmIChjb250YWluZXIuX3Zub2RlKSB7XG4gICAgICAgIHVubW91bnQoY29udGFpbmVyLl92bm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoKFxuICAgICAgICBjb250YWluZXIuX3Zub2RlIHx8IG51bGwsXG4gICAgICAgIHZub2RlLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgKTtcbiAgICB9XG4gICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICAgIGlmICghaXNGbHVzaGluZykge1xuICAgICAgaXNGbHVzaGluZyA9IHRydWU7XG4gICAgICBmbHVzaFByZUZsdXNoQ2JzKCk7XG4gICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgICAgaXNGbHVzaGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHA6IHBhdGNoLFxuICAgIHVtOiB1bm1vdW50LFxuICAgIG06IG1vdmUsXG4gICAgcjogcmVtb3ZlLFxuICAgIG10OiBtb3VudENvbXBvbmVudCxcbiAgICBtYzogbW91bnRDaGlsZHJlbixcbiAgICBwYzogcGF0Y2hDaGlsZHJlbixcbiAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcbiAgICBuOiBnZXROZXh0SG9zdE5vZGUsXG4gICAgbzogb3B0aW9uc1xuICB9O1xuICBsZXQgaHlkcmF0ZTtcbiAgbGV0IGh5ZHJhdGVOb2RlO1xuICBpZiAoY3JlYXRlSHlkcmF0aW9uRm5zKSB7XG4gICAgW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXSA9IGNyZWF0ZUh5ZHJhdGlvbkZucyhcbiAgICAgIGludGVybmFsc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZW5kZXIsXG4gICAgaHlkcmF0ZSxcbiAgICBjcmVhdGVBcHA6IGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlQ2hpbGRyZW5OYW1lc3BhY2UoeyB0eXBlLCBwcm9wcyB9LCBjdXJyZW50TmFtZXNwYWNlKSB7XG4gIHJldHVybiBjdXJyZW50TmFtZXNwYWNlID09PSBcInN2Z1wiICYmIHR5cGUgPT09IFwiZm9yZWlnbk9iamVjdFwiIHx8IGN1cnJlbnROYW1lc3BhY2UgPT09IFwibWF0aG1sXCIgJiYgdHlwZSA9PT0gXCJhbm5vdGF0aW9uLXhtbFwiICYmIHByb3BzICYmIHByb3BzLmVuY29kaW5nICYmIHByb3BzLmVuY29kaW5nLmluY2x1ZGVzKFwiaHRtbFwiKSA/IHZvaWQgMCA6IGN1cnJlbnROYW1lc3BhY2U7XG59XG5mdW5jdGlvbiB0b2dnbGVSZWN1cnNlKHsgZWZmZWN0LCBqb2IgfSwgYWxsb3dlZCkge1xuICBpZiAoYWxsb3dlZCkge1xuICAgIGVmZmVjdC5mbGFncyB8PSAzMjtcbiAgICBqb2IuZmxhZ3MgfD0gNDtcbiAgfSBlbHNlIHtcbiAgICBlZmZlY3QuZmxhZ3MgJj0gfjMyO1xuICAgIGpvYi5mbGFncyAmPSB+NDtcbiAgfVxufVxuZnVuY3Rpb24gbmVlZFRyYW5zaXRpb24ocGFyZW50U3VzcGVuc2UsIHRyYW5zaXRpb24pIHtcbiAgcmV0dXJuICghcGFyZW50U3VzcGVuc2UgfHwgcGFyZW50U3VzcGVuc2UgJiYgIXBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHNoYWxsb3cgPSBmYWxzZSkge1xuICBjb25zdCBjaDEgPSBuMS5jaGlsZHJlbjtcbiAgY29uc3QgY2gyID0gbjIuY2hpbGRyZW47XG4gIGlmIChpc0FycmF5KGNoMSkgJiYgaXNBcnJheShjaDIpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaDEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMxID0gY2gxW2ldO1xuICAgICAgbGV0IGMyID0gY2gyW2ldO1xuICAgICAgaWYgKGMyLnNoYXBlRmxhZyAmIDEgJiYgIWMyLmR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBpZiAoYzIucGF0Y2hGbGFnIDw9IDAgfHwgYzIucGF0Y2hGbGFnID09PSAzMikge1xuICAgICAgICAgIGMyID0gY2gyW2ldID0gY2xvbmVJZk1vdW50ZWQoY2gyW2ldKTtcbiAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2hhbGxvdyAmJiBjMi5wYXRjaEZsYWcgIT09IC0yKVxuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4oYzEsIGMyKTtcbiAgICAgIH1cbiAgICAgIGlmIChjMi50eXBlID09PSBUZXh0KSB7XG4gICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICB9XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjMi50eXBlID09PSBDb21tZW50ICYmICFjMi5lbCkge1xuICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2VxdWVuY2UoYXJyKSB7XG4gIGNvbnN0IHAgPSBhcnIuc2xpY2UoKTtcbiAgY29uc3QgcmVzdWx0ID0gWzBdO1xuICBsZXQgaSwgaiwgdSwgdiwgYztcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgYXJySSA9IGFycltpXTtcbiAgICBpZiAoYXJySSAhPT0gMCkge1xuICAgICAgaiA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoYXJyW2pdIDwgYXJySSkge1xuICAgICAgICBwW2ldID0gajtcbiAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdSA9IDA7XG4gICAgICB2ID0gcmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAodSA8IHYpIHtcbiAgICAgICAgYyA9IHUgKyB2ID4+IDE7XG4gICAgICAgIGlmIChhcnJbcmVzdWx0W2NdXSA8IGFyckkpIHtcbiAgICAgICAgICB1ID0gYyArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdiA9IGM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhcnJJIDwgYXJyW3Jlc3VsdFt1XV0pIHtcbiAgICAgICAgaWYgKHUgPiAwKSB7XG4gICAgICAgICAgcFtpXSA9IHJlc3VsdFt1IC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3VdID0gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdSA9IHJlc3VsdC5sZW5ndGg7XG4gIHYgPSByZXN1bHRbdSAtIDFdO1xuICB3aGlsZSAodS0tID4gMCkge1xuICAgIHJlc3VsdFt1XSA9IHY7XG4gICAgdiA9IHBbdl07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxvY2F0ZU5vbkh5ZHJhdGVkQXN5bmNSb290KGluc3RhbmNlKSB7XG4gIGNvbnN0IHN1YkNvbXBvbmVudCA9IGluc3RhbmNlLnN1YlRyZWUuY29tcG9uZW50O1xuICBpZiAoc3ViQ29tcG9uZW50KSB7XG4gICAgaWYgKHN1YkNvbXBvbmVudC5hc3luY0RlcCAmJiAhc3ViQ29tcG9uZW50LmFzeW5jUmVzb2x2ZWQpIHtcbiAgICAgIHJldHVybiBzdWJDb21wb25lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsb2NhdGVOb25IeWRyYXRlZEFzeW5jUm9vdChzdWJDb21wb25lbnQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW52YWxpZGF0ZU1vdW50KGhvb2tzKSB7XG4gIGlmIChob29rcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspXG4gICAgICBob29rc1tpXS5mbGFncyB8PSA4O1xuICB9XG59XG5cbmNvbnN0IHNzckNvbnRleHRLZXkgPSBTeW1ib2wuZm9yKFwidi1zY3hcIik7XG5jb25zdCB1c2VTU1JDb250ZXh0ID0gKCkgPT4ge1xuICB7XG4gICAgY29uc3QgY3R4ID0gaW5qZWN0KHNzckNvbnRleHRLZXkpO1xuICAgIGlmICghY3R4KSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShcbiAgICAgICAgYFNlcnZlciByZW5kZXJpbmcgY29udGV4dCBub3QgcHJvdmlkZWQuIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgdXNlU1NSQ29udGV4dCgpIGNvbmRpdGlvbmFsbHkgaW4gdGhlIHNlcnZlciBidWlsZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY3R4O1xuICB9XG59O1xuXG5mdW5jdGlvbiB3YXRjaEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHdhdGNoUG9zdEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRvV2F0Y2goXG4gICAgZWZmZWN0LFxuICAgIG51bGwsXG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGV4dGVuZCh7fSwgb3B0aW9ucywgeyBmbHVzaDogXCJwb3N0XCIgfSkgOiB7IGZsdXNoOiBcInBvc3RcIiB9XG4gICk7XG59XG5mdW5jdGlvbiB3YXRjaFN5bmNFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKFxuICAgIGVmZmVjdCxcbiAgICBudWxsLFxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBleHRlbmQoe30sIG9wdGlvbnMsIHsgZmx1c2g6IFwic3luY1wiIH0pIDogeyBmbHVzaDogXCJzeW5jXCIgfVxuICApO1xufVxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNGdW5jdGlvbihjYikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgXFxgd2F0Y2goZm4sIG9wdGlvbnM/KVxcYCBzaWduYXR1cmUgaGFzIGJlZW4gbW92ZWQgdG8gYSBzZXBhcmF0ZSBBUEkuIFVzZSBcXGB3YXRjaEVmZmVjdChmbiwgb3B0aW9ucz8pXFxgIGluc3RlYWQuIFxcYHdhdGNoXFxgIG5vdyBvbmx5IHN1cHBvcnRzIFxcYHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGRvV2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMgPSBFTVBUWV9PQkopIHtcbiAgY29uc3QgeyBpbW1lZGlhdGUsIGRlZXAsIGZsdXNoLCBvbmNlIH0gPSBvcHRpb25zO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY2IpIHtcbiAgICBpZiAoaW1tZWRpYXRlICE9PSB2b2lkIDApIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYHdhdGNoKCkgXCJpbW1lZGlhdGVcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZGVlcCAhPT0gdm9pZCAwKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGB3YXRjaCgpIFwiZGVlcFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvbmNlICE9PSB2b2lkIDApIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYHdhdGNoKCkgXCJvbmNlXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgYmFzZVdhdGNoT3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSBiYXNlV2F0Y2hPcHRpb25zLm9uV2FybiA9IHdhcm4kMTtcbiAgbGV0IHNzckNsZWFudXA7XG4gIGlmIChpc0luU1NSQ29tcG9uZW50U2V0dXApIHtcbiAgICBpZiAoZmx1c2ggPT09IFwic3luY1wiKSB7XG4gICAgICBjb25zdCBjdHggPSB1c2VTU1JDb250ZXh0KCk7XG4gICAgICBzc3JDbGVhbnVwID0gY3R4Ll9fd2F0Y2hlckhhbmRsZXMgfHwgKGN0eC5fX3dhdGNoZXJIYW5kbGVzID0gW10pO1xuICAgIH0gZWxzZSBpZiAoIWNiIHx8IGltbWVkaWF0ZSkge1xuICAgICAgYmFzZVdhdGNoT3B0aW9ucy5vbmNlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RvcDogTk9PUCxcbiAgICAgICAgcmVzdW1lOiBOT09QLFxuICAgICAgICBwYXVzZTogTk9PUFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gIGJhc2VXYXRjaE9wdGlvbnMuY2FsbCA9IChmbiwgdHlwZSwgYXJncykgPT4gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKTtcbiAgbGV0IGlzUHJlID0gZmFsc2U7XG4gIGlmIChmbHVzaCA9PT0gXCJwb3N0XCIpIHtcbiAgICBiYXNlV2F0Y2hPcHRpb25zLnNjaGVkdWxlciA9IChqb2IpID0+IHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChqb2IsIGluc3RhbmNlICYmIGluc3RhbmNlLnN1c3BlbnNlKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKGZsdXNoICE9PSBcInN5bmNcIikge1xuICAgIGlzUHJlID0gdHJ1ZTtcbiAgICBiYXNlV2F0Y2hPcHRpb25zLnNjaGVkdWxlciA9IChqb2IsIGlzRmlyc3RSdW4pID0+IHtcbiAgICAgIGlmIChpc0ZpcnN0UnVuKSB7XG4gICAgICAgIGpvYigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVKb2Ioam9iKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGJhc2VXYXRjaE9wdGlvbnMuYXVnbWVudEpvYiA9IChqb2IpID0+IHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGpvYi5mbGFncyB8PSA0O1xuICAgIH1cbiAgICBpZiAoaXNQcmUpIHtcbiAgICAgIGpvYi5mbGFncyB8PSAyO1xuICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGpvYi5pZCA9IGluc3RhbmNlLnVpZDtcbiAgICAgICAgam9iLmkgPSBpbnN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHdhdGNoSGFuZGxlID0gd2F0Y2gkMShzb3VyY2UsIGNiLCBiYXNlV2F0Y2hPcHRpb25zKTtcbiAgaWYgKHNzckNsZWFudXApIHNzckNsZWFudXAucHVzaCh3YXRjaEhhbmRsZSk7XG4gIHJldHVybiB3YXRjaEhhbmRsZTtcbn1cbmZ1bmN0aW9uIGluc3RhbmNlV2F0Y2goc291cmNlLCB2YWx1ZSwgb3B0aW9ucykge1xuICBjb25zdCBwdWJsaWNUaGlzID0gdGhpcy5wcm94eTtcbiAgY29uc3QgZ2V0dGVyID0gaXNTdHJpbmcoc291cmNlKSA/IHNvdXJjZS5pbmNsdWRlcyhcIi5cIikgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIHNvdXJjZSkgOiAoKSA9PiBwdWJsaWNUaGlzW3NvdXJjZV0gOiBzb3VyY2UuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKTtcbiAgbGV0IGNiO1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBjYiA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGNiID0gdmFsdWUuaGFuZGxlcjtcbiAgICBvcHRpb25zID0gdmFsdWU7XG4gIH1cbiAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UodGhpcyk7XG4gIGNvbnN0IHJlcyA9IGRvV2F0Y2goZ2V0dGVyLCBjYi5iaW5kKHB1YmxpY1RoaXMpLCBvcHRpb25zKTtcbiAgcmVzZXQoKTtcbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhHZXR0ZXIoY3R4LCBwYXRoKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi5cIik7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IGN1ciA9IGN0eDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAmJiBjdXI7IGkrKykge1xuICAgICAgY3VyID0gY3VyW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTW9kZWwocHJvcHMsIG5hbWUsIG9wdGlvbnMgPSBFTVBUWV9PQkopIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaSkge1xuICAgIHdhcm4kMShgdXNlTW9kZWwoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XG4gICAgcmV0dXJuIHJlZigpO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpLnByb3BzT3B0aW9uc1swXVtuYW1lXSkge1xuICAgIHdhcm4kMShgdXNlTW9kZWwoKSBjYWxsZWQgd2l0aCBwcm9wIFwiJHtuYW1lfVwiIHdoaWNoIGlzIG5vdCBkZWNsYXJlZC5gKTtcbiAgICByZXR1cm4gcmVmKCk7XG4gIH1cbiAgY29uc3QgY2FtZWxpemVkTmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICBjb25zdCBoeXBoZW5hdGVkTmFtZSA9IGh5cGhlbmF0ZShuYW1lKTtcbiAgY29uc3QgbW9kaWZpZXJzID0gZ2V0TW9kZWxNb2RpZmllcnMocHJvcHMsIG5hbWUpO1xuICBjb25zdCByZXMgPSBjdXN0b21SZWYoKHRyYWNrLCB0cmlnZ2VyKSA9PiB7XG4gICAgbGV0IGxvY2FsVmFsdWU7XG4gICAgbGV0IHByZXZTZXRWYWx1ZSA9IEVNUFRZX09CSjtcbiAgICBsZXQgcHJldkVtaXR0ZWRWYWx1ZTtcbiAgICB3YXRjaFN5bmNFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgcHJvcFZhbHVlID0gcHJvcHNbbmFtZV07XG4gICAgICBpZiAoaGFzQ2hhbmdlZChsb2NhbFZhbHVlLCBwcm9wVmFsdWUpKSB7XG4gICAgICAgIGxvY2FsVmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgIHRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0KCkge1xuICAgICAgICB0cmFjaygpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5nZXQgPyBvcHRpb25zLmdldChsb2NhbFZhbHVlKSA6IGxvY2FsVmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGVtaXR0ZWRWYWx1ZSA9IG9wdGlvbnMuc2V0ID8gb3B0aW9ucy5zZXQodmFsdWUpIDogdmFsdWU7XG4gICAgICAgIGlmICghaGFzQ2hhbmdlZChlbWl0dGVkVmFsdWUsIGxvY2FsVmFsdWUpICYmICEocHJldlNldFZhbHVlICE9PSBFTVBUWV9PQkogJiYgaGFzQ2hhbmdlZCh2YWx1ZSwgcHJldlNldFZhbHVlKSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmF3UHJvcHMgPSBpLnZub2RlLnByb3BzO1xuICAgICAgICBpZiAoIShyYXdQcm9wcyAmJiAvLyBjaGVjayBpZiBwYXJlbnQgaGFzIHBhc3NlZCB2LW1vZGVsXG4gICAgICAgIChuYW1lIGluIHJhd1Byb3BzIHx8IGNhbWVsaXplZE5hbWUgaW4gcmF3UHJvcHMgfHwgaHlwaGVuYXRlZE5hbWUgaW4gcmF3UHJvcHMpICYmIChgb25VcGRhdGU6JHtuYW1lfWAgaW4gcmF3UHJvcHMgfHwgYG9uVXBkYXRlOiR7Y2FtZWxpemVkTmFtZX1gIGluIHJhd1Byb3BzIHx8IGBvblVwZGF0ZToke2h5cGhlbmF0ZWROYW1lfWAgaW4gcmF3UHJvcHMpKSkge1xuICAgICAgICAgIGxvY2FsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0cmlnZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaS5lbWl0KGB1cGRhdGU6JHtuYW1lfWAsIGVtaXR0ZWRWYWx1ZSk7XG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBlbWl0dGVkVmFsdWUpICYmIGhhc0NoYW5nZWQodmFsdWUsIHByZXZTZXRWYWx1ZSkgJiYgIWhhc0NoYW5nZWQoZW1pdHRlZFZhbHVlLCBwcmV2RW1pdHRlZFZhbHVlKSkge1xuICAgICAgICAgIHRyaWdnZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2U2V0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcHJldkVtaXR0ZWRWYWx1ZSA9IGVtaXR0ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgcmVzW1N5bWJvbC5pdGVyYXRvcl0gPSAoKSA9PiB7XG4gICAgbGV0IGkyID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKGkyIDwgMikge1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpMisrID8gbW9kaWZpZXJzIHx8IEVNUFRZX09CSiA6IHJlcywgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4gcmVzO1xufVxuY29uc3QgZ2V0TW9kZWxNb2RpZmllcnMgPSAocHJvcHMsIG1vZGVsTmFtZSkgPT4ge1xuICByZXR1cm4gbW9kZWxOYW1lID09PSBcIm1vZGVsVmFsdWVcIiB8fCBtb2RlbE5hbWUgPT09IFwibW9kZWwtdmFsdWVcIiA/IHByb3BzLm1vZGVsTW9kaWZpZXJzIDogcHJvcHNbYCR7bW9kZWxOYW1lfU1vZGlmaWVyc2BdIHx8IHByb3BzW2Ake2NhbWVsaXplKG1vZGVsTmFtZSl9TW9kaWZpZXJzYF0gfHwgcHJvcHNbYCR7aHlwaGVuYXRlKG1vZGVsTmFtZSl9TW9kaWZpZXJzYF07XG59O1xuXG5mdW5jdGlvbiBlbWl0KGluc3RhbmNlLCBldmVudCwgLi4ucmF3QXJncykge1xuICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQpIHJldHVybjtcbiAgY29uc3QgcHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcyB8fCBFTVBUWV9PQko7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3Qge1xuICAgICAgZW1pdHNPcHRpb25zLFxuICAgICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXVxuICAgIH0gPSBpbnN0YW5jZTtcbiAgICBpZiAoZW1pdHNPcHRpb25zKSB7XG4gICAgICBpZiAoIShldmVudCBpbiBlbWl0c09wdGlvbnMpICYmIHRydWUpIHtcbiAgICAgICAgaWYgKCFwcm9wc09wdGlvbnMgfHwgISh0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKSBpbiBwcm9wc09wdGlvbnMpKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYENvbXBvbmVudCBlbWl0dGVkIGV2ZW50IFwiJHtldmVudH1cIiBidXQgaXQgaXMgbmVpdGhlciBkZWNsYXJlZCBpbiB0aGUgZW1pdHMgb3B0aW9uIG5vciBhcyBhbiBcIiR7dG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSl9XCIgcHJvcC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZW1pdHNPcHRpb25zW2V2ZW50XTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdG9yKSkge1xuICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0b3IoLi4ucmF3QXJncyk7XG4gICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIGV2ZW50IGFyZ3VtZW50czogZXZlbnQgdmFsaWRhdGlvbiBmYWlsZWQgZm9yIGV2ZW50IFwiJHtldmVudH1cIi5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgYXJncyA9IHJhd0FyZ3M7XG4gIGNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IGV2ZW50LnN0YXJ0c1dpdGgoXCJ1cGRhdGU6XCIpO1xuICBjb25zdCBtb2RpZmllcnMgPSBpc01vZGVsTGlzdGVuZXIgJiYgZ2V0TW9kZWxNb2RpZmllcnMocHJvcHMsIGV2ZW50LnNsaWNlKDcpKTtcbiAgaWYgKG1vZGlmaWVycykge1xuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKChhKSA9PiBpc1N0cmluZyhhKSA/IGEudHJpbSgpIDogYSk7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICBhcmdzID0gcmF3QXJncy5tYXAobG9vc2VUb051bWJlcik7XG4gICAgfVxuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgIGRldnRvb2xzQ29tcG9uZW50RW1pdChpbnN0YW5jZSwgZXZlbnQsIGFyZ3MpO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgcHJvcHNbdG9IYW5kbGVyS2V5KGxvd2VyQ2FzZUV2ZW50KV0pIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYEV2ZW50IFwiJHtsb3dlckNhc2VFdmVudH1cIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCAke2Zvcm1hdENvbXBvbmVudE5hbWUoXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgaW5zdGFuY2UudHlwZVxuICAgICAgICApfSBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXCIke2V2ZW50fVwiLiBOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSB2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2h5cGhlbmF0ZShcbiAgICAgICAgICBldmVudFxuICAgICAgICApfVwiIGluc3RlYWQgb2YgXCIke2V2ZW50fVwiLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGxldCBoYW5kbGVyTmFtZTtcbiAgbGV0IGhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShldmVudCldIHx8IC8vIGFsc28gdHJ5IGNhbWVsQ2FzZSBldmVudCBoYW5kbGVyICgjMjI0OSlcbiAgcHJvcHNbaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKV07XG4gIGlmICghaGFuZGxlciAmJiBpc01vZGVsTGlzdGVuZXIpIHtcbiAgICBoYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoaHlwaGVuYXRlKGV2ZW50KSldO1xuICB9XG4gIGlmIChoYW5kbGVyKSB7XG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICBoYW5kbGVyLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA2LFxuICAgICAgYXJnc1xuICAgICk7XG4gIH1cbiAgY29uc3Qgb25jZUhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSArIGBPbmNlYF07XG4gIGlmIChvbmNlSGFuZGxlcikge1xuICAgIGlmICghaW5zdGFuY2UuZW1pdHRlZCkge1xuICAgICAgaW5zdGFuY2UuZW1pdHRlZCA9IHt9O1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0gPSB0cnVlO1xuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgb25jZUhhbmRsZXIsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDYsXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplRW1pdHNPcHRpb25zKGNvbXAsIGFwcENvbnRleHQsIGFzTWl4aW4gPSBmYWxzZSkge1xuICBjb25zdCBjYWNoZSA9IGFwcENvbnRleHQuZW1pdHNDYWNoZTtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xuICBpZiAoY2FjaGVkICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IHJhdyA9IGNvbXAuZW1pdHM7XG4gIGxldCBub3JtYWxpemVkID0ge307XG4gIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XG4gIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgY29uc3QgZXh0ZW5kRW1pdHMgPSAocmF3MikgPT4ge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEZyb21FeHRlbmQgPSBub3JtYWxpemVFbWl0c09wdGlvbnMocmF3MiwgYXBwQ29udGV4dCwgdHJ1ZSk7XG4gICAgICBpZiAobm9ybWFsaXplZEZyb21FeHRlbmQpIHtcbiAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XG4gICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBub3JtYWxpemVkRnJvbUV4dGVuZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XG4gICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAuZXh0ZW5kcykge1xuICAgICAgZXh0ZW5kRW1pdHMoY29tcC5leHRlbmRzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAubWl4aW5zKSB7XG4gICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcbiAgICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICAgIGNhY2hlLnNldChjb21wLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgIHJhdy5mb3JFYWNoKChrZXkpID0+IG5vcm1hbGl6ZWRba2V5XSA9IG51bGwpO1xuICB9IGVsc2Uge1xuICAgIGV4dGVuZChub3JtYWxpemVkLCByYXcpO1xuICB9XG4gIGlmIChpc09iamVjdChjb21wKSkge1xuICAgIGNhY2hlLnNldChjb21wLCBub3JtYWxpemVkKTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbmZ1bmN0aW9uIGlzRW1pdExpc3RlbmVyKG9wdGlvbnMsIGtleSkge1xuICBpZiAoIW9wdGlvbnMgfHwgIWlzT24oa2V5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBrZXkgPSBrZXkuc2xpY2UoMikucmVwbGFjZSgvT25jZSQvLCBcIlwiKTtcbiAgcmV0dXJuIGhhc093bihvcHRpb25zLCBrZXlbMF0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgxKSkgfHwgaGFzT3duKG9wdGlvbnMsIGh5cGhlbmF0ZShrZXkpKSB8fCBoYXNPd24ob3B0aW9ucywga2V5KTtcbn1cblxubGV0IGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcbmZ1bmN0aW9uIG1hcmtBdHRyc0FjY2Vzc2VkKCkge1xuICBhY2Nlc3NlZEF0dHJzID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpIHtcbiAgY29uc3Qge1xuICAgIHR5cGU6IENvbXBvbmVudCxcbiAgICB2bm9kZSxcbiAgICBwcm94eSxcbiAgICB3aXRoUHJveHksXG4gICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSxcbiAgICBzbG90cyxcbiAgICBhdHRycyxcbiAgICBlbWl0LFxuICAgIHJlbmRlcixcbiAgICByZW5kZXJDYWNoZSxcbiAgICBwcm9wcyxcbiAgICBkYXRhLFxuICAgIHNldHVwU3RhdGUsXG4gICAgY3R4LFxuICAgIGluaGVyaXRBdHRyc1xuICB9ID0gaW5zdGFuY2U7XG4gIGNvbnN0IHByZXYgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpO1xuICBsZXQgcmVzdWx0O1xuICBsZXQgZmFsbHRocm91Z2hBdHRycztcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCkge1xuICAgICAgY29uc3QgcHJveHlUb1VzZSA9IHdpdGhQcm94eSB8fCBwcm94eTtcbiAgICAgIGNvbnN0IHRoaXNQcm94eSA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgPyBuZXcgUHJveHkocHJveHlUb1VzZSwge1xuICAgICAgICBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYFByb3BlcnR5ICcke1N0cmluZyhcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApfScgd2FzIGFjY2Vzc2VkIHZpYSAndGhpcycuIEF2b2lkIHVzaW5nICd0aGlzJyBpbiB0ZW1wbGF0ZXMuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XG4gICAgICAgIH1cbiAgICAgIH0pIDogcHJveHlUb1VzZTtcbiAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKFxuICAgICAgICByZW5kZXIuY2FsbChcbiAgICAgICAgICB0aGlzUHJveHksXG4gICAgICAgICAgcHJveHlUb1VzZSxcbiAgICAgICAgICByZW5kZXJDYWNoZSxcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KHByb3BzKSA6IHByb3BzLFxuICAgICAgICAgIHNldHVwU3RhdGUsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBjdHhcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBhdHRycztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVuZGVyMiA9IENvbXBvbmVudDtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGF0dHJzID09PSBwcm9wcykge1xuICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUoXG4gICAgICAgIHJlbmRlcjIubGVuZ3RoID4gMSA/IHJlbmRlcjIoXG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShwcm9wcykgOiBwcm9wcyxcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8ge1xuICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgICAgICAgICByZXR1cm4gc2hhbGxvd1JlYWRvbmx5KGF0dHJzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzbG90cyxcbiAgICAgICAgICAgIGVtaXRcbiAgICAgICAgICB9IDogeyBhdHRycywgc2xvdHMsIGVtaXQgfVxuICAgICAgICApIDogcmVuZGVyMihcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KHByb3BzKSA6IHByb3BzLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBDb21wb25lbnQucHJvcHMgPyBhdHRycyA6IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaChhdHRycyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBibG9ja1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMSk7XG4gICAgcmVzdWx0ID0gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gIH1cbiAgbGV0IHJvb3QgPSByZXN1bHQ7XG4gIGxldCBzZXRSb290ID0gdm9pZCAwO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiByZXN1bHQucGF0Y2hGbGFnID4gMCAmJiByZXN1bHQucGF0Y2hGbGFnICYgMjA0OCkge1xuICAgIFtyb290LCBzZXRSb290XSA9IGdldENoaWxkUm9vdChyZXN1bHQpO1xuICB9XG4gIGlmIChmYWxsdGhyb3VnaEF0dHJzICYmIGluaGVyaXRBdHRycyAhPT0gZmFsc2UpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmFsbHRocm91Z2hBdHRycyk7XG4gICAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHJvb3Q7XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBpZiAoc2hhcGVGbGFnICYgKDEgfCA2KSkge1xuICAgICAgICBpZiAocHJvcHNPcHRpb25zICYmIGtleXMuc29tZShpc01vZGVsTGlzdGVuZXIpKSB7XG4gICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGZpbHRlck1vZGVsTGlzdGVuZXJzKFxuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyxcbiAgICAgICAgICAgIHByb3BzT3B0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgZmFsbHRocm91Z2hBdHRycywgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFhY2Nlc3NlZEF0dHJzICYmIHJvb3QudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICBjb25zdCBhbGxBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKTtcbiAgICAgICAgY29uc3QgZXZlbnRBdHRycyA9IFtdO1xuICAgICAgICBjb25zdCBleHRyYUF0dHJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYWxsQXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYWxsQXR0cnNbaV07XG4gICAgICAgICAgaWYgKGlzT24oa2V5KSkge1xuICAgICAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xuICAgICAgICAgICAgICBldmVudEF0dHJzLnB1c2goa2V5WzJdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHRyYUF0dHJzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEV4dHJhbmVvdXMgbm9uLXByb3BzIGF0dHJpYnV0ZXMgKCR7ZXh0cmFBdHRycy5qb2luKFwiLCBcIil9KSB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRBdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgRXh0cmFuZW91cyBub24tZW1pdHMgZXZlbnQgbGlzdGVuZXJzICgke2V2ZW50QXR0cnMuam9pbihcIiwgXCIpfSkgd2VyZSBwYXNzZWQgdG8gY29tcG9uZW50IGJ1dCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBpbmhlcml0ZWQgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IHJvb3Qgbm9kZXMuIElmIHRoZSBsaXN0ZW5lciBpcyBpbnRlbmRlZCB0byBiZSBhIGNvbXBvbmVudCBjdXN0b20gZXZlbnQgbGlzdGVuZXIgb25seSwgZGVjbGFyZSBpdCB1c2luZyB0aGUgXCJlbWl0c1wiIG9wdGlvbi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm5vZGUuZGlycykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBSdW50aW1lIGRpcmVjdGl2ZSB1c2VkIG9uIGNvbXBvbmVudCB3aXRoIG5vbi1lbGVtZW50IHJvb3Qgbm9kZS4gVGhlIGRpcmVjdGl2ZXMgd2lsbCBub3QgZnVuY3Rpb24gYXMgaW50ZW5kZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgbnVsbCwgZmFsc2UsIHRydWUpO1xuICAgIHJvb3QuZGlycyA9IHJvb3QuZGlycyA/IHJvb3QuZGlycy5jb25jYXQodm5vZGUuZGlycykgOiB2bm9kZS5kaXJzO1xuICB9XG4gIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYENvbXBvbmVudCBpbnNpZGUgPFRyYW5zaXRpb24+IHJlbmRlcnMgbm9uLWVsZW1lbnQgcm9vdCBub2RlIHRoYXQgY2Fubm90IGJlIGFuaW1hdGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJvb3QudHJhbnNpdGlvbiA9IHZub2RlLnRyYW5zaXRpb247XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0Um9vdCkge1xuICAgIHNldFJvb3Qocm9vdCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gcm9vdDtcbiAgfVxuICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBnZXRDaGlsZFJvb3QgPSAodm5vZGUpID0+IHtcbiAgY29uc3QgcmF3Q2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgY29uc3QgZHluYW1pY0NoaWxkcmVuID0gdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICBjb25zdCBjaGlsZFJvb3QgPSBmaWx0ZXJTaW5nbGVSb290KHJhd0NoaWxkcmVuLCBmYWxzZSk7XG4gIGlmICghY2hpbGRSb290KSB7XG4gICAgcmV0dXJuIFt2bm9kZSwgdm9pZCAwXTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoaWxkUm9vdC5wYXRjaEZsYWcgPiAwICYmIGNoaWxkUm9vdC5wYXRjaEZsYWcgJiAyMDQ4KSB7XG4gICAgcmV0dXJuIGdldENoaWxkUm9vdChjaGlsZFJvb3QpO1xuICB9XG4gIGNvbnN0IGluZGV4ID0gcmF3Q2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpO1xuICBjb25zdCBkeW5hbWljSW5kZXggPSBkeW5hbWljQ2hpbGRyZW4gPyBkeW5hbWljQ2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpIDogLTE7XG4gIGNvbnN0IHNldFJvb3QgPSAodXBkYXRlZFJvb3QpID0+IHtcbiAgICByYXdDaGlsZHJlbltpbmRleF0gPSB1cGRhdGVkUm9vdDtcbiAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICBpZiAoZHluYW1pY0luZGV4ID4gLTEpIHtcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuW2R5bmFtaWNJbmRleF0gPSB1cGRhdGVkUm9vdDtcbiAgICAgIH0gZWxzZSBpZiAodXBkYXRlZFJvb3QucGF0Y2hGbGFnID4gMCkge1xuICAgICAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBbLi4uZHluYW1pY0NoaWxkcmVuLCB1cGRhdGVkUm9vdF07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gW25vcm1hbGl6ZVZOb2RlKGNoaWxkUm9vdCksIHNldFJvb3RdO1xufTtcbmZ1bmN0aW9uIGZpbHRlclNpbmdsZVJvb3QoY2hpbGRyZW4sIHJlY3Vyc2UgPSB0cnVlKSB7XG4gIGxldCBzaW5nbGVSb290O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNWTm9kZShjaGlsZCkpIHtcbiAgICAgIGlmIChjaGlsZC50eXBlICE9PSBDb21tZW50IHx8IGNoaWxkLmNoaWxkcmVuID09PSBcInYtaWZcIikge1xuICAgICAgICBpZiAoc2luZ2xlUm9vdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaW5nbGVSb290ID0gY2hpbGQ7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcmVjdXJzZSAmJiBzaW5nbGVSb290LnBhdGNoRmxhZyA+IDAgJiYgc2luZ2xlUm9vdC5wYXRjaEZsYWcgJiAyMDQ4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyU2luZ2xlUm9vdChzaW5nbGVSb290LmNoaWxkcmVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2luZ2xlUm9vdDtcbn1cbmNvbnN0IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaCA9IChhdHRycykgPT4ge1xuICBsZXQgcmVzO1xuICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIiB8fCBrZXkgPT09IFwic3R5bGVcIiB8fCBpc09uKGtleSkpIHtcbiAgICAgIChyZXMgfHwgKHJlcyA9IHt9KSlba2V5XSA9IGF0dHJzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgZmlsdGVyTW9kZWxMaXN0ZW5lcnMgPSAoYXR0cnMsIHByb3BzKSA9PiB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkgfHwgIShrZXkuc2xpY2UoOSkgaW4gcHJvcHMpKSB7XG4gICAgICByZXNba2V5XSA9IGF0dHJzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgaXNFbGVtZW50Um9vdCA9ICh2bm9kZSkgPT4ge1xuICByZXR1cm4gdm5vZGUuc2hhcGVGbGFnICYgKDYgfCAxKSB8fCB2bm9kZS50eXBlID09PSBDb21tZW50O1xufTtcbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZUNvbXBvbmVudChwcmV2Vk5vZGUsIG5leHRWTm9kZSwgb3B0aW1pemVkKSB7XG4gIGNvbnN0IHsgcHJvcHM6IHByZXZQcm9wcywgY2hpbGRyZW46IHByZXZDaGlsZHJlbiwgY29tcG9uZW50IH0gPSBwcmV2Vk5vZGU7XG4gIGNvbnN0IHsgcHJvcHM6IG5leHRQcm9wcywgY2hpbGRyZW46IG5leHRDaGlsZHJlbiwgcGF0Y2hGbGFnIH0gPSBuZXh0Vk5vZGU7XG4gIGNvbnN0IGVtaXRzID0gY29tcG9uZW50LmVtaXRzT3B0aW9ucztcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobmV4dFZOb2RlLmRpcnMgfHwgbmV4dFZOb2RlLnRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAob3B0aW1pemVkICYmIHBhdGNoRmxhZyA+PSAwKSB7XG4gICAgaWYgKHBhdGNoRmxhZyAmIDEwMjQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocGF0Y2hGbGFnICYgMTYpIHtcbiAgICAgIGlmICghcHJldlByb3BzKSB7XG4gICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcbiAgICB9IGVsc2UgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgIGNvbnN0IGR5bmFtaWNQcm9wcyA9IG5leHRWTm9kZS5keW5hbWljUHJvcHM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGR5bmFtaWNQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBkeW5hbWljUHJvcHNbaV07XG4gICAgICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiYgIWlzRW1pdExpc3RlbmVyKGVtaXRzLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuIHx8ICFuZXh0Q2hpbGRyZW4uJHN0YWJsZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByZXZQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghcHJldlByb3BzKSB7XG4gICAgICByZXR1cm4gISFuZXh0UHJvcHM7XG4gICAgfVxuICAgIGlmICghbmV4dFByb3BzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHNPcHRpb25zKSB7XG4gIGNvbnN0IG5leHRLZXlzID0gT2JqZWN0LmtleXMobmV4dFByb3BzKTtcbiAgaWYgKG5leHRLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocHJldlByb3BzKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gbmV4dEtleXNbaV07XG4gICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJiAhaXNFbWl0TGlzdGVuZXIoZW1pdHNPcHRpb25zLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdXBkYXRlSE9DSG9zdEVsKHsgdm5vZGUsIHBhcmVudCB9LCBlbCkge1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgY29uc3Qgcm9vdCA9IHBhcmVudC5zdWJUcmVlO1xuICAgIGlmIChyb290LnN1c3BlbnNlICYmIHJvb3Quc3VzcGVuc2UuYWN0aXZlQnJhbmNoID09PSB2bm9kZSkge1xuICAgICAgcm9vdC5lbCA9IHZub2RlLmVsO1xuICAgIH1cbiAgICBpZiAocm9vdCA9PT0gdm5vZGUpIHtcbiAgICAgICh2bm9kZSA9IHBhcmVudC52bm9kZSkuZWwgPSBlbDtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBpc1N1c3BlbnNlID0gKHR5cGUpID0+IHR5cGUuX19pc1N1c3BlbnNlO1xubGV0IHN1c3BlbnNlSWQgPSAwO1xuY29uc3QgU3VzcGVuc2VJbXBsID0ge1xuICBuYW1lOiBcIlN1c3BlbnNlXCIsXG4gIC8vIEluIG9yZGVyIHRvIG1ha2UgU3VzcGVuc2UgdHJlZS1zaGFrYWJsZSwgd2UgbmVlZCB0byBhdm9pZCBpbXBvcnRpbmcgaXRcbiAgLy8gZGlyZWN0bHkgaW4gdGhlIHJlbmRlcmVyLiBUaGUgcmVuZGVyZXIgY2hlY2tzIGZvciB0aGUgX19pc1N1c3BlbnNlIGZsYWdcbiAgLy8gb24gYSB2bm9kZSdzIHR5cGUgYW5kIGNhbGxzIHRoZSBgcHJvY2Vzc2AgbWV0aG9kLCBwYXNzaW5nIGluIHJlbmRlcmVyXG4gIC8vIGludGVybmFscy5cbiAgX19pc1N1c3BlbnNlOiB0cnVlLFxuICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIG1vdW50U3VzcGVuc2UoXG4gICAgICAgIG4yLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5kZXBzID4gMCAmJiAhbjEuc3VzcGVuc2UuaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgIG4yLnN1c3BlbnNlID0gbjEuc3VzcGVuc2U7XG4gICAgICAgIG4yLnN1c3BlbnNlLnZub2RlID0gbjI7XG4gICAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBhdGNoU3VzcGVuc2UoXG4gICAgICAgIG4xLFxuICAgICAgICBuMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHNcbiAgICAgICk7XG4gICAgfVxuICB9LFxuICBoeWRyYXRlOiBoeWRyYXRlU3VzcGVuc2UsXG4gIG5vcm1hbGl6ZTogbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlblxufTtcbmNvbnN0IFN1c3BlbnNlID0gU3VzcGVuc2VJbXBsIDtcbmZ1bmN0aW9uIHRyaWdnZXJFdmVudCh2bm9kZSwgbmFtZSkge1xuICBjb25zdCBldmVudExpc3RlbmVyID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHNbbmFtZV07XG4gIGlmIChpc0Z1bmN0aW9uKGV2ZW50TGlzdGVuZXIpKSB7XG4gICAgZXZlbnRMaXN0ZW5lcigpO1xuICB9XG59XG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpIHtcbiAgY29uc3Qge1xuICAgIHA6IHBhdGNoLFxuICAgIG86IHsgY3JlYXRlRWxlbWVudCB9XG4gIH0gPSByZW5kZXJlckludGVybmFscztcbiAgY29uc3QgaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXG4gICAgdm5vZGUsXG4gICAgcGFyZW50U3VzcGVuc2UsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIGNvbnRhaW5lcixcbiAgICBoaWRkZW5Db250YWluZXIsXG4gICAgYW5jaG9yLFxuICAgIG5hbWVzcGFjZSxcbiAgICBzbG90U2NvcGVJZHMsXG4gICAgb3B0aW1pemVkLFxuICAgIHJlbmRlcmVySW50ZXJuYWxzXG4gICk7XG4gIHBhdGNoKFxuICAgIG51bGwsXG4gICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCxcbiAgICBoaWRkZW5Db250YWluZXIsXG4gICAgbnVsbCxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgc3VzcGVuc2UsXG4gICAgbmFtZXNwYWNlLFxuICAgIHNsb3RTY29wZUlkc1xuICApO1xuICBpZiAoc3VzcGVuc2UuZGVwcyA+IDApIHtcbiAgICB0cmlnZ2VyRXZlbnQodm5vZGUsIFwib25QZW5kaW5nXCIpO1xuICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgXCJvbkZhbGxiYWNrXCIpO1xuICAgIHBhdGNoKFxuICAgICAgbnVsbCxcbiAgICAgIHZub2RlLnNzRmFsbGJhY2ssXG4gICAgICBjb250YWluZXIsXG4gICAgICBhbmNob3IsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBudWxsLFxuICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIHNsb3RTY29wZUlkc1xuICAgICk7XG4gICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCB2bm9kZS5zc0ZhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBzdXNwZW5zZS5yZXNvbHZlKGZhbHNlLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hTdXNwZW5zZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHsgcDogcGF0Y2gsIHVtOiB1bm1vdW50LCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9KSB7XG4gIGNvbnN0IHN1c3BlbnNlID0gbjIuc3VzcGVuc2UgPSBuMS5zdXNwZW5zZTtcbiAgc3VzcGVuc2Uudm5vZGUgPSBuMjtcbiAgbjIuZWwgPSBuMS5lbDtcbiAgY29uc3QgbmV3QnJhbmNoID0gbjIuc3NDb250ZW50O1xuICBjb25zdCBuZXdGYWxsYmFjayA9IG4yLnNzRmFsbGJhY2s7XG4gIGNvbnN0IHsgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBpc0luRmFsbGJhY2ssIGlzSHlkcmF0aW5nIH0gPSBzdXNwZW5zZTtcbiAgaWYgKHBlbmRpbmdCcmFuY2gpIHtcbiAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xuICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBwZW5kaW5nQnJhbmNoKSkge1xuICAgICAgcGF0Y2goXG4gICAgICAgIHBlbmRpbmdCcmFuY2gsXG4gICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICB9IGVsc2UgaWYgKGlzSW5GYWxsYmFjaykge1xuICAgICAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgICAgICBuZXdGYWxsYmFjayxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nSWQgPSBzdXNwZW5zZUlkKys7XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gcGVuZGluZ0JyYW5jaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVubW91bnQocGVuZGluZ0JyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBzdXNwZW5zZS5kZXBzID0gMDtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMubGVuZ3RoID0gMDtcbiAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBpZiAoaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICAgICAgbmV3RmFsbGJhY2ssXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XG4gICAgICBwYXRjaChcbiAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdCcmFuY2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyRXZlbnQobjIsIFwib25QZW5kaW5nXCIpO1xuICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcbiAgICAgIGlmIChuZXdCcmFuY2guc2hhcGVGbGFnICYgNTEyKSB7XG4gICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCA9IG5ld0JyYW5jaC5jb21wb25lbnQuc3VzcGVuc2VJZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCA9IHN1c3BlbnNlSWQrKztcbiAgICAgIH1cbiAgICAgIHBhdGNoKFxuICAgICAgICBudWxsLFxuICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyB0aW1lb3V0LCBwZW5kaW5nSWQgfSA9IHN1c3BlbnNlO1xuICAgICAgICBpZiAodGltZW91dCA+IDApIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nSWQgPT09IHBlbmRpbmdJZCkge1xuICAgICAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZW91dCA9PT0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxubGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGlzSHlkcmF0aW5nID0gZmFsc2UpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSAmJiAhaGFzV2FybmVkKSB7XG4gICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/IFwiaW5mb1wiIDogXCJsb2dcIl0oXG4gICAgICBgPFN1c3BlbnNlPiBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSBhbmQgaXRzIEFQSSB3aWxsIGxpa2VseSBjaGFuZ2UuYFxuICAgICk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHA6IHBhdGNoLFxuICAgIG06IG1vdmUsXG4gICAgdW06IHVubW91bnQsXG4gICAgbjogbmV4dCxcbiAgICBvOiB7IHBhcmVudE5vZGUsIHJlbW92ZSB9XG4gIH0gPSByZW5kZXJlckludGVybmFscztcbiAgbGV0IHBhcmVudFN1c3BlbnNlSWQ7XG4gIGNvbnN0IGlzU3VzcGVuc2libGUgPSBpc1ZOb2RlU3VzcGVuc2libGUodm5vZGUpO1xuICBpZiAoaXNTdXNwZW5zaWJsZSkge1xuICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICBwYXJlbnRTdXNwZW5zZUlkID0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkO1xuICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcysrO1xuICAgIH1cbiAgfVxuICBjb25zdCB0aW1lb3V0ID0gdm5vZGUucHJvcHMgPyB0b051bWJlcih2bm9kZS5wcm9wcy50aW1lb3V0KSA6IHZvaWQgMDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBhc3NlcnROdW1iZXIodGltZW91dCwgYFN1c3BlbnNlIHRpbWVvdXRgKTtcbiAgfVxuICBjb25zdCBpbml0aWFsQW5jaG9yID0gYW5jaG9yO1xuICBjb25zdCBzdXNwZW5zZSA9IHtcbiAgICB2bm9kZSxcbiAgICBwYXJlbnQ6IHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBuYW1lc3BhY2UsXG4gICAgY29udGFpbmVyLFxuICAgIGhpZGRlbkNvbnRhaW5lcixcbiAgICBkZXBzOiAwLFxuICAgIHBlbmRpbmdJZDogc3VzcGVuc2VJZCsrLFxuICAgIHRpbWVvdXQ6IHR5cGVvZiB0aW1lb3V0ID09PSBcIm51bWJlclwiID8gdGltZW91dCA6IC0xLFxuICAgIGFjdGl2ZUJyYW5jaDogbnVsbCxcbiAgICBwZW5kaW5nQnJhbmNoOiBudWxsLFxuICAgIGlzSW5GYWxsYmFjazogIWlzSHlkcmF0aW5nLFxuICAgIGlzSHlkcmF0aW5nLFxuICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcbiAgICBlZmZlY3RzOiBbXSxcbiAgICByZXNvbHZlKHJlc3VtZSA9IGZhbHNlLCBzeW5jID0gZmFsc2UpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGlmICghcmVzdW1lICYmICFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgd2l0aG91dCBhIHBlbmRpbmcgYnJhbmNoLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdXNwZW5zZS5pc1VubW91bnRlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIG9uIGFuIGFscmVhZHkgdW5tb3VudGVkIHN1c3BlbnNlIGJvdW5kYXJ5LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIHZub2RlOiB2bm9kZTIsXG4gICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgcGVuZGluZ0JyYW5jaCxcbiAgICAgICAgcGVuZGluZ0lkLFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQ6IHBhcmVudENvbXBvbmVudDIsXG4gICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyMlxuICAgICAgfSA9IHN1c3BlbnNlO1xuICAgICAgbGV0IGRlbGF5RW50ZXIgPSBmYWxzZTtcbiAgICAgIGlmIChzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xuICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghcmVzdW1lKSB7XG4gICAgICAgIGRlbGF5RW50ZXIgPSBhY3RpdmVCcmFuY2ggJiYgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uICYmIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbi5tb2RlID09PSBcIm91dC1pblwiO1xuICAgICAgICBpZiAoZGVsYXlFbnRlcikge1xuICAgICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGVuZGluZ0lkID09PSBzdXNwZW5zZS5wZW5kaW5nSWQpIHtcbiAgICAgICAgICAgICAgbW92ZShcbiAgICAgICAgICAgICAgICBwZW5kaW5nQnJhbmNoLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjIsXG4gICAgICAgICAgICAgICAgYW5jaG9yID09PSBpbml0aWFsQW5jaG9yID8gbmV4dChhY3RpdmVCcmFuY2gpIDogYW5jaG9yLFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihlZmZlY3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmVCcmFuY2gpIHtcbiAgICAgICAgICBpZiAocGFyZW50Tm9kZShhY3RpdmVCcmFuY2guZWwpICE9PSBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudDIsIHN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcbiAgICAgICAgICBtb3ZlKHBlbmRpbmdCcmFuY2gsIGNvbnRhaW5lcjIsIGFuY2hvciwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgcGVuZGluZ0JyYW5jaCk7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbnVsbDtcbiAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IGZhbHNlO1xuICAgICAgbGV0IHBhcmVudCA9IHN1c3BlbnNlLnBhcmVudDtcbiAgICAgIGxldCBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgICAgcGFyZW50LmVmZmVjdHMucHVzaCguLi5lZmZlY3RzKTtcbiAgICAgICAgICBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc1VucmVzb2x2ZWRBbmNlc3RvciAmJiAhZGVsYXlFbnRlcikge1xuICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKGVmZmVjdHMpO1xuICAgICAgfVxuICAgICAgc3VzcGVuc2UuZWZmZWN0cyA9IFtdO1xuICAgICAgaWYgKGlzU3VzcGVuc2libGUpIHtcbiAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgcGFyZW50U3VzcGVuc2VJZCA9PT0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xuICAgICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZS5kZXBzID09PSAwICYmICFzeW5jKSB7XG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmlnZ2VyRXZlbnQodm5vZGUyLCBcIm9uUmVzb2x2ZVwiKTtcbiAgICB9LFxuICAgIGZhbGxiYWNrKGZhbGxiYWNrVk5vZGUpIHtcbiAgICAgIGlmICghc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IHZub2RlOiB2bm9kZTIsIGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50OiBwYXJlbnRDb21wb25lbnQyLCBjb250YWluZXI6IGNvbnRhaW5lcjIsIG5hbWVzcGFjZTogbmFtZXNwYWNlMiB9ID0gc3VzcGVuc2U7XG4gICAgICB0cmlnZ2VyRXZlbnQodm5vZGUyLCBcIm9uRmFsbGJhY2tcIik7XG4gICAgICBjb25zdCBhbmNob3IyID0gbmV4dChhY3RpdmVCcmFuY2gpO1xuICAgICAgY29uc3QgbW91bnRGYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFzdXNwZW5zZS5pc0luRmFsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBmYWxsYmFja1ZOb2RlLFxuICAgICAgICAgIGNvbnRhaW5lcjIsXG4gICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICBuYW1lc3BhY2UyLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBmYWxsYmFja1ZOb2RlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkZWxheUVudGVyID0gZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uICYmIGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbi5tb2RlID09PSBcIm91dC1pblwiO1xuICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcbiAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9IG1vdW50RmFsbGJhY2s7XG4gICAgICB9XG4gICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgdW5tb3VudChcbiAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBubyBzdXNwZW5zZSBzbyB1bm1vdW50IGhvb2tzIGZpcmUgbm93XG4gICAgICAgIHRydWVcbiAgICAgICAgLy8gc2hvdWxkUmVtb3ZlXG4gICAgICApO1xuICAgICAgaWYgKCFkZWxheUVudGVyKSB7XG4gICAgICAgIG1vdW50RmFsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdmUoY29udGFpbmVyMiwgYW5jaG9yMiwgdHlwZSkge1xuICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG1vdmUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCBjb250YWluZXIyLCBhbmNob3IyLCB0eXBlKTtcbiAgICAgIHN1c3BlbnNlLmNvbnRhaW5lciA9IGNvbnRhaW5lcjI7XG4gICAgfSxcbiAgICBuZXh0KCkge1xuICAgICAgcmV0dXJuIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJiBuZXh0KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCk7XG4gICAgfSxcbiAgICByZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QsIG9wdGltaXplZDIpIHtcbiAgICAgIGNvbnN0IGlzSW5QZW5kaW5nU3VzcGVuc2UgPSAhIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2g7XG4gICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSkge1xuICAgICAgICBzdXNwZW5zZS5kZXBzKys7XG4gICAgICB9XG4gICAgICBjb25zdCBoeWRyYXRlZEVsID0gaW5zdGFuY2Uudm5vZGUuZWw7XG4gICAgICBpbnN0YW5jZS5hc3luY0RlcC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDApO1xuICAgICAgfSkudGhlbigoYXN5bmNTZXR1cFJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQgfHwgc3VzcGVuc2UuaXNVbm1vdW50ZWQgfHwgc3VzcGVuc2UucGVuZGluZ0lkICE9PSBpbnN0YW5jZS5zdXNwZW5zZUlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLmFzeW5jUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHZub2RlOiB2bm9kZTIgfSA9IGluc3RhbmNlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZTIpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBhc3luY1NldHVwUmVzdWx0LCBmYWxzZSk7XG4gICAgICAgIGlmIChoeWRyYXRlZEVsKSB7XG4gICAgICAgICAgdm5vZGUyLmVsID0gaHlkcmF0ZWRFbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9ICFoeWRyYXRlZEVsICYmIGluc3RhbmNlLnN1YlRyZWUuZWw7XG4gICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHZub2RlMixcbiAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiBtb3ZlZCBiZWZvcmUgcmVzb2x2ZS5cbiAgICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCBhIGh5ZHJhdGlvbiwgaW5zdGFuY2Uuc3ViVHJlZSB3aWxsIGJlIHRoZSBjb21tZW50XG4gICAgICAgICAgLy8gcGxhY2Vob2xkZXIuXG4gICAgICAgICAgcGFyZW50Tm9kZShoeWRyYXRlZEVsIHx8IGluc3RhbmNlLnN1YlRyZWUuZWwpLFxuICAgICAgICAgIC8vIGFuY2hvciB3aWxsIG5vdCBiZSB1c2VkIGlmIHRoaXMgaXMgaHlkcmF0aW9uLCBzbyBvbmx5IG5lZWQgdG9cbiAgICAgICAgICAvLyBjb25zaWRlciB0aGUgY29tbWVudCBwbGFjZWhvbGRlciBjYXNlLlxuICAgICAgICAgIGh5ZHJhdGVkRWwgPyBudWxsIDogbmV4dChpbnN0YW5jZS5zdWJUcmVlKSxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgb3B0aW1pemVkMlxuICAgICAgICApO1xuICAgICAgICBpZiAocGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICByZW1vdmUocGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgdm5vZGUyLmVsKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0luUGVuZGluZ1N1c3BlbnNlICYmIC0tc3VzcGVuc2UuZGVwcyA9PT0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB1bm1vdW50KHBhcmVudFN1c3BlbnNlMiwgZG9SZW1vdmUpIHtcbiAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgIGlmIChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpIHtcbiAgICAgICAgdW5tb3VudChcbiAgICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2gsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlMixcbiAgICAgICAgICBkb1JlbW92ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgdW5tb3VudChcbiAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZTIsXG4gICAgICAgICAgZG9SZW1vdmVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBzdXNwZW5zZTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGVTdXNwZW5zZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVOb2RlKSB7XG4gIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgIHZub2RlLFxuICAgIHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBub2RlLnBhcmVudE5vZGUsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgbnVsbCxcbiAgICBuYW1lc3BhY2UsXG4gICAgc2xvdFNjb3BlSWRzLFxuICAgIG9wdGltaXplZCxcbiAgICByZW5kZXJlckludGVybmFscyxcbiAgICB0cnVlXG4gICk7XG4gIGNvbnN0IHJlc3VsdCA9IGh5ZHJhdGVOb2RlKFxuICAgIG5vZGUsXG4gICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgc3VzcGVuc2UsXG4gICAgc2xvdFNjb3BlSWRzLFxuICAgIG9wdGltaXplZFxuICApO1xuICBpZiAoc3VzcGVuc2UuZGVwcyA9PT0gMCkge1xuICAgIHN1c3BlbnNlLnJlc29sdmUoZmFsc2UsIHRydWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuKHZub2RlKSB7XG4gIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gIGNvbnN0IGlzU2xvdENoaWxkcmVuID0gc2hhcGVGbGFnICYgMzI7XG4gIHZub2RlLnNzQ29udGVudCA9IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChcbiAgICBpc1Nsb3RDaGlsZHJlbiA/IGNoaWxkcmVuLmRlZmF1bHQgOiBjaGlsZHJlblxuICApO1xuICB2bm9kZS5zc0ZhbGxiYWNrID0gaXNTbG90Q2hpbGRyZW4gPyBub3JtYWxpemVTdXNwZW5zZVNsb3QoY2hpbGRyZW4uZmFsbGJhY2spIDogY3JlYXRlVk5vZGUoQ29tbWVudCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZVNsb3Qocykge1xuICBsZXQgYmxvY2s7XG4gIGlmIChpc0Z1bmN0aW9uKHMpKSB7XG4gICAgY29uc3QgdHJhY2tCbG9jayA9IGlzQmxvY2tUcmVlRW5hYmxlZCAmJiBzLl9jO1xuICAgIGlmICh0cmFja0Jsb2NrKSB7XG4gICAgICBzLl9kID0gZmFsc2U7XG4gICAgICBvcGVuQmxvY2soKTtcbiAgICB9XG4gICAgcyA9IHMoKTtcbiAgICBpZiAodHJhY2tCbG9jaykge1xuICAgICAgcy5fZCA9IHRydWU7XG4gICAgICBibG9jayA9IGN1cnJlbnRCbG9jaztcbiAgICAgIGNsb3NlQmxvY2soKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQXJyYXkocykpIHtcbiAgICBjb25zdCBzaW5nbGVDaGlsZCA9IGZpbHRlclNpbmdsZVJvb3Qocyk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXNpbmdsZUNoaWxkICYmIHMuZmlsdGVyKChjaGlsZCkgPT4gY2hpbGQgIT09IE5VTExfRFlOQU1JQ19DT01QT05FTlQpLmxlbmd0aCA+IDApIHtcbiAgICAgIHdhcm4kMShgPFN1c3BlbnNlPiBzbG90cyBleHBlY3QgYSBzaW5nbGUgcm9vdCBub2RlLmApO1xuICAgIH1cbiAgICBzID0gc2luZ2xlQ2hpbGQ7XG4gIH1cbiAgcyA9IG5vcm1hbGl6ZVZOb2RlKHMpO1xuICBpZiAoYmxvY2sgJiYgIXMuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgcy5keW5hbWljQ2hpbGRyZW4gPSBibG9jay5maWx0ZXIoKGMpID0+IGMgIT09IHMpO1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoZm4sIHN1c3BlbnNlKSB7XG4gIGlmIChzdXNwZW5zZSAmJiBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgaWYgKGlzQXJyYXkoZm4pKSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goLi4uZm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goZm4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVBvc3RGbHVzaENiKGZuKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBicmFuY2gpIHtcbiAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gYnJhbmNoO1xuICBjb25zdCB7IHZub2RlLCBwYXJlbnRDb21wb25lbnQgfSA9IHN1c3BlbnNlO1xuICBsZXQgZWwgPSBicmFuY2guZWw7XG4gIHdoaWxlICghZWwgJiYgYnJhbmNoLmNvbXBvbmVudCkge1xuICAgIGJyYW5jaCA9IGJyYW5jaC5jb21wb25lbnQuc3ViVHJlZTtcbiAgICBlbCA9IGJyYW5jaC5lbDtcbiAgfVxuICB2bm9kZS5lbCA9IGVsO1xuICBpZiAocGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC5zdWJUcmVlID09PSB2bm9kZSkge1xuICAgIHBhcmVudENvbXBvbmVudC52bm9kZS5lbCA9IGVsO1xuICAgIHVwZGF0ZUhPQ0hvc3RFbChwYXJlbnRDb21wb25lbnQsIGVsKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWTm9kZVN1c3BlbnNpYmxlKHZub2RlKSB7XG4gIGNvbnN0IHN1c3BlbnNpYmxlID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMuc3VzcGVuc2libGU7XG4gIHJldHVybiBzdXNwZW5zaWJsZSAhPSBudWxsICYmIHN1c3BlbnNpYmxlICE9PSBmYWxzZTtcbn1cblxuY29uc3QgRnJhZ21lbnQgPSBTeW1ib2wuZm9yKFwidi1mZ3RcIik7XG5jb25zdCBUZXh0ID0gU3ltYm9sLmZvcihcInYtdHh0XCIpO1xuY29uc3QgQ29tbWVudCA9IFN5bWJvbC5mb3IoXCJ2LWNtdFwiKTtcbmNvbnN0IFN0YXRpYyA9IFN5bWJvbC5mb3IoXCJ2LXN0Y1wiKTtcbmNvbnN0IGJsb2NrU3RhY2sgPSBbXTtcbmxldCBjdXJyZW50QmxvY2sgPSBudWxsO1xuZnVuY3Rpb24gb3BlbkJsb2NrKGRpc2FibGVUcmFja2luZyA9IGZhbHNlKSB7XG4gIGJsb2NrU3RhY2sucHVzaChjdXJyZW50QmxvY2sgPSBkaXNhYmxlVHJhY2tpbmcgPyBudWxsIDogW10pO1xufVxuZnVuY3Rpb24gY2xvc2VCbG9jaygpIHtcbiAgYmxvY2tTdGFjay5wb3AoKTtcbiAgY3VycmVudEJsb2NrID0gYmxvY2tTdGFja1tibG9ja1N0YWNrLmxlbmd0aCAtIDFdIHx8IG51bGw7XG59XG5sZXQgaXNCbG9ja1RyZWVFbmFibGVkID0gMTtcbmZ1bmN0aW9uIHNldEJsb2NrVHJhY2tpbmcodmFsdWUpIHtcbiAgaXNCbG9ja1RyZWVFbmFibGVkICs9IHZhbHVlO1xuICBpZiAodmFsdWUgPCAwICYmIGN1cnJlbnRCbG9jaykge1xuICAgIGN1cnJlbnRCbG9jay5oYXNPbmNlID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0dXBCbG9jayh2bm9kZSkge1xuICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwID8gY3VycmVudEJsb2NrIHx8IEVNUFRZX0FSUiA6IG51bGw7XG4gIGNsb3NlQmxvY2soKTtcbiAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xuICB9XG4gIHJldHVybiB2bm9kZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBzaGFwZUZsYWcpIHtcbiAgcmV0dXJuIHNldHVwQmxvY2soXG4gICAgY3JlYXRlQmFzZVZOb2RlKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBwYXRjaEZsYWcsXG4gICAgICBkeW5hbWljUHJvcHMsXG4gICAgICBzaGFwZUZsYWcsXG4gICAgICB0cnVlXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlQmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcykge1xuICByZXR1cm4gc2V0dXBCbG9jayhcbiAgICBjcmVhdGVWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgZHluYW1pY1Byb3BzLFxuICAgICAgdHJ1ZVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzVk5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gdmFsdWUuX192X2lzVk5vZGUgPT09IHRydWUgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbjIuc2hhcGVGbGFnICYgNiAmJiBuMS5jb21wb25lbnQpIHtcbiAgICBjb25zdCBkaXJ0eUluc3RhbmNlcyA9IGhtckRpcnR5Q29tcG9uZW50cy5nZXQobjIudHlwZSk7XG4gICAgaWYgKGRpcnR5SW5zdGFuY2VzICYmIGRpcnR5SW5zdGFuY2VzLmhhcyhuMS5jb21wb25lbnQpKSB7XG4gICAgICBuMS5zaGFwZUZsYWcgJj0gfjI1NjtcbiAgICAgIG4yLnNoYXBlRmxhZyAmPSB+NTEyO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbjEudHlwZSA9PT0gbjIudHlwZSAmJiBuMS5rZXkgPT09IG4yLmtleTtcbn1cbmxldCB2bm9kZUFyZ3NUcmFuc2Zvcm1lcjtcbmZ1bmN0aW9uIHRyYW5zZm9ybVZOb2RlQXJncyh0cmFuc2Zvcm1lcikge1xuICB2bm9kZUFyZ3NUcmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyO1xufVxuY29uc3QgY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA9ICguLi5hcmdzKSA9PiB7XG4gIHJldHVybiBfY3JlYXRlVk5vZGUoXG4gICAgLi4udm5vZGVBcmdzVHJhbnNmb3JtZXIgPyB2bm9kZUFyZ3NUcmFuc2Zvcm1lcihhcmdzLCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIDogYXJnc1xuICApO1xufTtcbmNvbnN0IG5vcm1hbGl6ZUtleSA9ICh7IGtleSB9KSA9PiBrZXkgIT0gbnVsbCA/IGtleSA6IG51bGw7XG5jb25zdCBub3JtYWxpemVSZWYgPSAoe1xuICByZWYsXG4gIHJlZl9rZXksXG4gIHJlZl9mb3Jcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiByZWYgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZWYgPSBcIlwiICsgcmVmO1xuICB9XG4gIHJldHVybiByZWYgIT0gbnVsbCA/IGlzU3RyaW5nKHJlZikgfHwgaXNSZWYocmVmKSB8fCBpc0Z1bmN0aW9uKHJlZikgPyB7IGk6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgcjogcmVmLCBrOiByZWZfa2V5LCBmOiAhIXJlZl9mb3IgfSA6IHJlZiA6IG51bGw7XG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBzaGFwZUZsYWcgPSB0eXBlID09PSBGcmFnbWVudCA/IDAgOiAxLCBpc0Jsb2NrTm9kZSA9IGZhbHNlLCBuZWVkRnVsbENoaWxkcmVuTm9ybWFsaXphdGlvbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHZub2RlID0ge1xuICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxuICAgIF9fdl9za2lwOiB0cnVlLFxuICAgIHR5cGUsXG4gICAgcHJvcHMsXG4gICAga2V5OiBwcm9wcyAmJiBub3JtYWxpemVLZXkocHJvcHMpLFxuICAgIHJlZjogcHJvcHMgJiYgbm9ybWFsaXplUmVmKHByb3BzKSxcbiAgICBzY29wZUlkOiBjdXJyZW50U2NvcGVJZCxcbiAgICBzbG90U2NvcGVJZHM6IG51bGwsXG4gICAgY2hpbGRyZW4sXG4gICAgY29tcG9uZW50OiBudWxsLFxuICAgIHN1c3BlbnNlOiBudWxsLFxuICAgIHNzQ29udGVudDogbnVsbCxcbiAgICBzc0ZhbGxiYWNrOiBudWxsLFxuICAgIGRpcnM6IG51bGwsXG4gICAgdHJhbnNpdGlvbjogbnVsbCxcbiAgICBlbDogbnVsbCxcbiAgICBhbmNob3I6IG51bGwsXG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIHRhcmdldFN0YXJ0OiBudWxsLFxuICAgIHRhcmdldEFuY2hvcjogbnVsbCxcbiAgICBzdGF0aWNDb3VudDogMCxcbiAgICBzaGFwZUZsYWcsXG4gICAgcGF0Y2hGbGFnLFxuICAgIGR5bmFtaWNQcm9wcyxcbiAgICBkeW5hbWljQ2hpbGRyZW46IG51bGwsXG4gICAgYXBwQ29udGV4dDogbnVsbCxcbiAgICBjdHg6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZVxuICB9O1xuICBpZiAobmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24pIHtcbiAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pO1xuICAgIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHR5cGUubm9ybWFsaXplKHZub2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICB2bm9kZS5zaGFwZUZsYWcgfD0gaXNTdHJpbmcoY2hpbGRyZW4pID8gOCA6IDE2O1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHZub2RlLmtleSAhPT0gdm5vZGUua2V5KSB7XG4gICAgd2FybiQxKGBWTm9kZSBjcmVhdGVkIHdpdGggaW52YWxpZCBrZXkgKE5hTikuIFZOb2RlIHR5cGU6YCwgdm5vZGUudHlwZSk7XG4gIH1cbiAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgLy8gYXZvaWQgYSBibG9jayBub2RlIGZyb20gdHJhY2tpbmcgaXRzZWxmXG4gICFpc0Jsb2NrTm9kZSAmJiAvLyBoYXMgY3VycmVudCBwYXJlbnQgYmxvY2tcbiAgY3VycmVudEJsb2NrICYmIC8vIHByZXNlbmNlIG9mIGEgcGF0Y2ggZmxhZyBpbmRpY2F0ZXMgdGhpcyBub2RlIG5lZWRzIHBhdGNoaW5nIG9uIHVwZGF0ZXMuXG4gIC8vIGNvbXBvbmVudCBub2RlcyBhbHNvIHNob3VsZCBhbHdheXMgYmUgcGF0Y2hlZCwgYmVjYXVzZSBldmVuIGlmIHRoZVxuICAvLyBjb21wb25lbnQgZG9lc24ndCBuZWVkIHRvIHVwZGF0ZSwgaXQgbmVlZHMgdG8gcGVyc2lzdCB0aGUgaW5zdGFuY2Ugb24gdG9cbiAgLy8gdGhlIG5leHQgdm5vZGUgc28gdGhhdCBpdCBjYW4gYmUgcHJvcGVybHkgdW5tb3VudGVkIGxhdGVyLlxuICAodm5vZGUucGF0Y2hGbGFnID4gMCB8fCBzaGFwZUZsYWcgJiA2KSAmJiAvLyB0aGUgRVZFTlRTIGZsYWcgaXMgb25seSBmb3IgaHlkcmF0aW9uIGFuZCBpZiBpdCBpcyB0aGUgb25seSBmbGFnLCB0aGVcbiAgLy8gdm5vZGUgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGR5bmFtaWMgZHVlIHRvIGhhbmRsZXIgY2FjaGluZy5cbiAgdm5vZGUucGF0Y2hGbGFnICE9PSAzMikge1xuICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5jb25zdCBjcmVhdGVWTm9kZSA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtIDogX2NyZWF0ZVZOb2RlO1xuZnVuY3Rpb24gX2NyZWF0ZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBpc0Jsb2NrTm9kZSA9IGZhbHNlKSB7XG4gIGlmICghdHlwZSB8fCB0eXBlID09PSBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXR5cGUpIHtcbiAgICAgIHdhcm4kMShgSW52YWxpZCB2bm9kZSB0eXBlIHdoZW4gY3JlYXRpbmcgdm5vZGU6ICR7dHlwZX0uYCk7XG4gICAgfVxuICAgIHR5cGUgPSBDb21tZW50O1xuICB9XG4gIGlmIChpc1ZOb2RlKHR5cGUpKSB7XG4gICAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHRydWVcbiAgICAgIC8qIG1lcmdlUmVmOiB0cnVlICovXG4gICAgKTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKGNsb25lZCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiAhaXNCbG9ja05vZGUgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgICBpZiAoY2xvbmVkLnNoYXBlRmxhZyAmIDYpIHtcbiAgICAgICAgY3VycmVudEJsb2NrW2N1cnJlbnRCbG9jay5pbmRleE9mKHR5cGUpXSA9IGNsb25lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKGNsb25lZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsb25lZC5wYXRjaEZsYWcgPSAtMjtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGlmIChpc0NsYXNzQ29tcG9uZW50KHR5cGUpKSB7XG4gICAgdHlwZSA9IHR5cGUuX192Y2NPcHRzO1xuICB9XG4gIGlmIChwcm9wcykge1xuICAgIHByb3BzID0gZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKTtcbiAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcbiAgICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xuICAgICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChzdHlsZSkpIHtcbiAgICAgIGlmIChpc1Byb3h5KHN0eWxlKSAmJiAhaXNBcnJheShzdHlsZSkpIHtcbiAgICAgICAgc3R5bGUgPSBleHRlbmQoe30sIHN0eWxlKTtcbiAgICAgIH1cbiAgICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICAgIH1cbiAgfVxuICBjb25zdCBzaGFwZUZsYWcgPSBpc1N0cmluZyh0eXBlKSA/IDEgOiBpc1N1c3BlbnNlKHR5cGUpID8gMTI4IDogaXNUZWxlcG9ydCh0eXBlKSA/IDY0IDogaXNPYmplY3QodHlwZSkgPyA0IDogaXNGdW5jdGlvbih0eXBlKSA/IDIgOiAwO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzaGFwZUZsYWcgJiA0ICYmIGlzUHJveHkodHlwZSkpIHtcbiAgICB0eXBlID0gdG9SYXcodHlwZSk7XG4gICAgd2FybiQxKFxuICAgICAgYFZ1ZSByZWNlaXZlZCBhIENvbXBvbmVudCB0aGF0IHdhcyBtYWRlIGEgcmVhY3RpdmUgb2JqZWN0LiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHBlcmZvcm1hbmNlIG92ZXJoZWFkIGFuZCBzaG91bGQgYmUgYXZvaWRlZCBieSBtYXJraW5nIHRoZSBjb21wb25lbnQgd2l0aCBcXGBtYXJrUmF3XFxgIG9yIHVzaW5nIFxcYHNoYWxsb3dSZWZcXGAgaW5zdGVhZCBvZiBcXGByZWZcXGAuYCxcbiAgICAgIGBcbkNvbXBvbmVudCB0aGF0IHdhcyBtYWRlIHJlYWN0aXZlOiBgLFxuICAgICAgdHlwZVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJhc2VWTm9kZShcbiAgICB0eXBlLFxuICAgIHByb3BzLFxuICAgIGNoaWxkcmVuLFxuICAgIHBhdGNoRmxhZyxcbiAgICBkeW5hbWljUHJvcHMsXG4gICAgc2hhcGVGbGFnLFxuICAgIGlzQmxvY2tOb2RlLFxuICAgIHRydWVcbiAgKTtcbn1cbmZ1bmN0aW9uIGd1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcykge1xuICBpZiAoIXByb3BzKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGlzUHJveHkocHJvcHMpIHx8IGlzSW50ZXJuYWxPYmplY3QocHJvcHMpID8gZXh0ZW5kKHt9LCBwcm9wcykgOiBwcm9wcztcbn1cbmZ1bmN0aW9uIGNsb25lVk5vZGUodm5vZGUsIGV4dHJhUHJvcHMsIG1lcmdlUmVmID0gZmFsc2UsIGNsb25lVHJhbnNpdGlvbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHsgcHJvcHMsIHJlZiwgcGF0Y2hGbGFnLCBjaGlsZHJlbiwgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XG4gIGNvbnN0IG1lcmdlZFByb3BzID0gZXh0cmFQcm9wcyA/IG1lcmdlUHJvcHMocHJvcHMgfHwge30sIGV4dHJhUHJvcHMpIDogcHJvcHM7XG4gIGNvbnN0IGNsb25lZCA9IHtcbiAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcbiAgICBfX3Zfc2tpcDogdHJ1ZSxcbiAgICB0eXBlOiB2bm9kZS50eXBlLFxuICAgIHByb3BzOiBtZXJnZWRQcm9wcyxcbiAgICBrZXk6IG1lcmdlZFByb3BzICYmIG5vcm1hbGl6ZUtleShtZXJnZWRQcm9wcyksXG4gICAgcmVmOiBleHRyYVByb3BzICYmIGV4dHJhUHJvcHMucmVmID8gKFxuICAgICAgLy8gIzIwNzggaW4gdGhlIGNhc2Ugb2YgPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiIHJlZj1cImV4dHJhXCIvPlxuICAgICAgLy8gaWYgdGhlIHZub2RlIGl0c2VsZiBhbHJlYWR5IGhhcyBhIHJlZiwgY2xvbmVWTm9kZSB3aWxsIG5lZWQgdG8gbWVyZ2VcbiAgICAgIC8vIHRoZSByZWZzIHNvIHRoZSBzaW5nbGUgdm5vZGUgY2FuIGJlIHNldCBvbiBtdWx0aXBsZSByZWZzXG4gICAgICBtZXJnZVJlZiAmJiByZWYgPyBpc0FycmF5KHJlZikgPyByZWYuY29uY2F0KG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKSkgOiBbcmVmLCBub3JtYWxpemVSZWYoZXh0cmFQcm9wcyldIDogbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXG4gICAgKSA6IHJlZixcbiAgICBzY29wZUlkOiB2bm9kZS5zY29wZUlkLFxuICAgIHNsb3RTY29wZUlkczogdm5vZGUuc2xvdFNjb3BlSWRzLFxuICAgIGNoaWxkcmVuOiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHBhdGNoRmxhZyA9PT0gLTEgJiYgaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpIDogY2hpbGRyZW4sXG4gICAgdGFyZ2V0OiB2bm9kZS50YXJnZXQsXG4gICAgdGFyZ2V0U3RhcnQ6IHZub2RlLnRhcmdldFN0YXJ0LFxuICAgIHRhcmdldEFuY2hvcjogdm5vZGUudGFyZ2V0QW5jaG9yLFxuICAgIHN0YXRpY0NvdW50OiB2bm9kZS5zdGF0aWNDb3VudCxcbiAgICBzaGFwZUZsYWc6IHZub2RlLnNoYXBlRmxhZyxcbiAgICAvLyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIHdpdGggZXh0cmEgcHJvcHMsIHdlIGNhbiBubyBsb25nZXIgYXNzdW1lIGl0c1xuICAgIC8vIGV4aXN0aW5nIHBhdGNoIGZsYWcgdG8gYmUgcmVsaWFibGUgYW5kIG5lZWQgdG8gYWRkIHRoZSBGVUxMX1BST1BTIGZsYWcuXG4gICAgLy8gbm90ZTogcHJlc2VydmUgZmxhZyBmb3IgZnJhZ21lbnRzIHNpbmNlIHRoZXkgdXNlIHRoZSBmbGFnIGZvciBjaGlsZHJlblxuICAgIC8vIGZhc3QgcGF0aHMgb25seS5cbiAgICBwYXRjaEZsYWc6IGV4dHJhUHJvcHMgJiYgdm5vZGUudHlwZSAhPT0gRnJhZ21lbnQgPyBwYXRjaEZsYWcgPT09IC0xID8gMTYgOiBwYXRjaEZsYWcgfCAxNiA6IHBhdGNoRmxhZyxcbiAgICBkeW5hbWljUHJvcHM6IHZub2RlLmR5bmFtaWNQcm9wcyxcbiAgICBkeW5hbWljQ2hpbGRyZW46IHZub2RlLmR5bmFtaWNDaGlsZHJlbixcbiAgICBhcHBDb250ZXh0OiB2bm9kZS5hcHBDb250ZXh0LFxuICAgIGRpcnM6IHZub2RlLmRpcnMsXG4gICAgdHJhbnNpdGlvbixcbiAgICAvLyBUaGVzZSBzaG91bGQgdGVjaG5pY2FsbHkgb25seSBiZSBub24tbnVsbCBvbiBtb3VudGVkIFZOb2Rlcy4gSG93ZXZlcixcbiAgICAvLyB0aGV5ICpzaG91bGQqIGJlIGNvcGllZCBmb3Iga2VwdC1hbGl2ZSB2bm9kZXMuIFNvIHdlIGp1c3QgYWx3YXlzIGNvcHlcbiAgICAvLyB0aGVtIHNpbmNlIHRoZW0gYmVpbmcgbm9uLW51bGwgZHVyaW5nIGEgbW91bnQgZG9lc24ndCBhZmZlY3QgdGhlIGxvZ2ljIGFzXG4gICAgLy8gdGhleSB3aWxsIHNpbXBseSBiZSBvdmVyd3JpdHRlbi5cbiAgICBjb21wb25lbnQ6IHZub2RlLmNvbXBvbmVudCxcbiAgICBzdXNwZW5zZTogdm5vZGUuc3VzcGVuc2UsXG4gICAgc3NDb250ZW50OiB2bm9kZS5zc0NvbnRlbnQgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0NvbnRlbnQpLFxuICAgIHNzRmFsbGJhY2s6IHZub2RlLnNzRmFsbGJhY2sgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0ZhbGxiYWNrKSxcbiAgICBlbDogdm5vZGUuZWwsXG4gICAgYW5jaG9yOiB2bm9kZS5hbmNob3IsXG4gICAgY3R4OiB2bm9kZS5jdHgsXG4gICAgY2U6IHZub2RlLmNlXG4gIH07XG4gIGlmICh0cmFuc2l0aW9uICYmIGNsb25lVHJhbnNpdGlvbikge1xuICAgIHNldFRyYW5zaXRpb25Ib29rcyhcbiAgICAgIGNsb25lZCxcbiAgICAgIHRyYW5zaXRpb24uY2xvbmUoY2xvbmVkKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNsb25lZDtcbn1cbmZ1bmN0aW9uIGRlZXBDbG9uZVZOb2RlKHZub2RlKSB7XG4gIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBpZiAoaXNBcnJheSh2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBjbG9uZWQuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpO1xuICB9XG4gIHJldHVybiBjbG9uZWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUodGV4dCA9IFwiIFwiLCBmbGFnID0gMCkge1xuICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgdGV4dCwgZmxhZyk7XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNWTm9kZShjb250ZW50LCBudW1iZXJPZk5vZGVzKSB7XG4gIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoU3RhdGljLCBudWxsLCBjb250ZW50KTtcbiAgdm5vZGUuc3RhdGljQ291bnQgPSBudW1iZXJPZk5vZGVzO1xuICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21tZW50Vk5vZGUodGV4dCA9IFwiXCIsIGFzQmxvY2sgPSBmYWxzZSkge1xuICByZXR1cm4gYXNCbG9jayA/IChvcGVuQmxvY2soKSwgY3JlYXRlQmxvY2soQ29tbWVudCwgbnVsbCwgdGV4dCkpIDogY3JlYXRlVk5vZGUoQ29tbWVudCwgbnVsbCwgdGV4dCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVWTm9kZShjaGlsZCkge1xuICBpZiAoY2hpbGQgPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoY2hpbGQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFxuICAgICAgRnJhZ21lbnQsXG4gICAgICBudWxsLFxuICAgICAgLy8gIzM2NjYsIGF2b2lkIHJlZmVyZW5jZSBwb2xsdXRpb24gd2hlbiByZXVzaW5nIHZub2RlXG4gICAgICBjaGlsZC5zbGljZSgpXG4gICAgKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gY2xvbmVJZk1vdW50ZWQoY2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCBTdHJpbmcoY2hpbGQpKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvbmVJZk1vdW50ZWQoY2hpbGQpIHtcbiAgcmV0dXJuIGNoaWxkLmVsID09PSBudWxsICYmIGNoaWxkLnBhdGNoRmxhZyAhPT0gLTEgfHwgY2hpbGQubWVtbyA/IGNoaWxkIDogY2xvbmVWTm9kZShjaGlsZCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pIHtcbiAgbGV0IHR5cGUgPSAwO1xuICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gdm5vZGU7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgdHlwZSA9IDE2O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChzaGFwZUZsYWcgJiAoMSB8IDY0KSkge1xuICAgICAgY29uc3Qgc2xvdCA9IGNoaWxkcmVuLmRlZmF1bHQ7XG4gICAgICBpZiAoc2xvdCkge1xuICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gZmFsc2UpO1xuICAgICAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgc2xvdCgpKTtcbiAgICAgICAgc2xvdC5fYyAmJiAoc2xvdC5fZCA9IHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gMzI7XG4gICAgICBjb25zdCBzbG90RmxhZyA9IGNoaWxkcmVuLl87XG4gICAgICBpZiAoIXNsb3RGbGFnICYmICFpc0ludGVybmFsT2JqZWN0KGNoaWxkcmVuKSkge1xuICAgICAgICBjaGlsZHJlbi5fY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICAgICAgfSBlbHNlIGlmIChzbG90RmxhZyA9PT0gMyAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5zbG90cy5fID09PSAxKSB7XG4gICAgICAgICAgY2hpbGRyZW4uXyA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hpbGRyZW4uXyA9IDI7XG4gICAgICAgICAgdm5vZGUucGF0Y2hGbGFnIHw9IDEwMjQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihjaGlsZHJlbikpIHtcbiAgICBjaGlsZHJlbiA9IHsgZGVmYXVsdDogY2hpbGRyZW4sIF9jdHg6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB9O1xuICAgIHR5cGUgPSAzMjtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZHJlbiA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICB0eXBlID0gMTY7XG4gICAgICBjaGlsZHJlbiA9IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IDg7XG4gICAgfVxuICB9XG4gIHZub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHZub2RlLnNoYXBlRmxhZyB8PSB0eXBlO1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wcyguLi5hcmdzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b01lcmdlID0gYXJnc1tpXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0b01lcmdlKSB7XG4gICAgICBpZiAoa2V5ID09PSBcImNsYXNzXCIpIHtcbiAgICAgICAgaWYgKHJldC5jbGFzcyAhPT0gdG9NZXJnZS5jbGFzcykge1xuICAgICAgICAgIHJldC5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKFtyZXQuY2xhc3MsIHRvTWVyZ2UuY2xhc3NdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwic3R5bGVcIikge1xuICAgICAgICByZXQuc3R5bGUgPSBub3JtYWxpemVTdHlsZShbcmV0LnN0eWxlLCB0b01lcmdlLnN0eWxlXSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT24oa2V5KSkge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IHJldFtrZXldO1xuICAgICAgICBjb25zdCBpbmNvbWluZyA9IHRvTWVyZ2Vba2V5XTtcbiAgICAgICAgaWYgKGluY29taW5nICYmIGV4aXN0aW5nICE9PSBpbmNvbWluZyAmJiAhKGlzQXJyYXkoZXhpc3RpbmcpICYmIGV4aXN0aW5nLmluY2x1ZGVzKGluY29taW5nKSkpIHtcbiAgICAgICAgICByZXRba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBpbmNvbWluZykgOiBpbmNvbWluZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgIT09IFwiXCIpIHtcbiAgICAgICAgcmV0W2tleV0gPSB0b01lcmdlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBpbnZva2VWTm9kZUhvb2soaG9vaywgaW5zdGFuY2UsIHZub2RlLCBwcmV2Vk5vZGUgPSBudWxsKSB7XG4gIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA3LCBbXG4gICAgdm5vZGUsXG4gICAgcHJldlZOb2RlXG4gIF0pO1xufVxuXG5jb25zdCBlbXB0eUFwcENvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XG5sZXQgdWlkID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKHZub2RlLCBwYXJlbnQsIHN1c3BlbnNlKSB7XG4gIGNvbnN0IHR5cGUgPSB2bm9kZS50eXBlO1xuICBjb25zdCBhcHBDb250ZXh0ID0gKHBhcmVudCA/IHBhcmVudC5hcHBDb250ZXh0IDogdm5vZGUuYXBwQ29udGV4dCkgfHwgZW1wdHlBcHBDb250ZXh0O1xuICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICB1aWQ6IHVpZCsrLFxuICAgIHZub2RlLFxuICAgIHR5cGUsXG4gICAgcGFyZW50LFxuICAgIGFwcENvbnRleHQsXG4gICAgcm9vdDogbnVsbCxcbiAgICAvLyB0byBiZSBpbW1lZGlhdGVseSBzZXRcbiAgICBuZXh0OiBudWxsLFxuICAgIHN1YlRyZWU6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgc3luY2hyb25vdXNseSByaWdodCBhZnRlciBjcmVhdGlvblxuICAgIGVmZmVjdDogbnVsbCxcbiAgICB1cGRhdGU6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgc3luY2hyb25vdXNseSByaWdodCBhZnRlciBjcmVhdGlvblxuICAgIGpvYjogbnVsbCxcbiAgICBzY29wZTogbmV3IEVmZmVjdFNjb3BlKFxuICAgICAgdHJ1ZVxuICAgICAgLyogZGV0YWNoZWQgKi9cbiAgICApLFxuICAgIHJlbmRlcjogbnVsbCxcbiAgICBwcm94eTogbnVsbCxcbiAgICBleHBvc2VkOiBudWxsLFxuICAgIGV4cG9zZVByb3h5OiBudWxsLFxuICAgIHdpdGhQcm94eTogbnVsbCxcbiAgICBwcm92aWRlczogcGFyZW50ID8gcGFyZW50LnByb3ZpZGVzIDogT2JqZWN0LmNyZWF0ZShhcHBDb250ZXh0LnByb3ZpZGVzKSxcbiAgICBpZHM6IHBhcmVudCA/IHBhcmVudC5pZHMgOiBbXCJcIiwgMCwgMF0sXG4gICAgYWNjZXNzQ2FjaGU6IG51bGwsXG4gICAgcmVuZGVyQ2FjaGU6IFtdLFxuICAgIC8vIGxvY2FsIHJlc29sdmVkIGFzc2V0c1xuICAgIGNvbXBvbmVudHM6IG51bGwsXG4gICAgZGlyZWN0aXZlczogbnVsbCxcbiAgICAvLyByZXNvbHZlZCBwcm9wcyBhbmQgZW1pdHMgb3B0aW9uc1xuICAgIHByb3BzT3B0aW9uczogbm9ybWFsaXplUHJvcHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgIGVtaXRzT3B0aW9uczogbm9ybWFsaXplRW1pdHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgIC8vIGVtaXRcbiAgICBlbWl0OiBudWxsLFxuICAgIC8vIHRvIGJlIHNldCBpbW1lZGlhdGVseVxuICAgIGVtaXR0ZWQ6IG51bGwsXG4gICAgLy8gcHJvcHMgZGVmYXVsdCB2YWx1ZVxuICAgIHByb3BzRGVmYXVsdHM6IEVNUFRZX09CSixcbiAgICAvLyBpbmhlcml0QXR0cnNcbiAgICBpbmhlcml0QXR0cnM6IHR5cGUuaW5oZXJpdEF0dHJzLFxuICAgIC8vIHN0YXRlXG4gICAgY3R4OiBFTVBUWV9PQkosXG4gICAgZGF0YTogRU1QVFlfT0JKLFxuICAgIHByb3BzOiBFTVBUWV9PQkosXG4gICAgYXR0cnM6IEVNUFRZX09CSixcbiAgICBzbG90czogRU1QVFlfT0JKLFxuICAgIHJlZnM6IEVNUFRZX09CSixcbiAgICBzZXR1cFN0YXRlOiBFTVBUWV9PQkosXG4gICAgc2V0dXBDb250ZXh0OiBudWxsLFxuICAgIC8vIHN1c3BlbnNlIHJlbGF0ZWRcbiAgICBzdXNwZW5zZSxcbiAgICBzdXNwZW5zZUlkOiBzdXNwZW5zZSA/IHN1c3BlbnNlLnBlbmRpbmdJZCA6IDAsXG4gICAgYXN5bmNEZXA6IG51bGwsXG4gICAgYXN5bmNSZXNvbHZlZDogZmFsc2UsXG4gICAgLy8gbGlmZWN5Y2xlIGhvb2tzXG4gICAgLy8gbm90IHVzaW5nIGVudW1zIGhlcmUgYmVjYXVzZSBpdCByZXN1bHRzIGluIGNvbXB1dGVkIHByb3BlcnRpZXNcbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcbiAgICBpc0RlYWN0aXZhdGVkOiBmYWxzZSxcbiAgICBiYzogbnVsbCxcbiAgICBjOiBudWxsLFxuICAgIGJtOiBudWxsLFxuICAgIG06IG51bGwsXG4gICAgYnU6IG51bGwsXG4gICAgdTogbnVsbCxcbiAgICB1bTogbnVsbCxcbiAgICBidW06IG51bGwsXG4gICAgZGE6IG51bGwsXG4gICAgYTogbnVsbCxcbiAgICBydGc6IG51bGwsXG4gICAgcnRjOiBudWxsLFxuICAgIGVjOiBudWxsLFxuICAgIHNwOiBudWxsXG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5zdGFuY2UuY3R4ID0gY3JlYXRlRGV2UmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UuY3R4ID0geyBfOiBpbnN0YW5jZSB9O1xuICB9XG4gIGluc3RhbmNlLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCA6IGluc3RhbmNlO1xuICBpbnN0YW5jZS5lbWl0ID0gZW1pdC5iaW5kKG51bGwsIGluc3RhbmNlKTtcbiAgaWYgKHZub2RlLmNlKSB7XG4gICAgdm5vZGUuY2UoaW5zdGFuY2UpO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmxldCBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xuY29uc3QgZ2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbmxldCBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZTtcbmxldCBzZXRJblNTUlNldHVwU3RhdGU7XG57XG4gIGNvbnN0IGcgPSBnZXRHbG9iYWxUaGlzKCk7XG4gIGNvbnN0IHJlZ2lzdGVyR2xvYmFsU2V0dGVyID0gKGtleSwgc2V0dGVyKSA9PiB7XG4gICAgbGV0IHNldHRlcnM7XG4gICAgaWYgKCEoc2V0dGVycyA9IGdba2V5XSkpIHNldHRlcnMgPSBnW2tleV0gPSBbXTtcbiAgICBzZXR0ZXJzLnB1c2goc2V0dGVyKTtcbiAgICByZXR1cm4gKHYpID0+IHtcbiAgICAgIGlmIChzZXR0ZXJzLmxlbmd0aCA+IDEpIHNldHRlcnMuZm9yRWFjaCgoc2V0KSA9PiBzZXQodikpO1xuICAgICAgZWxzZSBzZXR0ZXJzWzBdKHYpO1xuICAgIH07XG4gIH07XG4gIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlID0gcmVnaXN0ZXJHbG9iYWxTZXR0ZXIoXG4gICAgYF9fVlVFX0lOU1RBTkNFX1NFVFRFUlNfX2AsXG4gICAgKHYpID0+IGN1cnJlbnRJbnN0YW5jZSA9IHZcbiAgKTtcbiAgc2V0SW5TU1JTZXR1cFN0YXRlID0gcmVnaXN0ZXJHbG9iYWxTZXR0ZXIoXG4gICAgYF9fVlVFX1NTUl9TRVRURVJTX19gLFxuICAgICh2KSA9PiBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSB2XG4gICk7XG59XG5jb25zdCBzZXRDdXJyZW50SW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgY29uc3QgcHJldiA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICBpbnN0YW5jZS5zY29wZS5vbigpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGluc3RhbmNlLnNjb3BlLm9mZigpO1xuICAgIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlKHByZXYpO1xuICB9O1xufTtcbmNvbnN0IHVuc2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4ge1xuICBjdXJyZW50SW5zdGFuY2UgJiYgY3VycmVudEluc3RhbmNlLnNjb3BlLm9mZigpO1xuICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZShudWxsKTtcbn07XG5jb25zdCBpc0J1aWx0SW5UYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcInNsb3QsY29tcG9uZW50XCIpO1xuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIHsgaXNOYXRpdmVUYWcgfSkge1xuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGlzTmF0aXZlVGFnKG5hbWUpKSB7XG4gICAgd2FybiQxKFxuICAgICAgXCJEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50IGlkOiBcIiArIG5hbWVcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiA0O1xufVxubGV0IGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlKSB7XG4gIGlzU1NSICYmIHNldEluU1NSU2V0dXBTdGF0ZShpc1NTUik7XG4gIGNvbnN0IHsgcHJvcHMsIGNoaWxkcmVuIH0gPSBpbnN0YW5jZS52bm9kZTtcbiAgY29uc3QgaXNTdGF0ZWZ1bCA9IGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpO1xuICBpbml0UHJvcHMoaW5zdGFuY2UsIHByb3BzLCBpc1N0YXRlZnVsLCBpc1NTUik7XG4gIGluaXRTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gIGNvbnN0IHNldHVwUmVzdWx0ID0gaXNTdGF0ZWZ1bCA/IHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSA6IHZvaWQgMDtcbiAgaXNTU1IgJiYgc2V0SW5TU1JTZXR1cFN0YXRlKGZhbHNlKTtcbiAgcmV0dXJuIHNldHVwUmVzdWx0O1xufVxuZnVuY3Rpb24gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGlmIChDb21wb25lbnQubmFtZSkge1xuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKENvbXBvbmVudC5uYW1lLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChDb21wb25lbnQuY29tcG9uZW50cykge1xuICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuY29tcG9uZW50cyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lc1tpXSwgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQ29tcG9uZW50LmRpcmVjdGl2ZXMpIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmRpcmVjdGl2ZXMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQ29tcG9uZW50LmNvbXBpbGVyT3B0aW9ucyAmJiBpc1J1bnRpbWVPbmx5KCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYFwiY29tcGlsZXJPcHRpb25zXCIgaXMgb25seSBzdXBwb3J0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZSB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyLiBTaW5jZSB5b3UgYXJlIHVzaW5nIGEgcnVudGltZS1vbmx5IGJ1aWxkLCB0aGUgb3B0aW9ucyBzaG91bGQgYmUgcGFzc2VkIHZpYSB5b3VyIGJ1aWxkIHRvb2wgY29uZmlnIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaW5zdGFuY2UuYWNjZXNzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaW5zdGFuY2UucHJveHkgPSBuZXcgUHJveHkoaW5zdGFuY2UuY3R4LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgfVxuICBjb25zdCB7IHNldHVwIH0gPSBDb21wb25lbnQ7XG4gIGlmIChzZXR1cCkge1xuICAgIGNvbnN0IHNldHVwQ29udGV4dCA9IGluc3RhbmNlLnNldHVwQ29udGV4dCA9IHNldHVwLmxlbmd0aCA+IDEgPyBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIDogbnVsbDtcbiAgICBjb25zdCByZXNldCA9IHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgcGF1c2VUcmFja2luZygpO1xuICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKFxuICAgICAgc2V0dXAsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDAsXG4gICAgICBbXG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaW5zdGFuY2UucHJvcHMpIDogaW5zdGFuY2UucHJvcHMsXG4gICAgICAgIHNldHVwQ29udGV4dFxuICAgICAgXVxuICAgICk7XG4gICAgcmVzZXRUcmFja2luZygpO1xuICAgIHJlc2V0KCk7XG4gICAgaWYgKGlzUHJvbWlzZShzZXR1cFJlc3VsdCkpIHtcbiAgICAgIGlmICghaXNBc3luY1dyYXBwZXIoaW5zdGFuY2UpKSBtYXJrQXN5bmNCb3VuZGFyeShpbnN0YW5jZSk7XG4gICAgICBzZXR1cFJlc3VsdC50aGVuKHVuc2V0Q3VycmVudEluc3RhbmNlLCB1bnNldEN1cnJlbnRJbnN0YW5jZSk7XG4gICAgICBpZiAoaXNTU1IpIHtcbiAgICAgICAgcmV0dXJuIHNldHVwUmVzdWx0LnRoZW4oKHJlc29sdmVkUmVzdWx0KSA9PiB7XG4gICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHJlc29sdmVkUmVzdWx0LCBpc1NTUik7XG4gICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgaW5zdGFuY2UsIDApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLmFzeW5jRGVwID0gc2V0dXBSZXN1bHQ7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpbnN0YW5jZS5zdXNwZW5zZSkge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSAoX2EgPSBDb21wb25lbnQubmFtZSkgIT0gbnVsbCA/IF9hIDogXCJBbm9ueW1vdXNcIjtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgQ29tcG9uZW50IDwke25hbWV9Pjogc2V0dXAgZnVuY3Rpb24gcmV0dXJuZWQgYSBwcm9taXNlLCBidXQgbm8gPFN1c3BlbnNlPiBib3VuZGFyeSB3YXMgZm91bmQgaW4gdGhlIHBhcmVudCBjb21wb25lbnQgdHJlZS4gQSBjb21wb25lbnQgd2l0aCBhc3luYyBzZXR1cCgpIG11c3QgYmUgbmVzdGVkIGluIGEgPFN1c3BlbnNlPiBpbiBvcmRlciB0byBiZSByZW5kZXJlZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUikge1xuICBpZiAoaXNGdW5jdGlvbihzZXR1cFJlc3VsdCkpIHtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5fX3NzcklubGluZVJlbmRlcikge1xuICAgICAgaW5zdGFuY2Uuc3NyUmVuZGVyID0gc2V0dXBSZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnJlbmRlciA9IHNldHVwUmVzdWx0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChzZXR1cFJlc3VsdCkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc1ZOb2RlKHNldHVwUmVzdWx0KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgc2V0dXAoKSBzaG91bGQgbm90IHJldHVybiBWTm9kZXMgZGlyZWN0bHkgLSByZXR1cm4gYSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGluc3RhbmNlLmRldnRvb2xzUmF3U2V0dXBTdGF0ZSA9IHNldHVwUmVzdWx0O1xuICAgIH1cbiAgICBpbnN0YW5jZS5zZXR1cFN0YXRlID0gcHJveHlSZWZzKHNldHVwUmVzdWx0KTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBSZXN1bHQgIT09IHZvaWQgMCkge1xuICAgIHdhcm4kMShcbiAgICAgIGBzZXR1cCgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZDogJHtzZXR1cFJlc3VsdCA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHNldHVwUmVzdWx0fWBcbiAgICApO1xuICB9XG4gIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XG59XG5sZXQgY29tcGlsZTtcbmxldCBpbnN0YWxsV2l0aFByb3h5O1xuZnVuY3Rpb24gcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIoX2NvbXBpbGUpIHtcbiAgY29tcGlsZSA9IF9jb21waWxlO1xuICBpbnN0YWxsV2l0aFByb3h5ID0gKGkpID0+IHtcbiAgICBpZiAoaS5yZW5kZXIuX3JjKSB7XG4gICAgICBpLndpdGhQcm94eSA9IG5ldyBQcm94eShpLmN0eCwgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBpc1J1bnRpbWVPbmx5ID0gKCkgPT4gIWNvbXBpbGU7XG5mdW5jdGlvbiBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IsIHNraXBPcHRpb25zKSB7XG4gIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XG4gIGlmICghaW5zdGFuY2UucmVuZGVyKSB7XG4gICAgaWYgKCFpc1NTUiAmJiBjb21waWxlICYmICFDb21wb25lbnQucmVuZGVyKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IENvbXBvbmVudC50ZW1wbGF0ZSB8fCByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkudGVtcGxhdGU7XG4gICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpc0N1c3RvbUVsZW1lbnQsIGNvbXBpbGVyT3B0aW9ucyB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWc7XG4gICAgICAgIGNvbnN0IHsgZGVsaW1pdGVycywgY29tcGlsZXJPcHRpb25zOiBjb21wb25lbnRDb21waWxlck9wdGlvbnMgfSA9IENvbXBvbmVudDtcbiAgICAgICAgY29uc3QgZmluYWxDb21waWxlck9wdGlvbnMgPSBleHRlbmQoXG4gICAgICAgICAgZXh0ZW5kKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpc0N1c3RvbUVsZW1lbnQsXG4gICAgICAgICAgICAgIGRlbGltaXRlcnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21waWxlck9wdGlvbnNcbiAgICAgICAgICApLFxuICAgICAgICAgIGNvbXBvbmVudENvbXBpbGVyT3B0aW9uc1xuICAgICAgICApO1xuICAgICAgICBDb21wb25lbnQucmVuZGVyID0gY29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxDb21waWxlck9wdGlvbnMpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2UucmVuZGVyID0gQ29tcG9uZW50LnJlbmRlciB8fCBOT09QO1xuICAgIGlmIChpbnN0YWxsV2l0aFByb3h5KSB7XG4gICAgICBpbnN0YWxsV2l0aFByb3h5KGluc3RhbmNlKTtcbiAgICB9XG4gIH1cbiAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgdHJ1ZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgdHJ5IHtcbiAgICAgIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFDb21wb25lbnQucmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCAmJiAhaXNTU1IpIHtcbiAgICBpZiAoIWNvbXBpbGUgJiYgQ29tcG9uZW50LnRlbXBsYXRlKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBDb21wb25lbnQgcHJvdmlkZWQgdGVtcGxhdGUgb3B0aW9uIGJ1dCBydW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArIChgIENvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gYWxpYXMgXCJ2dWVcIiB0byBcInZ1ZS9kaXN0L3Z1ZS5lc20tYnVuZGxlci5qc1wiLmAgKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybiQxKGBDb21wb25lbnQgaXMgbWlzc2luZyB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb246IGAsIENvbXBvbmVudCk7XG4gICAgfVxuICB9XG59XG5jb25zdCBhdHRyc1Byb3h5SGFuZGxlcnMgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8ge1xuICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgIHRyYWNrKHRhcmdldCwgXCJnZXRcIiwgXCJcIik7XG4gICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICB9LFxuICBzZXQoKSB7XG4gICAgd2FybiQxKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICB3YXJuJDEoYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0gOiB7XG4gIGdldCh0YXJnZXQsIGtleSkge1xuICAgIHRyYWNrKHRhcmdldCwgXCJnZXRcIiwgXCJcIik7XG4gICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0U2xvdHNQcm94eShpbnN0YW5jZSkge1xuICByZXR1cm4gbmV3IFByb3h5KGluc3RhbmNlLnNsb3RzLCB7XG4gICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiwgXCIkc2xvdHNcIik7XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCBleHBvc2UgPSAoZXhwb3NlZCkgPT4ge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgICAgICB3YXJuJDEoYGV4cG9zZSgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBzZXR1cCgpLmApO1xuICAgICAgfVxuICAgICAgaWYgKGV4cG9zZWQgIT0gbnVsbCkge1xuICAgICAgICBsZXQgZXhwb3NlZFR5cGUgPSB0eXBlb2YgZXhwb3NlZDtcbiAgICAgICAgaWYgKGV4cG9zZWRUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoZXhwb3NlZCkpIHtcbiAgICAgICAgICAgIGV4cG9zZWRUeXBlID0gXCJhcnJheVwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNSZWYoZXhwb3NlZCkpIHtcbiAgICAgICAgICAgIGV4cG9zZWRUeXBlID0gXCJyZWZcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9zZWRUeXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYGV4cG9zZSgpIHNob3VsZCBiZSBwYXNzZWQgYSBwbGFpbiBvYmplY3QsIHJlY2VpdmVkICR7ZXhwb3NlZFR5cGV9LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLmV4cG9zZWQgPSBleHBvc2VkIHx8IHt9O1xuICB9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGxldCBhdHRyc1Byb3h5O1xuICAgIGxldCBzbG90c1Byb3h5O1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgIGdldCBhdHRycygpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJzUHJveHkgfHwgKGF0dHJzUHJveHkgPSBuZXcgUHJveHkoaW5zdGFuY2UuYXR0cnMsIGF0dHJzUHJveHlIYW5kbGVycykpO1xuICAgICAgfSxcbiAgICAgIGdldCBzbG90cygpIHtcbiAgICAgICAgcmV0dXJuIHNsb3RzUHJveHkgfHwgKHNsb3RzUHJveHkgPSBnZXRTbG90c1Byb3h5KGluc3RhbmNlKSk7XG4gICAgICB9LFxuICAgICAgZ2V0IGVtaXQoKSB7XG4gICAgICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IGluc3RhbmNlLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGV4cG9zZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBhdHRyczogbmV3IFByb3h5KGluc3RhbmNlLmF0dHJzLCBhdHRyc1Byb3h5SGFuZGxlcnMpLFxuICAgICAgc2xvdHM6IGluc3RhbmNlLnNsb3RzLFxuICAgICAgZW1pdDogaW5zdGFuY2UuZW1pdCxcbiAgICAgIGV4cG9zZVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLmV4cG9zZVByb3h5IHx8IChpbnN0YW5jZS5leHBvc2VQcm94eSA9IG5ldyBQcm94eShwcm94eVJlZnMobWFya1JhdyhpbnN0YW5jZS5leHBvc2VkKSksIHtcbiAgICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgaW4gcHVibGljUHJvcGVydGllc01hcCkge1xuICAgICAgICAgIHJldHVybiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGFzKHRhcmdldCwga2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgaW4gdGFyZ2V0IHx8IGtleSBpbiBwdWJsaWNQcm9wZXJ0aWVzTWFwO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW5zdGFuY2UucHJveHk7XG4gIH1cbn1cbmNvbnN0IGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG5jb25zdCBjbGFzc2lmeSA9IChzdHIpID0+IHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIChjKSA9PiBjLnRvVXBwZXJDYXNlKCkpLnJlcGxhY2UoL1stX10vZywgXCJcIik7XG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCwgaW5jbHVkZUluZmVycmVkID0gdHJ1ZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbihDb21wb25lbnQpID8gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIDogQ29tcG9uZW50Lm5hbWUgfHwgaW5jbHVkZUluZmVycmVkICYmIENvbXBvbmVudC5fX25hbWU7XG59XG5mdW5jdGlvbiBmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBDb21wb25lbnQsIGlzUm9vdCA9IGZhbHNlKSB7XG4gIGxldCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpO1xuICBpZiAoIW5hbWUgJiYgQ29tcG9uZW50Ll9fZmlsZSkge1xuICAgIGNvbnN0IG1hdGNoID0gQ29tcG9uZW50Ll9fZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC5cXHcrJC8pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgbmFtZSA9IG1hdGNoWzFdO1xuICAgIH1cbiAgfVxuICBpZiAoIW5hbWUgJiYgaW5zdGFuY2UgJiYgaW5zdGFuY2UucGFyZW50KSB7XG4gICAgY29uc3QgaW5mZXJGcm9tUmVnaXN0cnkgPSAocmVnaXN0cnkpID0+IHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlZ2lzdHJ5KSB7XG4gICAgICAgIGlmIChyZWdpc3RyeVtrZXldID09PSBDb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBuYW1lID0gaW5mZXJGcm9tUmVnaXN0cnkoXG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRzIHx8IGluc3RhbmNlLnBhcmVudC50eXBlLmNvbXBvbmVudHNcbiAgICApIHx8IGluZmVyRnJvbVJlZ2lzdHJ5KGluc3RhbmNlLmFwcENvbnRleHQuY29tcG9uZW50cyk7XG4gIH1cbiAgcmV0dXJuIG5hbWUgPyBjbGFzc2lmeShuYW1lKSA6IGlzUm9vdCA/IGBBcHBgIDogYEFub255bW91c2A7XG59XG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KHZhbHVlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSAmJiBcIl9fdmNjT3B0c1wiIGluIHZhbHVlO1xufVxuXG5jb25zdCBjb21wdXRlZCA9IChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucykgPT4ge1xuICBjb25zdCBjID0gY29tcHV0ZWQkMShnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucywgaXNJblNTUkNvbXBvbmVudFNldHVwKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgaWYgKGkgJiYgaS5hcHBDb250ZXh0LmNvbmZpZy53YXJuUmVjdXJzaXZlQ29tcHV0ZWQpIHtcbiAgICAgIGMuX3dhcm5SZWN1cnNpdmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYztcbn07XG5cbmZ1bmN0aW9uIHVzZVRlbXBsYXRlUmVmKGtleSkge1xuICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGNvbnN0IHIgPSBzaGFsbG93UmVmKG51bGwpO1xuICBpZiAoaSkge1xuICAgIGNvbnN0IHJlZnMgPSBpLnJlZnMgPT09IEVNUFRZX09CSiA/IGkucmVmcyA9IHt9IDogaS5yZWZzO1xuICAgIGxldCBkZXNjO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIChkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyZWZzLCBrZXkpKSAmJiAhZGVzYy5jb25maWd1cmFibGUpIHtcbiAgICAgIHdhcm4kMShgdXNlVGVtcGxhdGVSZWYoJyR7a2V5fScpIGFscmVhZHkgZXhpc3RzLmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVmcywga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gci52YWx1ZSxcbiAgICAgICAgc2V0OiAodmFsKSA9PiByLnZhbHVlID0gdmFsXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShcbiAgICAgIGB1c2VUZW1wbGF0ZVJlZigpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLmBcbiAgICApO1xuICB9XG4gIHJldHVybiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gcmVhZG9ubHkocikgOiByO1xufVxuXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pIHtcbiAgY29uc3QgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmIChsID09PSAyKSB7XG4gICAgaWYgKGlzT2JqZWN0KHByb3BzT3JDaGlsZHJlbikgJiYgIWlzQXJyYXkocHJvcHNPckNoaWxkcmVuKSkge1xuICAgICAgaWYgKGlzVk5vZGUocHJvcHNPckNoaWxkcmVuKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgW3Byb3BzT3JDaGlsZHJlbl0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBwcm9wc09yQ2hpbGRyZW4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAobCA+IDMpIHtcbiAgICAgIGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB9IGVsc2UgaWYgKGwgPT09IDMgJiYgaXNWTm9kZShjaGlsZHJlbikpIHtcbiAgICAgIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDdXN0b21Gb3JtYXR0ZXIoKSB7XG4gIGlmICghISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHZ1ZVN0eWxlID0geyBzdHlsZTogXCJjb2xvcjojM2JhNzc2XCIgfTtcbiAgY29uc3QgbnVtYmVyU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiMxNjc3ZmZcIiB9O1xuICBjb25zdCBzdHJpbmdTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6I2Y1MjIyZFwiIH07XG4gIGNvbnN0IGtleXdvcmRTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6I2ViMmY5NlwiIH07XG4gIGNvbnN0IGZvcm1hdHRlciA9IHtcbiAgICBfX3Z1ZV9jdXN0b21fZm9ybWF0dGVyOiB0cnVlLFxuICAgIGhlYWRlcihvYmopIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChvYmouX19pc1Z1ZSkge1xuICAgICAgICByZXR1cm4gW1wiZGl2XCIsIHZ1ZVN0eWxlLCBgVnVlSW5zdGFuY2VgXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWYob2JqKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgZ2VuUmVmRmxhZyhvYmopXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICAvLyBhdm9pZCBkZWJ1Z2dlciBhY2Nlc3NpbmcgdmFsdWUgYWZmZWN0aW5nIGJlaGF2aW9yXG4gICAgICAgICAgZm9ybWF0VmFsdWUoXCJfdmFsdWVcIiBpbiBvYmogPyBvYmouX3ZhbHVlIDogb2JqKSxcbiAgICAgICAgICBgPmBcbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWFjdGl2ZShvYmopKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBbXCJzcGFuXCIsIHZ1ZVN0eWxlLCBpc1NoYWxsb3cob2JqKSA/IFwiU2hhbGxvd1JlYWN0aXZlXCIgOiBcIlJlYWN0aXZlXCJdLFxuICAgICAgICAgIFwiPFwiLFxuICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXG4gICAgICAgICAgYD4ke2lzUmVhZG9ubHkob2JqKSA/IGAgKHJlYWRvbmx5KWAgOiBgYH1gXG4gICAgICAgIF07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhZG9ubHkob2JqKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyBcIlNoYWxsb3dSZWFkb25seVwiIDogXCJSZWFkb25seVwiXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxuICAgICAgICAgIFwiPlwiXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGhhc0JvZHkob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2lzVnVlO1xuICAgIH0sXG4gICAgYm9keShvYmopIHtcbiAgICAgIGlmIChvYmogJiYgb2JqLl9faXNWdWUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIC4uLmZvcm1hdEluc3RhbmNlKG9iai4kKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZm9ybWF0SW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBibG9ja3MgPSBbXTtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5wcm9wcyAmJiBpbnN0YW5jZS5wcm9wcykge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcInByb3BzXCIsIHRvUmF3KGluc3RhbmNlLnByb3BzKSkpO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2Uuc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwic2V0dXBcIiwgaW5zdGFuY2Uuc2V0dXBTdGF0ZSkpO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2UuZGF0YSAhPT0gRU1QVFlfT0JKKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwiZGF0YVwiLCB0b1JhdyhpbnN0YW5jZS5kYXRhKSkpO1xuICAgIH1cbiAgICBjb25zdCBjb21wdXRlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCBcImNvbXB1dGVkXCIpO1xuICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcImNvbXB1dGVkXCIsIGNvbXB1dGVkKSk7XG4gICAgfVxuICAgIGNvbnN0IGluamVjdGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsIFwiaW5qZWN0XCIpO1xuICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcImluamVjdGVkXCIsIGluamVjdGVkKSk7XG4gICAgfVxuICAgIGJsb2Nrcy5wdXNoKFtcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7fSxcbiAgICAgIFtcbiAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZToga2V5d29yZFN0eWxlLnN0eWxlICsgXCI7b3BhY2l0eTowLjY2XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCIkIChpbnRlcm5hbCk6IFwiXG4gICAgICBdLFxuICAgICAgW1wib2JqZWN0XCIsIHsgb2JqZWN0OiBpbnN0YW5jZSB9XVxuICAgIF0pO1xuICAgIHJldHVybiBibG9ja3M7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VCbG9jayh0eXBlLCB0YXJnZXQpIHtcbiAgICB0YXJnZXQgPSBleHRlbmQoe30sIHRhcmdldCk7XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0YXJnZXQpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwge31dO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgXCJkaXZcIixcbiAgICAgIHsgc3R5bGU6IFwibGluZS1oZWlnaHQ6MS4yNWVtO21hcmdpbi1ib3R0b206MC42ZW1cIiB9LFxuICAgICAgW1xuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IFwiY29sb3I6IzQ3NjU4MlwiXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGVcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZTogXCJwYWRkaW5nLWxlZnQ6MS4yNWVtXCJcbiAgICAgICAgfSxcbiAgICAgICAgLi4uT2JqZWN0LmtleXModGFyZ2V0KS5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBbXCJzcGFuXCIsIGtleXdvcmRTdHlsZSwga2V5ICsgXCI6IFwiXSxcbiAgICAgICAgICAgIGZvcm1hdFZhbHVlKHRhcmdldFtrZXldLCBmYWxzZSlcbiAgICAgICAgICBdO1xuICAgICAgICB9KVxuICAgICAgXVxuICAgIF07XG4gIH1cbiAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodiwgYXNSYXcgPSB0cnVlKSB7XG4gICAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCBudW1iZXJTdHlsZSwgdl07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwgc3RyaW5nU3R5bGUsIEpTT04uc3RyaW5naWZ5KHYpXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwga2V5d29yZFN0eWxlLCB2XTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHYpKSB7XG4gICAgICByZXR1cm4gW1wib2JqZWN0XCIsIHsgb2JqZWN0OiBhc1JhdyA/IHRvUmF3KHYpIDogdiB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwgc3RyaW5nU3R5bGUsIFN0cmluZyh2KV07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGV4dHJhY3RLZXlzKGluc3RhbmNlLCB0eXBlKSB7XG4gICAgY29uc3QgQ29tcCA9IGluc3RhbmNlLnR5cGU7XG4gICAgaWYgKGlzRnVuY3Rpb24oQ29tcCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXh0cmFjdGVkID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UuY3R4KSB7XG4gICAgICBpZiAoaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSkge1xuICAgICAgICBleHRyYWN0ZWRba2V5XSA9IGluc3RhbmNlLmN0eFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXh0cmFjdGVkO1xuICB9XG4gIGZ1bmN0aW9uIGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkge1xuICAgIGNvbnN0IG9wdHMgPSBDb21wW3R5cGVdO1xuICAgIGlmIChpc0FycmF5KG9wdHMpICYmIG9wdHMuaW5jbHVkZXMoa2V5KSB8fCBpc09iamVjdChvcHRzKSAmJiBrZXkgaW4gb3B0cykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChDb21wLmV4dGVuZHMgJiYgaXNLZXlPZlR5cGUoQ29tcC5leHRlbmRzLCBrZXksIHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKENvbXAubWl4aW5zICYmIENvbXAubWl4aW5zLnNvbWUoKG0pID0+IGlzS2V5T2ZUeXBlKG0sIGtleSwgdHlwZSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2VuUmVmRmxhZyh2KSB7XG4gICAgaWYgKGlzU2hhbGxvdyh2KSkge1xuICAgICAgcmV0dXJuIGBTaGFsbG93UmVmYDtcbiAgICB9XG4gICAgaWYgKHYuZWZmZWN0KSB7XG4gICAgICByZXR1cm4gYENvbXB1dGVkUmVmYDtcbiAgICB9XG4gICAgcmV0dXJuIGBSZWZgO1xuICB9XG4gIGlmICh3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzKSB7XG4gICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlcik7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycyA9IFtmb3JtYXR0ZXJdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdpdGhNZW1vKG1lbW8sIHJlbmRlciwgY2FjaGUsIGluZGV4KSB7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2luZGV4XTtcbiAgaWYgKGNhY2hlZCAmJiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IHJldCA9IHJlbmRlcigpO1xuICByZXQubWVtbyA9IG1lbW8uc2xpY2UoKTtcbiAgcmV0LmNhY2hlSW5kZXggPSBpbmRleDtcbiAgcmV0dXJuIGNhY2hlW2luZGV4XSA9IHJldDtcbn1cbmZ1bmN0aW9uIGlzTWVtb1NhbWUoY2FjaGVkLCBtZW1vKSB7XG4gIGNvbnN0IHByZXYgPSBjYWNoZWQubWVtbztcbiAgaWYgKHByZXYubGVuZ3RoICE9IG1lbW8ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChoYXNDaGFuZ2VkKHByZXZbaV0sIG1lbW9baV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIGN1cnJlbnRCbG9jaykge1xuICAgIGN1cnJlbnRCbG9jay5wdXNoKGNhY2hlZCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmNvbnN0IHZlcnNpb24gPSBcIjMuNS4wLWJldGEuM1wiO1xuY29uc3Qgd2FybiA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB3YXJuJDEgOiBOT09QO1xuY29uc3QgRXJyb3JUeXBlU3RyaW5ncyA9IEVycm9yVHlwZVN0cmluZ3MkMSA7XG5jb25zdCBkZXZ0b29scyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgdHJ1ZSA/IGRldnRvb2xzJDEgOiB2b2lkIDA7XG5jb25zdCBzZXREZXZ0b29sc0hvb2sgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IHRydWUgPyBzZXREZXZ0b29sc0hvb2skMSA6IE5PT1A7XG5jb25zdCBfc3NyVXRpbHMgPSB7XG4gIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlLFxuICBzZXR1cENvbXBvbmVudCxcbiAgcmVuZGVyQ29tcG9uZW50Um9vdCxcbiAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlLFxuICBpc1ZOb2RlOiBpc1ZOb2RlLFxuICBub3JtYWxpemVWTm9kZSxcbiAgZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2UsXG4gIGVuc3VyZVZhbGlkVk5vZGVcbn07XG5jb25zdCBzc3JVdGlscyA9IF9zc3JVdGlscyA7XG5jb25zdCByZXNvbHZlRmlsdGVyID0gbnVsbDtcbmNvbnN0IGNvbXBhdFV0aWxzID0gbnVsbDtcbmNvbnN0IERlcHJlY2F0aW9uVHlwZXMgPSBudWxsO1xuXG5leHBvcnQgeyBCYXNlVHJhbnNpdGlvbiwgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIENvbW1lbnQsIERlcHJlY2F0aW9uVHlwZXMsIEVycm9yQ29kZXMsIEVycm9yVHlwZVN0cmluZ3MsIEZyYWdtZW50LCBLZWVwQWxpdmUsIFN0YXRpYywgU3VzcGVuc2UsIFRlbGVwb3J0LCBUZXh0LCBhc3NlcnROdW1iZXIsIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nLCBjYWxsV2l0aEVycm9ySGFuZGxpbmcsIGNsb25lVk5vZGUsIGNvbXBhdFV0aWxzLCBjb21wdXRlZCwgY3JlYXRlQmxvY2ssIGNyZWF0ZUNvbW1lbnRWTm9kZSwgY3JlYXRlRWxlbWVudEJsb2NrLCBjcmVhdGVCYXNlVk5vZGUgYXMgY3JlYXRlRWxlbWVudFZOb2RlLCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciwgY3JlYXRlUHJvcHNSZXN0UHJveHksIGNyZWF0ZVJlbmRlcmVyLCBjcmVhdGVTbG90cywgY3JlYXRlU3RhdGljVk5vZGUsIGNyZWF0ZVRleHRWTm9kZSwgY3JlYXRlVk5vZGUsIGRlZmluZUFzeW5jQ29tcG9uZW50LCBkZWZpbmVDb21wb25lbnQsIGRlZmluZUVtaXRzLCBkZWZpbmVFeHBvc2UsIGRlZmluZU1vZGVsLCBkZWZpbmVPcHRpb25zLCBkZWZpbmVQcm9wcywgZGVmaW5lU2xvdHMsIGRldnRvb2xzLCBnZXRDdXJyZW50SW5zdGFuY2UsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgZ3VhcmRSZWFjdGl2ZVByb3BzLCBoLCBoYW5kbGVFcnJvciwgaGFzSW5qZWN0aW9uQ29udGV4dCwgaHlkcmF0ZU9uSWRsZSwgaHlkcmF0ZU9uSW50ZXJhY3Rpb24sIGh5ZHJhdGVPbk1lZGlhUXVlcnksIGh5ZHJhdGVPblZpc2libGUsIGluaXRDdXN0b21Gb3JtYXR0ZXIsIGluamVjdCwgaXNNZW1vU2FtZSwgaXNSdW50aW1lT25seSwgaXNWTm9kZSwgbWVyZ2VEZWZhdWx0cywgbWVyZ2VNb2RlbHMsIG1lcmdlUHJvcHMsIG5leHRUaWNrLCBvbkFjdGl2YXRlZCwgb25CZWZvcmVNb3VudCwgb25CZWZvcmVVbm1vdW50LCBvbkJlZm9yZVVwZGF0ZSwgb25EZWFjdGl2YXRlZCwgb25FcnJvckNhcHR1cmVkLCBvbk1vdW50ZWQsIG9uUmVuZGVyVHJhY2tlZCwgb25SZW5kZXJUcmlnZ2VyZWQsIG9uU2VydmVyUHJlZmV0Y2gsIG9uVW5tb3VudGVkLCBvblVwZGF0ZWQsIG9wZW5CbG9jaywgcG9wU2NvcGVJZCwgcHJvdmlkZSwgcHVzaFNjb3BlSWQsIHF1ZXVlUG9zdEZsdXNoQ2IsIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyLCByZW5kZXJMaXN0LCByZW5kZXJTbG90LCByZXNvbHZlQ29tcG9uZW50LCByZXNvbHZlRGlyZWN0aXZlLCByZXNvbHZlRHluYW1pY0NvbXBvbmVudCwgcmVzb2x2ZUZpbHRlciwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgc2V0QmxvY2tUcmFja2luZywgc2V0RGV2dG9vbHNIb29rLCBzZXRUcmFuc2l0aW9uSG9va3MsIHNzckNvbnRleHRLZXksIHNzclV0aWxzLCB0b0hhbmRsZXJzLCB0cmFuc2Zvcm1WTm9kZUFyZ3MsIHVzZUF0dHJzLCB1c2VJZCwgdXNlTW9kZWwsIHVzZVNTUkNvbnRleHQsIHVzZVNsb3RzLCB1c2VUZW1wbGF0ZVJlZiwgdXNlVHJhbnNpdGlvblN0YXRlLCB2ZXJzaW9uLCB3YXJuLCB3YXRjaCwgd2F0Y2hFZmZlY3QsIHdhdGNoUG9zdEVmZmVjdCwgd2F0Y2hTeW5jRWZmZWN0LCB3aXRoQXN5bmNDb250ZXh0LCB3aXRoQ3R4LCB3aXRoRGVmYXVsdHMsIHdpdGhEaXJlY3RpdmVzLCB3aXRoTWVtbywgd2l0aFNjb3BlSWQgfTtcbiIsIi8qKlxuKiBAdnVlL3NoYXJlZCB2My41LjAtYmV0YS4zXG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtYWtlTWFwKHN0ciwgZXhwZWN0c0xvd2VyQ2FzZSkge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KHN0ci5zcGxpdChcIixcIikpO1xuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/ICh2YWwpID0+IHNldC5oYXModmFsLnRvTG93ZXJDYXNlKCkpIDogKHZhbCkgPT4gc2V0Lmhhcyh2YWwpO1xufVxuXG5jb25zdCBFTVBUWV9PQkogPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiB7fTtcbmNvbnN0IEVNUFRZX0FSUiA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xuY29uc3QgTk9PUCA9ICgpID0+IHtcbn07XG5jb25zdCBOTyA9ICgpID0+IGZhbHNlO1xuY29uc3QgaXNPbiA9IChrZXkpID0+IGtleS5jaGFyQ29kZUF0KDApID09PSAxMTEgJiYga2V5LmNoYXJDb2RlQXQoMSkgPT09IDExMCAmJiAvLyB1cHBlcmNhc2UgbGV0dGVyXG4oa2V5LmNoYXJDb2RlQXQoMikgPiAxMjIgfHwga2V5LmNoYXJDb2RlQXQoMikgPCA5Nyk7XG5jb25zdCBpc01vZGVsTGlzdGVuZXIgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aChcIm9uVXBkYXRlOlwiKTtcbmNvbnN0IGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XG5jb25zdCByZW1vdmUgPSAoYXJyLCBlbCkgPT4ge1xuICBjb25zdCBpID0gYXJyLmluZGV4T2YoZWwpO1xuICBpZiAoaSA+IC0xKSB7XG4gICAgYXJyLnNwbGljZShpLCAxKTtcbiAgfVxufTtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGhhc093biA9ICh2YWwsIGtleSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmNvbnN0IGlzTWFwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBNYXBdXCI7XG5jb25zdCBpc1NldCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgU2V0XVwiO1xuY29uc3QgaXNEYXRlID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBEYXRlXVwiO1xuY29uc3QgaXNSZWdFeHAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBpc1N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCI7XG5jb25zdCBpc1N5bWJvbCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3ltYm9sXCI7XG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiO1xuY29uc3QgaXNQcm9taXNlID0gKHZhbCkgPT4ge1xuICByZXR1cm4gKGlzT2JqZWN0KHZhbCkgfHwgaXNGdW5jdGlvbih2YWwpKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XG59O1xuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgdG9UeXBlU3RyaW5nID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbmNvbnN0IHRvUmF3VHlwZSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XG59O1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuY29uc3QgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJiBrZXkgIT09IFwiTmFOXCIgJiYga2V5WzBdICE9PSBcIi1cIiAmJiBcIlwiICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcm9wID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIC8vIHRoZSBsZWFkaW5nIGNvbW1hIGlzIGludGVudGlvbmFsIHNvIGVtcHR5IHN0cmluZyBcIlwiIGlzIGFsc28gaW5jbHVkZWRcbiAgXCIsa2V5LHJlZixyZWZfZm9yLHJlZl9rZXksb25Wbm9kZUJlZm9yZU1vdW50LG9uVm5vZGVNb3VudGVkLG9uVm5vZGVCZWZvcmVVcGRhdGUsb25Wbm9kZVVwZGF0ZWQsb25Wbm9kZUJlZm9yZVVubW91bnQsb25Wbm9kZVVubW91bnRlZFwiXG4pO1xuY29uc3QgaXNCdWlsdEluRGlyZWN0aXZlID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIFwiYmluZCxjbG9hayxlbHNlLWlmLGVsc2UsZm9yLGh0bWwsaWYsbW9kZWwsb24sb25jZSxwcmUsc2hvdyxzbG90LHRleHQsbWVtb1wiXG4pO1xuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKHN0cikgPT4ge1xuICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICB9O1xufTtcbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXG4gIChzdHIpID0+IHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IGMgPyBjLnRvVXBwZXJDYXNlKCkgOiBcIlwiKTtcbiAgfVxuKTtcbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbmNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXG4gIChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpXG4pO1xuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufSk7XG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiB7XG4gICAgY29uc3QgcyA9IHN0ciA/IGBvbiR7Y2FwaXRhbGl6ZShzdHIpfWAgOiBgYDtcbiAgICByZXR1cm4gcztcbiAgfVxuKTtcbmNvbnN0IGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiAhT2JqZWN0LmlzKHZhbHVlLCBvbGRWYWx1ZSk7XG5jb25zdCBpbnZva2VBcnJheUZucyA9IChmbnMsIC4uLmFyZykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGZuc1tpXSguLi5hcmcpO1xuICB9XG59O1xuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSwgd3JpdGFibGUgPSBmYWxzZSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGUsXG4gICAgdmFsdWVcbiAgfSk7XG59O1xuY29uc3QgbG9vc2VUb051bWJlciA9ICh2YWwpID0+IHtcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5jb25zdCB0b051bWJlciA9ICh2YWwpID0+IHtcbiAgY29uc3QgbiA9IGlzU3RyaW5nKHZhbCkgPyBOdW1iZXIodmFsKSA6IE5hTjtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5sZXQgX2dsb2JhbFRoaXM7XG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xuICByZXR1cm4gX2dsb2JhbFRoaXMgfHwgKF9nbG9iYWxUaGlzID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSk7XG59O1xuY29uc3QgaWRlbnRSRSA9IC9eW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bXyRhLXpBLVowLTlcXHhBMC1cXHVGRkZGXSokLztcbmZ1bmN0aW9uIGdlblByb3BzQWNjZXNzRXhwKG5hbWUpIHtcbiAgcmV0dXJuIGlkZW50UkUudGVzdChuYW1lKSA/IGBfX3Byb3BzLiR7bmFtZX1gIDogYF9fcHJvcHNbJHtKU09OLnN0cmluZ2lmeShuYW1lKX1dYDtcbn1cblxuY29uc3QgUGF0Y2hGbGFncyA9IHtcbiAgXCJURVhUXCI6IDEsXG4gIFwiMVwiOiBcIlRFWFRcIixcbiAgXCJDTEFTU1wiOiAyLFxuICBcIjJcIjogXCJDTEFTU1wiLFxuICBcIlNUWUxFXCI6IDQsXG4gIFwiNFwiOiBcIlNUWUxFXCIsXG4gIFwiUFJPUFNcIjogOCxcbiAgXCI4XCI6IFwiUFJPUFNcIixcbiAgXCJGVUxMX1BST1BTXCI6IDE2LFxuICBcIjE2XCI6IFwiRlVMTF9QUk9QU1wiLFxuICBcIk5FRURfSFlEUkFUSU9OXCI6IDMyLFxuICBcIjMyXCI6IFwiTkVFRF9IWURSQVRJT05cIixcbiAgXCJTVEFCTEVfRlJBR01FTlRcIjogNjQsXG4gIFwiNjRcIjogXCJTVEFCTEVfRlJBR01FTlRcIixcbiAgXCJLRVlFRF9GUkFHTUVOVFwiOiAxMjgsXG4gIFwiMTI4XCI6IFwiS0VZRURfRlJBR01FTlRcIixcbiAgXCJVTktFWUVEX0ZSQUdNRU5UXCI6IDI1NixcbiAgXCIyNTZcIjogXCJVTktFWUVEX0ZSQUdNRU5UXCIsXG4gIFwiTkVFRF9QQVRDSFwiOiA1MTIsXG4gIFwiNTEyXCI6IFwiTkVFRF9QQVRDSFwiLFxuICBcIkRZTkFNSUNfU0xPVFNcIjogMTAyNCxcbiAgXCIxMDI0XCI6IFwiRFlOQU1JQ19TTE9UU1wiLFxuICBcIkRFVl9ST09UX0ZSQUdNRU5UXCI6IDIwNDgsXG4gIFwiMjA0OFwiOiBcIkRFVl9ST09UX0ZSQUdNRU5UXCIsXG4gIFwiQ0FDSEVEXCI6IC0xLFxuICBcIi0xXCI6IFwiQ0FDSEVEXCIsXG4gIFwiQkFJTFwiOiAtMixcbiAgXCItMlwiOiBcIkJBSUxcIlxufTtcbmNvbnN0IFBhdGNoRmxhZ05hbWVzID0ge1xuICBbMV06IGBURVhUYCxcbiAgWzJdOiBgQ0xBU1NgLFxuICBbNF06IGBTVFlMRWAsXG4gIFs4XTogYFBST1BTYCxcbiAgWzE2XTogYEZVTExfUFJPUFNgLFxuICBbMzJdOiBgTkVFRF9IWURSQVRJT05gLFxuICBbNjRdOiBgU1RBQkxFX0ZSQUdNRU5UYCxcbiAgWzEyOF06IGBLRVlFRF9GUkFHTUVOVGAsXG4gIFsyNTZdOiBgVU5LRVlFRF9GUkFHTUVOVGAsXG4gIFs1MTJdOiBgTkVFRF9QQVRDSGAsXG4gIFsxMDI0XTogYERZTkFNSUNfU0xPVFNgLFxuICBbMjA0OF06IGBERVZfUk9PVF9GUkFHTUVOVGAsXG4gIFstMV06IGBIT0lTVEVEYCxcbiAgWy0yXTogYEJBSUxgXG59O1xuXG5jb25zdCBTaGFwZUZsYWdzID0ge1xuICBcIkVMRU1FTlRcIjogMSxcbiAgXCIxXCI6IFwiRUxFTUVOVFwiLFxuICBcIkZVTkNUSU9OQUxfQ09NUE9ORU5UXCI6IDIsXG4gIFwiMlwiOiBcIkZVTkNUSU9OQUxfQ09NUE9ORU5UXCIsXG4gIFwiU1RBVEVGVUxfQ09NUE9ORU5UXCI6IDQsXG4gIFwiNFwiOiBcIlNUQVRFRlVMX0NPTVBPTkVOVFwiLFxuICBcIlRFWFRfQ0hJTERSRU5cIjogOCxcbiAgXCI4XCI6IFwiVEVYVF9DSElMRFJFTlwiLFxuICBcIkFSUkFZX0NISUxEUkVOXCI6IDE2LFxuICBcIjE2XCI6IFwiQVJSQVlfQ0hJTERSRU5cIixcbiAgXCJTTE9UU19DSElMRFJFTlwiOiAzMixcbiAgXCIzMlwiOiBcIlNMT1RTX0NISUxEUkVOXCIsXG4gIFwiVEVMRVBPUlRcIjogNjQsXG4gIFwiNjRcIjogXCJURUxFUE9SVFwiLFxuICBcIlNVU1BFTlNFXCI6IDEyOCxcbiAgXCIxMjhcIjogXCJTVVNQRU5TRVwiLFxuICBcIkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRVwiOiAyNTYsXG4gIFwiMjU2XCI6IFwiQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFXCIsXG4gIFwiQ09NUE9ORU5UX0tFUFRfQUxJVkVcIjogNTEyLFxuICBcIjUxMlwiOiBcIkNPTVBPTkVOVF9LRVBUX0FMSVZFXCIsXG4gIFwiQ09NUE9ORU5UXCI6IDYsXG4gIFwiNlwiOiBcIkNPTVBPTkVOVFwiXG59O1xuXG5jb25zdCBTbG90RmxhZ3MgPSB7XG4gIFwiU1RBQkxFXCI6IDEsXG4gIFwiMVwiOiBcIlNUQUJMRVwiLFxuICBcIkRZTkFNSUNcIjogMixcbiAgXCIyXCI6IFwiRFlOQU1JQ1wiLFxuICBcIkZPUldBUkRFRFwiOiAzLFxuICBcIjNcIjogXCJGT1JXQVJERURcIlxufTtcbmNvbnN0IHNsb3RGbGFnc1RleHQgPSB7XG4gIFsxXTogXCJTVEFCTEVcIixcbiAgWzJdOiBcIkRZTkFNSUNcIixcbiAgWzNdOiBcIkZPUldBUkRFRFwiXG59O1xuXG5jb25zdCBHTE9CQUxTX0FMTE9XRUQgPSBcIkluZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCxjb25zb2xlLEVycm9yLFN5bWJvbFwiO1xuY29uc3QgaXNHbG9iYWxseUFsbG93ZWQgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChHTE9CQUxTX0FMTE9XRUQpO1xuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gaXNHbG9iYWxseUFsbG93ZWQ7XG5cbmNvbnN0IHJhbmdlID0gMjtcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XG4gIHN0YXJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc3RhcnQsIHNvdXJjZS5sZW5ndGgpKTtcbiAgZW5kID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZW5kLCBzb3VyY2UubGVuZ3RoKSk7XG4gIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFwiXCI7XG4gIGxldCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvKFxccj9cXG4pLyk7XG4gIGNvbnN0IG5ld2xpbmVTZXF1ZW5jZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMSk7XG4gIGxpbmVzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDApO1xuICBsZXQgY291bnQgPSAwO1xuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIChuZXdsaW5lU2VxdWVuY2VzW2ldICYmIG5ld2xpbmVTZXF1ZW5jZXNbaV0ubGVuZ3RoIHx8IDApO1xuICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XG4gICAgICAgIHJlcy5wdXNoKFxuICAgICAgICAgIGAke2xpbmV9JHtcIiBcIi5yZXBlYXQoTWF0aC5tYXgoMyAtIFN0cmluZyhsaW5lKS5sZW5ndGgsIDApKX18ICAke2xpbmVzW2pdfWBcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmV3TGluZVNlcUxlbmd0aCA9IG5ld2xpbmVTZXF1ZW5jZXNbal0gJiYgbmV3bGluZVNlcXVlbmNlc1tqXS5sZW5ndGggfHwgMDtcbiAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIChsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aCkpO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIFwiIFwiLnJlcGVhdChwYWQpICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xuICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gaXNTdHJpbmcoaXRlbSkgPyBwYXJzZVN0cmluZ1N0eWxlKGl0ZW0pIDogbm9ybWFsaXplU3R5bGUoaXRlbSk7XG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XG4gICAgICAgICAgcmVzW2tleV0gPSBub3JtYWxpemVkW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5jb25zdCBsaXN0RGVsaW1pdGVyUkUgPSAvOyg/IVteKF0qXFwpKS9nO1xuY29uc3QgcHJvcGVydHlEZWxpbWl0ZXJSRSA9IC86KFteXSspLztcbmNvbnN0IHN0eWxlQ29tbWVudFJFID0gL1xcL1xcKlteXSo/XFwqXFwvL2c7XG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGNzc1RleHQucmVwbGFjZShzdHlsZUNvbW1lbnRSRSwgXCJcIikuc3BsaXQobGlzdERlbGltaXRlclJFKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xuICBsZXQgcmV0ID0gXCJcIjtcbiAgaWYgKCFzdHlsZXMgfHwgaXNTdHJpbmcoc3R5bGVzKSkge1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XG4gICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XG4gIGxldCByZXMgPSBcIlwiO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmVzID0gdmFsdWU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgcmVzICs9IG5vcm1hbGl6ZWQgKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWVbbmFtZV0pIHtcbiAgICAgICAgcmVzICs9IG5hbWUgKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy50cmltKCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhwcm9wcykge1xuICBpZiAoIXByb3BzKSByZXR1cm4gbnVsbDtcbiAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XG4gICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gIH1cbiAgaWYgKHN0eWxlKSB7XG4gICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BzO1xufVxuXG5jb25zdCBIVE1MX1RBR1MgPSBcImh0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGhncm91cCxoMSxoMixoMyxoNCxoNSxoNixuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSxzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290XCI7XG5jb25zdCBTVkdfVEFHUyA9IFwic3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLGRlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCxmZURpc3RhbnRMaWdodCxmZURyb3BTaGFkb3csZmVGbG9vZCxmZUZ1bmNBLGZlRnVuY0IsZmVGdW5jRyxmZUZ1bmNSLGZlR2F1c3NpYW5CbHVyLGZlSW1hZ2UsZmVNZXJnZSxmZU1lcmdlTm9kZSxmZU1vcnBob2xvZ3ksZmVPZmZzZXQsZmVQb2ludExpZ2h0LGZlU3BlY3VsYXJMaWdodGluZyxmZVNwb3RMaWdodCxmZVRpbGUsZmVUdXJidWxlbmNlLGZpbHRlcixmb3JlaWduT2JqZWN0LGcsaGF0Y2gsaGF0Y2hwYXRoLGltYWdlLGxpbmUsbGluZWFyR3JhZGllbnQsbWFya2VyLG1hc2ssbWVzaCxtZXNoZ3JhZGllbnQsbWVzaHBhdGNoLG1lc2hyb3csbWV0YWRhdGEsbXBhdGgscGF0aCxwYXR0ZXJuLHBvbHlnb24scG9seWxpbmUscmFkaWFsR3JhZGllbnQscmVjdCxzZXQsc29saWRjb2xvcixzdG9wLHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0UGF0aCx0aXRsZSx0c3Bhbix1bmtub3duLHVzZSx2aWV3XCI7XG5jb25zdCBNQVRIX1RBR1MgPSBcImFubm90YXRpb24sYW5ub3RhdGlvbi14bWwsbWFjdGlvbixtYWxpZ25ncm91cCxtYWxpZ25tYXJrLG1hdGgsbWVuY2xvc2UsbWVycm9yLG1mZW5jZWQsbWZyYWMsbWZyYWN0aW9uLG1nbHlwaCxtaSxtbGFiZWxlZHRyLG1sb25nZGl2LG1tdWx0aXNjcmlwdHMsbW4sbW8sbW92ZXIsbXBhZGRlZCxtcGhhbnRvbSxtcHJlc2NyaXB0cyxtcm9vdCxtcm93LG1zLG1zY2Fycmllcyxtc2NhcnJ5LG1zZ3JvdXAsbXNsaW5lLG1zcGFjZSxtc3FydCxtc3Jvdyxtc3RhY2ssbXN0eWxlLG1zdWIsbXN1YnN1cCxtc3VwLG10YWJsZSxtdGQsbXRleHQsbXRyLG11bmRlcixtdW5kZXJvdmVyLG5vbmUsc2VtYW50aWNzXCI7XG5jb25zdCBWT0lEX1RBR1MgPSBcImFyZWEsYmFzZSxicixjb2wsZW1iZWQsaHIsaW1nLGlucHV0LGxpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyXCI7XG5jb25zdCBpc0hUTUxUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChIVE1MX1RBR1MpO1xuY29uc3QgaXNTVkdUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChTVkdfVEFHUyk7XG5jb25zdCBpc01hdGhNTFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKE1BVEhfVEFHUyk7XG5jb25zdCBpc1ZvaWRUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xuXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBzcGVjaWFsQm9vbGVhbkF0dHJzICsgYCxhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY29udHJvbHMsZGVmYXVsdCxkZWZlcixkaXNhYmxlZCxoaWRkZW4saW5lcnQsbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYFxuKTtcbmZ1bmN0aW9uIGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJcIjtcbn1cbmNvbnN0IHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzU1NSU2FmZUF0dHJOYW1lKG5hbWUpIHtcbiAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcbiAgfVxuICBjb25zdCBpc1Vuc2FmZSA9IHVuc2FmZUF0dHJDaGFyUkUudGVzdChuYW1lKTtcbiAgaWYgKGlzVW5zYWZlKSB7XG4gICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XG4gIH1cbiAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmU7XG59XG5jb25zdCBwcm9wc1RvQXR0ck1hcCA9IHtcbiAgYWNjZXB0Q2hhcnNldDogXCJhY2NlcHQtY2hhcnNldFwiLFxuICBjbGFzc05hbWU6IFwiY2xhc3NcIixcbiAgaHRtbEZvcjogXCJmb3JcIixcbiAgaHR0cEVxdWl2OiBcImh0dHAtZXF1aXZcIlxufTtcbmNvbnN0IGlzS25vd25IdG1sQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgYWNjZXB0LGFjY2VwdC1jaGFyc2V0LGFjY2Vzc2tleSxhY3Rpb24sYWxpZ24sYWxsb3csYWx0LGFzeW5jLGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSxhdXRvZm9jdXMsYXV0b3BsYXksYmFja2dyb3VuZCxiZ2NvbG9yLGJvcmRlcixidWZmZXJlZCxjYXB0dXJlLGNoYWxsZW5nZSxjaGFyc2V0LGNoZWNrZWQsY2l0ZSxjbGFzcyxjb2RlLGNvZGViYXNlLGNvbG9yLGNvbHMsY29sc3Bhbixjb250ZW50LGNvbnRlbnRlZGl0YWJsZSxjb250ZXh0bWVudSxjb250cm9scyxjb29yZHMsY3Jvc3NvcmlnaW4sY3NwLGRhdGEsZGF0ZXRpbWUsZGVjb2RpbmcsZGVmYXVsdCxkZWZlcixkaXIsZGlybmFtZSxkaXNhYmxlZCxkb3dubG9hZCxkcmFnZ2FibGUsZHJvcHpvbmUsZW5jdHlwZSxlbnRlcmtleWhpbnQsZm9yLGZvcm0sZm9ybWFjdGlvbixmb3JtZW5jdHlwZSxmb3JtbWV0aG9kLGZvcm1ub3ZhbGlkYXRlLGZvcm10YXJnZXQsaGVhZGVycyxoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LGljb24saWQsaW1wb3J0YW5jZSxpbmVydCxpbnRlZ3JpdHksaXNtYXAsaXRlbXByb3Asa2V5dHlwZSxraW5kLGxhYmVsLGxhbmcsbGFuZ3VhZ2UsbG9hZGluZyxsaXN0LGxvb3AsbG93LG1hbmlmZXN0LG1heCxtYXhsZW5ndGgsbWlubGVuZ3RoLG1lZGlhLG1pbixtdWx0aXBsZSxtdXRlZCxuYW1lLG5vdmFsaWRhdGUsb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIscHJlbG9hZCxyYWRpb2dyb3VwLHJlYWRvbmx5LHJlZmVycmVycG9saWN5LHJlbCxyZXF1aXJlZCxyZXZlcnNlZCxyb3dzLHJvd3NwYW4sc2FuZGJveCxzY29wZSxzY29wZWQsc2VsZWN0ZWQsc2hhcGUsc2l6ZSxzaXplcyxzbG90LHNwYW4sc3BlbGxjaGVjayxzcmMsc3JjZG9jLHNyY2xhbmcsc3Jjc2V0LHN0YXJ0LHN0ZXAsc3R5bGUsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLHZhbHVlLHdpZHRoLHdyYXBgXG4pO1xuY29uc3QgaXNLbm93blN2Z0F0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYHhtbG5zLGFjY2VudC1oZWlnaHQsYWNjdW11bGF0ZSxhZGRpdGl2ZSxhbGlnbm1lbnQtYmFzZWxpbmUsYWxwaGFiZXRpYyxhbXBsaXR1ZGUsYXJhYmljLWZvcm0sYXNjZW50LGF0dHJpYnV0ZU5hbWUsYXR0cmlidXRlVHlwZSxhemltdXRoLGJhc2VGcmVxdWVuY3ksYmFzZWxpbmUtc2hpZnQsYmFzZVByb2ZpbGUsYmJveCxiZWdpbixiaWFzLGJ5LGNhbGNNb2RlLGNhcC1oZWlnaHQsY2xhc3MsY2xpcCxjbGlwUGF0aFVuaXRzLGNsaXAtcGF0aCxjbGlwLXJ1bGUsY29sb3IsY29sb3ItaW50ZXJwb2xhdGlvbixjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMsY29sb3ItcHJvZmlsZSxjb2xvci1yZW5kZXJpbmcsY29udGVudFNjcmlwdFR5cGUsY29udGVudFN0eWxlVHlwZSxjcm9zc29yaWdpbixjdXJzb3IsY3gsY3ksZCxkZWNlbGVyYXRlLGRlc2NlbnQsZGlmZnVzZUNvbnN0YW50LGRpcmVjdGlvbixkaXNwbGF5LGRpdmlzb3IsZG9taW5hbnQtYmFzZWxpbmUsZHVyLGR4LGR5LGVkZ2VNb2RlLGVsZXZhdGlvbixlbmFibGUtYmFja2dyb3VuZCxlbmQsZXhwb25lbnQsZmlsbCxmaWxsLW9wYWNpdHksZmlsbC1ydWxlLGZpbHRlcixmaWx0ZXJSZXMsZmlsdGVyVW5pdHMsZmxvb2QtY29sb3IsZmxvb2Qtb3BhY2l0eSxmb250LWZhbWlseSxmb250LXNpemUsZm9udC1zaXplLWFkanVzdCxmb250LXN0cmV0Y2gsZm9udC1zdHlsZSxmb250LXZhcmlhbnQsZm9udC13ZWlnaHQsZm9ybWF0LGZyb20sZnIsZngsZnksZzEsZzIsZ2x5cGgtbmFtZSxnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsLGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsLGdseXBoUmVmLGdyYWRpZW50VHJhbnNmb3JtLGdyYWRpZW50VW5pdHMsaGFuZ2luZyxoZWlnaHQsaHJlZixocmVmbGFuZyxob3Jpei1hZHYteCxob3Jpei1vcmlnaW4teCxpZCxpZGVvZ3JhcGhpYyxpbWFnZS1yZW5kZXJpbmcsaW4saW4yLGludGVyY2VwdCxrLGsxLGsyLGszLGs0LGtlcm5lbE1hdHJpeCxrZXJuZWxVbml0TGVuZ3RoLGtlcm5pbmcsa2V5UG9pbnRzLGtleVNwbGluZXMsa2V5VGltZXMsbGFuZyxsZW5ndGhBZGp1c3QsbGV0dGVyLXNwYWNpbmcsbGlnaHRpbmctY29sb3IsbGltaXRpbmdDb25lQW5nbGUsbG9jYWwsbWFya2VyLWVuZCxtYXJrZXItbWlkLG1hcmtlci1zdGFydCxtYXJrZXJIZWlnaHQsbWFya2VyVW5pdHMsbWFya2VyV2lkdGgsbWFzayxtYXNrQ29udGVudFVuaXRzLG1hc2tVbml0cyxtYXRoZW1hdGljYWwsbWF4LG1lZGlhLG1ldGhvZCxtaW4sbW9kZSxuYW1lLG51bU9jdGF2ZXMsb2Zmc2V0LG9wYWNpdHksb3BlcmF0b3Isb3JkZXIsb3JpZW50LG9yaWVudGF0aW9uLG9yaWdpbixvdmVyZmxvdyxvdmVybGluZS1wb3NpdGlvbixvdmVybGluZS10aGlja25lc3MscGFub3NlLTEscGFpbnQtb3JkZXIscGF0aCxwYXRoTGVuZ3RoLHBhdHRlcm5Db250ZW50VW5pdHMscGF0dGVyblRyYW5zZm9ybSxwYXR0ZXJuVW5pdHMscGluZyxwb2ludGVyLWV2ZW50cyxwb2ludHMscG9pbnRzQXRYLHBvaW50c0F0WSxwb2ludHNBdFoscHJlc2VydmVBbHBoYSxwcmVzZXJ2ZUFzcGVjdFJhdGlvLHByaW1pdGl2ZVVuaXRzLHIscmFkaXVzLHJlZmVycmVyUG9saWN5LHJlZlgscmVmWSxyZWwscmVuZGVyaW5nLWludGVudCxyZXBlYXRDb3VudCxyZXBlYXREdXIscmVxdWlyZWRFeHRlbnNpb25zLHJlcXVpcmVkRmVhdHVyZXMscmVzdGFydCxyZXN1bHQscm90YXRlLHJ4LHJ5LHNjYWxlLHNlZWQsc2hhcGUtcmVuZGVyaW5nLHNsb3BlLHNwYWNpbmcsc3BlY3VsYXJDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LHNwZWVkLHNwcmVhZE1ldGhvZCxzdGFydE9mZnNldCxzdGREZXZpYXRpb24sc3RlbWgsc3RlbXYsc3RpdGNoVGlsZXMsc3RvcC1jb2xvcixzdG9wLW9wYWNpdHksc3RyaWtldGhyb3VnaC1wb3NpdGlvbixzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyxzdHJpbmcsc3Ryb2tlLHN0cm9rZS1kYXNoYXJyYXksc3Ryb2tlLWRhc2hvZmZzZXQsc3Ryb2tlLWxpbmVjYXAsc3Ryb2tlLWxpbmVqb2luLHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aCxzdHlsZSxzdXJmYWNlU2NhbGUsc3lzdGVtTGFuZ3VhZ2UsdGFiaW5kZXgsdGFibGVWYWx1ZXMsdGFyZ2V0LHRhcmdldFgsdGFyZ2V0WSx0ZXh0LWFuY2hvcix0ZXh0LWRlY29yYXRpb24sdGV4dC1yZW5kZXJpbmcsdGV4dExlbmd0aCx0byx0cmFuc2Zvcm0sdHJhbnNmb3JtLW9yaWdpbix0eXBlLHUxLHUyLHVuZGVybGluZS1wb3NpdGlvbix1bmRlcmxpbmUtdGhpY2tuZXNzLHVuaWNvZGUsdW5pY29kZS1iaWRpLHVuaWNvZGUtcmFuZ2UsdW5pdHMtcGVyLWVtLHYtYWxwaGFiZXRpYyx2LWhhbmdpbmcsdi1pZGVvZ3JhcGhpYyx2LW1hdGhlbWF0aWNhbCx2YWx1ZXMsdmVjdG9yLWVmZmVjdCx2ZXJzaW9uLHZlcnQtYWR2LXksdmVydC1vcmlnaW4teCx2ZXJ0LW9yaWdpbi15LHZpZXdCb3gsdmlld1RhcmdldCx2aXNpYmlsaXR5LHdpZHRoLHdpZHRocyx3b3JkLXNwYWNpbmcsd3JpdGluZy1tb2RlLHgseC1oZWlnaHQseDEseDIseENoYW5uZWxTZWxlY3Rvcix4bGluazphY3R1YXRlLHhsaW5rOmFyY3JvbGUseGxpbms6aHJlZix4bGluazpyb2xlLHhsaW5rOnNob3cseGxpbms6dGl0bGUseGxpbms6dHlwZSx4bWxuczp4bGluayx4bWw6YmFzZSx4bWw6bGFuZyx4bWw6c3BhY2UseSx5MSx5Mix5Q2hhbm5lbFNlbGVjdG9yLHosem9vbUFuZFBhbmBcbik7XG5mdW5jdGlvbiBpc1JlbmRlcmFibGVBdHRyVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIjtcbn1cblxuY29uc3QgZXNjYXBlUkUgPSAvW1wiJyY8Pl0vO1xuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgY29uc3Qgc3RyID0gXCJcIiArIHN0cmluZztcbiAgY29uc3QgbWF0Y2ggPSBlc2NhcGVSRS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGxldCBodG1sID0gXCJcIjtcbiAgbGV0IGVzY2FwZWQ7XG4gIGxldCBpbmRleDtcbiAgbGV0IGxhc3RJbmRleCA9IDA7XG4gIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgIGNhc2UgMzQ6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZxdW90O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZhbXA7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOTpcbiAgICAgICAgZXNjYXBlZCA9IFwiJiMzOTtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYwOlxuICAgICAgICBlc2NhcGVkID0gXCImbHQ7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmd0O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCk7XG4gICAgfVxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICBodG1sICs9IGVzY2FwZWQ7XG4gIH1cbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbmNvbnN0IGNvbW1lbnRTdHJpcFJFID0gL14tPz58PCEtLXwtLT58LS0hPnw8IS0kL2c7XG5mdW5jdGlvbiBlc2NhcGVIdG1sQ29tbWVudChzcmMpIHtcbiAgcmV0dXJuIHNyYy5yZXBsYWNlKGNvbW1lbnRTdHJpcFJFLCBcIlwiKTtcbn1cblxuZnVuY3Rpb24gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBsZXQgZXF1YWwgPSB0cnVlO1xuICBmb3IgKGxldCBpID0gMDsgZXF1YWwgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBlcXVhbCA9IGxvb3NlRXF1YWwoYVtpXSwgYltpXSk7XG4gIH1cbiAgcmV0dXJuIGVxdWFsO1xufVxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgbGV0IGFWYWxpZFR5cGUgPSBpc0RhdGUoYSk7XG4gIGxldCBiVmFsaWRUeXBlID0gaXNEYXRlKGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc1N5bWJvbChhKTtcbiAgYlZhbGlkVHlwZSA9IGlzU3ltYm9sKGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzQXJyYXkoYSk7XG4gIGJWYWxpZFR5cGUgPSBpc0FycmF5KGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSA6IGZhbHNlO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc09iamVjdChhKTtcbiAgYlZhbGlkVHlwZSA9IGlzT2JqZWN0KGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgaWYgKCFhVmFsaWRUeXBlIHx8ICFiVmFsaWRUeXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XG4gICAgY29uc3QgYktleXNDb3VudCA9IE9iamVjdC5rZXlzKGIpLmxlbmd0aDtcbiAgICBpZiAoYUtleXNDb3VudCAhPT0gYktleXNDb3VudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgICBjb25zdCBhSGFzS2V5ID0gYS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgY29uc3QgYkhhc0tleSA9IGIuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGlmIChhSGFzS2V5ICYmICFiSGFzS2V5IHx8ICFhSGFzS2V5ICYmIGJIYXNLZXkgfHwgIWxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xufVxuZnVuY3Rpb24gbG9vc2VJbmRleE9mKGFyciwgdmFsKSB7XG4gIHJldHVybiBhcnIuZmluZEluZGV4KChpdGVtKSA9PiBsb29zZUVxdWFsKGl0ZW0sIHZhbCkpO1xufVxuXG5jb25zdCBpc1JlZiA9ICh2YWwpID0+IHtcbiAgcmV0dXJuICEhKHZhbCAmJiB2YWxbXCJfX3ZfaXNSZWZcIl0gPT09IHRydWUpO1xufTtcbmNvbnN0IHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIGlzU3RyaW5nKHZhbCkgPyB2YWwgOiB2YWwgPT0gbnVsbCA/IFwiXCIgOiBpc0FycmF5KHZhbCkgfHwgaXNPYmplY3QodmFsKSAmJiAodmFsLnRvU3RyaW5nID09PSBvYmplY3RUb1N0cmluZyB8fCAhaXNGdW5jdGlvbih2YWwudG9TdHJpbmcpKSA/IGlzUmVmKHZhbCkgPyB0b0Rpc3BsYXlTdHJpbmcodmFsLnZhbHVlKSA6IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpIDogU3RyaW5nKHZhbCk7XG59O1xuY29uc3QgcmVwbGFjZXIgPSAoX2tleSwgdmFsKSA9PiB7XG4gIGlmIChpc1JlZih2YWwpKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VyKF9rZXksIHZhbC52YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBbYE1hcCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC5lbnRyaWVzKCldLnJlZHVjZShcbiAgICAgICAgKGVudHJpZXMsIFtrZXksIHZhbDJdLCBpKSA9PiB7XG4gICAgICAgICAgZW50cmllc1tzdHJpbmdpZnlTeW1ib2woa2V5LCBpKSArIFwiID0+XCJdID0gdmFsMjtcbiAgICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICAgICAgfSxcbiAgICAgICAge31cbiAgICAgIClcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW2BTZXQoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwudmFsdWVzKCldLm1hcCgodikgPT4gc3RyaW5naWZ5U3ltYm9sKHYpKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNTeW1ib2wodmFsKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlTeW1ib2wodmFsKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpICYmICFpc0FycmF5KHZhbCkgJiYgIWlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgIHJldHVybiBTdHJpbmcodmFsKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcbmNvbnN0IHN0cmluZ2lmeVN5bWJvbCA9ICh2LCBpID0gXCJcIikgPT4ge1xuICB2YXIgX2E7XG4gIHJldHVybiAoXG4gICAgLy8gU3ltYm9sLmRlc2NyaXB0aW9uIGluIGVzMjAxOSsgc28gd2UgbmVlZCB0byBjYXN0IGhlcmUgdG8gcGFzc1xuICAgIC8vIHRoZSBsaWI6IGVzMjAxNiBjaGVja1xuICAgIGlzU3ltYm9sKHYpID8gYFN5bWJvbCgkeyhfYSA9IHYuZGVzY3JpcHRpb24pICE9IG51bGwgPyBfYSA6IGl9KWAgOiB2XG4gICk7XG59O1xuXG5leHBvcnQgeyBFTVBUWV9BUlIsIEVNUFRZX09CSiwgTk8sIE5PT1AsIFBhdGNoRmxhZ05hbWVzLCBQYXRjaEZsYWdzLCBTaGFwZUZsYWdzLCBTbG90RmxhZ3MsIGNhbWVsaXplLCBjYXBpdGFsaXplLCBkZWYsIGVzY2FwZUh0bWwsIGVzY2FwZUh0bWxDb21tZW50LCBleHRlbmQsIGdlblByb3BzQWNjZXNzRXhwLCBnZW5lcmF0ZUNvZGVGcmFtZSwgZ2V0R2xvYmFsVGhpcywgaGFzQ2hhbmdlZCwgaGFzT3duLCBoeXBoZW5hdGUsIGluY2x1ZGVCb29sZWFuQXR0ciwgaW52b2tlQXJyYXlGbnMsIGlzQXJyYXksIGlzQm9vbGVhbkF0dHIsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaXNEYXRlLCBpc0Z1bmN0aW9uLCBpc0dsb2JhbGx5QWxsb3dlZCwgaXNHbG9iYWxseVdoaXRlbGlzdGVkLCBpc0hUTUxUYWcsIGlzSW50ZWdlcktleSwgaXNLbm93bkh0bWxBdHRyLCBpc0tub3duU3ZnQXR0ciwgaXNNYXAsIGlzTWF0aE1MVGFnLCBpc01vZGVsTGlzdGVuZXIsIGlzT2JqZWN0LCBpc09uLCBpc1BsYWluT2JqZWN0LCBpc1Byb21pc2UsIGlzUmVnRXhwLCBpc1JlbmRlcmFibGVBdHRyVmFsdWUsIGlzUmVzZXJ2ZWRQcm9wLCBpc1NTUlNhZmVBdHRyTmFtZSwgaXNTVkdUYWcsIGlzU2V0LCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNTdHJpbmcsIGlzU3ltYm9sLCBpc1ZvaWRUYWcsIGxvb3NlRXF1YWwsIGxvb3NlSW5kZXhPZiwgbG9vc2VUb051bWJlciwgbWFrZU1hcCwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgb2JqZWN0VG9TdHJpbmcsIHBhcnNlU3RyaW5nU3R5bGUsIHByb3BzVG9BdHRyTWFwLCByZW1vdmUsIHNsb3RGbGFnc1RleHQsIHN0cmluZ2lmeVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSwgdG9OdW1iZXIsIHRvUmF3VHlwZSwgdG9UeXBlU3RyaW5nIH07XG4iLCIvKipcbiogQHZ1ZS9ydW50aW1lLWRvbSB2My41LjAtYmV0YS4zXG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG5pbXBvcnQgeyB3YXJuLCBoLCBCYXNlVHJhbnNpdGlvbiwgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIGFzc2VydE51bWJlciwgZ2V0Q3VycmVudEluc3RhbmNlLCBvbkJlZm9yZU1vdW50LCB3YXRjaFBvc3RFZmZlY3QsIG9uTW91bnRlZCwgb25Vbm1vdW50ZWQsIEZyYWdtZW50LCBTdGF0aWMsIGNhbWVsaXplLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgZGVmaW5lQ29tcG9uZW50LCBuZXh0VGljaywgdW5yZWYsIGNyZWF0ZVZOb2RlLCB1c2VUcmFuc2l0aW9uU3RhdGUsIG9uVXBkYXRlZCwgdG9SYXcsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgc2V0VHJhbnNpdGlvbkhvb2tzLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBpc1J1bnRpbWVPbmx5LCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIgfSBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5pbXBvcnQgeyBleHRlbmQsIGlzT2JqZWN0LCB0b051bWJlciwgaXNBcnJheSwgaXNTdHJpbmcsIGh5cGhlbmF0ZSwgY2FwaXRhbGl6ZSwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpc1N5bWJvbCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzRnVuY3Rpb24sIE5PT1AsIGlzT24sIGlzTW9kZWxMaXN0ZW5lciwgaXNQbGFpbk9iamVjdCwgaGFzT3duLCBjYW1lbGl6ZSBhcyBjYW1lbGl6ZSQxLCBFTVBUWV9PQkosIGxvb3NlVG9OdW1iZXIsIGxvb3NlSW5kZXhPZiwgaXNTZXQsIGxvb3NlRXF1YWwsIGludm9rZUFycmF5Rm5zLCBpc0hUTUxUYWcsIGlzU1ZHVGFnLCBpc01hdGhNTFRhZyB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxubGV0IHBvbGljeSA9IHZvaWQgMDtcbmNvbnN0IHR0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cudHJ1c3RlZFR5cGVzO1xuaWYgKHR0KSB7XG4gIHRyeSB7XG4gICAgcG9saWN5ID0gLyogQF9fUFVSRV9fICovIHR0LmNyZWF0ZVBvbGljeShcInZ1ZVwiLCB7XG4gICAgICBjcmVhdGVIVE1MOiAodmFsKSA9PiB2YWxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgRXJyb3IgY3JlYXRpbmcgdHJ1c3RlZCB0eXBlcyBwb2xpY3k6ICR7ZX1gKTtcbiAgfVxufVxuY29uc3QgdW5zYWZlVG9UcnVzdGVkSFRNTCA9IHBvbGljeSA/ICh2YWwpID0+IHBvbGljeS5jcmVhdGVIVE1MKHZhbCkgOiAodmFsKSA9PiB2YWw7XG5jb25zdCBzdmdOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbmNvbnN0IG1hdGhtbE5TID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7XG5jb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IG51bGw7XG5jb25zdCB0ZW1wbGF0ZUNvbnRhaW5lciA9IGRvYyAmJiAvKiBAX19QVVJFX18gKi8gZG9jLmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbmNvbnN0IG5vZGVPcHMgPSB7XG4gIGluc2VydDogKGNoaWxkLCBwYXJlbnQsIGFuY2hvcikgPT4ge1xuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGFuY2hvciB8fCBudWxsKTtcbiAgfSxcbiAgcmVtb3ZlOiAoY2hpbGQpID0+IHtcbiAgICBjb25zdCBwYXJlbnQgPSBjaGlsZC5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9LFxuICBjcmVhdGVFbGVtZW50OiAodGFnLCBuYW1lc3BhY2UsIGlzLCBwcm9wcykgPT4ge1xuICAgIGNvbnN0IGVsID0gbmFtZXNwYWNlID09PSBcInN2Z1wiID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgdGFnKSA6IG5hbWVzcGFjZSA9PT0gXCJtYXRobWxcIiA/IGRvYy5jcmVhdGVFbGVtZW50TlMobWF0aG1sTlMsIHRhZykgOiBpcyA/IGRvYy5jcmVhdGVFbGVtZW50KHRhZywgeyBpcyB9KSA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKHRhZyA9PT0gXCJzZWxlY3RcIiAmJiBwcm9wcyAmJiBwcm9wcy5tdWx0aXBsZSAhPSBudWxsKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiLCBwcm9wcy5tdWx0aXBsZSk7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbiAgfSxcbiAgY3JlYXRlVGV4dDogKHRleHQpID0+IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSxcbiAgY3JlYXRlQ29tbWVudDogKHRleHQpID0+IGRvYy5jcmVhdGVDb21tZW50KHRleHQpLFxuICBzZXRUZXh0OiAobm9kZSwgdGV4dCkgPT4ge1xuICAgIG5vZGUubm9kZVZhbHVlID0gdGV4dDtcbiAgfSxcbiAgc2V0RWxlbWVudFRleHQ6IChlbCwgdGV4dCkgPT4ge1xuICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcbiAgfSxcbiAgcGFyZW50Tm9kZTogKG5vZGUpID0+IG5vZGUucGFyZW50Tm9kZSxcbiAgbmV4dFNpYmxpbmc6IChub2RlKSA9PiBub2RlLm5leHRTaWJsaW5nLFxuICBxdWVyeVNlbGVjdG9yOiAoc2VsZWN0b3IpID0+IGRvYy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSxcbiAgc2V0U2NvcGVJZChlbCwgaWQpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoaWQsIFwiXCIpO1xuICB9LFxuICAvLyBfX1VOU0FGRV9fXG4gIC8vIFJlYXNvbjogaW5uZXJIVE1MLlxuICAvLyBTdGF0aWMgY29udGVudCBoZXJlIGNhbiBvbmx5IGNvbWUgZnJvbSBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gIC8vIEFzIGxvbmcgYXMgdGhlIHVzZXIgb25seSB1c2VzIHRydXN0ZWQgdGVtcGxhdGVzLCB0aGlzIGlzIHNhZmUuXG4gIGluc2VydFN0YXRpY0NvbnRlbnQoY29udGVudCwgcGFyZW50LCBhbmNob3IsIG5hbWVzcGFjZSwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGJlZm9yZSA9IGFuY2hvciA/IGFuY2hvci5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkO1xuICAgIGlmIChzdGFydCAmJiAoc3RhcnQgPT09IGVuZCB8fCBzdGFydC5uZXh0U2libGluZykpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoc3RhcnQuY2xvbmVOb2RlKHRydWUpLCBhbmNob3IpO1xuICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCB8fCAhKHN0YXJ0ID0gc3RhcnQubmV4dFNpYmxpbmcpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGVtcGxhdGVDb250YWluZXIuaW5uZXJIVE1MID0gdW5zYWZlVG9UcnVzdGVkSFRNTChcbiAgICAgICAgbmFtZXNwYWNlID09PSBcInN2Z1wiID8gYDxzdmc+JHtjb250ZW50fTwvc3ZnPmAgOiBuYW1lc3BhY2UgPT09IFwibWF0aG1sXCIgPyBgPG1hdGg+JHtjb250ZW50fTwvbWF0aD5gIDogY29udGVudFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVDb250YWluZXIuY29udGVudDtcbiAgICAgIGlmIChuYW1lc3BhY2UgPT09IFwic3ZnXCIgfHwgbmFtZXNwYWNlID09PSBcIm1hdGhtbFwiKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0ZW1wbGF0ZS5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAod3JhcHBlci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgdGVtcGxhdGUuYXBwZW5kQ2hpbGQod3JhcHBlci5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wbGF0ZS5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGVtcGxhdGUsIGFuY2hvcik7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAvLyBmaXJzdFxuICAgICAgYmVmb3JlID8gYmVmb3JlLm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQsXG4gICAgICAvLyBsYXN0XG4gICAgICBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZFxuICAgIF07XG4gIH1cbn07XG5cbmNvbnN0IFRSQU5TSVRJT04gPSBcInRyYW5zaXRpb25cIjtcbmNvbnN0IEFOSU1BVElPTiA9IFwiYW5pbWF0aW9uXCI7XG5jb25zdCB2dGNLZXkgPSBTeW1ib2woXCJfdnRjXCIpO1xuY29uc3QgVHJhbnNpdGlvbiA9IChwcm9wcywgeyBzbG90cyB9KSA9PiBoKEJhc2VUcmFuc2l0aW9uLCByZXNvbHZlVHJhbnNpdGlvblByb3BzKHByb3BzKSwgc2xvdHMpO1xuVHJhbnNpdGlvbi5kaXNwbGF5TmFtZSA9IFwiVHJhbnNpdGlvblwiO1xuY29uc3QgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGNzczoge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogdHJ1ZVxuICB9LFxuICBkdXJhdGlvbjogW1N0cmluZywgTnVtYmVyLCBPYmplY3RdLFxuICBlbnRlckZyb21DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBhcHBlYXJGcm9tQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZUZyb21DbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nXG59O1xuY29uc3QgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IFRyYW5zaXRpb24ucHJvcHMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKFxuICB7fSxcbiAgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsXG4gIERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnNcbik7XG5jb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzID0gW10pID0+IHtcbiAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICBob29rLmZvckVhY2goKGgyKSA9PiBoMiguLi5hcmdzKSk7XG4gIH0gZWxzZSBpZiAoaG9vaykge1xuICAgIGhvb2soLi4uYXJncyk7XG4gIH1cbn07XG5jb25zdCBoYXNFeHBsaWNpdENhbGxiYWNrID0gKGhvb2spID0+IHtcbiAgcmV0dXJuIGhvb2sgPyBpc0FycmF5KGhvb2spID8gaG9vay5zb21lKChoMikgPT4gaDIubGVuZ3RoID4gMSkgOiBob29rLmxlbmd0aCA+IDEgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKSB7XG4gIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiByYXdQcm9wcykge1xuICAgIGlmICghKGtleSBpbiBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzKSkge1xuICAgICAgYmFzZVByb3BzW2tleV0gPSByYXdQcm9wc1trZXldO1xuICAgIH1cbiAgfVxuICBpZiAocmF3UHJvcHMuY3NzID09PSBmYWxzZSkge1xuICAgIHJldHVybiBiYXNlUHJvcHM7XG4gIH1cbiAgY29uc3Qge1xuICAgIG5hbWUgPSBcInZcIixcbiAgICB0eXBlLFxuICAgIGR1cmF0aW9uLFxuICAgIGVudGVyRnJvbUNsYXNzID0gYCR7bmFtZX0tZW50ZXItZnJvbWAsXG4gICAgZW50ZXJBY3RpdmVDbGFzcyA9IGAke25hbWV9LWVudGVyLWFjdGl2ZWAsXG4gICAgZW50ZXJUb0NsYXNzID0gYCR7bmFtZX0tZW50ZXItdG9gLFxuICAgIGFwcGVhckZyb21DbGFzcyA9IGVudGVyRnJvbUNsYXNzLFxuICAgIGFwcGVhckFjdGl2ZUNsYXNzID0gZW50ZXJBY3RpdmVDbGFzcyxcbiAgICBhcHBlYXJUb0NsYXNzID0gZW50ZXJUb0NsYXNzLFxuICAgIGxlYXZlRnJvbUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtZnJvbWAsXG4gICAgbGVhdmVBY3RpdmVDbGFzcyA9IGAke25hbWV9LWxlYXZlLWFjdGl2ZWAsXG4gICAgbGVhdmVUb0NsYXNzID0gYCR7bmFtZX0tbGVhdmUtdG9gXG4gIH0gPSByYXdQcm9wcztcbiAgY29uc3QgZHVyYXRpb25zID0gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pO1xuICBjb25zdCBlbnRlckR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1swXTtcbiAgY29uc3QgbGVhdmVEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMV07XG4gIGNvbnN0IHtcbiAgICBvbkJlZm9yZUVudGVyLFxuICAgIG9uRW50ZXIsXG4gICAgb25FbnRlckNhbmNlbGxlZCxcbiAgICBvbkxlYXZlLFxuICAgIG9uTGVhdmVDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVBcHBlYXIgPSBvbkJlZm9yZUVudGVyLFxuICAgIG9uQXBwZWFyID0gb25FbnRlcixcbiAgICBvbkFwcGVhckNhbmNlbGxlZCA9IG9uRW50ZXJDYW5jZWxsZWRcbiAgfSA9IGJhc2VQcm9wcztcbiAgY29uc3QgZmluaXNoRW50ZXIgPSAoZWwsIGlzQXBwZWFyLCBkb25lKSA9PiB7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJBY3RpdmVDbGFzcyA6IGVudGVyQWN0aXZlQ2xhc3MpO1xuICAgIGRvbmUgJiYgZG9uZSgpO1xuICB9O1xuICBjb25zdCBmaW5pc2hMZWF2ZSA9IChlbCwgZG9uZSkgPT4ge1xuICAgIGVsLl9pc0xlYXZpbmcgPSBmYWxzZTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICBkb25lICYmIGRvbmUoKTtcbiAgfTtcbiAgY29uc3QgbWFrZUVudGVySG9vayA9IChpc0FwcGVhcikgPT4ge1xuICAgIHJldHVybiAoZWwsIGRvbmUpID0+IHtcbiAgICAgIGNvbnN0IGhvb2sgPSBpc0FwcGVhciA/IG9uQXBwZWFyIDogb25FbnRlcjtcbiAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hFbnRlcihlbCwgaXNBcHBlYXIsIGRvbmUpO1xuICAgICAgY2FsbEhvb2soaG9vaywgW2VsLCByZXNvbHZlXSk7XG4gICAgICBuZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyRnJvbUNsYXNzIDogZW50ZXJGcm9tQ2xhc3MpO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcyk7XG4gICAgICAgIGlmICghaGFzRXhwbGljaXRDYWxsYmFjayhob29rKSkge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgZW50ZXJEdXJhdGlvbiwgcmVzb2x2ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG4gIHJldHVybiBleHRlbmQoYmFzZVByb3BzLCB7XG4gICAgb25CZWZvcmVFbnRlcihlbCkge1xuICAgICAgY2FsbEhvb2sob25CZWZvcmVFbnRlciwgW2VsXSk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyRnJvbUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJBY3RpdmVDbGFzcyk7XG4gICAgfSxcbiAgICBvbkJlZm9yZUFwcGVhcihlbCkge1xuICAgICAgY2FsbEhvb2sob25CZWZvcmVBcHBlYXIsIFtlbF0pO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhcHBlYXJGcm9tQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhcHBlYXJBY3RpdmVDbGFzcyk7XG4gICAgfSxcbiAgICBvbkVudGVyOiBtYWtlRW50ZXJIb29rKGZhbHNlKSxcbiAgICBvbkFwcGVhcjogbWFrZUVudGVySG9vayh0cnVlKSxcbiAgICBvbkxlYXZlKGVsLCBkb25lKSB7XG4gICAgICBlbC5faXNMZWF2aW5nID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hMZWF2ZShlbCwgZG9uZSk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBmb3JjZVJlZmxvdygpO1xuICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgaWYgKCFlbC5faXNMZWF2aW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIGlmICghaGFzRXhwbGljaXRDYWxsYmFjayhvbkxlYXZlKSkge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgbGVhdmVEdXJhdGlvbiwgcmVzb2x2ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2FsbEhvb2sob25MZWF2ZSwgW2VsLCByZXNvbHZlXSk7XG4gICAgfSxcbiAgICBvbkVudGVyQ2FuY2VsbGVkKGVsKSB7XG4gICAgICBmaW5pc2hFbnRlcihlbCwgZmFsc2UpO1xuICAgICAgY2FsbEhvb2sob25FbnRlckNhbmNlbGxlZCwgW2VsXSk7XG4gICAgfSxcbiAgICBvbkFwcGVhckNhbmNlbGxlZChlbCkge1xuICAgICAgZmluaXNoRW50ZXIoZWwsIHRydWUpO1xuICAgICAgY2FsbEhvb2sob25BcHBlYXJDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH0sXG4gICAgb25MZWF2ZUNhbmNlbGxlZChlbCkge1xuICAgICAgZmluaXNoTGVhdmUoZWwpO1xuICAgICAgY2FsbEhvb2sob25MZWF2ZUNhbmNlbGxlZCwgW2VsXSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKSB7XG4gIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZHVyYXRpb24pKSB7XG4gICAgcmV0dXJuIFtOdW1iZXJPZihkdXJhdGlvbi5lbnRlciksIE51bWJlck9mKGR1cmF0aW9uLmxlYXZlKV07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbiA9IE51bWJlck9mKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gW24sIG5dO1xuICB9XG59XG5mdW5jdGlvbiBOdW1iZXJPZih2YWwpIHtcbiAgY29uc3QgcmVzID0gdG9OdW1iZXIodmFsKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBhc3NlcnROdW1iZXIocmVzLCBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBkdXJhdGlvblwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBlbC5jbGFzc0xpc3QuYWRkKGMpKTtcbiAgKGVsW3Z0Y0tleV0gfHwgKGVsW3Z0Y0tleV0gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSkuYWRkKGNscyk7XG59XG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xuICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGVsLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xuICBjb25zdCBfdnRjID0gZWxbdnRjS2V5XTtcbiAgaWYgKF92dGMpIHtcbiAgICBfdnRjLmRlbGV0ZShjbHMpO1xuICAgIGlmICghX3Z0Yy5zaXplKSB7XG4gICAgICBlbFt2dGNLZXldID0gdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbmV4dEZyYW1lKGNiKSB7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKTtcbiAgfSk7XG59XG5sZXQgZW5kSWQgPSAwO1xuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzKGVsLCBleHBlY3RlZFR5cGUsIGV4cGxpY2l0VGltZW91dCwgcmVzb2x2ZSkge1xuICBjb25zdCBpZCA9IGVsLl9lbmRJZCA9ICsrZW5kSWQ7XG4gIGNvbnN0IHJlc29sdmVJZk5vdFN0YWxlID0gKCkgPT4ge1xuICAgIGlmIChpZCA9PT0gZWwuX2VuZElkKSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfVxuICB9O1xuICBpZiAoZXhwbGljaXRUaW1lb3V0KSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZUlmTm90U3RhbGUsIGV4cGxpY2l0VGltZW91dCk7XG4gIH1cbiAgY29uc3QgeyB0eXBlLCB0aW1lb3V0LCBwcm9wQ291bnQgfSA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICBpZiAoIXR5cGUpIHtcbiAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICB9XG4gIGNvbnN0IGVuZEV2ZW50ID0gdHlwZSArIFwiZW5kXCI7XG4gIGxldCBlbmRlZCA9IDA7XG4gIGNvbnN0IGVuZCA9ICgpID0+IHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XG4gICAgcmVzb2x2ZUlmTm90U3RhbGUoKTtcbiAgfTtcbiAgY29uc3Qgb25FbmQgPSAoZSkgPT4ge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwgJiYgKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSkge1xuICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIGNvbnN0IGdldFN0eWxlUHJvcGVydGllcyA9IChrZXkpID0+IChzdHlsZXNba2V5XSB8fCBcIlwiKS5zcGxpdChcIiwgXCIpO1xuICBjb25zdCB0cmFuc2l0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059RGVsYXlgKTtcbiAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfUR1cmF0aW9uYCk7XG4gIGNvbnN0IHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgY29uc3QgYW5pbWF0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke0FOSU1BVElPTn1EZWxheWApO1xuICBjb25zdCBhbmltYXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7QU5JTUFUSU9OfUR1cmF0aW9uYCk7XG4gIGNvbnN0IGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcbiAgbGV0IHR5cGUgPSBudWxsO1xuICBsZXQgdGltZW91dCA9IDA7XG4gIGxldCBwcm9wQ291bnQgPSAwO1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0ID8gVFJBTlNJVElPTiA6IEFOSU1BVElPTiA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZSA/IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aCA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGggOiAwO1xuICB9XG4gIGNvbnN0IGhhc1RyYW5zZm9ybSA9IHR5cGUgPT09IFRSQU5TSVRJT04gJiYgL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLy50ZXN0KFxuICAgIGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfVByb3BlcnR5YCkudG9TdHJpbmcoKVxuICApO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgdGltZW91dCxcbiAgICBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtXG4gIH07XG59XG5mdW5jdGlvbiBnZXRUaW1lb3V0KGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoLi4uZHVyYXRpb25zLm1hcCgoZCwgaSkgPT4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKSkpO1xufVxuZnVuY3Rpb24gdG9NcyhzKSB7XG4gIGlmIChzID09PSBcImF1dG9cIikgcmV0dXJuIDA7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZShcIixcIiwgXCIuXCIpKSAqIDFlMztcbn1cbmZ1bmN0aW9uIGZvcmNlUmVmbG93KCkge1xuICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIHBhdGNoQ2xhc3MoZWwsIHZhbHVlLCBpc1NWRykge1xuICBjb25zdCB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsW3Z0Y0tleV07XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHZhbHVlID0gKHZhbHVlID8gW3ZhbHVlLCAuLi50cmFuc2l0aW9uQ2xhc3Nlc10gOiBbLi4udHJhbnNpdGlvbkNsYXNzZXNdKS5qb2luKFwiIFwiKTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICB9IGVsc2UgaWYgKGlzU1ZHKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGVsLmNsYXNzTmFtZSA9IHZhbHVlO1xuICB9XG59XG5cbmNvbnN0IHZTaG93T3JpZ2luYWxEaXNwbGF5ID0gU3ltYm9sKFwiX3ZvZFwiKTtcbmNvbnN0IHZTaG93SGlkZGVuID0gU3ltYm9sKFwiX3ZzaFwiKTtcbmNvbnN0IHZTaG93ID0ge1xuICBiZWZvcmVNb3VudChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgIGVsW3ZTaG93T3JpZ2luYWxEaXNwbGF5XSA9IGVsLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcbiAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBtb3VudGVkKGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcbiAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgIH1cbiAgfSxcbiAgdXBkYXRlZChlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHJldHVybjtcbiAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICBzZXREaXNwbGF5KGVsLCB0cnVlKTtcbiAgICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2l0aW9uLmxlYXZlKGVsLCAoKSA9PiB7XG4gICAgICAgICAgc2V0RGlzcGxheShlbCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlVW5tb3VudChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICB9XG59O1xuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgdlNob3cubmFtZSA9IFwic2hvd1wiO1xufVxuZnVuY3Rpb24gc2V0RGlzcGxheShlbCwgdmFsdWUpIHtcbiAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWxbdlNob3dPcmlnaW5hbERpc3BsYXldIDogXCJub25lXCI7XG4gIGVsW3ZTaG93SGlkZGVuXSA9ICF2YWx1ZTtcbn1cbmZ1bmN0aW9uIGluaXRWU2hvd0ZvclNTUigpIHtcbiAgdlNob3cuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHsgc3R5bGU6IHsgZGlzcGxheTogXCJub25lXCIgfSB9O1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgQ1NTX1ZBUl9URVhUID0gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIkNTU19WQVJfVEVYVFwiIDogXCJcIik7XG5mdW5jdGlvbiB1c2VDc3NWYXJzKGdldHRlcikge1xuICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoIWluc3RhbmNlKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGB1c2VDc3NWYXJzIGlzIGNhbGxlZCB3aXRob3V0IGN1cnJlbnQgYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5gKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdXBkYXRlVGVsZXBvcnRzID0gaW5zdGFuY2UudXQgPSAodmFycyA9IGdldHRlcihpbnN0YW5jZS5wcm94eSkpID0+IHtcbiAgICBBcnJheS5mcm9tKFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtdi1vd25lcj1cIiR7aW5zdGFuY2UudWlkfVwiXWApXG4gICAgKS5mb3JFYWNoKChub2RlKSA9PiBzZXRWYXJzT25Ob2RlKG5vZGUsIHZhcnMpKTtcbiAgfTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbnN0YW5jZS5nZXRDc3NWYXJzID0gKCkgPT4gZ2V0dGVyKGluc3RhbmNlLnByb3h5KTtcbiAgfVxuICBjb25zdCBzZXRWYXJzID0gKCkgPT4ge1xuICAgIGNvbnN0IHZhcnMgPSBnZXR0ZXIoaW5zdGFuY2UucHJveHkpO1xuICAgIGlmIChpbnN0YW5jZS5jZSkge1xuICAgICAgc2V0VmFyc09uTm9kZShpbnN0YW5jZS5jZSwgdmFycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFZhcnNPblZOb2RlKGluc3RhbmNlLnN1YlRyZWUsIHZhcnMpO1xuICAgIH1cbiAgICB1cGRhdGVUZWxlcG9ydHModmFycyk7XG4gIH07XG4gIG9uQmVmb3JlTW91bnQoKCkgPT4ge1xuICAgIHdhdGNoUG9zdEVmZmVjdChzZXRWYXJzKTtcbiAgfSk7XG4gIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgY29uc3Qgb2IgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihzZXRWYXJzKTtcbiAgICBvYi5vYnNlcnZlKGluc3RhbmNlLnN1YlRyZWUuZWwucGFyZW50Tm9kZSwgeyBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgb25Vbm1vdW50ZWQoKCkgPT4gb2IuZGlzY29ubmVjdCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXRWYXJzT25WTm9kZSh2bm9kZSwgdmFycykge1xuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZTtcbiAgICB2bm9kZSA9IHN1c3BlbnNlLmFjdGl2ZUJyYW5jaDtcbiAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiAhc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCgoKSA9PiB7XG4gICAgICAgIHNldFZhcnNPblZOb2RlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgdmFycyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKHZub2RlLmNvbXBvbmVudCkge1xuICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50LnN1YlRyZWU7XG4gIH1cbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgJiYgdm5vZGUuZWwpIHtcbiAgICBzZXRWYXJzT25Ob2RlKHZub2RlLmVsLCB2YXJzKTtcbiAgfSBlbHNlIGlmICh2bm9kZS50eXBlID09PSBGcmFnbWVudCkge1xuICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goKGMpID0+IHNldFZhcnNPblZOb2RlKGMsIHZhcnMpKTtcbiAgfSBlbHNlIGlmICh2bm9kZS50eXBlID09PSBTdGF0aWMpIHtcbiAgICBsZXQgeyBlbCwgYW5jaG9yIH0gPSB2bm9kZTtcbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpO1xuICAgICAgaWYgKGVsID09PSBhbmNob3IpIGJyZWFrO1xuICAgICAgZWwgPSBlbC5uZXh0U2libGluZztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpIHtcbiAgaWYgKGVsLm5vZGVUeXBlID09PSAxKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICBsZXQgY3NzVGV4dCA9IFwiXCI7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFycykge1xuICAgICAgc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtrZXl9YCwgdmFyc1trZXldKTtcbiAgICAgIGNzc1RleHQgKz0gYC0tJHtrZXl9OiAke3ZhcnNba2V5XX07YDtcbiAgICB9XG4gICAgc3R5bGVbQ1NTX1ZBUl9URVhUXSA9IGNzc1RleHQ7XG4gIH1cbn1cblxuY29uc3QgZGlzcGxheVJFID0gLyhefDspXFxzKmRpc3BsYXlcXHMqOi87XG5mdW5jdGlvbiBwYXRjaFN0eWxlKGVsLCBwcmV2LCBuZXh0KSB7XG4gIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gIGNvbnN0IGlzQ3NzU3RyaW5nID0gaXNTdHJpbmcobmV4dCk7XG4gIGxldCBoYXNDb250cm9sbGVkRGlzcGxheSA9IGZhbHNlO1xuICBpZiAobmV4dCAmJiAhaXNDc3NTdHJpbmcpIHtcbiAgICBpZiAocHJldikge1xuICAgICAgaWYgKCFpc1N0cmluZyhwcmV2KSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgICAgICAgaWYgKG5leHRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJldlN0eWxlIG9mIHByZXYuc3BsaXQoXCI7XCIpKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gcHJldlN0eWxlLnNsaWNlKDAsIHByZXZTdHlsZS5pbmRleE9mKFwiOlwiKSkudHJpbSgpO1xuICAgICAgICAgIGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcbiAgICAgIGlmIChrZXkgPT09IFwiZGlzcGxheVwiKSB7XG4gICAgICAgIGhhc0NvbnRyb2xsZWREaXNwbGF5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksIG5leHRba2V5XSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0Nzc1N0cmluZykge1xuICAgICAgaWYgKHByZXYgIT09IG5leHQpIHtcbiAgICAgICAgY29uc3QgY3NzVmFyVGV4dCA9IHN0eWxlW0NTU19WQVJfVEVYVF07XG4gICAgICAgIGlmIChjc3NWYXJUZXh0KSB7XG4gICAgICAgICAgbmV4dCArPSBcIjtcIiArIGNzc1ZhclRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUuY3NzVGV4dCA9IG5leHQ7XG4gICAgICAgIGhhc0NvbnRyb2xsZWREaXNwbGF5ID0gZGlzcGxheVJFLnRlc3QobmV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcmV2KSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZTaG93T3JpZ2luYWxEaXNwbGF5IGluIGVsKSB7XG4gICAgZWxbdlNob3dPcmlnaW5hbERpc3BsYXldID0gaGFzQ29udHJvbGxlZERpc3BsYXkgPyBzdHlsZS5kaXNwbGF5IDogXCJcIjtcbiAgICBpZiAoZWxbdlNob3dIaWRkZW5dKSB7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxuICB9XG59XG5jb25zdCBzZW1pY29sb25SRSA9IC9bXlxcXFxdO1xccyokLztcbmNvbnN0IGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG5mdW5jdGlvbiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdmFsKSB7XG4gIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICB2YWwuZm9yRWFjaCgodikgPT4gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHYpKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID09IG51bGwpIHZhbCA9IFwiXCI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGlmIChzZW1pY29sb25SRS50ZXN0KHZhbCkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgVW5leHBlY3RlZCBzZW1pY29sb24gYXQgdGhlIGVuZCBvZiAnJHtuYW1lfScgc3R5bGUgdmFsdWU6ICcke3ZhbH0nYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiLS1cIikpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZWZpeGVkID0gYXV0b1ByZWZpeChzdHlsZSwgbmFtZSk7XG4gICAgICBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgICAgIHN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIGh5cGhlbmF0ZShwcmVmaXhlZCksXG4gICAgICAgICAgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsIFwiXCIpLFxuICAgICAgICAgIFwiaW1wb3J0YW50XCJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlW3ByZWZpeGVkXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IHByZWZpeGVzID0gW1wiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIl07XG5jb25zdCBwcmVmaXhDYWNoZSA9IHt9O1xuZnVuY3Rpb24gYXV0b1ByZWZpeChzdHlsZSwgcmF3TmFtZSkge1xuICBjb25zdCBjYWNoZWQgPSBwcmVmaXhDYWNoZVtyYXdOYW1lXTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgbGV0IG5hbWUgPSBjYW1lbGl6ZShyYXdOYW1lKTtcbiAgaWYgKG5hbWUgIT09IFwiZmlsdGVyXCIgJiYgbmFtZSBpbiBzdHlsZSkge1xuICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IG5hbWU7XG4gIH1cbiAgbmFtZSA9IGNhcGl0YWxpemUobmFtZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgbmFtZTtcbiAgICBpZiAocHJlZml4ZWQgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IHByZWZpeGVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmF3TmFtZTtcbn1cblxuY29uc3QgeGxpbmtOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiO1xuZnVuY3Rpb24gcGF0Y2hBdHRyKGVsLCBrZXksIHZhbHVlLCBpc1NWRywgaW5zdGFuY2UsIGlzQm9vbGVhbiA9IGlzU3BlY2lhbEJvb2xlYW5BdHRyKGtleSkpIHtcbiAgaWYgKGlzU1ZHICYmIGtleS5zdGFydHNXaXRoKFwieGxpbms6XCIpKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleS5zbGljZSg2LCBrZXkubGVuZ3RoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBpc0Jvb2xlYW4gJiYgIWluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXG4gICAgICAgIGtleSxcbiAgICAgICAgaXNCb29sZWFuID8gXCJcIiA6IGlzU3ltYm9sKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiB2YWx1ZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGF0Y2hET01Qcm9wKGVsLCBrZXksIHZhbHVlLCBwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKGtleSA9PT0gXCJpbm5lckhUTUxcIiB8fCBrZXkgPT09IFwidGV4dENvbnRlbnRcIikge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm47XG4gICAgZWxba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YWcgPSBlbC50YWdOYW1lO1xuICBpZiAoa2V5ID09PSBcInZhbHVlXCIgJiYgdGFnICE9PSBcIlBST0dSRVNTXCIgJiYgLy8gY3VzdG9tIGVsZW1lbnRzIG1heSB1c2UgX3ZhbHVlIGludGVybmFsbHlcbiAgIXRhZy5pbmNsdWRlcyhcIi1cIikpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhZyA9PT0gXCJPUFRJT05cIiA/IGVsLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpIHx8IFwiXCIgOiBlbC52YWx1ZTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyBcIlwiIDogU3RyaW5nKHZhbHVlKTtcbiAgICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlIHx8ICEoXCJfdmFsdWVcIiBpbiBlbCkpIHtcbiAgICAgIGVsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9XG4gICAgZWwuX3ZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBuZWVkUmVtb3ZlID0gZmFsc2U7XG4gIGlmICh2YWx1ZSA9PT0gXCJcIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBlbFtrZXldO1xuICAgIGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgdmFsdWUgPSBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCAmJiB0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICBuZWVkUmVtb3ZlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhbHVlID0gMDtcbiAgICAgIG5lZWRSZW1vdmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIGVsW2tleV0gPSB2YWx1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFuZWVkUmVtb3ZlKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRmFpbGVkIHNldHRpbmcgcHJvcCBcIiR7a2V5fVwiIG9uIDwke3RhZy50b0xvd2VyQ2FzZSgpfT46IHZhbHVlICR7dmFsdWV9IGlzIGludmFsaWQuYCxcbiAgICAgICAgZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgbmVlZFJlbW92ZSAmJiBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmNvbnN0IHZlaUtleSA9IFN5bWJvbChcIl92ZWlcIik7XG5mdW5jdGlvbiBwYXRjaEV2ZW50KGVsLCByYXdOYW1lLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgaW5zdGFuY2UgPSBudWxsKSB7XG4gIGNvbnN0IGludm9rZXJzID0gZWxbdmVpS2V5XSB8fCAoZWxbdmVpS2V5XSA9IHt9KTtcbiAgY29uc3QgZXhpc3RpbmdJbnZva2VyID0gaW52b2tlcnNbcmF3TmFtZV07XG4gIGlmIChuZXh0VmFsdWUgJiYgZXhpc3RpbmdJbnZva2VyKSB7XG4gICAgZXhpc3RpbmdJbnZva2VyLnZhbHVlID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNhbml0aXplRXZlbnRWYWx1ZShuZXh0VmFsdWUsIHJhd05hbWUpIDogbmV4dFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtuYW1lLCBvcHRpb25zXSA9IHBhcnNlTmFtZShyYXdOYW1lKTtcbiAgICBpZiAobmV4dFZhbHVlKSB7XG4gICAgICBjb25zdCBpbnZva2VyID0gaW52b2tlcnNbcmF3TmFtZV0gPSBjcmVhdGVJbnZva2VyKFxuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2FuaXRpemVFdmVudFZhbHVlKG5leHRWYWx1ZSwgcmF3TmFtZSkgOiBuZXh0VmFsdWUsXG4gICAgICAgIGluc3RhbmNlXG4gICAgICApO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaW52b2tlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChleGlzdGluZ0ludm9rZXIpIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGV4aXN0aW5nSW52b2tlciwgb3B0aW9ucyk7XG4gICAgICBpbnZva2Vyc1tyYXdOYW1lXSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IG9wdGlvbnNNb2RpZmllclJFID0gLyg/Ok9uY2V8UGFzc2l2ZXxDYXB0dXJlKSQvO1xuZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUpIHtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChvcHRpb25zTW9kaWZpZXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICAgIGxldCBtO1xuICAgIHdoaWxlIChtID0gbmFtZS5tYXRjaChvcHRpb25zTW9kaWZpZXJSRSkpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoIC0gbVswXS5sZW5ndGgpO1xuICAgICAgb3B0aW9uc1ttWzBdLnRvTG93ZXJDYXNlKCldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZXZlbnQgPSBuYW1lWzJdID09PSBcIjpcIiA/IG5hbWUuc2xpY2UoMykgOiBoeXBoZW5hdGUobmFtZS5zbGljZSgyKSk7XG4gIHJldHVybiBbZXZlbnQsIG9wdGlvbnNdO1xufVxubGV0IGNhY2hlZE5vdyA9IDA7XG5jb25zdCBwID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xuY29uc3QgZ2V0Tm93ID0gKCkgPT4gY2FjaGVkTm93IHx8IChwLnRoZW4oKCkgPT4gY2FjaGVkTm93ID0gMCksIGNhY2hlZE5vdyA9IERhdGUubm93KCkpO1xuZnVuY3Rpb24gY3JlYXRlSW52b2tlcihpbml0aWFsVmFsdWUsIGluc3RhbmNlKSB7XG4gIGNvbnN0IGludm9rZXIgPSAoZSkgPT4ge1xuICAgIGlmICghZS5fdnRzKSB7XG4gICAgICBlLl92dHMgPSBEYXRlLm5vdygpO1xuICAgIH0gZWxzZSBpZiAoZS5fdnRzIDw9IGludm9rZXIuYXR0YWNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICBwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCBpbnZva2VyLnZhbHVlKSxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgNSxcbiAgICAgIFtlXVxuICAgICk7XG4gIH07XG4gIGludm9rZXIudmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGludm9rZXIuYXR0YWNoZWQgPSBnZXROb3coKTtcbiAgcmV0dXJuIGludm9rZXI7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUV2ZW50VmFsdWUodmFsdWUsIHByb3BOYW1lKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB3YXJuKFxuICAgIGBXcm9uZyB0eXBlIHBhc3NlZCBhcyBldmVudCBoYW5kbGVyIHRvICR7cHJvcE5hbWV9IC0gZGlkIHlvdSBmb3JnZXQgQCBvciA6IGluIGZyb250IG9mIHlvdXIgcHJvcD9cbkV4cGVjdGVkIGZ1bmN0aW9uIG9yIGFycmF5IG9mIGZ1bmN0aW9ucywgcmVjZWl2ZWQgdHlwZSAke3R5cGVvZiB2YWx1ZX0uYFxuICApO1xuICByZXR1cm4gTk9PUDtcbn1cbmZ1bmN0aW9uIHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIHZhbHVlKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IG9yaWdpbmFsU3RvcCA9IGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uO1xuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gKCkgPT4ge1xuICAgICAgb3JpZ2luYWxTdG9wLmNhbGwoZSk7XG4gICAgICBlLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiB2YWx1ZS5tYXAoXG4gICAgICAoZm4pID0+IChlMikgPT4gIWUyLl9zdG9wcGVkICYmIGZuICYmIGZuKGUyKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmNvbnN0IGlzTmF0aXZlT24gPSAoa2V5KSA9PiBrZXkuY2hhckNvZGVBdCgwKSA9PT0gMTExICYmIGtleS5jaGFyQ29kZUF0KDEpID09PSAxMTAgJiYgLy8gbG93ZXJjYXNlIGxldHRlclxua2V5LmNoYXJDb2RlQXQoMikgPiA5NiAmJiBrZXkuY2hhckNvZGVBdCgyKSA8IDEyMztcbmNvbnN0IHBhdGNoUHJvcCA9IChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgbmFtZXNwYWNlLCBwYXJlbnRDb21wb25lbnQpID0+IHtcbiAgY29uc3QgaXNTVkcgPSBuYW1lc3BhY2UgPT09IFwic3ZnXCI7XG4gIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgIHBhdGNoQ2xhc3MoZWwsIG5leHRWYWx1ZSwgaXNTVkcpO1xuICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgcGF0Y2hTdHlsZShlbCwgcHJldlZhbHVlLCBuZXh0VmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzT24oa2V5KSkge1xuICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkpIHtcbiAgICAgIHBhdGNoRXZlbnQoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIHBhcmVudENvbXBvbmVudCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGtleVswXSA9PT0gXCIuXCIgPyAoa2V5ID0ga2V5LnNsaWNlKDEpLCB0cnVlKSA6IGtleVswXSA9PT0gXCJeXCIgPyAoa2V5ID0ga2V5LnNsaWNlKDEpLCBmYWxzZSkgOiBzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRykpIHtcbiAgICBwYXRjaERPTVByb3AoZWwsIGtleSwgbmV4dFZhbHVlKTtcbiAgICBpZiAoIWVsLnRhZ05hbWUuaW5jbHVkZXMoXCItXCIpICYmIChrZXkgPT09IFwidmFsdWVcIiB8fCBrZXkgPT09IFwiY2hlY2tlZFwiIHx8IGtleSA9PT0gXCJzZWxlY3RlZFwiKSkge1xuICAgICAgcGF0Y2hBdHRyKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcsIHBhcmVudENvbXBvbmVudCwga2V5ICE9PSBcInZhbHVlXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoa2V5ID09PSBcInRydWUtdmFsdWVcIikge1xuICAgICAgZWwuX3RydWVWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJmYWxzZS12YWx1ZVwiKSB7XG4gICAgICBlbC5fZmFsc2VWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB9XG4gICAgcGF0Y2hBdHRyKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpO1xuICB9XG59O1xuZnVuY3Rpb24gc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIHZhbHVlLCBpc1NWRykge1xuICBpZiAoaXNTVkcpIHtcbiAgICBpZiAoa2V5ID09PSBcImlubmVySFRNTFwiIHx8IGtleSA9PT0gXCJ0ZXh0Q29udGVudFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGtleSBpbiBlbCAmJiBpc05hdGl2ZU9uKGtleSkgJiYgaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJzcGVsbGNoZWNrXCIgfHwga2V5ID09PSBcImRyYWdnYWJsZVwiIHx8IGtleSA9PT0gXCJ0cmFuc2xhdGVcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcImZvcm1cIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcImxpc3RcIiAmJiBlbC50YWdOYW1lID09PSBcIklOUFVUXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJ0eXBlXCIgJiYgZWwudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwid2lkdGhcIiB8fCBrZXkgPT09IFwiaGVpZ2h0XCIpIHtcbiAgICBjb25zdCB0YWcgPSBlbC50YWdOYW1lO1xuICAgIGlmICh0YWcgPT09IFwiSU1HXCIgfHwgdGFnID09PSBcIlZJREVPXCIgfHwgdGFnID09PSBcIkNBTlZBU1wiIHx8IHRhZyA9PT0gXCJTT1VSQ0VcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOYXRpdmVPbihrZXkpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5IGluIGVsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGVsLl9pc1Z1ZUNFICYmICgvW0EtWl0vLnRlc3Qoa2V5KSB8fCAhaXNTdHJpbmcodmFsdWUpKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgUkVNT1ZBTCA9IHt9O1xuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBleHRyYU9wdGlvbnMsIF9jcmVhdGVBcHApIHtcbiAgY29uc3QgQ29tcCA9IGRlZmluZUNvbXBvbmVudChvcHRpb25zLCBleHRyYU9wdGlvbnMpO1xuICBpZiAoaXNQbGFpbk9iamVjdChDb21wKSkgZXh0ZW5kKENvbXAsIGV4dHJhT3B0aW9ucyk7XG4gIGNsYXNzIFZ1ZUN1c3RvbUVsZW1lbnQgZXh0ZW5kcyBWdWVFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsUHJvcHMpIHtcbiAgICAgIHN1cGVyKENvbXAsIGluaXRpYWxQcm9wcywgX2NyZWF0ZUFwcCk7XG4gICAgfVxuICB9XG4gIFZ1ZUN1c3RvbUVsZW1lbnQuZGVmID0gQ29tcDtcbiAgcmV0dXJuIFZ1ZUN1c3RvbUVsZW1lbnQ7XG59XG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbmNvbnN0IGRlZmluZVNTUkN1c3RvbUVsZW1lbnQgPSAvKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyAob3B0aW9ucywgZXh0cmFPcHRpb25zKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBleHRyYU9wdGlvbnMsIGNyZWF0ZVNTUkFwcCk7XG59O1xuY29uc3QgQmFzZUNsYXNzID0gdHlwZW9mIEhUTUxFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gSFRNTEVsZW1lbnQgOiBjbGFzcyB7XG59O1xuY2xhc3MgVnVlRWxlbWVudCBleHRlbmRzIEJhc2VDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9kZWYsIF9wcm9wcyA9IHt9LCBfY3JlYXRlQXBwID0gY3JlYXRlQXBwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kZWYgPSBfZGVmO1xuICAgIHRoaXMuX3Byb3BzID0gX3Byb3BzO1xuICAgIHRoaXMuX2NyZWF0ZUFwcCA9IF9jcmVhdGVBcHA7XG4gICAgdGhpcy5faXNWdWVDRSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2FwcCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fbm9uY2UgPSB0aGlzLl9kZWYubm9uY2U7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9udW1iZXJQcm9wcyA9IG51bGw7XG4gICAgdGhpcy5fc3R5bGVDaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIHRoaXMuX29iID0gbnVsbDtcbiAgICBpZiAodGhpcy5zaGFkb3dSb290ICYmIF9jcmVhdGVBcHAgIT09IGNyZWF0ZUFwcCkge1xuICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuc2hhZG93Um9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYEN1c3RvbSBlbGVtZW50IGhhcyBwcmUtcmVuZGVyZWQgZGVjbGFyYXRpdmUgc2hhZG93IHJvb3QgYnV0IGlzIG5vdCBkZWZpbmVkIGFzIGh5ZHJhdGFibGUuIFVzZSBcXGBkZWZpbmVTU1JDdXN0b21FbGVtZW50XFxgLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGVmLnNoYWRvd1Jvb3QgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogXCJvcGVuXCIgfSk7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzLnNoYWRvd1Jvb3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yb290ID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kZWYuX19hc3luY0xvYWRlcikge1xuICAgICAgdGhpcy5fcmVzb2x2ZVByb3BzKHRoaXMuX2RlZik7XG4gICAgfVxuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICghdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICB0aGlzLl9wYXJzZVNsb3RzKCk7XG4gICAgfVxuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgbGV0IHBhcmVudCA9IHRoaXM7XG4gICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudCAmJiAocGFyZW50LnBhcmVudE5vZGUgfHwgcGFyZW50Lmhvc3QpKSB7XG4gICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgVnVlRWxlbWVudCkge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICBpZiAodGhpcy5fcmVzb2x2ZWQpIHtcbiAgICAgICAgdGhpcy5fc2V0UGFyZW50KCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmdSZXNvbHZlKSB7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSBwYXJlbnQuX3BlbmRpbmdSZXNvbHZlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSB2b2lkIDA7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlRGVmKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZURlZigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9zZXRQYXJlbnQocGFyZW50ID0gdGhpcy5fcGFyZW50KSB7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy5faW5zdGFuY2UucGFyZW50ID0gcGFyZW50Ll9pbnN0YW5jZTtcbiAgICAgIHRoaXMuX2luc3RhbmNlLnByb3ZpZGVzID0gcGFyZW50Ll9pbnN0YW5jZS5wcm92aWRlcztcbiAgICB9XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX29iKSB7XG4gICAgICAgICAgdGhpcy5fb2IuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIHRoaXMuX29iID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hcHAgJiYgdGhpcy5fYXBwLnVubW91bnQoKTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2UuY2UgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX2FwcCA9IHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogcmVzb2x2ZSBpbm5lciBjb21wb25lbnQgZGVmaW5pdGlvbiAoaGFuZGxlIHBvc3NpYmxlIGFzeW5jIGNvbXBvbmVudClcbiAgICovXG4gIF9yZXNvbHZlRGVmKCkge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nUmVzb2x2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fc2V0QXR0cih0aGlzLmF0dHJpYnV0ZXNbaV0ubmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX29iID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xuICAgICAgZm9yIChjb25zdCBtIG9mIG11dGF0aW9ucykge1xuICAgICAgICB0aGlzLl9zZXRBdHRyKG0uYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fb2Iub2JzZXJ2ZSh0aGlzLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG4gICAgY29uc3QgcmVzb2x2ZSA9IChkZWYsIGlzQXN5bmMgPSBmYWxzZSkgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSB2b2lkIDA7XG4gICAgICBjb25zdCB7IHByb3BzLCBzdHlsZXMgfSA9IGRlZjtcbiAgICAgIGxldCBudW1iZXJQcm9wcztcbiAgICAgIGlmIChwcm9wcyAmJiAhaXNBcnJheShwcm9wcykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICBjb25zdCBvcHQgPSBwcm9wc1trZXldO1xuICAgICAgICAgIGlmIChvcHQgPT09IE51bWJlciB8fCBvcHQgJiYgb3B0LnR5cGUgPT09IE51bWJlcikge1xuICAgICAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9wcm9wcykge1xuICAgICAgICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gdG9OdW1iZXIodGhpcy5fcHJvcHNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAobnVtYmVyUHJvcHMgfHwgKG51bWJlclByb3BzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpKVtjYW1lbGl6ZSQxKGtleSldID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX251bWJlclByb3BzID0gbnVtYmVyUHJvcHM7XG4gICAgICBpZiAoaXNBc3luYykge1xuICAgICAgICB0aGlzLl9yZXNvbHZlUHJvcHMoZGVmKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMoc3R5bGVzKTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzdHlsZXMpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkN1c3RvbSBlbGVtZW50IHN0eWxlIGluamVjdGlvbiBpcyBub3Qgc3VwcG9ydGVkIHdoZW4gdXNpbmcgc2hhZG93Um9vdDogZmFsc2VcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fbW91bnQoZGVmKTtcbiAgICB9O1xuICAgIGNvbnN0IGFzeW5jRGVmID0gdGhpcy5fZGVmLl9fYXN5bmNMb2FkZXI7XG4gICAgaWYgKGFzeW5jRGVmKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nUmVzb2x2ZSA9IGFzeW5jRGVmKCkudGhlbihcbiAgICAgICAgKGRlZikgPT4gcmVzb2x2ZSh0aGlzLl9kZWYgPSBkZWYsIHRydWUpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKHRoaXMuX2RlZik7XG4gICAgfVxuICB9XG4gIF9tb3VudChkZWYpIHtcbiAgICBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJiAhZGVmLm5hbWUpIHtcbiAgICAgIGRlZi5uYW1lID0gXCJWdWVFbGVtZW50XCI7XG4gICAgfVxuICAgIHRoaXMuX2FwcCA9IHRoaXMuX2NyZWF0ZUFwcChkZWYpO1xuICAgIGlmIChkZWYuY29uZmlndXJlQXBwKSB7XG4gICAgICBkZWYuY29uZmlndXJlQXBwKHRoaXMuX2FwcCk7XG4gICAgfVxuICAgIHRoaXMuX2FwcC5fY2VWTm9kZSA9IHRoaXMuX2NyZWF0ZVZOb2RlKCk7XG4gICAgdGhpcy5fYXBwLm1vdW50KHRoaXMuX3Jvb3QpO1xuICAgIGNvbnN0IGV4cG9zZWQgPSB0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9pbnN0YW5jZS5leHBvc2VkO1xuICAgIGlmICghZXhwb3NlZCkgcmV0dXJuO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGV4cG9zZWQpIHtcbiAgICAgIGlmICghaGFzT3duKHRoaXMsIGtleSkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICAgIC8vIHVud3JhcCByZWYgdG8gYmUgY29uc2lzdGVudCB3aXRoIHB1YmxpYyBpbnN0YW5jZSBiZWhhdmlvclxuICAgICAgICAgIGdldDogKCkgPT4gdW5yZWYoZXhwb3NlZFtrZXldKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB3YXJuKGBFeHBvc2VkIHByb3BlcnR5IFwiJHtrZXl9XCIgYWxyZWFkeSBleGlzdHMgb24gY3VzdG9tIGVsZW1lbnQuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9yZXNvbHZlUHJvcHMoZGVmKSB7XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gZGVmO1xuICAgIGNvbnN0IGRlY2xhcmVkUHJvcEtleXMgPSBpc0FycmF5KHByb3BzKSA/IHByb3BzIDogT2JqZWN0LmtleXMocHJvcHMgfHwge30pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMpKSB7XG4gICAgICBpZiAoa2V5WzBdICE9PSBcIl9cIiAmJiBkZWNsYXJlZFByb3BLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgdGhpcy5fc2V0UHJvcChrZXksIHRoaXNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGRlY2xhcmVkUHJvcEtleXMubWFwKGNhbWVsaXplJDEpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcChrZXkpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UHJvcChrZXksIHZhbCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc2V0QXR0cihrZXkpIHtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJkYXRhLXYtXCIpKSByZXR1cm47XG4gICAgY29uc3QgaGFzID0gdGhpcy5oYXNBdHRyaWJ1dGUoa2V5KTtcbiAgICBsZXQgdmFsdWUgPSBoYXMgPyB0aGlzLmdldEF0dHJpYnV0ZShrZXkpIDogUkVNT1ZBTDtcbiAgICBjb25zdCBjYW1lbEtleSA9IGNhbWVsaXplJDEoa2V5KTtcbiAgICBpZiAoaGFzICYmIHRoaXMuX251bWJlclByb3BzICYmIHRoaXMuX251bWJlclByb3BzW2NhbWVsS2V5XSkge1xuICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMuX3NldFByb3AoY2FtZWxLZXksIHZhbHVlLCBmYWxzZSwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2dldFByb3Aoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3BzW2tleV07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NldFByb3Aoa2V5LCB2YWwsIHNob3VsZFJlZmxlY3QgPSB0cnVlLCBzaG91bGRVcGRhdGUgPSBmYWxzZSkge1xuICAgIGlmICh2YWwgIT09IHRoaXMuX3Byb3BzW2tleV0pIHtcbiAgICAgIGlmICh2YWwgPT09IFJFTU9WQUwpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Byb3BzW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gdmFsO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFVwZGF0ZSAmJiB0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZWZsZWN0KSB7XG4gICAgICAgIGlmICh2YWwgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSwgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSksIHZhbCArIFwiXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKCF2YWwpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3VwZGF0ZSgpIHtcbiAgICByZW5kZXIodGhpcy5fY3JlYXRlVk5vZGUoKSwgdGhpcy5fcm9vdCk7XG4gIH1cbiAgX2NyZWF0ZVZOb2RlKCkge1xuICAgIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xuICAgIGlmICghdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICBiYXNlUHJvcHMub25Wbm9kZU1vdW50ZWQgPSBiYXNlUHJvcHMub25Wbm9kZVVwZGF0ZWQgPSB0aGlzLl9yZW5kZXJTbG90cy5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHRoaXMuX2RlZiwgZXh0ZW5kKGJhc2VQcm9wcywgdGhpcy5fcHJvcHMpKTtcbiAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICB2bm9kZS5jZSA9IChpbnN0YW5jZSkgPT4ge1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICBpbnN0YW5jZS5jZSA9IHRoaXM7XG4gICAgICAgIGluc3RhbmNlLmlzQ0UgPSB0cnVlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGluc3RhbmNlLmNlUmVsb2FkID0gKG5ld1N0eWxlcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0eWxlcykge1xuICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMuZm9yRWFjaCgocykgPT4gdGhpcy5fcm9vdC5yZW1vdmVDaGlsZChzKSk7XG4gICAgICAgICAgICAgIHRoaXMuX3N0eWxlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMobmV3U3R5bGVzKTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzcGF0Y2ggPSAoZXZlbnQsIGFyZ3MpID0+IHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoXG4gICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICBpc1BsYWluT2JqZWN0KGFyZ3NbMF0pID8gZXh0ZW5kKHsgZGV0YWlsOiBhcmdzIH0sIGFyZ3NbMF0pIDogeyBkZXRhaWw6IGFyZ3MgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICAgIGluc3RhbmNlLmVtaXQgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBkaXNwYXRjaChldmVudCwgYXJncyk7XG4gICAgICAgICAgaWYgKGh5cGhlbmF0ZShldmVudCkgIT09IGV2ZW50KSB7XG4gICAgICAgICAgICBkaXNwYXRjaChoeXBoZW5hdGUoZXZlbnQpLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NldFBhcmVudCgpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG4gIF9hcHBseVN0eWxlcyhzdHlsZXMsIG93bmVyKSB7XG4gICAgaWYgKCFzdHlsZXMpIHJldHVybjtcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIGlmIChvd25lciA9PT0gdGhpcy5fZGVmIHx8IHRoaXMuX3N0eWxlQ2hpbGRyZW4uaGFzKG93bmVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zdHlsZUNoaWxkcmVuLmFkZChvd25lcik7XG4gICAgfVxuICAgIGNvbnN0IG5vbmNlID0gdGhpcy5fbm9uY2U7XG4gICAgZm9yIChsZXQgaSA9IHN0eWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIGlmIChub25jZSkgcy5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gICAgICBzLnRleHRDb250ZW50ID0gc3R5bGVzW2ldO1xuICAgICAgdGhpcy5zaGFkb3dSb290LnByZXBlbmQocyk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgICBpZiAob3duZXIuX19obXJJZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jaGlsZFN0eWxlcykgdGhpcy5fY2hpbGRTdHlsZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gdGhpcy5fY2hpbGRTdHlsZXMuZ2V0KG93bmVyLl9faG1ySWQpO1xuICAgICAgICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICAgICAgICB0aGlzLl9jaGlsZFN0eWxlcy5zZXQob3duZXIuX19obXJJZCwgZW50cnkgPSBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRyeS5wdXNoKHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAodGhpcy5fc3R5bGVzIHx8ICh0aGlzLl9zdHlsZXMgPSBbXSkpLnB1c2gocyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE9ubHkgY2FsbGVkIHdoZW4gc2hhZGRvd1Jvb3QgaXMgZmFsc2VcbiAgICovXG4gIF9wYXJzZVNsb3RzKCkge1xuICAgIGNvbnN0IHNsb3RzID0gdGhpcy5fc2xvdHMgPSB7fTtcbiAgICBsZXQgbjtcbiAgICB3aGlsZSAobiA9IHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgY29uc3Qgc2xvdE5hbWUgPSBuLm5vZGVUeXBlID09PSAxICYmIG4uZ2V0QXR0cmlidXRlKFwic2xvdFwiKSB8fCBcImRlZmF1bHRcIjtcbiAgICAgIChzbG90c1tzbG90TmFtZV0gfHwgKHNsb3RzW3Nsb3ROYW1lXSA9IFtdKSkucHVzaChuKTtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQobik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPbmx5IGNhbGxlZCB3aGVuIHNoYWRkb3dSb290IGlzIGZhbHNlXG4gICAqL1xuICBfcmVuZGVyU2xvdHMoKSB7XG4gICAgY29uc3Qgb3V0bGV0cyA9IHRoaXMucXVlcnlTZWxlY3RvckFsbChcInNsb3RcIik7XG4gICAgY29uc3Qgc2NvcGVJZCA9IHRoaXMuX2luc3RhbmNlLnR5cGUuX19zY29wZUlkO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0bGV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbyA9IG91dGxldHNbaV07XG4gICAgICBjb25zdCBzbG90TmFtZSA9IG8uZ2V0QXR0cmlidXRlKFwibmFtZVwiKSB8fCBcImRlZmF1bHRcIjtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl9zbG90c1tzbG90TmFtZV07XG4gICAgICBjb25zdCBwYXJlbnQgPSBvLnBhcmVudE5vZGU7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICBmb3IgKGNvbnN0IG4gb2YgY29udGVudCkge1xuICAgICAgICAgIGlmIChzY29wZUlkICYmIG4ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gc2NvcGVJZCArIFwiLXNcIjtcbiAgICAgICAgICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIobiwgMSk7XG4gICAgICAgICAgICBuLnNldEF0dHJpYnV0ZShpZCwgXCJcIik7XG4gICAgICAgICAgICBsZXQgY2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGQgPSB3YWxrZXIubmV4dE5vZGUoKSkge1xuICAgICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoaWQsIFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG4sIG8pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAoby5maXJzdENoaWxkKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKG8uZmlyc3RDaGlsZCwgbyk7XG4gICAgICB9XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9pbmplY3RDaGlsZFN0eWxlKGNvbXApIHtcbiAgICB0aGlzLl9hcHBseVN0eWxlcyhjb21wLnN0eWxlcywgY29tcCk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3JlbW92ZUNoaWxkU3R5bGUoY29tcCkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB0aGlzLl9zdHlsZUNoaWxkcmVuLmRlbGV0ZShjb21wKTtcbiAgICAgIGlmICh0aGlzLl9jaGlsZFN0eWxlcyAmJiBjb21wLl9faG1ySWQpIHtcbiAgICAgICAgY29uc3Qgb2xkU3R5bGVzID0gdGhpcy5fY2hpbGRTdHlsZXMuZ2V0KGNvbXAuX19obXJJZCk7XG4gICAgICAgIGlmIChvbGRTdHlsZXMpIHtcbiAgICAgICAgICBvbGRTdHlsZXMuZm9yRWFjaCgocykgPT4gdGhpcy5fcm9vdC5yZW1vdmVDaGlsZChzKSk7XG4gICAgICAgICAgb2xkU3R5bGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZUhvc3QoY2FsbGVyKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGNvbnN0IGVsID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuY2U7XG4gIGlmIChlbCkge1xuICAgIHJldHVybiBlbDtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgd2FybihcbiAgICAgICAgYCR7Y2FsbGVyIHx8IFwidXNlSG9zdFwifSBjYWxsZWQgd2l0aG91dCBhbiBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlLmBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGAke2NhbGxlciB8fCBcInVzZUhvc3RcIn0gY2FuIG9ubHkgYmUgdXNlZCBpbiBjb21wb25lbnRzIGRlZmluZWQgdmlhIGRlZmluZUN1c3RvbUVsZW1lbnQuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1c2VTaGFkb3dSb290KCkge1xuICBjb25zdCBlbCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB1c2VIb3N0KFwidXNlU2hhZG93Um9vdFwiKSA6IHVzZUhvc3QoKTtcbiAgcmV0dXJuIGVsICYmIGVsLnNoYWRvd1Jvb3Q7XG59XG5cbmZ1bmN0aW9uIHVzZUNzc01vZHVsZShuYW1lID0gXCIkc3R5bGVcIikge1xuICB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYHVzZUNzc01vZHVsZSBtdXN0IGJlIGNhbGxlZCBpbnNpZGUgc2V0dXAoKWApO1xuICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlcyA9IGluc3RhbmNlLnR5cGUuX19jc3NNb2R1bGVzO1xuICAgIGlmICghbW9kdWxlcykge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZXMgaW5qZWN0ZWQuYCk7XG4gICAgICByZXR1cm4gRU1QVFlfT0JKO1xuICAgIH1cbiAgICBjb25zdCBtb2QgPSBtb2R1bGVzW25hbWVdO1xuICAgIGlmICghbW9kKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlIG5hbWVkIFwiJHtuYW1lfVwiLmApO1xuICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICB9XG4gICAgcmV0dXJuIG1vZDtcbiAgfVxufVxuXG5jb25zdCBwb3NpdGlvbk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgbmV3UG9zaXRpb25NYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG1vdmVDYktleSA9IFN5bWJvbChcIl9tb3ZlQ2JcIik7XG5jb25zdCBlbnRlckNiS2V5ID0gU3ltYm9sKFwiX2VudGVyQ2JcIik7XG5jb25zdCBUcmFuc2l0aW9uR3JvdXBJbXBsID0ge1xuICBuYW1lOiBcIlRyYW5zaXRpb25Hcm91cFwiLFxuICBwcm9wczogLyogQF9fUFVSRV9fICovIGV4dGVuZCh7fSwgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywge1xuICAgIHRhZzogU3RyaW5nLFxuICAgIG1vdmVDbGFzczogU3RyaW5nXG4gIH0pLFxuICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xuICAgIGxldCBwcmV2Q2hpbGRyZW47XG4gICAgbGV0IGNoaWxkcmVuO1xuICAgIG9uVXBkYXRlZCgoKSA9PiB7XG4gICAgICBpZiAoIXByZXZDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbW92ZUNsYXNzID0gcHJvcHMubW92ZUNsYXNzIHx8IGAke3Byb3BzLm5hbWUgfHwgXCJ2XCJ9LW1vdmVgO1xuICAgICAgaWYgKCFoYXNDU1NUcmFuc2Zvcm0oXG4gICAgICAgIHByZXZDaGlsZHJlblswXS5lbCxcbiAgICAgICAgaW5zdGFuY2Uudm5vZGUuZWwsXG4gICAgICAgIG1vdmVDbGFzc1xuICAgICAgKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgICBjb25zdCBtb3ZlZENoaWxkcmVuID0gcHJldkNoaWxkcmVuLmZpbHRlcihhcHBseVRyYW5zbGF0aW9uKTtcbiAgICAgIGZvcmNlUmVmbG93KCk7XG4gICAgICBtb3ZlZENoaWxkcmVuLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgY29uc3QgZWwgPSBjLmVsO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IHN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IFwiXCI7XG4gICAgICAgIGNvbnN0IGNiID0gZWxbbW92ZUNiS2V5XSA9IChlKSA9PiB7XG4gICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGNiKTtcbiAgICAgICAgICAgIGVsW21vdmVDYktleV0gPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgY2IpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xuICAgICAgY29uc3QgY3NzVHJhbnNpdGlvblByb3BzID0gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcyk7XG4gICAgICBsZXQgdGFnID0gcmF3UHJvcHMudGFnIHx8IEZyYWdtZW50O1xuICAgICAgcHJldkNoaWxkcmVuID0gW107XG4gICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgaWYgKGNoaWxkLmVsICYmIGNoaWxkLmVsIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgcHJldkNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgICAgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgICAgICBjc3NUcmFuc2l0aW9uUHJvcHMsXG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChcbiAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgIGNoaWxkLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ID8gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSkgOiBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuKGA8VHJhbnNpdGlvbkdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlVk5vZGUodGFnLCBudWxsLCBjaGlsZHJlbik7XG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IHJlbW92ZU1vZGUgPSAocHJvcHMpID0+IGRlbGV0ZSBwcm9wcy5tb2RlO1xuLyogQF9fUFVSRV9fICovIHJlbW92ZU1vZGUoVHJhbnNpdGlvbkdyb3VwSW1wbC5wcm9wcyk7XG5jb25zdCBUcmFuc2l0aW9uR3JvdXAgPSBUcmFuc2l0aW9uR3JvdXBJbXBsO1xuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMoYykge1xuICBjb25zdCBlbCA9IGMuZWw7XG4gIGlmIChlbFttb3ZlQ2JLZXldKSB7XG4gICAgZWxbbW92ZUNiS2V5XSgpO1xuICB9XG4gIGlmIChlbFtlbnRlckNiS2V5XSkge1xuICAgIGVsW2VudGVyQ2JLZXldKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uKGMpIHtcbiAgbmV3UG9zaXRpb25NYXAuc2V0KGMsIGMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xufVxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbihjKSB7XG4gIGNvbnN0IG9sZFBvcyA9IHBvc2l0aW9uTWFwLmdldChjKTtcbiAgY29uc3QgbmV3UG9zID0gbmV3UG9zaXRpb25NYXAuZ2V0KGMpO1xuICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGNvbnN0IHMgPSBjLmVsLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy53ZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZHh9cHgsJHtkeX1weClgO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gXCIwc1wiO1xuICAgIHJldHVybiBjO1xuICB9XG59XG5mdW5jdGlvbiBoYXNDU1NUcmFuc2Zvcm0oZWwsIHJvb3QsIG1vdmVDbGFzcykge1xuICBjb25zdCBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICBjb25zdCBfdnRjID0gZWxbdnRjS2V5XTtcbiAgaWYgKF92dGMpIHtcbiAgICBfdnRjLmZvckVhY2goKGNscykgPT4ge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgICB9KTtcbiAgfVxuICBtb3ZlQ2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5hZGQoYykpO1xuICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIGNvbnN0IGNvbnRhaW5lciA9IHJvb3Qubm9kZVR5cGUgPT09IDEgPyByb290IDogcm9vdC5wYXJlbnROb2RlO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICBjb25zdCB7IGhhc1RyYW5zZm9ybSB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICByZXR1cm4gaGFzVHJhbnNmb3JtO1xufVxuXG5jb25zdCBnZXRNb2RlbEFzc2lnbmVyID0gKHZub2RlKSA9PiB7XG4gIGNvbnN0IGZuID0gdm5vZGUucHJvcHNbXCJvblVwZGF0ZTptb2RlbFZhbHVlXCJdIHx8IGZhbHNlO1xuICByZXR1cm4gaXNBcnJheShmbikgPyAodmFsdWUpID0+IGludm9rZUFycmF5Rm5zKGZuLCB2YWx1ZSkgOiBmbjtcbn07XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChlKSB7XG4gIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICBpZiAodGFyZ2V0LmNvbXBvc2luZykge1xuICAgIHRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiKSk7XG4gIH1cbn1cbmNvbnN0IGFzc2lnbktleSA9IFN5bWJvbChcIl9hc3NpZ25cIik7XG5jb25zdCB2TW9kZWxUZXh0ID0ge1xuICBjcmVhdGVkKGVsLCB7IG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBjb25zdCBjYXN0VG9OdW1iZXIgPSBudW1iZXIgfHwgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZSA9PT0gXCJudW1iZXJcIjtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBsYXp5ID8gXCJjaGFuZ2VcIiA6IFwiaW5wdXRcIiwgKGUpID0+IHtcbiAgICAgIGlmIChlLnRhcmdldC5jb21wb3NpbmcpIHJldHVybjtcbiAgICAgIGxldCBkb21WYWx1ZSA9IGVsLnZhbHVlO1xuICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgZG9tVmFsdWUgPSBkb21WYWx1ZS50cmltKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FzdFRvTnVtYmVyKSB7XG4gICAgICAgIGRvbVZhbHVlID0gbG9vc2VUb051bWJlcihkb21WYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbFthc3NpZ25LZXldKGRvbVZhbHVlKTtcbiAgICB9KTtcbiAgICBpZiAodHJpbSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICBlbC52YWx1ZSA9IGVsLnZhbHVlLnRyaW0oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWxhenkpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY29tcG9zaXRpb25zdGFydFwiLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjb21wb3NpdGlvbmVuZFwiLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgIH1cbiAgfSxcbiAgLy8gc2V0IHZhbHVlIG9uIG1vdW50ZWQgc28gaXQncyBhZnRlciBtaW4vbWF4IGZvciB0eXBlPVwicmFuZ2VcIlxuICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICBlbC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWU7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUsIG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBpZiAoZWwuY29tcG9zaW5nKSByZXR1cm47XG4gICAgY29uc3QgZWxWYWx1ZSA9IChudW1iZXIgfHwgZWwudHlwZSA9PT0gXCJudW1iZXJcIikgJiYgIS9eMFxcZC8udGVzdChlbC52YWx1ZSkgPyBsb29zZVRvTnVtYmVyKGVsLnZhbHVlKSA6IGVsLnZhbHVlO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgICBpZiAoZWxWYWx1ZSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsICYmIGVsLnR5cGUgIT09IFwicmFuZ2VcIikge1xuICAgICAgaWYgKGxhenkgJiYgdmFsdWUgPT09IG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmltICYmIGVsLnZhbHVlLnRyaW0oKSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICB9XG59O1xuY29uc3Qgdk1vZGVsQ2hlY2tib3ggPSB7XG4gIC8vICM0MDk2IGFycmF5IGNoZWNrYm94ZXMgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxuICBkZWVwOiB0cnVlLFxuICBjcmVhdGVkKGVsLCBfLCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2RlbFZhbHVlID0gZWwuX21vZGVsVmFsdWU7XG4gICAgICBjb25zdCBlbGVtZW50VmFsdWUgPSBnZXRWYWx1ZShlbCk7XG4gICAgICBjb25zdCBjaGVja2VkID0gZWwuY2hlY2tlZDtcbiAgICAgIGNvbnN0IGFzc2lnbiA9IGVsW2Fzc2lnbktleV07XG4gICAgICBpZiAoaXNBcnJheShtb2RlbFZhbHVlKSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGxvb3NlSW5kZXhPZihtb2RlbFZhbHVlLCBlbGVtZW50VmFsdWUpO1xuICAgICAgICBjb25zdCBmb3VuZCA9IGluZGV4ICE9PSAtMTtcbiAgICAgICAgaWYgKGNoZWNrZWQgJiYgIWZvdW5kKSB7XG4gICAgICAgICAgYXNzaWduKG1vZGVsVmFsdWUuY29uY2F0KGVsZW1lbnRWYWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFjaGVja2VkICYmIGZvdW5kKSB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBbLi4ubW9kZWxWYWx1ZV07XG4gICAgICAgICAgZmlsdGVyZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBhc3NpZ24oZmlsdGVyZWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzU2V0KG1vZGVsVmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZCA9IG5ldyBTZXQobW9kZWxWYWx1ZSk7XG4gICAgICAgIGlmIChjaGVja2VkKSB7XG4gICAgICAgICAgY2xvbmVkLmFkZChlbGVtZW50VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb25lZC5kZWxldGUoZWxlbWVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NpZ24oY2xvbmVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2lnbihnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIC8vIHNldCBpbml0aWFsIGNoZWNrZWQgb24gbW91bnQgdG8gd2FpdCBmb3IgdHJ1ZS12YWx1ZS9mYWxzZS12YWx1ZVxuICBtb3VudGVkOiBzZXRDaGVja2VkLFxuICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIHNldENoZWNrZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNldENoZWNrZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XG4gIGVsLl9tb2RlbFZhbHVlID0gdmFsdWU7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGVsLmNoZWNrZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xO1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIGVsLmNoZWNrZWQgPSB2YWx1ZS5oYXModm5vZGUucHJvcHMudmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCBnZXRDaGVja2JveFZhbHVlKGVsLCB0cnVlKSk7XG4gIH1cbn1cbmNvbnN0IHZNb2RlbFJhZGlvID0ge1xuICBjcmVhdGVkKGVsLCB7IHZhbHVlIH0sIHZub2RlKSB7XG4gICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgZWxbYXNzaWduS2V5XShnZXRWYWx1ZShlbCkpO1xuICAgIH0pO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuY29uc3Qgdk1vZGVsU2VsZWN0ID0ge1xuICAvLyA8c2VsZWN0IG11bHRpcGxlPiB2YWx1ZSBuZWVkIHRvIGJlIGRlZXAgdHJhdmVyc2VkXG4gIGRlZXA6IHRydWUsXG4gIGNyZWF0ZWQoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgIGNvbnN0IGlzU2V0TW9kZWwgPSBpc1NldCh2YWx1ZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRWYWwgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZWwub3B0aW9ucywgKG8pID0+IG8uc2VsZWN0ZWQpLm1hcChcbiAgICAgICAgKG8pID0+IG51bWJlciA/IGxvb3NlVG9OdW1iZXIoZ2V0VmFsdWUobykpIDogZ2V0VmFsdWUobylcbiAgICAgICk7XG4gICAgICBlbFthc3NpZ25LZXldKFxuICAgICAgICBlbC5tdWx0aXBsZSA/IGlzU2V0TW9kZWwgPyBuZXcgU2V0KHNlbGVjdGVkVmFsKSA6IHNlbGVjdGVkVmFsIDogc2VsZWN0ZWRWYWxbMF1cbiAgICAgICk7XG4gICAgICBlbC5fYXNzaWduaW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgZWwuX2Fzc2lnbmluZyA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICB9LFxuICAvLyBzZXQgdmFsdWUgaW4gbW91bnRlZCAmIHVwZGF0ZWQgYmVjYXVzZSA8c2VsZWN0PiByZWxpZXMgb24gaXRzIGNoaWxkcmVuXG4gIC8vIDxvcHRpb24+cy5cbiAgbW91bnRlZChlbCwgeyB2YWx1ZSwgbW9kaWZpZXJzOiB7IG51bWJlciB9IH0pIHtcbiAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIF9iaW5kaW5nLCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlZChlbCwgeyB2YWx1ZSwgbW9kaWZpZXJzOiB7IG51bWJlciB9IH0pIHtcbiAgICBpZiAoIWVsLl9hc3NpZ25pbmcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWQoZWwsIHZhbHVlLCBudW1iZXIpIHtcbiAgY29uc3QgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBjb25zdCBpc0FycmF5VmFsdWUgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIWlzQXJyYXlWYWx1ZSAmJiAhaXNTZXQodmFsdWUpKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgYDxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD4gZXhwZWN0cyBhbiBBcnJheSBvciBTZXQgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290ICR7T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSl9LmBcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3Qgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBjb25zdCBvcHRpb25WYWx1ZSA9IGdldFZhbHVlKG9wdGlvbik7XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIGlmIChpc0FycmF5VmFsdWUpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uVHlwZSA9IHR5cGVvZiBvcHRpb25WYWx1ZTtcbiAgICAgICAgaWYgKG9wdGlvblR5cGUgPT09IFwic3RyaW5nXCIgfHwgb3B0aW9uVHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLnNvbWUoKHYpID0+IFN0cmluZyh2KSA9PT0gU3RyaW5nKG9wdGlvblZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBvcHRpb25WYWx1ZSkgPiAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaGFzKG9wdGlvblZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSAmJiBlbC5zZWxlY3RlZEluZGV4ICE9PSAtMSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmFsdWUoZWwpIHtcbiAgcmV0dXJuIFwiX3ZhbHVlXCIgaW4gZWwgPyBlbC5fdmFsdWUgOiBlbC52YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpIHtcbiAgY29uc3Qga2V5ID0gY2hlY2tlZCA/IFwiX3RydWVWYWx1ZVwiIDogXCJfZmFsc2VWYWx1ZVwiO1xuICByZXR1cm4ga2V5IGluIGVsID8gZWxba2V5XSA6IGNoZWNrZWQ7XG59XG5jb25zdCB2TW9kZWxEeW5hbWljID0ge1xuICBjcmVhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCBcImNyZWF0ZWRcIik7XG4gIH0sXG4gIG1vdW50ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsIFwibW91bnRlZFwiKTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgXCJiZWZvcmVVcGRhdGVcIik7XG4gIH0sXG4gIHVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBcInVwZGF0ZWRcIik7XG4gIH1cbn07XG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY01vZGVsKHRhZ05hbWUsIHR5cGUpIHtcbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcIlNFTEVDVFwiOlxuICAgICAgcmV0dXJuIHZNb2RlbFNlbGVjdDtcbiAgICBjYXNlIFwiVEVYVEFSRUFcIjpcbiAgICAgIHJldHVybiB2TW9kZWxUZXh0O1xuICAgIGRlZmF1bHQ6XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICAgICAgcmV0dXJuIHZNb2RlbENoZWNrYm94O1xuICAgICAgICBjYXNlIFwicmFkaW9cIjpcbiAgICAgICAgICByZXR1cm4gdk1vZGVsUmFkaW87XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHZNb2RlbFRleHQ7XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIGhvb2spIHtcbiAgY29uc3QgbW9kZWxUb1VzZSA9IHJlc29sdmVEeW5hbWljTW9kZWwoXG4gICAgZWwudGFnTmFtZSxcbiAgICB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlXG4gICk7XG4gIGNvbnN0IGZuID0gbW9kZWxUb1VzZVtob29rXTtcbiAgZm4gJiYgZm4oZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpO1xufVxuZnVuY3Rpb24gaW5pdFZNb2RlbEZvclNTUigpIHtcbiAgdk1vZGVsVGV4dC5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0pID0+ICh7IHZhbHVlIH0pO1xuICB2TW9kZWxSYWRpby5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0sIHZub2RlKSA9PiB7XG4gICAgaWYgKHZub2RlLnByb3BzICYmIGxvb3NlRXF1YWwodm5vZGUucHJvcHMudmFsdWUsIHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgIH1cbiAgfTtcbiAgdk1vZGVsQ2hlY2tib3guZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKHZub2RlLnByb3BzICYmIGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgICBpZiAodm5vZGUucHJvcHMgJiYgdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKSkge1xuICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgIH1cbiAgfTtcbiAgdk1vZGVsRHluYW1pYy5nZXRTU1JQcm9wcyA9IChiaW5kaW5nLCB2bm9kZSkgPT4ge1xuICAgIGlmICh0eXBlb2Ygdm5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtb2RlbFRvVXNlID0gcmVzb2x2ZUR5bmFtaWNNb2RlbChcbiAgICAgIC8vIHJlc29sdmVEeW5hbWljTW9kZWwgZXhwZWN0cyBhbiB1cHBlcmNhc2UgdGFnIG5hbWUsIGJ1dCB2bm9kZS50eXBlIGlzIGxvd2VyY2FzZVxuICAgICAgdm5vZGUudHlwZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZVxuICAgICk7XG4gICAgaWYgKG1vZGVsVG9Vc2UuZ2V0U1NSUHJvcHMpIHtcbiAgICAgIHJldHVybiBtb2RlbFRvVXNlLmdldFNTUlByb3BzKGJpbmRpbmcsIHZub2RlKTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IHN5c3RlbU1vZGlmaWVycyA9IFtcImN0cmxcIiwgXCJzaGlmdFwiLCBcImFsdFwiLCBcIm1ldGFcIl07XG5jb25zdCBtb2RpZmllckd1YXJkcyA9IHtcbiAgc3RvcDogKGUpID0+IGUuc3RvcFByb3BhZ2F0aW9uKCksXG4gIHByZXZlbnQ6IChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCksXG4gIHNlbGY6IChlKSA9PiBlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0LFxuICBjdHJsOiAoZSkgPT4gIWUuY3RybEtleSxcbiAgc2hpZnQ6IChlKSA9PiAhZS5zaGlmdEtleSxcbiAgYWx0OiAoZSkgPT4gIWUuYWx0S2V5LFxuICBtZXRhOiAoZSkgPT4gIWUubWV0YUtleSxcbiAgbGVmdDogKGUpID0+IFwiYnV0dG9uXCIgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMCxcbiAgbWlkZGxlOiAoZSkgPT4gXCJidXR0b25cIiBpbiBlICYmIGUuYnV0dG9uICE9PSAxLFxuICByaWdodDogKGUpID0+IFwiYnV0dG9uXCIgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMixcbiAgZXhhY3Q6IChlLCBtb2RpZmllcnMpID0+IHN5c3RlbU1vZGlmaWVycy5zb21lKChtKSA9PiBlW2Ake219S2V5YF0gJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhtKSlcbn07XG5jb25zdCB3aXRoTW9kaWZpZXJzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcbiAgY29uc3QgY2FjaGUgPSBmbi5fd2l0aE1vZHMgfHwgKGZuLl93aXRoTW9kcyA9IHt9KTtcbiAgY29uc3QgY2FjaGVLZXkgPSBtb2RpZmllcnMuam9pbihcIi5cIik7XG4gIHJldHVybiBjYWNoZVtjYWNoZUtleV0gfHwgKGNhY2hlW2NhY2hlS2V5XSA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBndWFyZCA9IG1vZGlmaWVyR3VhcmRzW21vZGlmaWVyc1tpXV07XG4gICAgICBpZiAoZ3VhcmQgJiYgZ3VhcmQoZXZlbnQsIG1vZGlmaWVycykpIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGZuKGV2ZW50LCAuLi5hcmdzKTtcbiAgfSk7XG59O1xuY29uc3Qga2V5TmFtZXMgPSB7XG4gIGVzYzogXCJlc2NhcGVcIixcbiAgc3BhY2U6IFwiIFwiLFxuICB1cDogXCJhcnJvdy11cFwiLFxuICBsZWZ0OiBcImFycm93LWxlZnRcIixcbiAgcmlnaHQ6IFwiYXJyb3ctcmlnaHRcIixcbiAgZG93bjogXCJhcnJvdy1kb3duXCIsXG4gIGRlbGV0ZTogXCJiYWNrc3BhY2VcIlxufTtcbmNvbnN0IHdpdGhLZXlzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcbiAgY29uc3QgY2FjaGUgPSBmbi5fd2l0aEtleXMgfHwgKGZuLl93aXRoS2V5cyA9IHt9KTtcbiAgY29uc3QgY2FjaGVLZXkgPSBtb2RpZmllcnMuam9pbihcIi5cIik7XG4gIHJldHVybiBjYWNoZVtjYWNoZUtleV0gfHwgKGNhY2hlW2NhY2hlS2V5XSA9IChldmVudCkgPT4ge1xuICAgIGlmICghKFwia2V5XCIgaW4gZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50S2V5ID0gaHlwaGVuYXRlKGV2ZW50LmtleSk7XG4gICAgaWYgKG1vZGlmaWVycy5zb21lKFxuICAgICAgKGspID0+IGsgPT09IGV2ZW50S2V5IHx8IGtleU5hbWVzW2tdID09PSBldmVudEtleVxuICAgICkpIHtcbiAgICAgIHJldHVybiBmbihldmVudCk7XG4gICAgfVxuICB9KTtcbn07XG5cbmNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoeyBwYXRjaFByb3AgfSwgbm9kZU9wcyk7XG5sZXQgcmVuZGVyZXI7XG5sZXQgZW5hYmxlZEh5ZHJhdGlvbiA9IGZhbHNlO1xuZnVuY3Rpb24gZW5zdXJlUmVuZGVyZXIoKSB7XG4gIHJldHVybiByZW5kZXJlciB8fCAocmVuZGVyZXIgPSBjcmVhdGVSZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkge1xuICByZW5kZXJlciA9IGVuYWJsZWRIeWRyYXRpb24gPyByZW5kZXJlciA6IGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucyk7XG4gIGVuYWJsZWRIeWRyYXRpb24gPSB0cnVlO1xuICByZXR1cm4gcmVuZGVyZXI7XG59XG5jb25zdCByZW5kZXIgPSAoLi4uYXJncykgPT4ge1xuICBlbnN1cmVSZW5kZXJlcigpLnJlbmRlciguLi5hcmdzKTtcbn07XG5jb25zdCBoeWRyYXRlID0gKC4uLmFyZ3MpID0+IHtcbiAgZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5oeWRyYXRlKC4uLmFyZ3MpO1xufTtcbmNvbnN0IGNyZWF0ZUFwcCA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGFwcCA9IGVuc3VyZVJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XG4gICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcbiAgfVxuICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XG4gIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG4gICAgY29uc3QgY29tcG9uZW50ID0gYXBwLl9jb21wb25lbnQ7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGNvbXBvbmVudCkgJiYgIWNvbXBvbmVudC5yZW5kZXIgJiYgIWNvbXBvbmVudC50ZW1wbGF0ZSkge1xuICAgICAgY29tcG9uZW50LnRlbXBsYXRlID0gY29udGFpbmVyLmlubmVySFRNTDtcbiAgICB9XG4gICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgY29udGFpbmVyLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICB9XG4gICAgY29uc3QgcHJveHkgPSBtb3VudChjb250YWluZXIsIGZhbHNlLCByZXNvbHZlUm9vdE5hbWVzcGFjZShjb250YWluZXIpKTtcbiAgICBpZiAoY29udGFpbmVyIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZShcInYtY2xvYWtcIik7XG4gICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS12LWFwcFwiLCBcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xuICByZXR1cm4gYXBwO1xufTtcbmNvbnN0IGNyZWF0ZVNTUkFwcCA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGFwcCA9IGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XG4gICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcbiAgfVxuICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XG4gIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIHJldHVybiBtb3VudChjb250YWluZXIsIHRydWUsIHJlc29sdmVSb290TmFtZXNwYWNlKGNvbnRhaW5lcikpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGFwcDtcbn07XG5mdW5jdGlvbiByZXNvbHZlUm9vdE5hbWVzcGFjZShjb250YWluZXIpIHtcbiAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcbiAgICByZXR1cm4gXCJzdmdcIjtcbiAgfVxuICBpZiAodHlwZW9mIE1hdGhNTEVsZW1lbnQgPT09IFwiZnVuY3Rpb25cIiAmJiBjb250YWluZXIgaW5zdGFuY2VvZiBNYXRoTUxFbGVtZW50KSB7XG4gICAgcmV0dXJuIFwibWF0aG1sXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgXCJpc05hdGl2ZVRhZ1wiLCB7XG4gICAgdmFsdWU6ICh0YWcpID0+IGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHVGFnKHRhZykgfHwgaXNNYXRoTUxUYWcodGFnKSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG59XG5mdW5jdGlvbiBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApIHtcbiAgaWYgKGlzUnVudGltZU9ubHkoKSkge1xuICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGFwcC5jb25maWcuaXNDdXN0b21FbGVtZW50O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCBcImlzQ3VzdG9tRWxlbWVudFwiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBpc0N1c3RvbUVsZW1lbnQ7XG4gICAgICB9LFxuICAgICAgc2V0KCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBUaGUgXFxgaXNDdXN0b21FbGVtZW50XFxgIGNvbmZpZyBvcHRpb24gaXMgZGVwcmVjYXRlZC4gVXNlIFxcYGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnRcXGAgaW5zdGVhZC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgY29tcGlsZXJPcHRpb25zID0gYXBwLmNvbmZpZy5jb21waWxlck9wdGlvbnM7XG4gICAgY29uc3QgbXNnID0gYFRoZSBcXGBjb21waWxlck9wdGlvbnNcXGAgY29uZmlnIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIGEgYnVpbGQgb2YgVnVlLmpzIHRoYXQgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIgKGFrYSBcImZ1bGwgYnVpbGRcIikuIFNpbmNlIHlvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCwgXFxgY29tcGlsZXJPcHRpb25zXFxgIG11c3QgYmUgcGFzc2VkIHRvIFxcYEB2dWUvY29tcGlsZXItZG9tXFxgIGluIHRoZSBidWlsZCBzZXR1cCBpbnN0ZWFkLlxuLSBGb3IgdnVlLWxvYWRlcjogcGFzcyBpdCB2aWEgdnVlLWxvYWRlcidzIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBsb2FkZXIgb3B0aW9uLlxuLSBGb3IgdnVlLWNsaTogc2VlIGh0dHBzOi8vY2xpLnZ1ZWpzLm9yZy9ndWlkZS93ZWJwYWNrLmh0bWwjbW9kaWZ5aW5nLW9wdGlvbnMtb2YtYS1sb2FkZXJcbi0gRm9yIHZpdGU6IHBhc3MgaXQgdmlhIEB2aXRlanMvcGx1Z2luLXZ1ZSBvcHRpb25zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlLXBsdWdpbi12dWUvdHJlZS9tYWluL3BhY2thZ2VzL3BsdWdpbi12dWUjZXhhbXBsZS1mb3ItcGFzc2luZy1vcHRpb25zLXRvLXZ1ZWNvbXBpbGVyLXNmY2A7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsIFwiY29tcGlsZXJPcHRpb25zXCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICByZXR1cm4gY29tcGlsZXJPcHRpb25zO1xuICAgICAgfSxcbiAgICAgIHNldCgpIHtcbiAgICAgICAgd2Fybihtc2cpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmIChpc1N0cmluZyhjb250YWluZXIpKSB7XG4gICAgY29uc3QgcmVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250YWluZXIpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFyZXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBGYWlsZWQgdG8gbW91bnQgYXBwOiBtb3VudCB0YXJnZXQgc2VsZWN0b3IgXCIke2NvbnRhaW5lcn1cIiByZXR1cm5lZCBudWxsLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2luZG93LlNoYWRvd1Jvb3QgJiYgY29udGFpbmVyIGluc3RhbmNlb2Ygd2luZG93LlNoYWRvd1Jvb3QgJiYgY29udGFpbmVyLm1vZGUgPT09IFwiY2xvc2VkXCIpIHtcbiAgICB3YXJuKFxuICAgICAgYG1vdW50aW5nIG9uIGEgU2hhZG93Um9vdCB3aXRoIFxcYHttb2RlOiBcImNsb3NlZFwifVxcYCBtYXkgbGVhZCB0byB1bnByZWRpY3RhYmxlIGJ1Z3NgXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29udGFpbmVyO1xufVxubGV0IHNzckRpcmVjdGl2ZUluaXRpYWxpemVkID0gZmFsc2U7XG5jb25zdCBpbml0RGlyZWN0aXZlc0ZvclNTUiA9ICgpID0+IHtcbiAgaWYgKCFzc3JEaXJlY3RpdmVJbml0aWFsaXplZCkge1xuICAgIHNzckRpcmVjdGl2ZUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBpbml0Vk1vZGVsRm9yU1NSKCk7XG4gICAgaW5pdFZTaG93Rm9yU1NSKCk7XG4gIH1cbn0gO1xuXG5leHBvcnQgeyBUcmFuc2l0aW9uLCBUcmFuc2l0aW9uR3JvdXAsIFZ1ZUVsZW1lbnQsIGNyZWF0ZUFwcCwgY3JlYXRlU1NSQXBwLCBkZWZpbmVDdXN0b21FbGVtZW50LCBkZWZpbmVTU1JDdXN0b21FbGVtZW50LCBoeWRyYXRlLCBpbml0RGlyZWN0aXZlc0ZvclNTUiwgcmVuZGVyLCB1c2VDc3NNb2R1bGUsIHVzZUNzc1ZhcnMsIHVzZUhvc3QsIHVzZVNoYWRvd1Jvb3QsIHZNb2RlbENoZWNrYm94LCB2TW9kZWxEeW5hbWljLCB2TW9kZWxSYWRpbywgdk1vZGVsU2VsZWN0LCB2TW9kZWxUZXh0LCB2U2hvdywgd2l0aEtleXMsIHdpdGhNb2RpZmllcnMgfTtcbiIsImV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzQuNTYuMCc7IC8vIHgtcmVsZWFzZS1wbGVhc2UtdmVyc2lvblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5tanMubWFwIiwiZXhwb3J0IGxldCBhdXRvID0gZmFsc2U7XG5leHBvcnQgbGV0IGtpbmQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGZldGNoID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBSZXNwb25zZSA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgSGVhZGVycyA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgRm9ybURhdGEgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IEJsb2IgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IEZpbGUgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IFJlYWRhYmxlU3RyZWFtID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucyA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgZ2V0RGVmYXVsdEFnZW50ID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBmaWxlRnJvbVBhdGggPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGlzRnNSZWFkU3RyZWFtID0gdW5kZWZpbmVkO1xuZXhwb3J0IGZ1bmN0aW9uIHNldFNoaW1zKHNoaW1zLCBvcHRpb25zID0geyBhdXRvOiBmYWxzZSB9KSB7XG4gICAgaWYgKGF1dG8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB5b3UgbXVzdCBcXGBpbXBvcnQgJ29wZW5haS9zaGltcy8ke3NoaW1zLmtpbmR9J1xcYCBiZWZvcmUgaW1wb3J0aW5nIGFueXRoaW5nIGVsc2UgZnJvbSBvcGVuYWlgKTtcbiAgICB9XG4gICAgaWYgKGtpbmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW4ndCBcXGBpbXBvcnQgJ29wZW5haS9zaGltcy8ke3NoaW1zLmtpbmR9J1xcYCBhZnRlciBcXGBpbXBvcnQgJ29wZW5haS9zaGltcy8ke2tpbmR9J1xcYGApO1xuICAgIH1cbiAgICBhdXRvID0gb3B0aW9ucy5hdXRvO1xuICAgIGtpbmQgPSBzaGltcy5raW5kO1xuICAgIGZldGNoID0gc2hpbXMuZmV0Y2g7XG4gICAgUmVxdWVzdCA9IHNoaW1zLlJlcXVlc3Q7XG4gICAgUmVzcG9uc2UgPSBzaGltcy5SZXNwb25zZTtcbiAgICBIZWFkZXJzID0gc2hpbXMuSGVhZGVycztcbiAgICBGb3JtRGF0YSA9IHNoaW1zLkZvcm1EYXRhO1xuICAgIEJsb2IgPSBzaGltcy5CbG9iO1xuICAgIEZpbGUgPSBzaGltcy5GaWxlO1xuICAgIFJlYWRhYmxlU3RyZWFtID0gc2hpbXMuUmVhZGFibGVTdHJlYW07XG4gICAgZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMgPSBzaGltcy5nZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucztcbiAgICBnZXREZWZhdWx0QWdlbnQgPSBzaGltcy5nZXREZWZhdWx0QWdlbnQ7XG4gICAgZmlsZUZyb21QYXRoID0gc2hpbXMuZmlsZUZyb21QYXRoO1xuICAgIGlzRnNSZWFkU3RyZWFtID0gc2hpbXMuaXNGc1JlYWRTdHJlYW07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWdpc3RyeS5tanMubWFwIiwiLyoqXG4gKiBEaXNjbGFpbWVyOiBtb2R1bGVzIGluIF9zaGltcyBhcmVuJ3QgaW50ZW5kZWQgdG8gYmUgaW1wb3J0ZWQgYnkgU0RLIHVzZXJzLlxuICovXG5leHBvcnQgY2xhc3MgTXVsdGlwYXJ0Qm9keSB7XG4gICAgY29uc3RydWN0b3IoYm9keSkge1xuICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIH1cbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiAnTXVsdGlwYXJ0Qm9keSc7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TXVsdGlwYXJ0Qm9keS5tanMubWFwIiwiaW1wb3J0IHsgTXVsdGlwYXJ0Qm9keSB9IGZyb20gXCIuL011bHRpcGFydEJvZHkubWpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UnVudGltZSh7IG1hbnVhbGx5SW1wb3J0ZWQgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVjb21tZW5kYXRpb24gPSBtYW51YWxseUltcG9ydGVkID9cbiAgICAgICAgYFlvdSBtYXkgbmVlZCB0byB1c2UgcG9seWZpbGxzYFxuICAgICAgICA6IGBBZGQgb25lIG9mIHRoZXNlIGltcG9ydHMgYmVmb3JlIHlvdXIgZmlyc3QgXFxgaW1wb3J0IOKApiBmcm9tICdvcGVuYWknXFxgOlxuLSBcXGBpbXBvcnQgJ29wZW5haS9zaGltcy9ub2RlJ1xcYCAoaWYgeW91J3JlIHJ1bm5pbmcgb24gTm9kZSlcbi0gXFxgaW1wb3J0ICdvcGVuYWkvc2hpbXMvd2ViJ1xcYCAob3RoZXJ3aXNlKVxuYDtcbiAgICBsZXQgX2ZldGNoLCBfUmVxdWVzdCwgX1Jlc3BvbnNlLCBfSGVhZGVycztcbiAgICB0cnkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIF9mZXRjaCA9IGZldGNoO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIF9SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBfUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBfSGVhZGVycyA9IEhlYWRlcnM7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRoaXMgZW52aXJvbm1lbnQgaXMgbWlzc2luZyB0aGUgZm9sbG93aW5nIFdlYiBGZXRjaCBBUEkgdHlwZTogJHtlcnJvci5tZXNzYWdlfS4gJHtyZWNvbW1lbmRhdGlvbn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogJ3dlYicsXG4gICAgICAgIGZldGNoOiBfZmV0Y2gsXG4gICAgICAgIFJlcXVlc3Q6IF9SZXF1ZXN0LFxuICAgICAgICBSZXNwb25zZTogX1Jlc3BvbnNlLFxuICAgICAgICBIZWFkZXJzOiBfSGVhZGVycyxcbiAgICAgICAgRm9ybURhdGE6IFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBGb3JtRGF0YSA6IChjbGFzcyBGb3JtRGF0YSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZpbGUgdXBsb2FkcyBhcmVuJ3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQgeWV0IGFzICdGb3JtRGF0YScgaXMgdW5kZWZpbmVkLiAke3JlY29tbWVuZGF0aW9ufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgQmxvYjogdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnID8gQmxvYiA6IChjbGFzcyBCbG9iIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZmlsZSB1cGxvYWRzIGFyZW4ndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCB5ZXQgYXMgJ0Jsb2InIGlzIHVuZGVmaW5lZC4gJHtyZWNvbW1lbmRhdGlvbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIEZpbGU6IFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyA/IEZpbGUgOiAoY2xhc3MgRmlsZSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZpbGUgdXBsb2FkcyBhcmVuJ3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQgeWV0IGFzICdGaWxlJyBpcyB1bmRlZmluZWQuICR7cmVjb21tZW5kYXRpb259YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBSZWFkYWJsZVN0cmVhbTogXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdHlwZW9mIFJlYWRhYmxlU3RyZWFtICE9PSAndW5kZWZpbmVkJyA/IFJlYWRhYmxlU3RyZWFtIDogKGNsYXNzIFJlYWRhYmxlU3RyZWFtIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3RyZWFtaW5nIGlzbid0IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50IHlldCBhcyAnUmVhZGFibGVTdHJlYW0nIGlzIHVuZGVmaW5lZC4gJHtyZWNvbW1lbmRhdGlvbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zOiBhc3luYyAoXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZm9ybSwgb3B0cykgPT4gKHtcbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICBib2R5OiBuZXcgTXVsdGlwYXJ0Qm9keShmb3JtKSxcbiAgICAgICAgfSksXG4gICAgICAgIGdldERlZmF1bHRBZ2VudDogKHVybCkgPT4gdW5kZWZpbmVkLFxuICAgICAgICBmaWxlRnJvbVBhdGg6ICgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGBmaWxlRnJvbVBhdGhgIGZ1bmN0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGluIE5vZGUuIFNlZSB0aGUgUkVBRE1FIGZvciBtb3JlIGRldGFpbHM6IGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlI2ZpbGUtdXBsb2FkcycpO1xuICAgICAgICB9LFxuICAgICAgICBpc0ZzUmVhZFN0cmVhbTogKHZhbHVlKSA9PiBmYWxzZSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViLXJ1bnRpbWUubWpzLm1hcCIsIi8qKlxuICogRGlzY2xhaW1lcjogbW9kdWxlcyBpbiBfc2hpbXMgYXJlbid0IGludGVuZGVkIHRvIGJlIGltcG9ydGVkIGJ5IFNESyB1c2Vycy5cbiAqL1xuaW1wb3J0ICogYXMgc2hpbXMgZnJvbSAnLi9yZWdpc3RyeS5tanMnO1xuaW1wb3J0ICogYXMgYXV0byBmcm9tICdvcGVuYWkvX3NoaW1zL2F1dG8vcnVudGltZSc7XG5pZiAoIXNoaW1zLmtpbmQpIHNoaW1zLnNldFNoaW1zKGF1dG8uZ2V0UnVudGltZSgpLCB7IGF1dG86IHRydWUgfSk7XG5leHBvcnQgKiBmcm9tICcuL3JlZ2lzdHJ5Lm1qcyc7XG4iLCJpbXBvcnQgeyBSZWFkYWJsZVN0cmVhbSB9IGZyb20gXCIuL19zaGltcy9pbmRleC5tanNcIjtcbmltcG9ydCB7IE9wZW5BSUVycm9yIH0gZnJvbSBcIi4vZXJyb3IubWpzXCI7XG5pbXBvcnQgeyBBUElFcnJvciB9IGZyb20gJ29wZW5haS9lcnJvcic7XG5leHBvcnQgY2xhc3MgU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVyYXRvciwgY29udHJvbGxlcikge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRlcmF0b3I7XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU1NFUmVzcG9uc2UocmVzcG9uc2UsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgbGV0IGNvbnN1bWVkID0gZmFsc2U7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBpdGVyYXRvcigpIHtcbiAgICAgICAgICAgIGlmIChjb25zdW1lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGl0ZXJhdGUgb3ZlciBhIGNvbnN1bWVkIHN0cmVhbSwgdXNlIGAudGVlKClgIHRvIHNwbGl0IHRoZSBzdHJlYW0uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdW1lZCA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHNzZSBvZiBfaXRlclNTRU1lc3NhZ2VzKHJlc3BvbnNlLCBjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3NlLmRhdGEuc3RhcnRzV2l0aCgnW0RPTkVdJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNzZS5ldmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHNzZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IHBhcnNlIG1lc3NhZ2UgaW50byBKU09OOmAsIHNzZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGcm9tIGNodW5rOmAsIHNzZS5yYXcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKHVuZGVmaW5lZCwgZGF0YS5lcnJvciwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShzc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBwYXJzZSBtZXNzYWdlIGludG8gSlNPTjpgLCBzc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRnJvbSBjaHVuazpgLCBzc2UucmF3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogSXMgdGhpcyB3aGVyZSB0aGUgZXJyb3Igc2hvdWxkIGJlIHRocm93bj9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzc2UuZXZlbnQgPT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBUElFcnJvcih1bmRlZmluZWQsIGRhdGEuZXJyb3IsIGRhdGEubWVzc2FnZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHsgZXZlbnQ6IHNzZS5ldmVudCwgZGF0YTogZGF0YSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBjYWxscyBgc3RyZWFtLmNvbnRyb2xsZXIuYWJvcnQoKWAsIHdlIHNob3VsZCBleGl0IHdpdGhvdXQgdGhyb3dpbmcuXG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm5hbWUgPT09ICdBYm9ydEVycm9yJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBgYnJlYWtgcywgYWJvcnQgdGhlIG9uZ29pbmcgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShpdGVyYXRvciwgY29udHJvbGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFN0cmVhbSBmcm9tIGEgbmV3bGluZS1zZXBhcmF0ZWQgUmVhZGFibGVTdHJlYW1cbiAgICAgKiB3aGVyZSBlYWNoIGl0ZW0gaXMgYSBKU09OIHZhbHVlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgbGV0IGNvbnN1bWVkID0gZmFsc2U7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBpdGVyTGluZXMoKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lRGVjb2RlciA9IG5ldyBMaW5lRGVjb2RlcigpO1xuICAgICAgICAgICAgY29uc3QgaXRlciA9IHJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYWJsZShyZWFkYWJsZVN0cmVhbSk7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGl0ZXIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZGVjb2RlKGNodW5rKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBsaW5lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5mbHVzaCgpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiogaXRlcmF0b3IoKSB7XG4gICAgICAgICAgICBpZiAoY29uc3VtZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpdGVyYXRlIG92ZXIgYSBjb25zdW1lZCBzdHJlYW0sIHVzZSBgLnRlZSgpYCB0byBzcGxpdCB0aGUgc3RyZWFtLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3VtZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBsaW5lIG9mIGl0ZXJMaW5lcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lKVxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgSlNPTi5wYXJzZShsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGNhbGxzIGBzdHJlYW0uY29udHJvbGxlci5hYm9ydCgpYCwgd2Ugc2hvdWxkIGV4aXQgd2l0aG91dCB0aHJvd2luZy5cbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubmFtZSA9PT0gJ0Fib3J0RXJyb3InKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGBicmVha2BzLCBhYm9ydCB0aGUgb25nb2luZyByZXF1ZXN0LlxuICAgICAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKGl0ZXJhdG9yLCBjb250cm9sbGVyKTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BsaXRzIHRoZSBzdHJlYW0gaW50byB0d28gc3RyZWFtcyB3aGljaCBjYW4gYmVcbiAgICAgKiBpbmRlcGVuZGVudGx5IHJlYWQgZnJvbSBhdCBkaWZmZXJlbnQgc3BlZWRzLlxuICAgICAqL1xuICAgIHRlZSgpIHtcbiAgICAgICAgY29uc3QgbGVmdCA9IFtdO1xuICAgICAgICBjb25zdCByaWdodCA9IFtdO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgY29uc3QgdGVlSXRlcmF0b3IgPSAocXVldWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBTdHJlYW0oKCkgPT4gdGVlSXRlcmF0b3IobGVmdCksIHRoaXMuY29udHJvbGxlciksXG4gICAgICAgICAgICBuZXcgU3RyZWFtKCgpID0+IHRlZUl0ZXJhdG9yKHJpZ2h0KSwgdGhpcy5jb250cm9sbGVyKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBzdHJlYW0gdG8gYSBuZXdsaW5lLXNlcGFyYXRlZCBSZWFkYWJsZVN0cmVhbSBvZlxuICAgICAqIEpTT04gc3RyaW5naWZpZWQgdmFsdWVzIGluIHRoZSBzdHJlYW1cbiAgICAgKiB3aGljaCBjYW4gYmUgdHVybmVkIGJhY2sgaW50byBhIFN0cmVhbSB3aXRoIGBTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKClgLlxuICAgICAqL1xuICAgIHRvUmVhZGFibGVTdHJlYW0oKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgaXRlcjtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICAgICAgICAgIGl0ZXIgPSBzZWxmW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jIHB1bGwoY3RybCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGl0ZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHJsLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmVucXVldWUoYnl0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGl0ZXIucmV0dXJuPy4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogX2l0ZXJTU0VNZXNzYWdlcyhyZXNwb25zZSwgY29udHJvbGxlcikge1xuICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgQXR0ZW1wdGVkIHRvIGl0ZXJhdGUgb3ZlciBhIHJlc3BvbnNlIHdpdGggbm8gYm9keWApO1xuICAgIH1cbiAgICBjb25zdCBzc2VEZWNvZGVyID0gbmV3IFNTRURlY29kZXIoKTtcbiAgICBjb25zdCBsaW5lRGVjb2RlciA9IG5ldyBMaW5lRGVjb2RlcigpO1xuICAgIGNvbnN0IGl0ZXIgPSByZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmFibGUocmVzcG9uc2UuYm9keSk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBzc2VDaHVuayBvZiBpdGVyU1NFQ2h1bmtzKGl0ZXIpKSB7XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5kZWNvZGUoc3NlQ2h1bmspKSB7XG4gICAgICAgICAgICBjb25zdCBzc2UgPSBzc2VEZWNvZGVyLmRlY29kZShsaW5lKTtcbiAgICAgICAgICAgIGlmIChzc2UpXG4gICAgICAgICAgICAgICAgeWllbGQgc3NlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5mbHVzaCgpKSB7XG4gICAgICAgIGNvbnN0IHNzZSA9IHNzZURlY29kZXIuZGVjb2RlKGxpbmUpO1xuICAgICAgICBpZiAoc3NlKVxuICAgICAgICAgICAgeWllbGQgc3NlO1xuICAgIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gYXN5bmMgaXRlcmFibGUgaXRlcmF0b3IsIGl0ZXJhdGVzIG92ZXIgaXQgYW5kIHlpZWxkcyBmdWxsXG4gKiBTU0UgY2h1bmtzLCBpLmUuIHlpZWxkcyB3aGVuIGEgZG91YmxlIG5ldy1saW5lIGlzIGVuY291bnRlcmVkLlxuICovXG5hc3luYyBmdW5jdGlvbiogaXRlclNTRUNodW5rcyhpdGVyYXRvcikge1xuICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgIGlmIChjaHVuayA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiaW5hcnlDaHVuayA9IGNodW5rIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgVWludDhBcnJheShjaHVuaylcbiAgICAgICAgICAgIDogdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShjaHVuaylcbiAgICAgICAgICAgICAgICA6IGNodW5rO1xuICAgICAgICBsZXQgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgYmluYXJ5Q2h1bmsubGVuZ3RoKTtcbiAgICAgICAgbmV3RGF0YS5zZXQoZGF0YSk7XG4gICAgICAgIG5ld0RhdGEuc2V0KGJpbmFyeUNodW5rLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgIGRhdGEgPSBuZXdEYXRhO1xuICAgICAgICBsZXQgcGF0dGVybkluZGV4O1xuICAgICAgICB3aGlsZSAoKHBhdHRlcm5JbmRleCA9IGZpbmREb3VibGVOZXdsaW5lSW5kZXgoZGF0YSkpICE9PSAtMSkge1xuICAgICAgICAgICAgeWllbGQgZGF0YS5zbGljZSgwLCBwYXR0ZXJuSW5kZXgpO1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UocGF0dGVybkluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHlpZWxkIGRhdGE7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZERvdWJsZU5ld2xpbmVJbmRleChidWZmZXIpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHNlYXJjaGVzIHRoZSBidWZmZXIgZm9yIHRoZSBlbmQgcGF0dGVybnMgKFxcclxcciwgXFxuXFxuLCBcXHJcXG5cXHJcXG4pXG4gICAgLy8gYW5kIHJldHVybnMgdGhlIGluZGV4IHJpZ2h0IGFmdGVyIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFueSBwYXR0ZXJuLFxuICAgIC8vIG9yIC0xIGlmIG5vbmUgb2YgdGhlIHBhdHRlcm5zIGFyZSBmb3VuZC5cbiAgICBjb25zdCBuZXdsaW5lID0gMHgwYTsgLy8gXFxuXG4gICAgY29uc3QgY2FycmlhZ2UgPSAweDBkOyAvLyBcXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gbmV3bGluZSAmJiBidWZmZXJbaSArIDFdID09PSBuZXdsaW5lKSB7XG4gICAgICAgICAgICAvLyBcXG5cXG5cbiAgICAgICAgICAgIHJldHVybiBpICsgMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyW2ldID09PSBjYXJyaWFnZSAmJiBidWZmZXJbaSArIDFdID09PSBjYXJyaWFnZSkge1xuICAgICAgICAgICAgLy8gXFxyXFxyXG4gICAgICAgICAgICByZXR1cm4gaSArIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gY2FycmlhZ2UgJiZcbiAgICAgICAgICAgIGJ1ZmZlcltpICsgMV0gPT09IG5ld2xpbmUgJiZcbiAgICAgICAgICAgIGkgKyAzIDwgYnVmZmVyLmxlbmd0aCAmJlxuICAgICAgICAgICAgYnVmZmVyW2kgKyAyXSA9PT0gY2FycmlhZ2UgJiZcbiAgICAgICAgICAgIGJ1ZmZlcltpICsgM10gPT09IG5ld2xpbmUpIHtcbiAgICAgICAgICAgIC8vIFxcclxcblxcclxcblxuICAgICAgICAgICAgcmV0dXJuIGkgKyA0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmNsYXNzIFNTRURlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmV2ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgfVxuICAgIGRlY29kZShsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmVuZHNXaXRoKCdcXHInKSkge1xuICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyaW5nKDAsIGxpbmUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBsaW5lIGFuZCB3ZSBkaWRuJ3QgcHJldmlvdXNseSBlbmNvdW50ZXIgYW55IG1lc3NhZ2VzXG4gICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnQgJiYgIXRoaXMuZGF0YS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCBzc2UgPSB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgICAgIHJhdzogdGhpcy5jaHVua3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5ldmVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgICAgICByZXR1cm4gc3NlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobGluZSk7XG4gICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJzonKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFtmaWVsZG5hbWUsIF8sIHZhbHVlXSA9IHBhcnRpdGlvbihsaW5lLCAnOicpO1xuICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnICcpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRuYW1lID09PSAnZXZlbnQnKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGRuYW1lID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vKipcbiAqIEEgcmUtaW1wbGVtZW50YXRpb24gb2YgaHR0cHgncyBgTGluZURlY29kZXJgIGluIFB5dGhvbiB0aGF0IGhhbmRsZXMgaW5jcmVtZW50YWxseVxuICogcmVhZGluZyBsaW5lcyBmcm9tIHRleHQuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2VuY29kZS9odHRweC9ibG9iLzkyMDMzM2VhOTgxMThlOWNmNjE3ZjI0NjkwNWQ3YjIwMjUxMDk0MWMvaHR0cHgvX2RlY29kZXJzLnB5I0wyNThcbiAqL1xuY2xhc3MgTGluZURlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnRyYWlsaW5nQ1IgPSBmYWxzZTtcbiAgICB9XG4gICAgZGVjb2RlKGNodW5rKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gdGhpcy5kZWNvZGVUZXh0KGNodW5rKTtcbiAgICAgICAgaWYgKHRoaXMudHJhaWxpbmdDUikge1xuICAgICAgICAgICAgdGV4dCA9ICdcXHInICsgdGV4dDtcbiAgICAgICAgICAgIHRoaXMudHJhaWxpbmdDUiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0LmVuZHNXaXRoKCdcXHInKSkge1xuICAgICAgICAgICAgdGhpcy50cmFpbGluZ0NSID0gdHJ1ZTtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFpbGluZ05ld2xpbmUgPSBMaW5lRGVjb2Rlci5ORVdMSU5FX0NIQVJTLmhhcyh0ZXh0W3RleHQubGVuZ3RoIC0gMV0gfHwgJycpO1xuICAgICAgICBsZXQgbGluZXMgPSB0ZXh0LnNwbGl0KExpbmVEZWNvZGVyLk5FV0xJTkVfUkVHRVhQKTtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSB0cmFpbGluZyBuZXcgbGluZSB0aGVuIHRoZSBsYXN0IGVudHJ5IHdpbGwgYmUgYW4gZW1wdHlcbiAgICAgICAgLy8gc3RyaW5nIHdoaWNoIHdlIGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgaWYgKHRyYWlsaW5nTmV3bGluZSkge1xuICAgICAgICAgICAgbGluZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSAmJiAhdHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGxpbmVzWzBdKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGluZXMgPSBbdGhpcy5idWZmZXIuam9pbignJykgKyBsaW5lc1swXSwgLi4ubGluZXMuc2xpY2UoMSldO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRyYWlsaW5nTmV3bGluZSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBbbGluZXMucG9wKCkgfHwgJyddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG4gICAgZGVjb2RlVGV4dChieXRlcykge1xuICAgICAgICBpZiAoYnl0ZXMgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICAgIC8vIE5vZGU6XG4gICAgICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ5dGVzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBVbmV4cGVjdGVkOiByZWNlaXZlZCBub24tVWludDhBcnJheSAoJHtieXRlcy5jb25zdHJ1Y3Rvci5uYW1lfSkgc3RyZWFtIGNodW5rIGluIGFuIGVudmlyb25tZW50IHdpdGggYSBnbG9iYWwgXCJCdWZmZXJcIiBkZWZpbmVkLCB3aGljaCB0aGlzIGxpYnJhcnkgYXNzdW1lcyB0byBiZSBOb2RlLiBQbGVhc2UgcmVwb3J0IHRoaXMgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnJvd3NlclxuICAgICAgICBpZiAodHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBieXRlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0RGVjb2RlciA/PyAodGhpcy50ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0RGVjb2Rlci5kZWNvZGUoYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBVbmV4cGVjdGVkOiByZWNlaXZlZCBub24tVWludDhBcnJheS9BcnJheUJ1ZmZlciAoJHtieXRlcy5jb25zdHJ1Y3Rvci5uYW1lfSkgaW4gYSB3ZWIgcGxhdGZvcm0uIFBsZWFzZSByZXBvcnQgdGhpcyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYFVuZXhwZWN0ZWQ6IG5laXRoZXIgQnVmZmVyIG5vciBUZXh0RGVjb2RlciBhcmUgYXZhaWxhYmxlIGFzIGdsb2JhbHMuIFBsZWFzZSByZXBvcnQgdGhpcyBlcnJvci5gKTtcbiAgICB9XG4gICAgZmx1c2goKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIubGVuZ3RoICYmICF0aGlzLnRyYWlsaW5nQ1IpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lcyA9IFt0aGlzLmJ1ZmZlci5qb2luKCcnKV07XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIHRoaXMudHJhaWxpbmdDUiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxufVxuLy8gcHJldHRpZXItaWdub3JlXG5MaW5lRGVjb2Rlci5ORVdMSU5FX0NIQVJTID0gbmV3IFNldChbJ1xcbicsICdcXHInXSk7XG5MaW5lRGVjb2Rlci5ORVdMSU5FX1JFR0VYUCA9IC9cXHJcXG58W1xcblxccl0vZztcbi8qKiBUaGlzIGlzIGFuIGludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0aGF0J3MganVzdCB1c2VkIGZvciB0ZXN0aW5nICovXG5leHBvcnQgZnVuY3Rpb24gX2RlY29kZUNodW5rcyhjaHVua3MpIHtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IExpbmVEZWNvZGVyKCk7XG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgICAgICBsaW5lcy5wdXNoKC4uLmRlY29kZXIuZGVjb2RlKGNodW5rKSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbn1cbmZ1bmN0aW9uIHBhcnRpdGlvbihzdHIsIGRlbGltaXRlcikge1xuICAgIGNvbnN0IGluZGV4ID0gc3RyLmluZGV4T2YoZGVsaW1pdGVyKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbc3RyLnN1YnN0cmluZygwLCBpbmRleCksIGRlbGltaXRlciwgc3RyLnN1YnN0cmluZyhpbmRleCArIGRlbGltaXRlci5sZW5ndGgpXTtcbiAgICB9XG4gICAgcmV0dXJuIFtzdHIsICcnLCAnJ107XG59XG4vKipcbiAqIE1vc3QgYnJvd3NlcnMgZG9uJ3QgeWV0IGhhdmUgYXN5bmMgaXRlcmFibGUgc3VwcG9ydCBmb3IgUmVhZGFibGVTdHJlYW0sXG4gKiBhbmQgTm9kZSBoYXMgYSB2ZXJ5IGRpZmZlcmVudCB3YXkgb2YgcmVhZGluZyBieXRlcyBmcm9tIGl0cyBcIlJlYWRhYmxlU3RyZWFtXCIuXG4gKlxuICogVGhpcyBwb2x5ZmlsbCB3YXMgcHVsbGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL01hdHRpYXNCdWVsZW5zL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3B1bGwvMTIyI2lzc3VlY29tbWVudC0xNjI3MzU0NDkwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmFibGUoc3RyZWFtKSB7XG4gICAgaWYgKHN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pXG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdD8uZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayB3aGVuIHN0cmVhbSBiZWNvbWVzIGNsb3NlZFxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgd2hlbiBzdHJlYW0gYmVjb21lcyBlcnJvcmVkXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgcmV0dXJuKCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgYXdhaXQgY2FuY2VsUHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgfSxcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJlYW1pbmcubWpzLm1hcCIsImltcG9ydCB7IEZvcm1EYXRhLCBGaWxlLCBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucywgaXNGc1JlYWRTdHJlYW0sIH0gZnJvbSBcIi4vX3NoaW1zL2luZGV4Lm1qc1wiO1xuZXhwb3J0IHsgZmlsZUZyb21QYXRoIH0gZnJvbSBcIi4vX3NoaW1zL2luZGV4Lm1qc1wiO1xuZXhwb3J0IGNvbnN0IGlzUmVzcG9uc2VMaWtlID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsICYmXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB2YWx1ZS51cmwgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIHZhbHVlLmJsb2IgPT09ICdmdW5jdGlvbic7XG5leHBvcnQgY29uc3QgaXNGaWxlTGlrZSA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdmFsdWUubmFtZSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgdmFsdWUubGFzdE1vZGlmaWVkID09PSAnbnVtYmVyJyAmJlxuICAgIGlzQmxvYkxpa2UodmFsdWUpO1xuLyoqXG4gKiBUaGUgQmxvYkxpa2UgdHlwZSBvbWl0cyBhcnJheUJ1ZmZlcigpIGJlY2F1c2UgQHR5cGVzL25vZGUtZmV0Y2hAXjIuNi40IGxhY2tzIGl0OyBidXQgdGhpcyBjaGVja1xuICogYWRkcyB0aGUgYXJyYXlCdWZmZXIoKSBtZXRob2QgdHlwZSBiZWNhdXNlIGl0IGlzIGF2YWlsYWJsZSBhbmQgdXNlZCBhdCBydW50aW1lXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Jsb2JMaWtlID0gKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsICYmXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5zaXplID09PSAnbnVtYmVyJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS50eXBlID09PSAnc3RyaW5nJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS50ZXh0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbHVlLnNsaWNlID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbHVlLmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0IGNvbnN0IGlzVXBsb2FkYWJsZSA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBpc0ZpbGVMaWtlKHZhbHVlKSB8fCBpc1Jlc3BvbnNlTGlrZSh2YWx1ZSkgfHwgaXNGc1JlYWRTdHJlYW0odmFsdWUpO1xufTtcbi8qKlxuICogSGVscGVyIGZvciBjcmVhdGluZyBhIHtAbGluayBGaWxlfSB0byBwYXNzIHRvIGFuIFNESyB1cGxvYWQgbWV0aG9kIGZyb20gYSB2YXJpZXR5IG9mIGRpZmZlcmVudCBkYXRhIGZvcm1hdHNcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgcmF3IGNvbnRlbnQgb2YgdGhlIGZpbGUuICBDYW4gYmUgYW4ge0BsaW5rIFVwbG9hZGFibGV9LCB7QGxpbmsgQmxvYkxpa2VQYXJ0fSwgb3Ige0BsaW5rIEFzeW5jSXRlcmFibGV9IG9mIHtAbGluayBCbG9iTGlrZVBhcnR9c1xuICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlLiBJZiBvbWl0dGVkLCB0b0ZpbGUgd2lsbCB0cnkgdG8gZGV0ZXJtaW5lIGEgZmlsZSBuYW1lIGZyb20gYml0cyBpZiBwb3NzaWJsZVxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLnR5cGUgdGhlIE1JTUUgdHlwZSBvZiB0aGUgY29udGVudFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRpb25zLmxhc3RNb2RpZmllZCB0aGUgbGFzdCBtb2RpZmllZCB0aW1lc3RhbXBcbiAqIEByZXR1cm5zIGEge0BsaW5rIEZpbGV9IHdpdGggdGhlIGdpdmVuIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRvRmlsZSh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xuICAgIC8vIElmIGl0J3MgYSBwcm9taXNlLCByZXNvbHZlIGl0LlxuICAgIHZhbHVlID0gYXdhaXQgdmFsdWU7XG4gICAgLy8gVXNlIHRoZSBmaWxlJ3Mgb3B0aW9ucyBpZiB0aGVyZSBpc24ndCBvbmUgcHJvdmlkZWRcbiAgICBvcHRpb25zID8/IChvcHRpb25zID0gaXNGaWxlTGlrZSh2YWx1ZSkgPyB7IGxhc3RNb2RpZmllZDogdmFsdWUubGFzdE1vZGlmaWVkLCB0eXBlOiB2YWx1ZS50eXBlIH0gOiB7fSk7XG4gICAgaWYgKGlzUmVzcG9uc2VMaWtlKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgdmFsdWUuYmxvYigpO1xuICAgICAgICBuYW1lIHx8IChuYW1lID0gbmV3IFVSTCh2YWx1ZS51cmwpLnBhdGhuYW1lLnNwbGl0KC9bXFxcXC9dLykucG9wKCkgPz8gJ3Vua25vd25fZmlsZScpO1xuICAgICAgICByZXR1cm4gbmV3IEZpbGUoW2Jsb2JdLCBuYW1lLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgYml0cyA9IGF3YWl0IGdldEJ5dGVzKHZhbHVlKTtcbiAgICBuYW1lIHx8IChuYW1lID0gZ2V0TmFtZSh2YWx1ZSkgPz8gJ3Vua25vd25fZmlsZScpO1xuICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBiaXRzWzBdPy50eXBlO1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCB0eXBlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGaWxlKGJpdHMsIG5hbWUsIG9wdGlvbnMpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0Qnl0ZXModmFsdWUpIHtcbiAgICBsZXQgcGFydHMgPSBbXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpIHx8IC8vIGluY2x1ZGVzIFVpbnQ4QXJyYXksIEJ1ZmZlciwgZXRjLlxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHBhcnRzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Jsb2JMaWtlKHZhbHVlKSkge1xuICAgICAgICBwYXJ0cy5wdXNoKGF3YWl0IHZhbHVlLmFycmF5QnVmZmVyKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FzeW5jSXRlcmFibGVJdGVyYXRvcih2YWx1ZSkgLy8gaW5jbHVkZXMgUmVhZGFibGUsIFJlYWRhYmxlU3RyZWFtLCBldGMuXG4gICAgKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goY2h1bmspOyAvLyBUT0RPLCBjb25zaWRlciB2YWxpZGF0aW5nP1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZGF0YSB0eXBlOiAke3R5cGVvZiB2YWx1ZX07IGNvbnN0cnVjdG9yOiAke3ZhbHVlPy5jb25zdHJ1Y3RvclxuICAgICAgICAgICAgPy5uYW1lfTsgcHJvcHM6ICR7cHJvcHNGb3JFcnJvcih2YWx1ZSl9YCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cztcbn1cbmZ1bmN0aW9uIHByb3BzRm9yRXJyb3IodmFsdWUpIHtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgICByZXR1cm4gYFske3Byb3BzLm1hcCgocCkgPT4gYFwiJHtwfVwiYCkuam9pbignLCAnKX1dYDtcbn1cbmZ1bmN0aW9uIGdldE5hbWUodmFsdWUpIHtcbiAgICByZXR1cm4gKGdldFN0cmluZ0Zyb21NYXliZUJ1ZmZlcih2YWx1ZS5uYW1lKSB8fFxuICAgICAgICBnZXRTdHJpbmdGcm9tTWF5YmVCdWZmZXIodmFsdWUuZmlsZW5hbWUpIHx8XG4gICAgICAgIC8vIEZvciBmcy5SZWFkU3RyZWFtXG4gICAgICAgIGdldFN0cmluZ0Zyb21NYXliZUJ1ZmZlcih2YWx1ZS5wYXRoKT8uc3BsaXQoL1tcXFxcL10vKS5wb3AoKSk7XG59XG5jb25zdCBnZXRTdHJpbmdGcm9tTWF5YmVCdWZmZXIgPSAoeCkgPT4ge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB4O1xuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgQnVmZmVyKVxuICAgICAgICByZXR1cm4gU3RyaW5nKHgpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuY29uc3QgaXNBc3luY0l0ZXJhYmxlSXRlcmF0b3IgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0IGNvbnN0IGlzTXVsdGlwYXJ0Qm9keSA9IChib2R5KSA9PiBib2R5ICYmIHR5cGVvZiBib2R5ID09PSAnb2JqZWN0JyAmJiBib2R5LmJvZHkgJiYgYm9keVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTXVsdGlwYXJ0Qm9keSc7XG4vKipcbiAqIFJldHVybnMgYSBtdWx0aXBhcnQvZm9ybS1kYXRhIHJlcXVlc3QgaWYgYW55IHBhcnQgb2YgdGhlIGdpdmVuIHJlcXVlc3QgYm9keSBjb250YWlucyBhIEZpbGUgLyBCbG9iIHZhbHVlLlxuICogT3RoZXJ3aXNlIHJldHVybnMgdGhlIHJlcXVlc3QgYXMgaXMuXG4gKi9cbmV4cG9ydCBjb25zdCBtYXliZU11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyA9IGFzeW5jIChvcHRzKSA9PiB7XG4gICAgaWYgKCFoYXNVcGxvYWRhYmxlVmFsdWUob3B0cy5ib2R5KSlcbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgY29uc3QgZm9ybSA9IGF3YWl0IGNyZWF0ZUZvcm0ob3B0cy5ib2R5KTtcbiAgICByZXR1cm4gZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMoZm9ybSwgb3B0cyk7XG59O1xuZXhwb3J0IGNvbnN0IG11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyA9IGFzeW5jIChvcHRzKSA9PiB7XG4gICAgY29uc3QgZm9ybSA9IGF3YWl0IGNyZWF0ZUZvcm0ob3B0cy5ib2R5KTtcbiAgICByZXR1cm4gZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMoZm9ybSwgb3B0cyk7XG59O1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUZvcm0gPSBhc3luYyAoYm9keSkgPT4ge1xuICAgIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyhib2R5IHx8IHt9KS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYWRkRm9ybVZhbHVlKGZvcm0sIGtleSwgdmFsdWUpKSk7XG4gICAgcmV0dXJuIGZvcm07XG59O1xuY29uc3QgaGFzVXBsb2FkYWJsZVZhbHVlID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKGlzVXBsb2FkYWJsZSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNvbWUoaGFzVXBsb2FkYWJsZVZhbHVlKTtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChoYXNVcGxvYWRhYmxlVmFsdWUodmFsdWVba10pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBhZGRGb3JtVmFsdWUgPSBhc3luYyAoZm9ybSwga2V5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUmVjZWl2ZWQgbnVsbCBmb3IgXCIke2tleX1cIjsgdG8gcGFzcyBudWxsIGluIEZvcm1EYXRhLCB5b3UgbXVzdCB1c2UgdGhlIHN0cmluZyAnbnVsbCdgKTtcbiAgICB9XG4gICAgLy8gVE9ETzogbWFrZSBuZXN0ZWQgZm9ybWF0cyBjb25maWd1cmFibGVcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGZvcm0uYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzVXBsb2FkYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IHRvRmlsZSh2YWx1ZSk7XG4gICAgICAgIGZvcm0uYXBwZW5kKGtleSwgZmlsZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHZhbHVlLm1hcCgoZW50cnkpID0+IGFkZEZvcm1WYWx1ZShmb3JtLCBrZXkgKyAnW10nLCBlbnRyeSkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyh2YWx1ZSkubWFwKChbbmFtZSwgcHJvcF0pID0+IGFkZEZvcm1WYWx1ZShmb3JtLCBgJHtrZXl9WyR7bmFtZX1dYCwgcHJvcCkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgdmFsdWUgZ2l2ZW4gdG8gZm9ybSwgZXhwZWN0ZWQgYSBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb2JqZWN0LCBBcnJheSwgRmlsZSBvciBCbG9iIGJ1dCBnb3QgJHt2YWx1ZX0gaW5zdGVhZGApO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cGxvYWRzLm1qcy5tYXAiLCJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0Fic3RyYWN0UGFnZV9jbGllbnQ7XG5pbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSBcIi4vdmVyc2lvbi5tanNcIjtcbmltcG9ydCB7IFN0cmVhbSB9IGZyb20gXCIuL3N0cmVhbWluZy5tanNcIjtcbmltcG9ydCB7IE9wZW5BSUVycm9yLCBBUElFcnJvciwgQVBJQ29ubmVjdGlvbkVycm9yLCBBUElDb25uZWN0aW9uVGltZW91dEVycm9yLCBBUElVc2VyQWJvcnRFcnJvciwgfSBmcm9tIFwiLi9lcnJvci5tanNcIjtcbmltcG9ydCB7IGtpbmQgYXMgc2hpbXNLaW5kLCBnZXREZWZhdWx0QWdlbnQsIGZldGNoLCB9IGZyb20gXCIuL19zaGltcy9pbmRleC5tanNcIjtcbmltcG9ydCB7IGlzQmxvYkxpa2UsIGlzTXVsdGlwYXJ0Qm9keSB9IGZyb20gXCIuL3VwbG9hZHMubWpzXCI7XG5leHBvcnQgeyBtYXliZU11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucywgbXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zLCBjcmVhdGVGb3JtLCB9IGZyb20gXCIuL3VwbG9hZHMubWpzXCI7XG5hc3luYyBmdW5jdGlvbiBkZWZhdWx0UGFyc2VSZXNwb25zZShwcm9wcykge1xuICAgIGNvbnN0IHsgcmVzcG9uc2UgfSA9IHByb3BzO1xuICAgIGlmIChwcm9wcy5vcHRpb25zLnN0cmVhbSkge1xuICAgICAgICBkZWJ1ZygncmVzcG9uc2UnLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnVybCwgcmVzcG9uc2UuaGVhZGVycywgcmVzcG9uc2UuYm9keSk7XG4gICAgICAgIC8vIE5vdGU6IHRoZXJlIGlzIGFuIGludmFyaWFudCBoZXJlIHRoYXQgaXNuJ3QgcmVwcmVzZW50ZWQgaW4gdGhlIHR5cGUgc3lzdGVtXG4gICAgICAgIC8vIHRoYXQgaWYgeW91IHNldCBgc3RyZWFtOiB0cnVlYCB0aGUgcmVzcG9uc2UgdHlwZSBtdXN0IGFsc28gYmUgYFN0cmVhbTxUPmBcbiAgICAgICAgaWYgKHByb3BzLm9wdGlvbnMuX19zdHJlYW1DbGFzcykge1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLm9wdGlvbnMuX19zdHJlYW1DbGFzcy5mcm9tU1NFUmVzcG9uc2UocmVzcG9uc2UsIHByb3BzLmNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJlYW0uZnJvbVNTRVJlc3BvbnNlKHJlc3BvbnNlLCBwcm9wcy5jb250cm9sbGVyKTtcbiAgICB9XG4gICAgLy8gZmV0Y2ggcmVmdXNlcyB0byByZWFkIHRoZSBib2R5IHdoZW4gdGhlIHN0YXR1cyBjb2RlIGlzIDIwNC5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwcm9wcy5vcHRpb25zLl9fYmluYXJ5UmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICBjb25zdCBpc0pTT04gPSBjb250ZW50VHlwZT8uaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSB8fCBjb250ZW50VHlwZT8uaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL3ZuZC5hcGkranNvbicpO1xuICAgIGlmIChpc0pTT04pIHtcbiAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgZGVidWcoJ3Jlc3BvbnNlJywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS51cmwsIHJlc3BvbnNlLmhlYWRlcnMsIGpzb24pO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICBkZWJ1ZygncmVzcG9uc2UnLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnVybCwgcmVzcG9uc2UuaGVhZGVycywgdGV4dCk7XG4gICAgLy8gVE9ETyBoYW5kbGUgYmxvYiwgYXJyYXlidWZmZXIsIG90aGVyIGNvbnRlbnQgdHlwZXMsIGV0Yy5cbiAgICByZXR1cm4gdGV4dDtcbn1cbi8qKlxuICogQSBzdWJjbGFzcyBvZiBgUHJvbWlzZWAgcHJvdmlkaW5nIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHNcbiAqIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBTREsuXG4gKi9cbmV4cG9ydCBjbGFzcyBBUElQcm9taXNlIGV4dGVuZHMgUHJvbWlzZSB7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2VQcm9taXNlLCBwYXJzZVJlc3BvbnNlID0gZGVmYXVsdFBhcnNlUmVzcG9uc2UpIHtcbiAgICAgICAgc3VwZXIoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbWF5YmUgYSBiaXQgd2VpcmQgYnV0IHRoaXMgaGFzIHRvIGJlIGEgbm8tb3AgdG8gbm90IGltcGxpY2l0bHlcbiAgICAgICAgICAgIC8vIHBhcnNlIHRoZSByZXNwb25zZSBib2R5OyBpbnN0ZWFkIC50aGVuLCAuY2F0Y2gsIC5maW5hbGx5IGFyZSBvdmVycmlkZGVuXG4gICAgICAgICAgICAvLyB0byBwYXJzZSB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlc3BvbnNlUHJvbWlzZSA9IHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgdGhpcy5wYXJzZVJlc3BvbnNlID0gcGFyc2VSZXNwb25zZTtcbiAgICB9XG4gICAgX3RoZW5VbndyYXAodHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiBuZXcgQVBJUHJvbWlzZSh0aGlzLnJlc3BvbnNlUHJvbWlzZSwgYXN5bmMgKHByb3BzKSA9PiB0cmFuc2Zvcm0oYXdhaXQgdGhpcy5wYXJzZVJlc3BvbnNlKHByb3BzKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByYXcgYFJlc3BvbnNlYCBpbnN0YW5jZSBpbnN0ZWFkIG9mIHBhcnNpbmcgdGhlIHJlc3BvbnNlXG4gICAgICogZGF0YS5cbiAgICAgKlxuICAgICAqIElmIHlvdSB3YW50IHRvIHBhcnNlIHRoZSByZXNwb25zZSBib2R5IGJ1dCBzdGlsbCBnZXQgdGhlIGBSZXNwb25zZWBcbiAgICAgKiBpbnN0YW5jZSwgeW91IGNhbiB1c2Uge0BsaW5rIHdpdGhSZXNwb25zZSgpfS5cbiAgICAgKlxuICAgICAqIPCfkYsgR2V0dGluZyB0aGUgd3JvbmcgVHlwZVNjcmlwdCB0eXBlIGZvciBgUmVzcG9uc2VgP1xuICAgICAqIFRyeSBzZXR0aW5nIGBcIm1vZHVsZVJlc29sdXRpb25cIjogXCJOb2RlTmV4dFwiYCBpZiB5b3UgY2FuLFxuICAgICAqIG9yIGFkZCBvbmUgb2YgdGhlc2UgaW1wb3J0cyBiZWZvcmUgeW91ciBmaXJzdCBgaW1wb3J0IOKApiBmcm9tICdvcGVuYWknYDpcbiAgICAgKiAtIGBpbXBvcnQgJ29wZW5haS9zaGltcy9ub2RlJ2AgKGlmIHlvdSdyZSBydW5uaW5nIG9uIE5vZGUpXG4gICAgICogLSBgaW1wb3J0ICdvcGVuYWkvc2hpbXMvd2ViJ2AgKG90aGVyd2lzZSlcbiAgICAgKi9cbiAgICBhc1Jlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZVByb21pc2UudGhlbigocCkgPT4gcC5yZXNwb25zZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBhcnNlZCByZXNwb25zZSBkYXRhIGFuZCB0aGUgcmF3IGBSZXNwb25zZWAgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBJZiB5b3UganVzdCB3YW50IHRvIGdldCB0aGUgcmF3IGBSZXNwb25zZWAgaW5zdGFuY2Ugd2l0aG91dCBwYXJzaW5nIGl0LFxuICAgICAqIHlvdSBjYW4gdXNlIHtAbGluayBhc1Jlc3BvbnNlKCl9LlxuICAgICAqXG4gICAgICpcbiAgICAgKiDwn5GLIEdldHRpbmcgdGhlIHdyb25nIFR5cGVTY3JpcHQgdHlwZSBmb3IgYFJlc3BvbnNlYD9cbiAgICAgKiBUcnkgc2V0dGluZyBgXCJtb2R1bGVSZXNvbHV0aW9uXCI6IFwiTm9kZU5leHRcImAgaWYgeW91IGNhbixcbiAgICAgKiBvciBhZGQgb25lIG9mIHRoZXNlIGltcG9ydHMgYmVmb3JlIHlvdXIgZmlyc3QgYGltcG9ydCDigKYgZnJvbSAnb3BlbmFpJ2A6XG4gICAgICogLSBgaW1wb3J0ICdvcGVuYWkvc2hpbXMvbm9kZSdgIChpZiB5b3UncmUgcnVubmluZyBvbiBOb2RlKVxuICAgICAqIC0gYGltcG9ydCAnb3BlbmFpL3NoaW1zL3dlYidgIChvdGhlcndpc2UpXG4gICAgICovXG4gICAgYXN5bmMgd2l0aFJlc3BvbnNlKCkge1xuICAgICAgICBjb25zdCBbZGF0YSwgcmVzcG9uc2VdID0gYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMucGFyc2UoKSwgdGhpcy5hc1Jlc3BvbnNlKCldKTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YSwgcmVzcG9uc2UgfTtcbiAgICB9XG4gICAgcGFyc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJzZWRQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFByb21pc2UgPSB0aGlzLnJlc3BvbnNlUHJvbWlzZS50aGVuKHRoaXMucGFyc2VSZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkUHJvbWlzZTtcbiAgICB9XG4gICAgdGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZSgpLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xuICAgIH1cbiAgICBjYXRjaChvbnJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlKCkuY2F0Y2gob25yZWplY3RlZCk7XG4gICAgfVxuICAgIGZpbmFsbHkob25maW5hbGx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlKCkuZmluYWxseShvbmZpbmFsbHkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBUElDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHsgYmFzZVVSTCwgbWF4UmV0cmllcyA9IDIsIHRpbWVvdXQgPSA2MDAwMDAsIC8vIDEwIG1pbnV0ZXNcbiAgICBodHRwQWdlbnQsIGZldGNoOiBvdmVycmlkZW5GZXRjaCwgfSkge1xuICAgICAgICB0aGlzLmJhc2VVUkwgPSBiYXNlVVJMO1xuICAgICAgICB0aGlzLm1heFJldHJpZXMgPSB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcignbWF4UmV0cmllcycsIG1heFJldHJpZXMpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcigndGltZW91dCcsIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLmh0dHBBZ2VudCA9IGh0dHBBZ2VudDtcbiAgICAgICAgdGhpcy5mZXRjaCA9IG92ZXJyaWRlbkZldGNoID8/IGZldGNoO1xuICAgIH1cbiAgICBhdXRoSGVhZGVycyhvcHRzKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyB0byBhZGQgeW91ciBvd24gZGVmYXVsdCBoZWFkZXJzLCBmb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqICB7XG4gICAgICogICAgLi4uc3VwZXIuZGVmYXVsdEhlYWRlcnMoKSxcbiAgICAgKiAgICBBdXRob3JpemF0aW9uOiAnQmVhcmVyIDEyMycsXG4gICAgICogIH1cbiAgICAgKi9cbiAgICBkZWZhdWx0SGVhZGVycyhvcHRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnVXNlci1BZ2VudCc6IHRoaXMuZ2V0VXNlckFnZW50KCksXG4gICAgICAgICAgICAuLi5nZXRQbGF0Zm9ybUhlYWRlcnMoKSxcbiAgICAgICAgICAgIC4uLnRoaXMuYXV0aEhlYWRlcnMob3B0cyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgdG8gYWRkIHlvdXIgb3duIGhlYWRlcnMgdmFsaWRhdGlvbjpcbiAgICAgKi9cbiAgICB2YWxpZGF0ZUhlYWRlcnMoaGVhZGVycywgY3VzdG9tSGVhZGVycykgeyB9XG4gICAgZGVmYXVsdElkZW1wb3RlbmN5S2V5KCkge1xuICAgICAgICByZXR1cm4gYHN0YWlubGVzcy1ub2RlLXJldHJ5LSR7dXVpZDQoKX1gO1xuICAgIH1cbiAgICBnZXQocGF0aCwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdnZXQnLCBwYXRoLCBvcHRzKTtcbiAgICB9XG4gICAgcG9zdChwYXRoLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoJ3Bvc3QnLCBwYXRoLCBvcHRzKTtcbiAgICB9XG4gICAgcGF0Y2gocGF0aCwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwYXRjaCcsIHBhdGgsIG9wdHMpO1xuICAgIH1cbiAgICBwdXQocGF0aCwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwdXQnLCBwYXRoLCBvcHRzKTtcbiAgICB9XG4gICAgZGVsZXRlKHBhdGgsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0aG9kUmVxdWVzdCgnZGVsZXRlJywgcGF0aCwgb3B0cyk7XG4gICAgfVxuICAgIG1ldGhvZFJlcXVlc3QobWV0aG9kLCBwYXRoLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoUHJvbWlzZS5yZXNvbHZlKG9wdHMpLnRoZW4oYXN5bmMgKG9wdHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBvcHRzICYmIGlzQmxvYkxpa2Uob3B0cz8uYm9keSkgPyBuZXcgRGF0YVZpZXcoYXdhaXQgb3B0cy5ib2R5LmFycmF5QnVmZmVyKCkpXG4gICAgICAgICAgICAgICAgOiBvcHRzPy5ib2R5IGluc3RhbmNlb2YgRGF0YVZpZXcgPyBvcHRzLmJvZHlcbiAgICAgICAgICAgICAgICAgICAgOiBvcHRzPy5ib2R5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgRGF0YVZpZXcob3B0cy5ib2R5KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvcHRzICYmIEFycmF5QnVmZmVyLmlzVmlldyhvcHRzPy5ib2R5KSA/IG5ldyBEYXRhVmlldyhvcHRzLmJvZHkuYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogb3B0cz8uYm9keTtcbiAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZCwgcGF0aCwgLi4ub3B0cywgYm9keSB9O1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGdldEFQSUxpc3QocGF0aCwgUGFnZSwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QVBJTGlzdChQYWdlLCB7IG1ldGhvZDogJ2dldCcsIHBhdGgsIC4uLm9wdHMgfSk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZUNvbnRlbnRMZW5ndGgoYm9keSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoYm9keSwgJ3V0ZjgnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZXIuZW5jb2RlKGJvZHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVkLmxlbmd0aC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhib2R5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGJvZHkuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBidWlsZFJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IG1ldGhvZCwgcGF0aCwgcXVlcnksIGhlYWRlcnM6IGhlYWRlcnMgPSB7fSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgYm9keSA9IEFycmF5QnVmZmVyLmlzVmlldyhvcHRpb25zLmJvZHkpIHx8IChvcHRpb25zLl9fYmluYXJ5UmVxdWVzdCAmJiB0eXBlb2Ygb3B0aW9ucy5ib2R5ID09PSAnc3RyaW5nJykgP1xuICAgICAgICAgICAgb3B0aW9ucy5ib2R5XG4gICAgICAgICAgICA6IGlzTXVsdGlwYXJ0Qm9keShvcHRpb25zLmJvZHkpID8gb3B0aW9ucy5ib2R5LmJvZHlcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMuYm9keSA/IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9keSwgbnVsbCwgMilcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gdGhpcy5jYWxjdWxhdGVDb250ZW50TGVuZ3RoKGJvZHkpO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmJ1aWxkVVJMKHBhdGgsIHF1ZXJ5KTtcbiAgICAgICAgaWYgKCd0aW1lb3V0JyBpbiBvcHRpb25zKVxuICAgICAgICAgICAgdmFsaWRhdGVQb3NpdGl2ZUludGVnZXIoJ3RpbWVvdXQnLCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0ID8/IHRoaXMudGltZW91dDtcbiAgICAgICAgY29uc3QgaHR0cEFnZW50ID0gb3B0aW9ucy5odHRwQWdlbnQgPz8gdGhpcy5odHRwQWdlbnQgPz8gZ2V0RGVmYXVsdEFnZW50KHVybCk7XG4gICAgICAgIGNvbnN0IG1pbkFnZW50VGltZW91dCA9IHRpbWVvdXQgKyAxMDAwO1xuICAgICAgICBpZiAodHlwZW9mIGh0dHBBZ2VudD8ub3B0aW9ucz8udGltZW91dCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIG1pbkFnZW50VGltZW91dCA+IChodHRwQWdlbnQub3B0aW9ucy50aW1lb3V0ID8/IDApKSB7XG4gICAgICAgICAgICAvLyBBbGxvdyBhbnkgZ2l2ZW4gcmVxdWVzdCB0byBidW1wIG91ciBhZ2VudCBhY3RpdmUgc29ja2V0IHRpbWVvdXQuXG4gICAgICAgICAgICAvLyBUaGlzIG1heSBzZWVtIHN0cmFuZ2UsIGJ1dCBsZWFraW5nIGFjdGl2ZSBzb2NrZXRzIHNob3VsZCBiZSByYXJlIGFuZCBub3QgcGFydGljdWxhcmx5IHByb2JsZW1hdGljLFxuICAgICAgICAgICAgLy8gYW5kIHdpdGhvdXQgbXV0YXRpbmcgYWdlbnQgd2Ugd291bGQgbmVlZCB0byBjcmVhdGUgbW9yZSBvZiB0aGVtLlxuICAgICAgICAgICAgLy8gVGhpcyB0cmFkZW9mZiBvcHRpbWl6ZXMgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgICAgICAgaHR0cEFnZW50Lm9wdGlvbnMudGltZW91dCA9IG1pbkFnZW50VGltZW91dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pZGVtcG90ZW5jeUhlYWRlciAmJiBtZXRob2QgIT09ICdnZXQnKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuaWRlbXBvdGVuY3lLZXkpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5pZGVtcG90ZW5jeUtleSA9IHRoaXMuZGVmYXVsdElkZW1wb3RlbmN5S2V5KCk7XG4gICAgICAgICAgICBoZWFkZXJzW3RoaXMuaWRlbXBvdGVuY3lIZWFkZXJdID0gb3B0aW9ucy5pZGVtcG90ZW5jeUtleTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXFIZWFkZXJzID0gdGhpcy5idWlsZEhlYWRlcnMoeyBvcHRpb25zLCBoZWFkZXJzLCBjb250ZW50TGVuZ3RoIH0pO1xuICAgICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAuLi4oYm9keSAmJiB7IGJvZHk6IGJvZHkgfSksXG4gICAgICAgICAgICBoZWFkZXJzOiByZXFIZWFkZXJzLFxuICAgICAgICAgICAgLi4uKGh0dHBBZ2VudCAmJiB7IGFnZW50OiBodHRwQWdlbnQgfSksXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIG5vZGUtZmV0Y2ggdXNlcyBhIGN1c3RvbSBBYm9ydFNpZ25hbCB0eXBlIHRoYXQgaXNcbiAgICAgICAgICAgIC8vIG5vdCBjb21wYXRpYmxlIHdpdGggc3RhbmRhcmQgd2ViIHR5cGVzXG4gICAgICAgICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsID8/IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IHJlcSwgdXJsLCB0aW1lb3V0IH07XG4gICAgfVxuICAgIGJ1aWxkSGVhZGVycyh7IG9wdGlvbnMsIGhlYWRlcnMsIGNvbnRlbnRMZW5ndGgsIH0pIHtcbiAgICAgICAgY29uc3QgcmVxSGVhZGVycyA9IHt9O1xuICAgICAgICBpZiAoY29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgcmVxSGVhZGVyc1snY29udGVudC1sZW5ndGgnXSA9IGNvbnRlbnRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmYXVsdEhlYWRlcnMgPSB0aGlzLmRlZmF1bHRIZWFkZXJzKG9wdGlvbnMpO1xuICAgICAgICBhcHBseUhlYWRlcnNNdXQocmVxSGVhZGVycywgZGVmYXVsdEhlYWRlcnMpO1xuICAgICAgICBhcHBseUhlYWRlcnNNdXQocmVxSGVhZGVycywgaGVhZGVycyk7XG4gICAgICAgIC8vIGxldCBidWlsdGluIGZldGNoIHNldCB0aGUgQ29udGVudC1UeXBlIGZvciBtdWx0aXBhcnQgYm9kaWVzXG4gICAgICAgIGlmIChpc011bHRpcGFydEJvZHkob3B0aW9ucy5ib2R5KSAmJiBzaGltc0tpbmQgIT09ICdub2RlJykge1xuICAgICAgICAgICAgZGVsZXRlIHJlcUhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsaWRhdGVIZWFkZXJzKHJlcUhlYWRlcnMsIGhlYWRlcnMpO1xuICAgICAgICByZXR1cm4gcmVxSGVhZGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCBhcyBhIGNhbGxiYWNrIGZvciBtdXRhdGluZyB0aGUgZ2l2ZW4gYEZpbmFsUmVxdWVzdE9wdGlvbnNgIG9iamVjdC5cbiAgICAgKi9cbiAgICBhc3luYyBwcmVwYXJlT3B0aW9ucyhvcHRpb25zKSB7IH1cbiAgICAvKipcbiAgICAgKiBVc2VkIGFzIGEgY2FsbGJhY2sgZm9yIG11dGF0aW5nIHRoZSBnaXZlbiBgUmVxdWVzdEluaXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGZvciBjYXNlcyB3aGVyZSB5b3Ugd2FudCB0byBhZGQgY2VydGFpbiBoZWFkZXJzIGJhc2VkIG9mZiBvZlxuICAgICAqIHRoZSByZXF1ZXN0IHByb3BlcnRpZXMsIGUuZy4gYG1ldGhvZGAgb3IgYHVybGAuXG4gICAgICovXG4gICAgYXN5bmMgcHJlcGFyZVJlcXVlc3QocmVxdWVzdCwgeyB1cmwsIG9wdGlvbnMgfSkgeyB9XG4gICAgcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuICghaGVhZGVycyA/IHt9XG4gICAgICAgICAgICA6IFN5bWJvbC5pdGVyYXRvciBpbiBoZWFkZXJzID9cbiAgICAgICAgICAgICAgICBPYmplY3QuZnJvbUVudHJpZXMoQXJyYXkuZnJvbShoZWFkZXJzKS5tYXAoKGhlYWRlcikgPT4gWy4uLmhlYWRlcl0pKVxuICAgICAgICAgICAgICAgIDogeyAuLi5oZWFkZXJzIH0pO1xuICAgIH1cbiAgICBtYWtlU3RhdHVzRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycykge1xuICAgICAgICByZXR1cm4gQVBJRXJyb3IuZ2VuZXJhdGUoc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuICAgIHJlcXVlc3Qob3B0aW9ucywgcmVtYWluaW5nUmV0cmllcyA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBUElQcm9taXNlKHRoaXMubWFrZVJlcXVlc3Qob3B0aW9ucywgcmVtYWluaW5nUmV0cmllcykpO1xuICAgIH1cbiAgICBhc3luYyBtYWtlUmVxdWVzdChvcHRpb25zSW5wdXQsIHJldHJpZXNSZW1haW5pbmcpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IG9wdGlvbnNJbnB1dDtcbiAgICAgICAgaWYgKHJldHJpZXNSZW1haW5pbmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0cmllc1JlbWFpbmluZyA9IG9wdGlvbnMubWF4UmV0cmllcyA/PyB0aGlzLm1heFJldHJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5wcmVwYXJlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyByZXEsIHVybCwgdGltZW91dCB9ID0gdGhpcy5idWlsZFJlcXVlc3Qob3B0aW9ucyk7XG4gICAgICAgIGF3YWl0IHRoaXMucHJlcGFyZVJlcXVlc3QocmVxLCB7IHVybCwgb3B0aW9ucyB9KTtcbiAgICAgICAgZGVidWcoJ3JlcXVlc3QnLCB1cmwsIG9wdGlvbnMsIHJlcS5oZWFkZXJzKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hXaXRoVGltZW91dCh1cmwsIHJlcSwgdGltZW91dCwgY29udHJvbGxlcikuY2F0Y2goY2FzdFRvRXJyb3IpO1xuICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV0cmllc1JlbWFpbmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChvcHRpb25zLCByZXRyaWVzUmVtYWluaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEFQSUNvbm5lY3Rpb25FcnJvcih7IGNhdXNlOiByZXNwb25zZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBjcmVhdGVSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGlmIChyZXRyaWVzUmVtYWluaW5nICYmIHRoaXMuc2hvdWxkUmV0cnkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlNZXNzYWdlID0gYHJldHJ5aW5nLCAke3JldHJpZXNSZW1haW5pbmd9IGF0dGVtcHRzIHJlbWFpbmluZ2A7XG4gICAgICAgICAgICAgICAgZGVidWcoYHJlc3BvbnNlIChlcnJvcjsgJHtyZXRyeU1lc3NhZ2V9KWAsIHJlc3BvbnNlLnN0YXR1cywgdXJsLCByZXNwb25zZUhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChvcHRpb25zLCByZXRyaWVzUmVtYWluaW5nLCByZXNwb25zZUhlYWRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXJyVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoZSkgPT4gY2FzdFRvRXJyb3IoZSkubWVzc2FnZSk7XG4gICAgICAgICAgICBjb25zdCBlcnJKU09OID0gc2FmZUpTT04oZXJyVGV4dCk7XG4gICAgICAgICAgICBjb25zdCBlcnJNZXNzYWdlID0gZXJySlNPTiA/IHVuZGVmaW5lZCA6IGVyclRleHQ7XG4gICAgICAgICAgICBjb25zdCByZXRyeU1lc3NhZ2UgPSByZXRyaWVzUmVtYWluaW5nID8gYChlcnJvcjsgbm8gbW9yZSByZXRyaWVzIGxlZnQpYCA6IGAoZXJyb3I7IG5vdCByZXRyeWFibGUpYDtcbiAgICAgICAgICAgIGRlYnVnKGByZXNwb25zZSAoZXJyb3I7ICR7cmV0cnlNZXNzYWdlfSlgLCByZXNwb25zZS5zdGF0dXMsIHVybCwgcmVzcG9uc2VIZWFkZXJzLCBlcnJNZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMubWFrZVN0YXR1c0Vycm9yKHJlc3BvbnNlLnN0YXR1cywgZXJySlNPTiwgZXJyTWVzc2FnZSwgcmVzcG9uc2VIZWFkZXJzKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByZXNwb25zZSwgb3B0aW9ucywgY29udHJvbGxlciB9O1xuICAgIH1cbiAgICByZXF1ZXN0QVBJTGlzdChQYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLm1ha2VSZXF1ZXN0KG9wdGlvbnMsIG51bGwpO1xuICAgICAgICByZXR1cm4gbmV3IFBhZ2VQcm9taXNlKHRoaXMsIHJlcXVlc3QsIFBhZ2UpO1xuICAgIH1cbiAgICBidWlsZFVSTChwYXRoLCBxdWVyeSkge1xuICAgICAgICBjb25zdCB1cmwgPSBpc0Fic29sdXRlVVJMKHBhdGgpID9cbiAgICAgICAgICAgIG5ldyBVUkwocGF0aClcbiAgICAgICAgICAgIDogbmV3IFVSTCh0aGlzLmJhc2VVUkwgKyAodGhpcy5iYXNlVVJMLmVuZHNXaXRoKCcvJykgJiYgcGF0aC5zdGFydHNXaXRoKCcvJykgPyBwYXRoLnNsaWNlKDEpIDogcGF0aCkpO1xuICAgICAgICBjb25zdCBkZWZhdWx0UXVlcnkgPSB0aGlzLmRlZmF1bHRRdWVyeSgpO1xuICAgICAgICBpZiAoIWlzRW1wdHlPYmooZGVmYXVsdFF1ZXJ5KSkge1xuICAgICAgICAgICAgcXVlcnkgPSB7IC4uLmRlZmF1bHRRdWVyeSwgLi4ucXVlcnkgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0JyAmJiBxdWVyeSAmJiAhQXJyYXkuaXNBcnJheShxdWVyeSkpIHtcbiAgICAgICAgICAgIHVybC5zZWFyY2ggPSB0aGlzLnN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhxdWVyeSlcbiAgICAgICAgICAgIC5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfT1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBDYW5ub3Qgc3RyaW5naWZ5IHR5cGUgJHt0eXBlb2YgdmFsdWV9OyBFeHBlY3RlZCBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgbnVsbC4gSWYgeW91IG5lZWQgdG8gcGFzcyBuZXN0ZWQgcXVlcnkgcGFyYW1ldGVycywgeW91IGNhbiBtYW51YWxseSBlbmNvZGUgdGhlbSwgZS5nLiB7IHF1ZXJ5OiB7ICdmb29ba2V5MV0nOiB2YWx1ZTEsICdmb29ba2V5Ml0nOiB2YWx1ZTIgfSB9LCBhbmQgcGxlYXNlIG9wZW4gYSBHaXRIdWIgaXNzdWUgcmVxdWVzdGluZyBiZXR0ZXIgc3VwcG9ydCBmb3IgeW91ciB1c2UgY2FzZS5gKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcmJyk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoV2l0aFRpbWVvdXQodXJsLCBpbml0LCBtcywgY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCB7IHNpZ25hbCwgLi4ub3B0aW9ucyB9ID0gaW5pdCB8fCB7fTtcbiAgICAgICAgaWYgKHNpZ25hbClcbiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgbXMpO1xuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0UmVxdWVzdENsaWVudCgpXG4gICAgICAgICAgICAvLyB1c2UgdW5kZWZpbmVkIHRoaXMgYmluZGluZzsgZmV0Y2ggZXJyb3JzIGlmIGJvdW5kIHRvIHNvbWV0aGluZyBlbHNlIGluIGJyb3dzZXIvY2xvdWRmbGFyZVxuICAgICAgICAgICAgLmZldGNoLmNhbGwodW5kZWZpbmVkLCB1cmwsIHsgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCwgLi4ub3B0aW9ucyB9KVxuICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGdldFJlcXVlc3RDbGllbnQoKSB7XG4gICAgICAgIHJldHVybiB7IGZldGNoOiB0aGlzLmZldGNoIH07XG4gICAgfVxuICAgIHNob3VsZFJldHJ5KHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIE5vdGUgdGhpcyBpcyBub3QgYSBzdGFuZGFyZCBoZWFkZXIuXG4gICAgICAgIGNvbnN0IHNob3VsZFJldHJ5SGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtc2hvdWxkLXJldHJ5Jyk7XG4gICAgICAgIC8vIElmIHRoZSBzZXJ2ZXIgZXhwbGljaXRseSBzYXlzIHdoZXRoZXIgb3Igbm90IHRvIHJldHJ5LCBvYmV5LlxuICAgICAgICBpZiAoc2hvdWxkUmV0cnlIZWFkZXIgPT09ICd0cnVlJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoc2hvdWxkUmV0cnlIZWFkZXIgPT09ICdmYWxzZScpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFJldHJ5IG9uIHJlcXVlc3QgdGltZW91dHMuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwOClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBSZXRyeSBvbiBsb2NrIHRpbWVvdXRzLlxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gUmV0cnkgb24gcmF0ZSBsaW1pdHMuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBSZXRyeSBpbnRlcm5hbCBlcnJvcnMuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNTAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgcmV0cnlSZXF1ZXN0KG9wdGlvbnMsIHJldHJpZXNSZW1haW5pbmcsIHJlc3BvbnNlSGVhZGVycykge1xuICAgICAgICBsZXQgdGltZW91dE1pbGxpcztcbiAgICAgICAgLy8gTm90ZSB0aGUgYHJldHJ5LWFmdGVyLW1zYCBoZWFkZXIgbWF5IG5vdCBiZSBzdGFuZGFyZCwgYnV0IGlzIGEgZ29vZCBpZGVhIGFuZCB3ZSdkIGxpa2UgcHJvYWN0aXZlIHN1cHBvcnQgZm9yIGl0LlxuICAgICAgICBjb25zdCByZXRyeUFmdGVyTWlsbGlzSGVhZGVyID0gcmVzcG9uc2VIZWFkZXJzPy5bJ3JldHJ5LWFmdGVyLW1zJ107XG4gICAgICAgIGlmIChyZXRyeUFmdGVyTWlsbGlzSGVhZGVyKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0TXMgPSBwYXJzZUZsb2F0KHJldHJ5QWZ0ZXJNaWxsaXNIZWFkZXIpO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odGltZW91dE1zKSkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXRNaWxsaXMgPSB0aW1lb3V0TXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWJvdXQgdGhlIFJldHJ5LUFmdGVyIGhlYWRlcjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1JldHJ5LUFmdGVyXG4gICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXJIZWFkZXIgPSByZXNwb25zZUhlYWRlcnM/LlsncmV0cnktYWZ0ZXInXTtcbiAgICAgICAgaWYgKHJldHJ5QWZ0ZXJIZWFkZXIgJiYgIXRpbWVvdXRNaWxsaXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRTZWNvbmRzID0gcGFyc2VGbG9hdChyZXRyeUFmdGVySGVhZGVyKTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHRpbWVvdXRTZWNvbmRzKSkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXRNaWxsaXMgPSB0aW1lb3V0U2Vjb25kcyAqIDEwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0TWlsbGlzID0gRGF0ZS5wYXJzZShyZXRyeUFmdGVySGVhZGVyKSAtIERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIEFQSSBhc2tzIHVzIHRvIHdhaXQgYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lIChhbmQgaXQncyBhIHJlYXNvbmFibGUgYW1vdW50KSxcbiAgICAgICAgLy8ganVzdCBkbyB3aGF0IGl0IHNheXMsIGJ1dCBvdGhlcndpc2UgY2FsY3VsYXRlIGEgZGVmYXVsdFxuICAgICAgICBpZiAoISh0aW1lb3V0TWlsbGlzICYmIDAgPD0gdGltZW91dE1pbGxpcyAmJiB0aW1lb3V0TWlsbGlzIDwgNjAgKiAxMDAwKSkge1xuICAgICAgICAgICAgY29uc3QgbWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcyA/PyB0aGlzLm1heFJldHJpZXM7XG4gICAgICAgICAgICB0aW1lb3V0TWlsbGlzID0gdGhpcy5jYWxjdWxhdGVEZWZhdWx0UmV0cnlUaW1lb3V0TWlsbGlzKHJldHJpZXNSZW1haW5pbmcsIG1heFJldHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHNsZWVwKHRpbWVvdXRNaWxsaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdChvcHRpb25zLCByZXRyaWVzUmVtYWluaW5nIC0gMSk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZURlZmF1bHRSZXRyeVRpbWVvdXRNaWxsaXMocmV0cmllc1JlbWFpbmluZywgbWF4UmV0cmllcykge1xuICAgICAgICBjb25zdCBpbml0aWFsUmV0cnlEZWxheSA9IDAuNTtcbiAgICAgICAgY29uc3QgbWF4UmV0cnlEZWxheSA9IDguMDtcbiAgICAgICAgY29uc3QgbnVtUmV0cmllcyA9IG1heFJldHJpZXMgLSByZXRyaWVzUmVtYWluaW5nO1xuICAgICAgICAvLyBBcHBseSBleHBvbmVudGlhbCBiYWNrb2ZmLCBidXQgbm90IG1vcmUgdGhhbiB0aGUgbWF4LlxuICAgICAgICBjb25zdCBzbGVlcFNlY29uZHMgPSBNYXRoLm1pbihpbml0aWFsUmV0cnlEZWxheSAqIE1hdGgucG93KDIsIG51bVJldHJpZXMpLCBtYXhSZXRyeURlbGF5KTtcbiAgICAgICAgLy8gQXBwbHkgc29tZSBqaXR0ZXIsIHRha2UgdXAgdG8gYXQgbW9zdCAyNSBwZXJjZW50IG9mIHRoZSByZXRyeSB0aW1lLlxuICAgICAgICBjb25zdCBqaXR0ZXIgPSAxIC0gTWF0aC5yYW5kb20oKSAqIDAuMjU7XG4gICAgICAgIHJldHVybiBzbGVlcFNlY29uZHMgKiBqaXR0ZXIgKiAxMDAwO1xuICAgIH1cbiAgICBnZXRVc2VyQWdlbnQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9L0pTICR7VkVSU0lPTn1gO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFBhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCwgcmVzcG9uc2UsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgX0Fic3RyYWN0UGFnZV9jbGllbnQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Fic3RyYWN0UGFnZV9jbGllbnQsIGNsaWVudCwgXCJmXCIpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgfVxuICAgIGhhc05leHRQYWdlKCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuZ2V0UGFnaW5hdGVkSXRlbXMoKTtcbiAgICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRQYWdlSW5mbygpICE9IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGdldE5leHRQYWdlKCkge1xuICAgICAgICBjb25zdCBuZXh0SW5mbyA9IHRoaXMubmV4dFBhZ2VJbmZvKCk7XG4gICAgICAgIGlmICghbmV4dEluZm8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcignTm8gbmV4dCBwYWdlIGV4cGVjdGVkOyBwbGVhc2UgY2hlY2sgYC5oYXNOZXh0UGFnZSgpYCBiZWZvcmUgY2FsbGluZyBgLmdldE5leHRQYWdlKClgLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRPcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMgfTtcbiAgICAgICAgaWYgKCdwYXJhbXMnIGluIG5leHRJbmZvICYmIHR5cGVvZiBuZXh0T3B0aW9ucy5xdWVyeSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG5leHRPcHRpb25zLnF1ZXJ5ID0geyAuLi5uZXh0T3B0aW9ucy5xdWVyeSwgLi4ubmV4dEluZm8ucGFyYW1zIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ3VybCcgaW4gbmV4dEluZm8pIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IFsuLi5PYmplY3QuZW50cmllcyhuZXh0T3B0aW9ucy5xdWVyeSB8fCB7fSksIC4uLm5leHRJbmZvLnVybC5zZWFyY2hQYXJhbXMuZW50cmllcygpXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIG5leHRJbmZvLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dE9wdGlvbnMucXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBuZXh0T3B0aW9ucy5wYXRoID0gbmV4dEluZm8udXJsLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fic3RyYWN0UGFnZV9jbGllbnQsIFwiZlwiKS5yZXF1ZXN0QVBJTGlzdCh0aGlzLmNvbnN0cnVjdG9yLCBuZXh0T3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jICppdGVyUGFnZXMoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBsZXQgcGFnZSA9IHRoaXM7XG4gICAgICAgIHlpZWxkIHBhZ2U7XG4gICAgICAgIHdoaWxlIChwYWdlLmhhc05leHRQYWdlKCkpIHtcbiAgICAgICAgICAgIHBhZ2UgPSBhd2FpdCBwYWdlLmdldE5leHRQYWdlKCk7XG4gICAgICAgICAgICB5aWVsZCBwYWdlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICpbKF9BYnN0cmFjdFBhZ2VfY2xpZW50ID0gbmV3IFdlYWtNYXAoKSwgU3ltYm9sLmFzeW5jSXRlcmF0b3IpXSgpIHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwYWdlIG9mIHRoaXMuaXRlclBhZ2VzKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBwYWdlLmdldFBhZ2luYXRlZEl0ZW1zKCkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIHN1YmNsYXNzIG9mIFByb21pc2Ugd2lsbCByZXNvbHZlIHRvIGFuIGluc3RhbnRpYXRlZCBQYWdlIG9uY2UgdGhlIHJlcXVlc3QgY29tcGxldGVzLlxuICpcbiAqIEl0IGFsc28gaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlIHRvIGFsbG93IGF1dG8tcGFnaW5hdGluZyBpdGVyYXRpb24gb24gYW4gdW5hd2FpdGVkIGxpc3QgY2FsbCwgZWc6XG4gKlxuICogICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGNsaWVudC5pdGVtcy5saXN0KCkpIHtcbiAqICAgICAgY29uc29sZS5sb2coaXRlbSlcbiAqICAgIH1cbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2VQcm9taXNlIGV4dGVuZHMgQVBJUHJvbWlzZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50LCByZXF1ZXN0LCBQYWdlKSB7XG4gICAgICAgIHN1cGVyKHJlcXVlc3QsIGFzeW5jIChwcm9wcykgPT4gbmV3IFBhZ2UoY2xpZW50LCBwcm9wcy5yZXNwb25zZSwgYXdhaXQgZGVmYXVsdFBhcnNlUmVzcG9uc2UocHJvcHMpLCBwcm9wcy5vcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93IGF1dG8tcGFnaW5hdGluZyBpdGVyYXRpb24gb24gYW4gdW5hd2FpdGVkIGxpc3QgY2FsbCwgZWc6XG4gICAgICpcbiAgICAgKiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgY2xpZW50Lml0ZW1zLmxpc3QoKSkge1xuICAgICAqICAgICAgY29uc29sZS5sb2coaXRlbSlcbiAgICAgKiAgICB9XG4gICAgICovXG4gICAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCB0aGlzO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgcGFnZSkge1xuICAgICAgICAgICAgeWllbGQgaXRlbTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBjcmVhdGVSZXNwb25zZUhlYWRlcnMgPSAoaGVhZGVycykgPT4ge1xuICAgIHJldHVybiBuZXcgUHJveHkoT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBoZWFkZXJzLmVudHJpZXMoKSksIHtcbiAgICAgICAgZ2V0KHRhcmdldCwgbmFtZSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gbmFtZS50b1N0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXkudG9Mb3dlckNhc2UoKV0gfHwgdGFyZ2V0W2tleV07XG4gICAgICAgIH0sXG4gICAgfSk7XG59O1xuLy8gVGhpcyBpcyByZXF1aXJlZCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgaWYgYSBnaXZlbiBvYmplY3QgbWF0Y2hlcyB0aGUgUmVxdWVzdE9wdGlvbnNcbi8vIHR5cGUgYXQgcnVudGltZS4gV2hpbGUgdGhpcyByZXF1aXJlcyBkdXBsaWNhdGlvbiwgaXQgaXMgZW5mb3JjZWQgYnkgdGhlIFR5cGVTY3JpcHRcbi8vIGNvbXBpbGVyIHN1Y2ggdGhhdCBhbnkgbWlzc2luZyAvIGV4dHJhbmVvdXMga2V5cyB3aWxsIGNhdXNlIGFuIGVycm9yLlxuY29uc3QgcmVxdWVzdE9wdGlvbnNLZXlzID0ge1xuICAgIG1ldGhvZDogdHJ1ZSxcbiAgICBwYXRoOiB0cnVlLFxuICAgIHF1ZXJ5OiB0cnVlLFxuICAgIGJvZHk6IHRydWUsXG4gICAgaGVhZGVyczogdHJ1ZSxcbiAgICBtYXhSZXRyaWVzOiB0cnVlLFxuICAgIHN0cmVhbTogdHJ1ZSxcbiAgICB0aW1lb3V0OiB0cnVlLFxuICAgIGh0dHBBZ2VudDogdHJ1ZSxcbiAgICBzaWduYWw6IHRydWUsXG4gICAgaWRlbXBvdGVuY3lLZXk6IHRydWUsXG4gICAgX19iaW5hcnlSZXF1ZXN0OiB0cnVlLFxuICAgIF9fYmluYXJ5UmVzcG9uc2U6IHRydWUsXG4gICAgX19zdHJlYW1DbGFzczogdHJ1ZSxcbn07XG5leHBvcnQgY29uc3QgaXNSZXF1ZXN0T3B0aW9ucyA9IChvYmopID0+IHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgICAgIG9iaiAhPT0gbnVsbCAmJlxuICAgICAgICAhaXNFbXB0eU9iaihvYmopICYmXG4gICAgICAgIE9iamVjdC5rZXlzKG9iaikuZXZlcnkoKGspID0+IGhhc093bihyZXF1ZXN0T3B0aW9uc0tleXMsIGspKSk7XG59O1xuY29uc3QgZ2V0UGxhdGZvcm1Qcm9wZXJ0aWVzID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcgJiYgRGVuby5idWlsZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1PUyc6IG5vcm1hbGl6ZVBsYXRmb3JtKERlbm8uYnVpbGQub3MpLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiBub3JtYWxpemVBcmNoKERlbm8uYnVpbGQuYXJjaCksXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICdkZW5vJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiB0eXBlb2YgRGVuby52ZXJzaW9uID09PSAnc3RyaW5nJyA/IERlbm8udmVyc2lvbiA6IERlbm8udmVyc2lvbj8uZGVubyA/PyAndW5rbm93bicsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgRWRnZVJ1bnRpbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1PUyc6ICdVbmtub3duJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogYG90aGVyOiR7RWRnZVJ1bnRpbWV9YCxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ2VkZ2UnLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6IHByb2Nlc3MudmVyc2lvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgTm9kZS5qc1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnID8gcHJvY2VzcyA6IDApID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1MYW5nJzogJ2pzJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBWRVJTSU9OLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLU9TJzogbm9ybWFsaXplUGxhdGZvcm0ocHJvY2Vzcy5wbGF0Zm9ybSksXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6IG5vcm1hbGl6ZUFyY2gocHJvY2Vzcy5hcmNoKSxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ25vZGUnLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6IHByb2Nlc3MudmVyc2lvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgYnJvd3NlckluZm8gPSBnZXRCcm93c2VySW5mbygpO1xuICAgIGlmIChicm93c2VySW5mbykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IFZFUlNJT04sXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtT1MnOiAnVW5rbm93bicsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6ICd1bmtub3duJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogYGJyb3dzZXI6JHticm93c2VySW5mby5icm93c2VyfWAsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogYnJvd3NlckluZm8udmVyc2lvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gVE9ETyBhZGQgc3VwcG9ydCBmb3IgQ2xvdWRmbGFyZSB3b3JrZXJzLCBldGMuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICAgJ1gtU3RhaW5sZXNzLU9TJzogJ1Vua25vd24nLFxuICAgICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6ICd1bmtub3duJyxcbiAgICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiAndW5rbm93bicsXG4gICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiAndW5rbm93bicsXG4gICAgfTtcbn07XG4vLyBOb3RlOiBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9KUy1EZXZUb29scy9ob3N0LWVudmlyb25tZW50L2Jsb2IvYjFhYjc5ZWNkZTM3ZGI1ZDZlMTYzYzA1MGU1NGZlN2QyODdkN2M5Mi9zcmMvaXNvbW9ycGhpYy5icm93c2VyLnRzXG5mdW5jdGlvbiBnZXRCcm93c2VySW5mbygpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gTk9URTogVGhlIG9yZGVyIG1hdHRlcnMgaGVyZSFcbiAgICBjb25zdCBicm93c2VyUGF0dGVybnMgPSBbXG4gICAgICAgIHsga2V5OiAnZWRnZScsIHBhdHRlcm46IC9FZGdlKD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgICAgIHsga2V5OiAnaWUnLCBwYXR0ZXJuOiAvTVNJRSg/OlxcVysoXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/LyB9LFxuICAgICAgICB7IGtleTogJ2llJywgcGF0dGVybjogL1RyaWRlbnQoPzouKnJ2XFw6KFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICAgICAgeyBrZXk6ICdjaHJvbWUnLCBwYXR0ZXJuOiAvQ2hyb21lKD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgICAgIHsga2V5OiAnZmlyZWZveCcsIHBhdHRlcm46IC9GaXJlZm94KD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgICAgIHsga2V5OiAnc2FmYXJpJywgcGF0dGVybjogLyg/OlZlcnNpb25cXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPyg/OlxcVytNb2JpbGVcXFMqKT9cXFcrU2FmYXJpLyB9LFxuICAgIF07XG4gICAgLy8gRmluZCB0aGUgRklSU1QgbWF0Y2hpbmcgYnJvd3NlclxuICAgIGZvciAoY29uc3QgeyBrZXksIHBhdHRlcm4gfSBvZiBicm93c2VyUGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgbWFqb3IgPSBtYXRjaFsxXSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgbWlub3IgPSBtYXRjaFsyXSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgcGF0Y2ggPSBtYXRjaFszXSB8fCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgYnJvd3Nlcjoga2V5LCB2ZXJzaW9uOiBgJHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH1gIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBub3JtYWxpemVBcmNoID0gKGFyY2gpID0+IHtcbiAgICAvLyBOb2RlIGRvY3M6XG4gICAgLy8gLSBodHRwczovL25vZGVqcy5vcmcvYXBpL3Byb2Nlc3MuaHRtbCNwcm9jZXNzYXJjaFxuICAgIC8vIERlbm8gZG9jczpcbiAgICAvLyAtIGh0dHBzOi8vZG9jLmRlbm8ubGFuZC9kZW5vL3N0YWJsZS9+L0Rlbm8uYnVpbGRcbiAgICBpZiAoYXJjaCA9PT0gJ3gzMicpXG4gICAgICAgIHJldHVybiAneDMyJztcbiAgICBpZiAoYXJjaCA9PT0gJ3g4Nl82NCcgfHwgYXJjaCA9PT0gJ3g2NCcpXG4gICAgICAgIHJldHVybiAneDY0JztcbiAgICBpZiAoYXJjaCA9PT0gJ2FybScpXG4gICAgICAgIHJldHVybiAnYXJtJztcbiAgICBpZiAoYXJjaCA9PT0gJ2FhcmNoNjQnIHx8IGFyY2ggPT09ICdhcm02NCcpXG4gICAgICAgIHJldHVybiAnYXJtNjQnO1xuICAgIGlmIChhcmNoKVxuICAgICAgICByZXR1cm4gYG90aGVyOiR7YXJjaH1gO1xuICAgIHJldHVybiAndW5rbm93bic7XG59O1xuY29uc3Qgbm9ybWFsaXplUGxhdGZvcm0gPSAocGxhdGZvcm0pID0+IHtcbiAgICAvLyBOb2RlIHBsYXRmb3JtczpcbiAgICAvLyAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NwbGF0Zm9ybVxuICAgIC8vIERlbm8gcGxhdGZvcm1zOlxuICAgIC8vIC0gaHR0cHM6Ly9kb2MuZGVuby5sYW5kL2Rlbm8vc3RhYmxlL34vRGVuby5idWlsZFxuICAgIC8vIC0gaHR0cHM6Ly9naXRodWIuY29tL2Rlbm9sYW5kL2Rlbm8vaXNzdWVzLzE0Nzk5XG4gICAgcGxhdGZvcm0gPSBwbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIE5PVEU6IHRoaXMgaU9TIGNoZWNrIGlzIHVudGVzdGVkIGFuZCBtYXkgbm90IHdvcmtcbiAgICAvLyBOb2RlIGRvZXMgbm90IHdvcmsgbmF0aXZlbHkgb24gSU9TLCB0aGVyZSBpcyBhIGZvcmsgYXRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzLW1vYmlsZS9ub2RlanMtbW9iaWxlXG4gICAgLy8gaG93ZXZlciBpdCBpcyB1bmtub3duIGF0IHRoZSB0aW1lIG9mIHdyaXRpbmcgaG93IHRvIGRldGVjdCBpZiBpdCBpcyBydW5uaW5nXG4gICAgaWYgKHBsYXRmb3JtLmluY2x1ZGVzKCdpb3MnKSlcbiAgICAgICAgcmV0dXJuICdpT1MnO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKVxuICAgICAgICByZXR1cm4gJ0FuZHJvaWQnO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ2RhcndpbicpXG4gICAgICAgIHJldHVybiAnTWFjT1MnO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ3dpbjMyJylcbiAgICAgICAgcmV0dXJuICdXaW5kb3dzJztcbiAgICBpZiAocGxhdGZvcm0gPT09ICdmcmVlYnNkJylcbiAgICAgICAgcmV0dXJuICdGcmVlQlNEJztcbiAgICBpZiAocGxhdGZvcm0gPT09ICdvcGVuYnNkJylcbiAgICAgICAgcmV0dXJuICdPcGVuQlNEJztcbiAgICBpZiAocGxhdGZvcm0gPT09ICdsaW51eCcpXG4gICAgICAgIHJldHVybiAnTGludXgnO1xuICAgIGlmIChwbGF0Zm9ybSlcbiAgICAgICAgcmV0dXJuIGBPdGhlcjoke3BsYXRmb3JtfWA7XG4gICAgcmV0dXJuICdVbmtub3duJztcbn07XG5sZXQgX3BsYXRmb3JtSGVhZGVycztcbmNvbnN0IGdldFBsYXRmb3JtSGVhZGVycyA9ICgpID0+IHtcbiAgICByZXR1cm4gKF9wbGF0Zm9ybUhlYWRlcnMgPz8gKF9wbGF0Zm9ybUhlYWRlcnMgPSBnZXRQbGF0Zm9ybVByb3BlcnRpZXMoKSkpO1xufTtcbmV4cG9ydCBjb25zdCBzYWZlSlNPTiA9ICh0ZXh0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5NzA5ODQ2XG5jb25zdCBzdGFydHNXaXRoU2NoZW1lUmVnZXhwID0gbmV3IFJlZ0V4cCgnXig/OlthLXpdKzopPy8vJywgJ2knKTtcbmNvbnN0IGlzQWJzb2x1dGVVUkwgPSAodXJsKSA9PiB7XG4gICAgcmV0dXJuIHN0YXJ0c1dpdGhTY2hlbWVSZWdleHAudGVzdCh1cmwpO1xufTtcbmV4cG9ydCBjb25zdCBzbGVlcCA9IChtcykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbmNvbnN0IHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyID0gKG5hbWUsIG4pID0+IHtcbiAgICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKG4pKSB7XG4gICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgJHtuYW1lfSBtdXN0IGJlIGFuIGludGVnZXJgKTtcbiAgICB9XG4gICAgaWYgKG4gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgJHtuYW1lfSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcmApO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn07XG5leHBvcnQgY29uc3QgY2FzdFRvRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgICByZXR1cm4gZXJyO1xuICAgIHJldHVybiBuZXcgRXJyb3IoZXJyKTtcbn07XG5leHBvcnQgY29uc3QgZW5zdXJlUHJlc2VudCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYEV4cGVjdGVkIGEgdmFsdWUgdG8gYmUgZ2l2ZW4gYnV0IHJlY2VpdmVkICR7dmFsdWV9IGluc3RlYWQuYCk7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbi8qKlxuICogUmVhZCBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAqXG4gKiBUcmltcyBiZWdpbm5pbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuXG4gKlxuICogV2lsbCByZXR1cm4gdW5kZWZpbmVkIGlmIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBkb2Vzbid0IGV4aXN0IG9yIGNhbm5vdCBiZSBhY2Nlc3NlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRFbnYgPSAoZW52KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnY/LltlbnZdPy50cmltKCkgPz8gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBEZW5vLmVudj8uZ2V0Py4oZW52KT8udHJpbSgpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmV4cG9ydCBjb25zdCBjb2VyY2VJbnRlZ2VyID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBDb3VsZCBub3QgY29lcmNlICR7dmFsdWV9ICh0eXBlOiAke3R5cGVvZiB2YWx1ZX0pIGludG8gYSBudW1iZXJgKTtcbn07XG5leHBvcnQgY29uc3QgY29lcmNlRmxvYXQgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBDb3VsZCBub3QgY29lcmNlICR7dmFsdWV9ICh0eXBlOiAke3R5cGVvZiB2YWx1ZX0pIGludG8gYSBudW1iZXJgKTtcbn07XG5leHBvcnQgY29uc3QgY29lcmNlQm9vbGVhbiA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJylcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdmFsdWUgPT09ICd0cnVlJztcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XG59O1xuZXhwb3J0IGNvbnN0IG1heWJlQ29lcmNlSW50ZWdlciA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBjb2VyY2VJbnRlZ2VyKHZhbHVlKTtcbn07XG5leHBvcnQgY29uc3QgbWF5YmVDb2VyY2VGbG9hdCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBjb2VyY2VGbG9hdCh2YWx1ZSk7XG59O1xuZXhwb3J0IGNvbnN0IG1heWJlQ29lcmNlQm9vbGVhbiA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBjb2VyY2VCb29sZWFuKHZhbHVlKTtcbn07XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQ0OTEyODdcbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5T2JqKG9iaikge1xuICAgIGlmICghb2JqKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IF9rIGluIG9iailcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gaHR0cHM6Ly9lc2xpbnQub3JnL2RvY3MvbGF0ZXN0L3J1bGVzL25vLXByb3RvdHlwZS1idWlsdGluc1xuZXhwb3J0IGZ1bmN0aW9uIGhhc093bihvYmosIGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuLyoqXG4gKiBDb3BpZXMgaGVhZGVycyBmcm9tIFwibmV3SGVhZGVyc1wiIG9udG8gXCJ0YXJnZXRIZWFkZXJzXCIsXG4gKiB1c2luZyBsb3dlci1jYXNlIGZvciBhbGwgcHJvcGVydGllcyxcbiAqIGlnbm9yaW5nIGFueSBrZXlzIHdpdGggdW5kZWZpbmVkIHZhbHVlcyxcbiAqIGFuZCBkZWxldGluZyBhbnkga2V5cyB3aXRoIG51bGwgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBhcHBseUhlYWRlcnNNdXQodGFyZ2V0SGVhZGVycywgbmV3SGVhZGVycykge1xuICAgIGZvciAoY29uc3QgayBpbiBuZXdIZWFkZXJzKSB7XG4gICAgICAgIGlmICghaGFzT3duKG5ld0hlYWRlcnMsIGspKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGxvd2VyS2V5ID0gay50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIWxvd2VyS2V5KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHZhbCA9IG5ld0hlYWRlcnNba107XG4gICAgICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRIZWFkZXJzW2xvd2VyS2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGFyZ2V0SGVhZGVyc1tsb3dlcktleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZGVidWcoYWN0aW9uLCAuLi5hcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzPy5lbnY/LlsnREVCVUcnXSA9PT0gJ3RydWUnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBPcGVuQUk6REVCVUc6JHthY3Rpb259YCwgLi4uYXJncyk7XG4gICAgfVxufVxuLyoqXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjExNzUyM1xuICovXG5jb25zdCB1dWlkNCA9ICgpID0+IHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCAoYykgPT4ge1xuICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwO1xuICAgICAgICBjb25zdCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufTtcbmV4cG9ydCBjb25zdCBpc1J1bm5pbmdJbkJyb3dzZXIgPSAoKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKTtcbn07XG5leHBvcnQgY29uc3QgaXNIZWFkZXJzUHJvdG9jb2wgPSAoaGVhZGVycykgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgaGVhZGVycz8uZ2V0ID09PSAnZnVuY3Rpb24nO1xufTtcbmV4cG9ydCBjb25zdCBnZXRSZXF1aXJlZEhlYWRlciA9IChoZWFkZXJzLCBoZWFkZXIpID0+IHtcbiAgICBjb25zdCBsb3dlckNhc2VkSGVhZGVyID0gaGVhZGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGlzSGVhZGVyc1Byb3RvY29sKGhlYWRlcnMpKSB7XG4gICAgICAgIC8vIHRvIGRlYWwgd2l0aCB0aGUgY2FzZSB3aGVyZSB0aGUgaGVhZGVyIGxvb2tzIGxpa2UgU3RhaW5sZXNzLUV2ZW50LUlkXG4gICAgICAgIGNvbnN0IGludGVyY2Fwc0hlYWRlciA9IGhlYWRlclswXT8udG9VcHBlckNhc2UoKSArXG4gICAgICAgICAgICBoZWFkZXIuc3Vic3RyaW5nKDEpLnJlcGxhY2UoLyhbXlxcd10pKFxcdykvZywgKF9tLCBnMSwgZzIpID0+IGcxICsgZzIudG9VcHBlckNhc2UoKSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFtoZWFkZXIsIGxvd2VyQ2FzZWRIZWFkZXIsIGhlYWRlci50b1VwcGVyQ2FzZSgpLCBpbnRlcmNhcHNIZWFkZXJdKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSBsb3dlckNhc2VkSGVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoIDw9IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVswXTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFJlY2VpdmVkICR7dmFsdWUubGVuZ3RofSBlbnRyaWVzIGZvciB0aGUgJHtoZWFkZXJ9IGhlYWRlciwgdXNpbmcgdGhlIGZpcnN0IGVudHJ5LmApO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kICR7aGVhZGVyfSBoZWFkZXJgKTtcbn07XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgdG8gQmFzZTY0IGZvcm1hdC5cbiAqL1xuZXhwb3J0IGNvbnN0IHRvQmFzZTY0ID0gKHN0cikgPT4ge1xuICAgIGlmICghc3RyKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gYnRvYShzdHIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoJ0Nhbm5vdCBnZW5lcmF0ZSBiNjQgc3RyaW5nOyBFeHBlY3RlZCBgQnVmZmVyYCBvciBgYnRvYWAgdG8gYmUgZGVmaW5lZCcpO1xufTtcbmV4cG9ydCBmdW5jdGlvbiBpc09iaihvYmopIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob2JqKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBjYXN0VG9FcnJvciB9IGZyb20gXCIuL2NvcmUubWpzXCI7XG5leHBvcnQgY2xhc3MgT3BlbkFJRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5leHBvcnQgY2xhc3MgQVBJRXJyb3IgZXh0ZW5kcyBPcGVuQUlFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycykge1xuICAgICAgICBzdXBlcihgJHtBUElFcnJvci5tYWtlTWVzc2FnZShzdGF0dXMsIGVycm9yLCBtZXNzYWdlKX1gKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMucmVxdWVzdF9pZCA9IGhlYWRlcnM/LlsneC1yZXF1ZXN0LWlkJ107XG4gICAgICAgIGNvbnN0IGRhdGEgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5lcnJvciA9IGRhdGE7XG4gICAgICAgIHRoaXMuY29kZSA9IGRhdGE/LlsnY29kZSddO1xuICAgICAgICB0aGlzLnBhcmFtID0gZGF0YT8uWydwYXJhbSddO1xuICAgICAgICB0aGlzLnR5cGUgPSBkYXRhPy5bJ3R5cGUnXTtcbiAgICB9XG4gICAgc3RhdGljIG1ha2VNZXNzYWdlKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbXNnID0gZXJyb3I/Lm1lc3NhZ2UgP1xuICAgICAgICAgICAgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShlcnJvci5tZXNzYWdlKVxuICAgICAgICAgICAgOiBlcnJvciA/IEpTT04uc3RyaW5naWZ5KGVycm9yKVxuICAgICAgICAgICAgICAgIDogbWVzc2FnZTtcbiAgICAgICAgaWYgKHN0YXR1cyAmJiBtc2cpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtzdGF0dXN9ICR7bXNnfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgcmV0dXJuIGAke3N0YXR1c30gc3RhdHVzIGNvZGUgKG5vIGJvZHkpYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXNnKSB7XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnKG5vIHN0YXR1cyBjb2RlIG9yIGJvZHkpJztcbiAgICB9XG4gICAgc3RhdGljIGdlbmVyYXRlKHN0YXR1cywgZXJyb3JSZXNwb25zZSwgbWVzc2FnZSwgaGVhZGVycykge1xuICAgICAgICBpZiAoIXN0YXR1cykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBUElDb25uZWN0aW9uRXJyb3IoeyBjYXVzZTogY2FzdFRvRXJyb3IoZXJyb3JSZXNwb25zZSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvclJlc3BvbnNlPy5bJ2Vycm9yJ107XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDQwMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCYWRSZXF1ZXN0RXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcm1pc3Npb25EZW5pZWRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm90Rm91bmRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uZmxpY3RFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSA0MjIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDQyOSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYXRlTGltaXRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID49IDUwMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbFNlcnZlckVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQVBJRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFQSVVzZXJBYm9ydEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIodW5kZWZpbmVkLCB1bmRlZmluZWQsIG1lc3NhZ2UgfHwgJ1JlcXVlc3Qgd2FzIGFib3J0ZWQuJywgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFQSUNvbm5lY3Rpb25FcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UsIGNhdXNlIH0pIHtcbiAgICAgICAgc3VwZXIodW5kZWZpbmVkLCB1bmRlZmluZWQsIG1lc3NhZ2UgfHwgJ0Nvbm5lY3Rpb24gZXJyb3IuJywgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIGluIHNvbWUgZW52aXJvbm1lbnRzIHRoZSAnY2F1c2UnIHByb3BlcnR5IGlzIGFscmVhZHkgZGVjbGFyZWRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoY2F1c2UpXG4gICAgICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IgZXh0ZW5kcyBBUElDb25uZWN0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoeyBtZXNzYWdlOiBtZXNzYWdlID8/ICdSZXF1ZXN0IHRpbWVkIG91dC4nIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCYWRSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gNDAwO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBdXRoZW50aWNhdGlvbkVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IDQwMTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUGVybWlzc2lvbkRlbmllZEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IDQwMztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTm90Rm91bmRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSA0MDQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbmZsaWN0RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gNDA5O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gNDIyO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSYXRlTGltaXRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSA0Mjk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEludGVybmFsU2VydmVyRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnQgY2xhc3MgTGVuZ3RoRmluaXNoUmVhc29uRXJyb3IgZXh0ZW5kcyBPcGVuQUlFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKGBDb3VsZCBub3QgcGFyc2UgcmVzcG9uc2UgY29udGVudCBhcyB0aGUgbGVuZ3RoIGxpbWl0IHdhcyByZWFjaGVkYCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbnRlbnRGaWx0ZXJGaW5pc2hSZWFzb25FcnJvciBleHRlbmRzIE9wZW5BSUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoYENvdWxkIG5vdCBwYXJzZSByZXNwb25zZSBjb250ZW50IGFzIHRoZSByZXF1ZXN0IHdhcyByZWplY3RlZCBieSB0aGUgY29udGVudCBmaWx0ZXJgKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFic3RyYWN0UGFnZSB9IGZyb20gXCIuL2NvcmUubWpzXCI7XG4vKipcbiAqIE5vdGU6IG5vIHBhZ2luYXRpb24gYWN0dWFsbHkgb2NjdXJzIHlldCwgdGhpcyBpcyBmb3IgZm9yd2FyZHMtY29tcGF0aWJpbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2UgZXh0ZW5kcyBBYnN0cmFjdFBhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCwgcmVzcG9uc2UsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoY2xpZW50LCByZXNwb25zZSwgYm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGJvZHkuZGF0YSB8fCBbXTtcbiAgICAgICAgdGhpcy5vYmplY3QgPSBib2R5Lm9iamVjdDtcbiAgICB9XG4gICAgZ2V0UGFnaW5hdGVkSXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEgPz8gW107XG4gICAgfVxuICAgIC8vIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYG5leHRQYWdlSW5mbygpYCBpbnN0ZWFkXG4gICAgLyoqXG4gICAgICogVGhpcyBwYWdlIHJlcHJlc2VudHMgYSByZXNwb25zZSB0aGF0IGlzbid0IGFjdHVhbGx5IHBhZ2luYXRlZCBhdCB0aGUgQVBJIGxldmVsXG4gICAgICogc28gdGhlcmUgd2lsbCBuZXZlciBiZSBhbnkgbmV4dCBwYWdlIHBhcmFtcy5cbiAgICAgKi9cbiAgICBuZXh0UGFnZVBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG5leHRQYWdlSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEN1cnNvclBhZ2UgZXh0ZW5kcyBBYnN0cmFjdFBhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCwgcmVzcG9uc2UsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoY2xpZW50LCByZXNwb25zZSwgYm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGJvZHkuZGF0YSB8fCBbXTtcbiAgICB9XG4gICAgZ2V0UGFnaW5hdGVkSXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEgPz8gW107XG4gICAgfVxuICAgIC8vIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgYG5leHRQYWdlSW5mbygpYCBpbnN0ZWFkXG4gICAgbmV4dFBhZ2VQYXJhbXMoKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLm5leHRQYWdlSW5mbygpO1xuICAgICAgICBpZiAoIWluZm8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCdwYXJhbXMnIGluIGluZm8pXG4gICAgICAgICAgICByZXR1cm4gaW5mby5wYXJhbXM7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5mcm9tRW50cmllcyhpbmZvLnVybC5zZWFyY2hQYXJhbXMpO1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIG5leHRQYWdlSW5mbygpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0UGFnaW5hdGVkSXRlbXMoKTtcbiAgICAgICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0/LmlkO1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwYXJhbXM6IHsgYWZ0ZXI6IGlkIH0gfTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdpbmF0aW9uLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuZXhwb3J0IGNsYXNzIEFQSVJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc291cmNlLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vcmVzb3VyY2UubWpzXCI7XG5leHBvcnQgY2xhc3MgQ29tcGxldGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgY3JlYXRlKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvY2hhdC9jb21wbGV0aW9ucycsIHsgYm9keSwgLi4ub3B0aW9ucywgc3RyZWFtOiBib2R5LnN0cmVhbSA/PyBmYWxzZSB9KTtcbiAgICB9XG59XG4oZnVuY3Rpb24gKENvbXBsZXRpb25zKSB7XG59KShDb21wbGV0aW9ucyB8fCAoQ29tcGxldGlvbnMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGxldGlvbnMubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi9yZXNvdXJjZS5tanNcIjtcbmltcG9ydCAqIGFzIENvbXBsZXRpb25zQVBJIGZyb20gXCIuL2NvbXBsZXRpb25zLm1qc1wiO1xuZXhwb3J0IGNsYXNzIENoYXQgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY29tcGxldGlvbnMgPSBuZXcgQ29tcGxldGlvbnNBUEkuQ29tcGxldGlvbnModGhpcy5fY2xpZW50KTtcbiAgICB9XG59XG4oZnVuY3Rpb24gKENoYXQpIHtcbiAgICBDaGF0LkNvbXBsZXRpb25zID0gQ29tcGxldGlvbnNBUEkuQ29tcGxldGlvbnM7XG59KShDaGF0IHx8IChDaGF0ID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYXQubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi9yZXNvdXJjZS5tanNcIjtcbmV4cG9ydCBjbGFzcyBTcGVlY2ggZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGF1ZGlvIGZyb20gdGhlIGlucHV0IHRleHQuXG4gICAgICovXG4gICAgY3JlYXRlKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvYXVkaW8vc3BlZWNoJywgeyBib2R5LCAuLi5vcHRpb25zLCBfX2JpbmFyeVJlc3BvbnNlOiB0cnVlIH0pO1xuICAgIH1cbn1cbihmdW5jdGlvbiAoU3BlZWNoKSB7XG59KShTcGVlY2ggfHwgKFNwZWVjaCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcGVlY2gubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi9yZXNvdXJjZS5tanNcIjtcbmltcG9ydCAqIGFzIENvcmUgZnJvbSBcIi4uLy4uL2NvcmUubWpzXCI7XG5leHBvcnQgY2xhc3MgVHJhbnNjcmlwdGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogVHJhbnNjcmliZXMgYXVkaW8gaW50byB0aGUgaW5wdXQgbGFuZ3VhZ2UuXG4gICAgICovXG4gICAgY3JlYXRlKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvYXVkaW8vdHJhbnNjcmlwdGlvbnMnLCBDb3JlLm11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyh7IGJvZHksIC4uLm9wdGlvbnMgfSkpO1xuICAgIH1cbn1cbihmdW5jdGlvbiAoVHJhbnNjcmlwdGlvbnMpIHtcbn0pKFRyYW5zY3JpcHRpb25zIHx8IChUcmFuc2NyaXB0aW9ucyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2NyaXB0aW9ucy5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tIFwiLi4vLi4vY29yZS5tanNcIjtcbmV4cG9ydCBjbGFzcyBUcmFuc2xhdGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBhdWRpbyBpbnRvIEVuZ2xpc2guXG4gICAgICovXG4gICAgY3JlYXRlKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvYXVkaW8vdHJhbnNsYXRpb25zJywgQ29yZS5tdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgICB9XG59XG4oZnVuY3Rpb24gKFRyYW5zbGF0aW9ucykge1xufSkoVHJhbnNsYXRpb25zIHx8IChUcmFuc2xhdGlvbnMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNsYXRpb25zLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgKiBhcyBTcGVlY2hBUEkgZnJvbSBcIi4vc3BlZWNoLm1qc1wiO1xuaW1wb3J0ICogYXMgVHJhbnNjcmlwdGlvbnNBUEkgZnJvbSBcIi4vdHJhbnNjcmlwdGlvbnMubWpzXCI7XG5pbXBvcnQgKiBhcyBUcmFuc2xhdGlvbnNBUEkgZnJvbSBcIi4vdHJhbnNsYXRpb25zLm1qc1wiO1xuZXhwb3J0IGNsYXNzIEF1ZGlvIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnRyYW5zY3JpcHRpb25zID0gbmV3IFRyYW5zY3JpcHRpb25zQVBJLlRyYW5zY3JpcHRpb25zKHRoaXMuX2NsaWVudCk7XG4gICAgICAgIHRoaXMudHJhbnNsYXRpb25zID0gbmV3IFRyYW5zbGF0aW9uc0FQSS5UcmFuc2xhdGlvbnModGhpcy5fY2xpZW50KTtcbiAgICAgICAgdGhpcy5zcGVlY2ggPSBuZXcgU3BlZWNoQVBJLlNwZWVjaCh0aGlzLl9jbGllbnQpO1xuICAgIH1cbn1cbihmdW5jdGlvbiAoQXVkaW8pIHtcbiAgICBBdWRpby5UcmFuc2NyaXB0aW9ucyA9IFRyYW5zY3JpcHRpb25zQVBJLlRyYW5zY3JpcHRpb25zO1xuICAgIEF1ZGlvLlRyYW5zbGF0aW9ucyA9IFRyYW5zbGF0aW9uc0FQSS5UcmFuc2xhdGlvbnM7XG4gICAgQXVkaW8uU3BlZWNoID0gU3BlZWNoQVBJLlNwZWVjaDtcbn0pKEF1ZGlvIHx8IChBdWRpbyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdWRpby5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCIuLi9jb3JlLm1qc1wiO1xuaW1wb3J0ICogYXMgQmF0Y2hlc0FQSSBmcm9tIFwiLi9iYXRjaGVzLm1qc1wiO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSB9IGZyb20gXCIuLi9wYWdpbmF0aW9uLm1qc1wiO1xuZXhwb3J0IGNsYXNzIEJhdGNoZXMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgZXhlY3V0ZXMgYSBiYXRjaCBmcm9tIGFuIHVwbG9hZGVkIGZpbGUgb2YgcmVxdWVzdHNcbiAgICAgKi9cbiAgICBjcmVhdGUoYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9iYXRjaGVzJywgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBiYXRjaC5cbiAgICAgKi9cbiAgICByZXRyaWV2ZShiYXRjaElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvYmF0Y2hlcy8ke2JhdGNoSWR9YCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGxpc3QocXVlcnkgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Qoe30sIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoJy9iYXRjaGVzJywgQmF0Y2hlc1BhZ2UsIHsgcXVlcnksIC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYW4gaW4tcHJvZ3Jlc3MgYmF0Y2guIFRoZSBiYXRjaCB3aWxsIGJlIGluIHN0YXR1cyBgY2FuY2VsbGluZ2AgZm9yIHVwIHRvXG4gICAgICogMTAgbWludXRlcywgYmVmb3JlIGNoYW5naW5nIHRvIGBjYW5jZWxsZWRgLCB3aGVyZSBpdCB3aWxsIGhhdmUgcGFydGlhbCByZXN1bHRzXG4gICAgICogKGlmIGFueSkgYXZhaWxhYmxlIGluIHRoZSBvdXRwdXQgZmlsZS5cbiAgICAgKi9cbiAgICBjYW5jZWwoYmF0Y2hJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC9iYXRjaGVzLyR7YmF0Y2hJZH0vY2FuY2VsYCwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJhdGNoZXNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZSB7XG59XG4oZnVuY3Rpb24gKEJhdGNoZXMpIHtcbiAgICBCYXRjaGVzLkJhdGNoZXNQYWdlID0gQmF0Y2hlc0FQSS5CYXRjaGVzUGFnZTtcbn0pKEJhdGNoZXMgfHwgKEJhdGNoZXMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmF0Y2hlcy5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCIuLi8uLi9jb3JlLm1qc1wiO1xuaW1wb3J0ICogYXMgQXNzaXN0YW50c0FQSSBmcm9tIFwiLi9hc3Npc3RhbnRzLm1qc1wiO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSB9IGZyb20gXCIuLi8uLi9wYWdpbmF0aW9uLm1qc1wiO1xuZXhwb3J0IGNsYXNzIEFzc2lzdGFudHMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGFzc2lzdGFudCB3aXRoIGEgbW9kZWwgYW5kIGluc3RydWN0aW9ucy5cbiAgICAgKi9cbiAgICBjcmVhdGUoYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9hc3Npc3RhbnRzJywge1xuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuIGFzc2lzdGFudC5cbiAgICAgKi9cbiAgICByZXRyaWV2ZShhc3Npc3RhbnRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH1gLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIGFuIGFzc2lzdGFudC5cbiAgICAgKi9cbiAgICB1cGRhdGUoYXNzaXN0YW50SWQsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvYXNzaXN0YW50cy8ke2Fzc2lzdGFudElkfWAsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3QocXVlcnkgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Qoe30sIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoJy9hc3Npc3RhbnRzJywgQXNzaXN0YW50c1BhZ2UsIHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYW4gYXNzaXN0YW50LlxuICAgICAqL1xuICAgIGRlbChhc3Npc3RhbnRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH1gLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFzc2lzdGFudHNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZSB7XG59XG4oZnVuY3Rpb24gKEFzc2lzdGFudHMpIHtcbiAgICBBc3Npc3RhbnRzLkFzc2lzdGFudHNQYWdlID0gQXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRzUGFnZTtcbn0pKEFzc2lzdGFudHMgfHwgKEFzc2lzdGFudHMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzaXN0YW50cy5tanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGlzUnVubmFibGVGdW5jdGlvbldpdGhQYXJzZShmbikge1xuICAgIHJldHVybiB0eXBlb2YgZm4ucGFyc2UgPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIFRoaXMgaXMgaGVscGVyIGNsYXNzIGZvciBwYXNzaW5nIGEgYGZ1bmN0aW9uYCBhbmQgYHBhcnNlYCB3aGVyZSB0aGUgYGZ1bmN0aW9uYFxuICogYXJndW1lbnQgdHlwZSBtYXRjaGVzIHRoZSBgcGFyc2VgIHJldHVybiB0eXBlLlxuICpcbiAqIEBkZXByZWNhdGVkIC0gcGxlYXNlIHVzZSBQYXJzaW5nVG9vbEZ1bmN0aW9uIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJzaW5nRnVuY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHRoaXMuZnVuY3Rpb24gPSBpbnB1dC5mdW5jdGlvbjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IGlucHV0LnBhcnNlO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBpbnB1dC5wYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gaW5wdXQuZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMubmFtZSA9IGlucHV0Lm5hbWU7XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGlzIGhlbHBlciBjbGFzcyBmb3IgcGFzc2luZyBhIGBmdW5jdGlvbmAgYW5kIGBwYXJzZWAgd2hlcmUgdGhlIGBmdW5jdGlvbmBcbiAqIGFyZ3VtZW50IHR5cGUgbWF0Y2hlcyB0aGUgYHBhcnNlYCByZXR1cm4gdHlwZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhcnNpbmdUb29sRnVuY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHRoaXMuZnVuY3Rpb24gPSBpbnB1dDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SdW5uYWJsZUZ1bmN0aW9uLm1qcy5tYXAiLCJleHBvcnQgY29uc3QgaXNBc3Npc3RhbnRNZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICByZXR1cm4gbWVzc2FnZT8ucm9sZSA9PT0gJ2Fzc2lzdGFudCc7XG59O1xuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb25NZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICByZXR1cm4gbWVzc2FnZT8ucm9sZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG5leHBvcnQgY29uc3QgaXNUb29sTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgcmV0dXJuIG1lc3NhZ2U/LnJvbGUgPT09ICd0b29sJztcbn07XG5leHBvcnQgZnVuY3Rpb24gaXNQcmVzZW50KG9iaikge1xuICAgIHJldHVybiBvYmogIT0gbnVsbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYXRDb21wbGV0aW9uVXRpbHMubWpzLm1hcCIsInZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfRXZlbnRTdHJlYW1faW5zdGFuY2VzLCBfRXZlbnRTdHJlYW1fY29ubmVjdGVkUHJvbWlzZSwgX0V2ZW50U3RyZWFtX3Jlc29sdmVDb25uZWN0ZWRQcm9taXNlLCBfRXZlbnRTdHJlYW1fcmVqZWN0Q29ubmVjdGVkUHJvbWlzZSwgX0V2ZW50U3RyZWFtX2VuZFByb21pc2UsIF9FdmVudFN0cmVhbV9yZXNvbHZlRW5kUHJvbWlzZSwgX0V2ZW50U3RyZWFtX3JlamVjdEVuZFByb21pc2UsIF9FdmVudFN0cmVhbV9saXN0ZW5lcnMsIF9FdmVudFN0cmVhbV9lbmRlZCwgX0V2ZW50U3RyZWFtX2Vycm9yZWQsIF9FdmVudFN0cmVhbV9hYm9ydGVkLCBfRXZlbnRTdHJlYW1fY2F0Y2hpbmdQcm9taXNlQ3JlYXRlZCwgX0V2ZW50U3RyZWFtX2hhbmRsZUVycm9yO1xuaW1wb3J0IHsgQVBJVXNlckFib3J0RXJyb3IsIE9wZW5BSUVycm9yIH0gZnJvbSAnb3BlbmFpL2Vycm9yJztcbmV4cG9ydCBjbGFzcyBFdmVudFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIF9FdmVudFN0cmVhbV9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIF9FdmVudFN0cmVhbV9jb25uZWN0ZWRQcm9taXNlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfRXZlbnRTdHJlYW1fcmVzb2x2ZUNvbm5lY3RlZFByb21pc2Uuc2V0KHRoaXMsICgpID0+IHsgfSk7XG4gICAgICAgIF9FdmVudFN0cmVhbV9yZWplY3RDb25uZWN0ZWRQcm9taXNlLnNldCh0aGlzLCAoKSA9PiB7IH0pO1xuICAgICAgICBfRXZlbnRTdHJlYW1fZW5kUHJvbWlzZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0V2ZW50U3RyZWFtX3Jlc29sdmVFbmRQcm9taXNlLnNldCh0aGlzLCAoKSA9PiB7IH0pO1xuICAgICAgICBfRXZlbnRTdHJlYW1fcmVqZWN0RW5kUHJvbWlzZS5zZXQodGhpcywgKCkgPT4geyB9KTtcbiAgICAgICAgX0V2ZW50U3RyZWFtX2xpc3RlbmVycy5zZXQodGhpcywge30pO1xuICAgICAgICBfRXZlbnRTdHJlYW1fZW5kZWQuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICAgICAgX0V2ZW50U3RyZWFtX2Vycm9yZWQuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICAgICAgX0V2ZW50U3RyZWFtX2Fib3J0ZWQuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICAgICAgX0V2ZW50U3RyZWFtX2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRXZlbnRTdHJlYW1fY29ubmVjdGVkUHJvbWlzZSwgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRXZlbnRTdHJlYW1fcmVzb2x2ZUNvbm5lY3RlZFByb21pc2UsIHJlc29sdmUsIFwiZlwiKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0V2ZW50U3RyZWFtX3JlamVjdENvbm5lY3RlZFByb21pc2UsIHJlamVjdCwgXCJmXCIpO1xuICAgICAgICB9KSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FdmVudFN0cmVhbV9lbmRQcm9taXNlLCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FdmVudFN0cmVhbV9yZXNvbHZlRW5kUHJvbWlzZSwgcmVzb2x2ZSwgXCJmXCIpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRXZlbnRTdHJlYW1fcmVqZWN0RW5kUHJvbWlzZSwgcmVqZWN0LCBcImZcIik7XG4gICAgICAgIH0pLCBcImZcIik7XG4gICAgICAgIC8vIERvbid0IGxldCB0aGVzZSBwcm9taXNlcyBjYXVzZSB1bmhhbmRsZWQgcmVqZWN0aW9uIGVycm9ycy5cbiAgICAgICAgLy8gd2Ugd2lsbCBtYW51YWxseSBjYXVzZSBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uIGVycm9yIGxhdGVyXG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIGhhc24ndCByZWdpc3RlcmVkIGFueSBlcnJvciBsaXN0ZW5lciBvciBjYWxsZWRcbiAgICAgICAgLy8gYW55IHByb21pc2UtcmV0dXJuaW5nIG1ldGhvZC5cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1fY29ubmVjdGVkUHJvbWlzZSwgXCJmXCIpLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50U3RyZWFtX2VuZFByb21pc2UsIFwiZlwiKS5jYXRjaCgoKSA9PiB7IH0pO1xuICAgIH1cbiAgICBfcnVuKGV4ZWN1dG9yKSB7XG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHkgaWYgd2UgY2FsbCBgZXhlY3V0b3IoKWAgaW1tZWRpYXRlbHkgd2UgZ2V0IHJ1bnRpbWUgZXJyb3JzIGFib3V0XG4gICAgICAgIC8vIHJlZmVyZW5jZXMgdG8gYHRoaXNgIGJlZm9yZSB0aGUgYHN1cGVyKClgIGNvbnN0cnVjdG9yIGNhbGwgcmV0dXJucy5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBleGVjdXRvcigpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRGaW5hbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2VuZCcpO1xuICAgICAgICAgICAgfSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX0V2ZW50U3RyZWFtX2hhbmRsZUVycm9yKS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIF9jb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudFN0cmVhbV9yZXNvbHZlQ29ubmVjdGVkUHJvbWlzZSwgXCJmXCIpLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2VtaXQoJ2Nvbm5lY3QnKTtcbiAgICB9XG4gICAgZ2V0IGVuZGVkKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1fZW5kZWQsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGVycm9yZWQoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudFN0cmVhbV9lcnJvcmVkLCBcImZcIik7XG4gICAgfVxuICAgIGdldCBhYm9ydGVkKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1fYWJvcnRlZCwgXCJmXCIpO1xuICAgIH1cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhlIGV2ZW50LlxuICAgICAqIE5vIGNoZWNrcyBhcmUgbWFkZSB0byBzZWUgaWYgdGhlIGxpc3RlbmVyIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQuIE11bHRpcGxlIGNhbGxzIHBhc3NpbmdcbiAgICAgKiB0aGUgc2FtZSBjb21iaW5hdGlvbiBvZiBldmVudCBhbmQgbGlzdGVuZXIgd2lsbCByZXN1bHQgaW4gdGhlIGxpc3RlbmVyIGJlaW5nIGFkZGVkLCBhbmRcbiAgICAgKiBjYWxsZWQsIG11bHRpcGxlIHRpbWVzLlxuICAgICAqIEByZXR1cm5zIHRoaXMgQ2hhdENvbXBsZXRpb25TdHJlYW0sIHNvIHRoYXQgY2FsbHMgY2FuIGJlIGNoYWluZWRcbiAgICAgKi9cbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1fbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdIHx8IChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudFN0cmVhbV9saXN0ZW5lcnMsIFwiZlwiKVtldmVudF0gPSBbXSk7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgZnJvbSB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBldmVudC5cbiAgICAgKiBvZmYoKSB3aWxsIHJlbW92ZSwgYXQgbW9zdCwgb25lIGluc3RhbmNlIG9mIGEgbGlzdGVuZXIgZnJvbSB0aGUgbGlzdGVuZXIgYXJyYXkuIElmIGFueSBzaW5nbGVcbiAgICAgKiBsaXN0ZW5lciBoYXMgYmVlbiBhZGRlZCBtdWx0aXBsZSB0aW1lcyB0byB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQsIHRoZW5cbiAgICAgKiBvZmYoKSBtdXN0IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byByZW1vdmUgZWFjaCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB0aGlzIENoYXRDb21wbGV0aW9uU3RyZWFtLCBzbyB0aGF0IGNhbGxzIGNhbiBiZSBjaGFpbmVkXG4gICAgICovXG4gICAgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudFN0cmVhbV9saXN0ZW5lcnMsIFwiZlwiKVtldmVudF07XG4gICAgICAgIGlmICghbGlzdGVuZXJzKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmZpbmRJbmRleCgobCkgPT4gbC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMClcbiAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG9uZS10aW1lIGxpc3RlbmVyIGZ1bmN0aW9uIGZvciB0aGUgZXZlbnQuIFRoZSBuZXh0IHRpbWUgdGhlIGV2ZW50IGlzIHRyaWdnZXJlZCxcbiAgICAgKiB0aGlzIGxpc3RlbmVyIGlzIHJlbW92ZWQgYW5kIHRoZW4gaW52b2tlZC5cbiAgICAgKiBAcmV0dXJucyB0aGlzIENoYXRDb21wbGV0aW9uU3RyZWFtLCBzbyB0aGF0IGNhbGxzIGNhbiBiZSBjaGFpbmVkXG4gICAgICovXG4gICAgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1fbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdIHx8IChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudFN0cmVhbV9saXN0ZW5lcnMsIFwiZlwiKVtldmVudF0gPSBbXSk7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHNpbWlsYXIgdG8gYC5vbmNlKClgLCBidXQgcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0aGUgbmV4dCB0aW1lXG4gICAgICogdGhlIGV2ZW50IGlzIHRyaWdnZXJlZCwgaW5zdGVhZCBvZiBjYWxsaW5nIGEgbGlzdGVuZXIgY2FsbGJhY2suXG4gICAgICogQHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdGhlIG5leHQgdGltZSBnaXZlbiBldmVudCBpcyB0cmlnZ2VyZWQsXG4gICAgICogb3IgcmVqZWN0cyBpZiBhbiBlcnJvciBpcyBlbWl0dGVkLiAgKElmIHlvdSByZXF1ZXN0IHRoZSAnZXJyb3InIGV2ZW50LFxuICAgICAqIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXJyb3IpLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHN0cmVhbS5lbWl0dGVkKCdtZXNzYWdlJykgLy8gcmVqZWN0cyBpZiB0aGUgc3RyZWFtIGVycm9yc1xuICAgICAqL1xuICAgIGVtaXR0ZWQoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0V2ZW50U3RyZWFtX2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQsIHRydWUsIFwiZlwiKTtcbiAgICAgICAgICAgIGlmIChldmVudCAhPT0gJ2Vycm9yJylcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICAgIHRoaXMub25jZShldmVudCwgcmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBkb25lKCkge1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FdmVudFN0cmVhbV9jYXRjaGluZ1Byb21pc2VDcmVhdGVkLCB0cnVlLCBcImZcIik7XG4gICAgICAgIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50U3RyZWFtX2VuZFByb21pc2UsIFwiZlwiKTtcbiAgICB9XG4gICAgX2VtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGRvbid0IGVtaXQgYW55IGV2ZW50cyBhZnRlciBlbmRcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50U3RyZWFtX2VuZGVkLCBcImZcIikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FdmVudFN0cmVhbV9lbmRlZCwgdHJ1ZSwgXCJmXCIpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1fcmVzb2x2ZUVuZFByb21pc2UsIFwiZlwiKS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50U3RyZWFtX2xpc3RlbmVycywgXCJmXCIpW2V2ZW50XTtcbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1fbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdID0gbGlzdGVuZXJzLmZpbHRlcigobCkgPT4gIWwub25jZSk7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lciguLi5hcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50ID09PSAnYWJvcnQnKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGFyZ3NbMF07XG4gICAgICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50U3RyZWFtX2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQsIFwiZlwiKSAmJiAhbGlzdGVuZXJzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudFN0cmVhbV9yZWplY3RDb25uZWN0ZWRQcm9taXNlLCBcImZcIikuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudFN0cmVhbV9yZWplY3RFbmRQcm9taXNlLCBcImZcIikuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdlbmQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IF9lbWl0KCdlcnJvcicsIGVycm9yKSBzaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSAjaGFuZGxlRXJyb3IoKS5cbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gYXJnc1swXTtcbiAgICAgICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRTdHJlYW1fY2F0Y2hpbmdQcm9taXNlQ3JlYXRlZCwgXCJmXCIpICYmICFsaXN0ZW5lcnM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgYW4gdW5oYW5kbGVkIHJlamVjdGlvbiBpZiB0aGUgdXNlciBoYXNuJ3QgcmVnaXN0ZXJlZCBhbnkgZXJyb3IgaGFuZGxlcnMuXG4gICAgICAgICAgICAgICAgLy8gSWYgeW91IGFyZSBzZWVpbmcgc3RhY2sgdHJhY2VzIGhlcmUsIG1ha2Ugc3VyZSB0byBoYW5kbGUgZXJyb3JzIHZpYSBlaXRoZXI6XG4gICAgICAgICAgICAgICAgLy8gLSBydW5uZXIub24oJ2Vycm9yJywgKCkgPT4gLi4uKVxuICAgICAgICAgICAgICAgIC8vIC0gYXdhaXQgcnVubmVyLmRvbmUoKVxuICAgICAgICAgICAgICAgIC8vIC0gYXdhaXQgcnVubmVyLmZpbmFsQ2hhdENvbXBsZXRpb24oKVxuICAgICAgICAgICAgICAgIC8vIC0gZXRjLlxuICAgICAgICAgICAgICAgIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50U3RyZWFtX3JlamVjdENvbm5lY3RlZFByb21pc2UsIFwiZlwiKS5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50U3RyZWFtX3JlamVjdEVuZFByb21pc2UsIFwiZlwiKS5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9lbWl0RmluYWwoKSB7IH1cbn1cbl9FdmVudFN0cmVhbV9jb25uZWN0ZWRQcm9taXNlID0gbmV3IFdlYWtNYXAoKSwgX0V2ZW50U3RyZWFtX3Jlc29sdmVDb25uZWN0ZWRQcm9taXNlID0gbmV3IFdlYWtNYXAoKSwgX0V2ZW50U3RyZWFtX3JlamVjdENvbm5lY3RlZFByb21pc2UgPSBuZXcgV2Vha01hcCgpLCBfRXZlbnRTdHJlYW1fZW5kUHJvbWlzZSA9IG5ldyBXZWFrTWFwKCksIF9FdmVudFN0cmVhbV9yZXNvbHZlRW5kUHJvbWlzZSA9IG5ldyBXZWFrTWFwKCksIF9FdmVudFN0cmVhbV9yZWplY3RFbmRQcm9taXNlID0gbmV3IFdlYWtNYXAoKSwgX0V2ZW50U3RyZWFtX2xpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCksIF9FdmVudFN0cmVhbV9lbmRlZCA9IG5ldyBXZWFrTWFwKCksIF9FdmVudFN0cmVhbV9lcnJvcmVkID0gbmV3IFdlYWtNYXAoKSwgX0V2ZW50U3RyZWFtX2Fib3J0ZWQgPSBuZXcgV2Vha01hcCgpLCBfRXZlbnRTdHJlYW1fY2F0Y2hpbmdQcm9taXNlQ3JlYXRlZCA9IG5ldyBXZWFrTWFwKCksIF9FdmVudFN0cmVhbV9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpLCBfRXZlbnRTdHJlYW1faGFuZGxlRXJyb3IgPSBmdW5jdGlvbiBfRXZlbnRTdHJlYW1faGFuZGxlRXJyb3IoZXJyb3IpIHtcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FdmVudFN0cmVhbV9lcnJvcmVkLCB0cnVlLCBcImZcIik7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIGVycm9yID0gbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFQSVVzZXJBYm9ydEVycm9yKSB7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0V2ZW50U3RyZWFtX2Fib3J0ZWQsIHRydWUsIFwiZlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXQoJ2Fib3J0JywgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBPcGVuQUlFcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGNvbnN0IG9wZW5BSUVycm9yID0gbmV3IE9wZW5BSUVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIG9wZW5BSUVycm9yLmNhdXNlID0gZXJyb3I7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbWl0KCdlcnJvcicsIG9wZW5BSUVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VtaXQoJ2Vycm9yJywgbmV3IE9wZW5BSUVycm9yKFN0cmluZyhlcnJvcikpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudFN0cmVhbS5tanMubWFwIiwiaW1wb3J0IHsgQ29udGVudEZpbHRlckZpbmlzaFJlYXNvbkVycm9yLCBMZW5ndGhGaW5pc2hSZWFzb25FcnJvciwgT3BlbkFJRXJyb3IgfSBmcm9tICdvcGVuYWkvZXJyb3InO1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQYXJzZWFibGVSZXNwb25zZUZvcm1hdChyZXNwb25zZV9mb3JtYXQsIHBhcnNlcikge1xuICAgIGNvbnN0IG9iaiA9IHsgLi4ucmVzcG9uc2VfZm9ybWF0IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqLCB7XG4gICAgICAgICRicmFuZDoge1xuICAgICAgICAgICAgdmFsdWU6ICdhdXRvLXBhcnNlYWJsZS1yZXNwb25zZS1mb3JtYXQnLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgICRwYXJzZVJhdzoge1xuICAgICAgICAgICAgdmFsdWU6IHBhcnNlcixcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRvUGFyc2FibGVSZXNwb25zZUZvcm1hdChyZXNwb25zZV9mb3JtYXQpIHtcbiAgICByZXR1cm4gcmVzcG9uc2VfZm9ybWF0Py5bJyRicmFuZCddID09PSAnYXV0by1wYXJzZWFibGUtcmVzcG9uc2UtZm9ybWF0Jztcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUGFyc2VhYmxlVG9vbCh0b29sLCB7IHBhcnNlciwgY2FsbGJhY2ssIH0pIHtcbiAgICBjb25zdCBvYmogPSB7IC4uLnRvb2wgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmosIHtcbiAgICAgICAgJGJyYW5kOiB7XG4gICAgICAgICAgICB2YWx1ZTogJ2F1dG8tcGFyc2VhYmxlLXRvb2wnLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgICRwYXJzZVJhdzoge1xuICAgICAgICAgICAgdmFsdWU6IHBhcnNlcixcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICAkY2FsbGJhY2s6IHtcbiAgICAgICAgICAgIHZhbHVlOiBjYWxsYmFjayxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRvUGFyc2FibGVUb29sKHRvb2wpIHtcbiAgICByZXR1cm4gdG9vbD8uWyckYnJhbmQnXSA9PT0gJ2F1dG8tcGFyc2VhYmxlLXRvb2wnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlUGFyc2VDaGF0Q29tcGxldGlvbihjb21wbGV0aW9uLCBwYXJhbXMpIHtcbiAgICBpZiAoIXBhcmFtcyB8fCAhaGFzQXV0b1BhcnNlYWJsZUlucHV0KHBhcmFtcykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbXBsZXRpb24sXG4gICAgICAgICAgICBjaG9pY2VzOiBjb21wbGV0aW9uLmNob2ljZXMubWFwKChjaG9pY2UpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uY2hvaWNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHsgLi4uY2hvaWNlLm1lc3NhZ2UsIHBhcnNlZDogbnVsbCwgdG9vbF9jYWxsczogY2hvaWNlLm1lc3NhZ2UudG9vbF9jYWxscyA/PyBbXSB9LFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VDaGF0Q29tcGxldGlvbihjb21wbGV0aW9uLCBwYXJhbXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ2hhdENvbXBsZXRpb24oY29tcGxldGlvbiwgcGFyYW1zKSB7XG4gICAgY29uc3QgY2hvaWNlcyA9IGNvbXBsZXRpb24uY2hvaWNlcy5tYXAoKGNob2ljZSkgPT4ge1xuICAgICAgICBpZiAoY2hvaWNlLmZpbmlzaF9yZWFzb24gPT09ICdsZW5ndGgnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTGVuZ3RoRmluaXNoUmVhc29uRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hvaWNlLmZpbmlzaF9yZWFzb24gPT09ICdjb250ZW50X2ZpbHRlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb250ZW50RmlsdGVyRmluaXNoUmVhc29uRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY2hvaWNlLFxuICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgIC4uLmNob2ljZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IGNob2ljZS5tZXNzYWdlLnRvb2xfY2FsbHM/Lm1hcCgodG9vbENhbGwpID0+IHBhcnNlVG9vbENhbGwocGFyYW1zLCB0b29sQ2FsbCkpID8/IFtdLFxuICAgICAgICAgICAgICAgIHBhcnNlZDogY2hvaWNlLm1lc3NhZ2UuY29udGVudCAmJiAhY2hvaWNlLm1lc3NhZ2UucmVmdXNhbCA/XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlUmVzcG9uc2VGb3JtYXQocGFyYW1zLCBjaG9pY2UubWVzc2FnZS5jb250ZW50KVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7IC4uLmNvbXBsZXRpb24sIGNob2ljZXMgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VGb3JtYXQocGFyYW1zLCBjb250ZW50KSB7XG4gICAgaWYgKHBhcmFtcy5yZXNwb25zZV9mb3JtYXQ/LnR5cGUgIT09ICdqc29uX3NjaGVtYScpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwYXJhbXMucmVzcG9uc2VfZm9ybWF0Py50eXBlID09PSAnanNvbl9zY2hlbWEnKSB7XG4gICAgICAgIGlmICgnJHBhcnNlUmF3JyBpbiBwYXJhbXMucmVzcG9uc2VfZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZV9mb3JtYXQgPSBwYXJhbXMucmVzcG9uc2VfZm9ybWF0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlX2Zvcm1hdC4kcGFyc2VSYXcoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoY29udGVudCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VUb29sQ2FsbChwYXJhbXMsIHRvb2xDYWxsKSB7XG4gICAgY29uc3QgaW5wdXRUb29sID0gcGFyYW1zLnRvb2xzPy5maW5kKChpbnB1dFRvb2wpID0+IGlucHV0VG9vbC5mdW5jdGlvbj8ubmFtZSA9PT0gdG9vbENhbGwuZnVuY3Rpb24ubmFtZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4udG9vbENhbGwsXG4gICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAuLi50b29sQ2FsbC5mdW5jdGlvbixcbiAgICAgICAgICAgIHBhcnNlZF9hcmd1bWVudHM6IGlzQXV0b1BhcnNhYmxlVG9vbChpbnB1dFRvb2wpID8gaW5wdXRUb29sLiRwYXJzZVJhdyh0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgOiBpbnB1dFRvb2w/LmZ1bmN0aW9uLnN0cmljdCA/IEpTT04ucGFyc2UodG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRQYXJzZVRvb2xDYWxsKHBhcmFtcywgdG9vbENhbGwpIHtcbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0VG9vbCA9IHBhcmFtcy50b29scz8uZmluZCgoaW5wdXRUb29sKSA9PiBpbnB1dFRvb2wuZnVuY3Rpb24/Lm5hbWUgPT09IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUpO1xuICAgIHJldHVybiBpc0F1dG9QYXJzYWJsZVRvb2woaW5wdXRUb29sKSB8fCBpbnB1dFRvb2w/LmZ1bmN0aW9uLnN0cmljdCB8fCBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNBdXRvUGFyc2VhYmxlSW5wdXQocGFyYW1zKSB7XG4gICAgaWYgKGlzQXV0b1BhcnNhYmxlUmVzcG9uc2VGb3JtYXQocGFyYW1zLnJlc3BvbnNlX2Zvcm1hdCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAocGFyYW1zLnRvb2xzPy5zb21lKCh0KSA9PiBpc0F1dG9QYXJzYWJsZVRvb2wodCkgfHwgKHQudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0LmZ1bmN0aW9uLnN0cmljdCA9PT0gdHJ1ZSkpID8/IGZhbHNlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUlucHV0VG9vbHModG9vbHMpIHtcbiAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbHMgPz8gW10pIHtcbiAgICAgICAgaWYgKHRvb2wudHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBDdXJyZW50bHkgb25seSBcXGBmdW5jdGlvblxcYCB0b29sIHR5cGVzIHN1cHBvcnQgYXV0by1wYXJzaW5nOyBSZWNlaXZlZCBcXGAke3Rvb2wudHlwZX1cXGBgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9vbC5mdW5jdGlvbi5zdHJpY3QgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgVGhlIFxcYCR7dG9vbC5mdW5jdGlvbi5uYW1lfVxcYCB0b29sIGlzIG5vdCBtYXJrZWQgd2l0aCBcXGBzdHJpY3Q6IHRydWVcXGAuIE9ubHkgc3RyaWN0IGZ1bmN0aW9uIHRvb2xzIGNhbiBiZSBhdXRvLXBhcnNlZGApO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VyLm1qcy5tYXAiLCJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9pbnN0YW5jZXMsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsQ29udGVudCwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxNZXNzYWdlLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbEZ1bmN0aW9uQ2FsbCwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxGdW5jdGlvbkNhbGxSZXN1bHQsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2NhbGN1bGF0ZVRvdGFsVXNhZ2UsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX3ZhbGlkYXRlUGFyYW1zLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9zdHJpbmdpZnlGdW5jdGlvbkNhbGxSZXN1bHQ7XG5pbXBvcnQgeyBPcGVuQUlFcnJvciB9IGZyb20gJ29wZW5haS9lcnJvcic7XG5pbXBvcnQgeyBpc1J1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2UsIH0gZnJvbSBcIi4vUnVubmFibGVGdW5jdGlvbi5tanNcIjtcbmltcG9ydCB7IGlzQXNzaXN0YW50TWVzc2FnZSwgaXNGdW5jdGlvbk1lc3NhZ2UsIGlzVG9vbE1lc3NhZ2UgfSBmcm9tIFwiLi9jaGF0Q29tcGxldGlvblV0aWxzLm1qc1wiO1xuaW1wb3J0IHsgRXZlbnRTdHJlYW0gfSBmcm9tIFwiLi9FdmVudFN0cmVhbS5tanNcIjtcbmltcG9ydCB7IGlzQXV0b1BhcnNhYmxlVG9vbCwgcGFyc2VDaGF0Q29tcGxldGlvbiB9IGZyb20gJ29wZW5haS9saWIvcGFyc2VyJztcbmNvbnN0IERFRkFVTFRfTUFYX0NIQVRfQ09NUExFVElPTlMgPSAxMDtcbmV4cG9ydCBjbGFzcyBBYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyIGV4dGVuZHMgRXZlbnRTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICB0aGlzLl9jaGF0Q29tcGxldGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgIH1cbiAgICBfYWRkQ2hhdENvbXBsZXRpb24oY2hhdENvbXBsZXRpb24pIHtcbiAgICAgICAgdGhpcy5fY2hhdENvbXBsZXRpb25zLnB1c2goY2hhdENvbXBsZXRpb24pO1xuICAgICAgICB0aGlzLl9lbWl0KCdjaGF0Q29tcGxldGlvbicsIGNoYXRDb21wbGV0aW9uKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNoYXRDb21wbGV0aW9uLmNob2ljZXNbMF0/Lm1lc3NhZ2U7XG4gICAgICAgIGlmIChtZXNzYWdlKVxuICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGNoYXRDb21wbGV0aW9uO1xuICAgIH1cbiAgICBfYWRkTWVzc2FnZShtZXNzYWdlLCBlbWl0ID0gdHJ1ZSkge1xuICAgICAgICBpZiAoISgnY29udGVudCcgaW4gbWVzc2FnZSkpXG4gICAgICAgICAgICBtZXNzYWdlLmNvbnRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoKGlzRnVuY3Rpb25NZXNzYWdlKG1lc3NhZ2UpIHx8IGlzVG9vbE1lc3NhZ2UobWVzc2FnZSkpICYmIG1lc3NhZ2UuY29udGVudCkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGUsIHRoaXMgYXNzdW1lcyB0aGF0IHtyb2xlOiAndG9vbCcsIGNvbnRlbnQ6IOKApn0gaXMgYWx3YXlzIHRoZSByZXN1bHQgb2YgYSBjYWxsIG9mIHRvb2wgb2YgdHlwZT1mdW5jdGlvbi5cbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCdmdW5jdGlvbkNhbGxSZXN1bHQnLCBtZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNBc3Npc3RhbnRNZXNzYWdlKG1lc3NhZ2UpICYmIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2Z1bmN0aW9uQ2FsbCcsIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2UobWVzc2FnZSkgJiYgbWVzc2FnZS50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b29sX2NhbGwgb2YgbWVzc2FnZS50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29sX2NhbGwudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgnZnVuY3Rpb25DYWxsJywgdG9vbF9jYWxsLmZ1bmN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBmaW5hbCBDaGF0Q29tcGxldGlvbiwgb3IgcmVqZWN0c1xuICAgICAqIGlmIGFuIGVycm9yIG9jY3VycmVkIG9yIHRoZSBzdHJlYW0gZW5kZWQgcHJlbWF0dXJlbHkgd2l0aG91dCBwcm9kdWNpbmcgYSBDaGF0Q29tcGxldGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBmaW5hbENoYXRDb21wbGV0aW9uKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICAgICAgY29uc3QgY29tcGxldGlvbiA9IHRoaXMuX2NoYXRDb21wbGV0aW9uc1t0aGlzLl9jaGF0Q29tcGxldGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICghY29tcGxldGlvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcignc3RyZWFtIGVuZGVkIHdpdGhvdXQgcHJvZHVjaW5nIGEgQ2hhdENvbXBsZXRpb24nKTtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGNvbnRlbnQgb2YgdGhlIGZpbmFsIENoYXRDb21wbGV0aW9uTWVzc2FnZSwgb3IgcmVqZWN0c1xuICAgICAqIGlmIGFuIGVycm9yIG9jY3VycmVkIG9yIHRoZSBzdHJlYW0gZW5kZWQgcHJlbWF0dXJlbHkgd2l0aG91dCBwcm9kdWNpbmcgYSBDaGF0Q29tcGxldGlvbk1lc3NhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgZmluYWxDb250ZW50KCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxDb250ZW50KS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSB0aGUgZmluYWwgYXNzaXN0YW50IENoYXRDb21wbGV0aW9uTWVzc2FnZSByZXNwb25zZSxcbiAgICAgKiBvciByZWplY3RzIGlmIGFuIGVycm9yIG9jY3VycmVkIG9yIHRoZSBzdHJlYW0gZW5kZWQgcHJlbWF0dXJlbHkgd2l0aG91dCBwcm9kdWNpbmcgYSBDaGF0Q29tcGxldGlvbk1lc3NhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgZmluYWxNZXNzYWdlKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxNZXNzYWdlKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBjb250ZW50IG9mIHRoZSBmaW5hbCBGdW5jdGlvbkNhbGwsIG9yIHJlamVjdHNcbiAgICAgKiBpZiBhbiBlcnJvciBvY2N1cnJlZCBvciB0aGUgc3RyZWFtIGVuZGVkIHByZW1hdHVyZWx5IHdpdGhvdXQgcHJvZHVjaW5nIGEgQ2hhdENvbXBsZXRpb25NZXNzYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIGZpbmFsRnVuY3Rpb25DYWxsKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxGdW5jdGlvbkNhbGwpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGFzeW5jIGZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0KCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxGdW5jdGlvbkNhbGxSZXN1bHQpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGFzeW5jIHRvdGFsVXNhZ2UoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9pbnN0YW5jZXMsIFwibVwiLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9jYWxjdWxhdGVUb3RhbFVzYWdlKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBhbGxDaGF0Q29tcGxldGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5fY2hhdENvbXBsZXRpb25zXTtcbiAgICB9XG4gICAgX2VtaXRGaW5hbCgpIHtcbiAgICAgICAgY29uc3QgY29tcGxldGlvbiA9IHRoaXMuX2NoYXRDb21wbGV0aW9uc1t0aGlzLl9jaGF0Q29tcGxldGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChjb21wbGV0aW9uKVxuICAgICAgICAgICAgdGhpcy5fZW1pdCgnZmluYWxDaGF0Q29tcGxldGlvbicsIGNvbXBsZXRpb24pO1xuICAgICAgICBjb25zdCBmaW5hbE1lc3NhZ2UgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2luc3RhbmNlcywgXCJtXCIsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsTWVzc2FnZSkuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKGZpbmFsTWVzc2FnZSlcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2ZpbmFsTWVzc2FnZScsIGZpbmFsTWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IGZpbmFsQ29udGVudCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxDb250ZW50KS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAoZmluYWxDb250ZW50KVxuICAgICAgICAgICAgdGhpcy5fZW1pdCgnZmluYWxDb250ZW50JywgZmluYWxDb250ZW50KTtcbiAgICAgICAgY29uc3QgZmluYWxGdW5jdGlvbkNhbGwgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2luc3RhbmNlcywgXCJtXCIsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsRnVuY3Rpb25DYWxsKS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAoZmluYWxGdW5jdGlvbkNhbGwpXG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdmaW5hbEZ1bmN0aW9uQ2FsbCcsIGZpbmFsRnVuY3Rpb25DYWxsKTtcbiAgICAgICAgY29uc3QgZmluYWxGdW5jdGlvbkNhbGxSZXN1bHQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2luc3RhbmNlcywgXCJtXCIsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0KS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAoZmluYWxGdW5jdGlvbkNhbGxSZXN1bHQgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2ZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0JywgZmluYWxGdW5jdGlvbkNhbGxSZXN1bHQpO1xuICAgICAgICBpZiAodGhpcy5fY2hhdENvbXBsZXRpb25zLnNvbWUoKGMpID0+IGMudXNhZ2UpKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCd0b3RhbFVzYWdlJywgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9pbnN0YW5jZXMsIFwibVwiLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9jYWxjdWxhdGVUb3RhbFVzYWdlKS5jYWxsKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfY3JlYXRlQ2hhdENvbXBsZXRpb24oY2xpZW50LCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9pbnN0YW5jZXMsIFwibVwiLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl92YWxpZGF0ZVBhcmFtcykuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBjaGF0Q29tcGxldGlvbiA9IGF3YWl0IGNsaWVudC5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7IC4uLnBhcmFtcywgc3RyZWFtOiBmYWxzZSB9LCB7IC4uLm9wdGlvbnMsIHNpZ25hbDogdGhpcy5jb250cm9sbGVyLnNpZ25hbCB9KTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGF0Q29tcGxldGlvbihwYXJzZUNoYXRDb21wbGV0aW9uKGNoYXRDb21wbGV0aW9uLCBwYXJhbXMpKTtcbiAgICB9XG4gICAgYXN5bmMgX3J1bkNoYXRDb21wbGV0aW9uKGNsaWVudCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwYXJhbXMubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UobWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9jcmVhdGVDaGF0Q29tcGxldGlvbihjbGllbnQsIHBhcmFtcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIF9ydW5GdW5jdGlvbnMoY2xpZW50LCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgcm9sZSA9ICdmdW5jdGlvbic7XG4gICAgICAgIGNvbnN0IHsgZnVuY3Rpb25fY2FsbCA9ICdhdXRvJywgc3RyZWFtLCAuLi5yZXN0UGFyYW1zIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IHNpbmdsZUZ1bmN0aW9uVG9DYWxsID0gdHlwZW9mIGZ1bmN0aW9uX2NhbGwgIT09ICdzdHJpbmcnICYmIGZ1bmN0aW9uX2NhbGw/Lm5hbWU7XG4gICAgICAgIGNvbnN0IHsgbWF4Q2hhdENvbXBsZXRpb25zID0gREVGQVVMVF9NQVhfQ0hBVF9DT01QTEVUSU9OUyB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25zQnlOYW1lID0ge307XG4gICAgICAgIGZvciAoY29uc3QgZiBvZiBwYXJhbXMuZnVuY3Rpb25zKSB7XG4gICAgICAgICAgICBmdW5jdGlvbnNCeU5hbWVbZi5uYW1lIHx8IGYuZnVuY3Rpb24ubmFtZV0gPSBmO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9ucyA9IHBhcmFtcy5mdW5jdGlvbnMubWFwKChmKSA9PiAoe1xuICAgICAgICAgICAgbmFtZTogZi5uYW1lIHx8IGYuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IGYucGFyYW1ldGVycyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBmLmRlc2NyaXB0aW9uLFxuICAgICAgICB9KSk7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwYXJhbXMubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UobWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4Q2hhdENvbXBsZXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXRDb21wbGV0aW9uID0gYXdhaXQgdGhpcy5fY3JlYXRlQ2hhdENvbXBsZXRpb24oY2xpZW50LCB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdFBhcmFtcyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9ucyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogWy4uLnRoaXMubWVzc2FnZXNdLFxuICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gY2hhdENvbXBsZXRpb24uY2hvaWNlc1swXT8ubWVzc2FnZTtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyBtZXNzYWdlIGluIENoYXRDb21wbGV0aW9uIHJlc3BvbnNlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UuZnVuY3Rpb25fY2FsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIGFyZ3VtZW50czogYXJncyB9ID0gbWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICAgICAgY29uc3QgZm4gPSBmdW5jdGlvbnNCeU5hbWVbbmFtZV07XG4gICAgICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGBJbnZhbGlkIGZ1bmN0aW9uX2NhbGw6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9LiBBdmFpbGFibGUgb3B0aW9ucyBhcmU6ICR7ZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGYpID0+IEpTT04uc3RyaW5naWZ5KGYubmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfS4gUGxlYXNlIHRyeSBhZ2FpbmA7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7IHJvbGUsIG5hbWUsIGNvbnRlbnQgfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaW5nbGVGdW5jdGlvblRvQ2FsbCAmJiBzaW5nbGVGdW5jdGlvblRvQ2FsbCAhPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBgSW52YWxpZCBmdW5jdGlvbl9jYWxsOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfS4gJHtKU09OLnN0cmluZ2lmeShzaW5nbGVGdW5jdGlvblRvQ2FsbCl9IHJlcXVlc3RlZC4gUGxlYXNlIHRyeSBhZ2FpbmA7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7IHJvbGUsIG5hbWUsIGNvbnRlbnQgfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGFyc2VkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBpc1J1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2UoZm4pID8gYXdhaXQgZm4ucGFyc2UoYXJncykgOiBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHJvbGUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaXQgY2FuJ3QgcnVsZSBvdXQgYG5ldmVyYCB0eXBlLlxuICAgICAgICAgICAgY29uc3QgcmF3Q29udGVudCA9IGF3YWl0IGZuLmZ1bmN0aW9uKHBhcnNlZCwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9pbnN0YW5jZXMsIFwibVwiLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9zdHJpbmdpZnlGdW5jdGlvbkNhbGxSZXN1bHQpLmNhbGwodGhpcywgcmF3Q29udGVudCk7XG4gICAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgbmFtZSwgY29udGVudCB9KTtcbiAgICAgICAgICAgIGlmIChzaW5nbGVGdW5jdGlvblRvQ2FsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3J1blRvb2xzKGNsaWVudCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJvbGUgPSAndG9vbCc7XG4gICAgICAgIGNvbnN0IHsgdG9vbF9jaG9pY2UgPSAnYXV0bycsIHN0cmVhbSwgLi4ucmVzdFBhcmFtcyB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCBzaW5nbGVGdW5jdGlvblRvQ2FsbCA9IHR5cGVvZiB0b29sX2Nob2ljZSAhPT0gJ3N0cmluZycgJiYgdG9vbF9jaG9pY2U/LmZ1bmN0aW9uPy5uYW1lO1xuICAgICAgICBjb25zdCB7IG1heENoYXRDb21wbGV0aW9ucyA9IERFRkFVTFRfTUFYX0NIQVRfQ09NUExFVElPTlMgfSA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIC8vIFRPRE8oc29tZWRheSk6IGNsZWFuIHRoaXMgbG9naWMgdXBcbiAgICAgICAgY29uc3QgaW5wdXRUb29scyA9IHBhcmFtcy50b29scy5tYXAoKHRvb2wpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0F1dG9QYXJzYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRvb2wuJGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcignVG9vbCBnaXZlbiB0byBgLnJ1blRvb2xzKClgIHRoYXQgZG9lcyBub3QgaGF2ZSBhbiBhc3NvY2lhdGVkIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjogdG9vbC4kY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5mdW5jdGlvbi5kZXNjcmlwdGlvbiB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHRvb2wuZnVuY3Rpb24ucGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlOiB0b29sLiRwYXJzZVJhdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvb2w7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmdW5jdGlvbnNCeU5hbWUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBmIG9mIGlucHV0VG9vbHMpIHtcbiAgICAgICAgICAgIGlmIChmLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbnNCeU5hbWVbZi5mdW5jdGlvbi5uYW1lIHx8IGYuZnVuY3Rpb24uZnVuY3Rpb24ubmFtZV0gPSBmLmZ1bmN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvb2xzID0gJ3Rvb2xzJyBpbiBwYXJhbXMgP1xuICAgICAgICAgICAgaW5wdXRUb29scy5tYXAoKHQpID0+IHQudHlwZSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdC5mdW5jdGlvbi5uYW1lIHx8IHQuZnVuY3Rpb24uZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHQuZnVuY3Rpb24ucGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0LmZ1bmN0aW9uLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0OiB0LmZ1bmN0aW9uLnN0cmljdCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB0KVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwYXJhbXMubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UobWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4Q2hhdENvbXBsZXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXRDb21wbGV0aW9uID0gYXdhaXQgdGhpcy5fY3JlYXRlQ2hhdENvbXBsZXRpb24oY2xpZW50LCB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdFBhcmFtcyxcbiAgICAgICAgICAgICAgICB0b29sX2Nob2ljZSxcbiAgICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogWy4uLnRoaXMubWVzc2FnZXNdLFxuICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gY2hhdENvbXBsZXRpb24uY2hvaWNlc1swXT8ubWVzc2FnZTtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyBtZXNzYWdlIGluIENoYXRDb21wbGV0aW9uIHJlc3BvbnNlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UudG9vbF9jYWxscz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sX2NhbGwgb2YgbWVzc2FnZS50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2xfY2FsbC50eXBlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sX2NhbGxfaWQgPSB0b29sX2NhbGwuaWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBhcmd1bWVudHM6IGFyZ3MgfSA9IHRvb2xfY2FsbC5mdW5jdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBmbiA9IGZ1bmN0aW9uc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBgSW52YWxpZCB0b29sX2NhbGw6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9LiBBdmFpbGFibGUgb3B0aW9ucyBhcmU6ICR7T2JqZWN0LmtleXMoZnVuY3Rpb25zQnlOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgobmFtZSkgPT4gSlNPTi5zdHJpbmdpZnkobmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKX0uIFBsZWFzZSB0cnkgYWdhaW5gO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgdG9vbF9jYWxsX2lkLCBjb250ZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2luZ2xlRnVuY3Rpb25Ub0NhbGwgJiYgc2luZ2xlRnVuY3Rpb25Ub0NhbGwgIT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGBJbnZhbGlkIHRvb2xfY2FsbDogJHtKU09OLnN0cmluZ2lmeShuYW1lKX0uICR7SlNPTi5zdHJpbmdpZnkoc2luZ2xlRnVuY3Rpb25Ub0NhbGwpfSByZXF1ZXN0ZWQuIFBsZWFzZSB0cnkgYWdhaW5gO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgdG9vbF9jYWxsX2lkLCBjb250ZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBpc1J1bm5hYmxlRnVuY3Rpb25XaXRoUGFyc2UoZm4pID8gYXdhaXQgZm4ucGFyc2UoYXJncykgOiBhcmdzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZSh7IHJvbGUsIHRvb2xfY2FsbF9pZCwgY29udGVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaXQgY2FuJ3QgcnVsZSBvdXQgYG5ldmVyYCB0eXBlLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJhd0NvbnRlbnQgPSBhd2FpdCBmbi5mdW5jdGlvbihwYXJzZWQsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2luc3RhbmNlcywgXCJtXCIsIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX3N0cmluZ2lmeUZ1bmN0aW9uQ2FsbFJlc3VsdCkuY2FsbCh0aGlzLCByYXdDb250ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKHsgcm9sZSwgdG9vbF9jYWxsX2lkLCBjb250ZW50IH0pO1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVGdW5jdGlvblRvQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG5fQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpLCBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbENvbnRlbnQgPSBmdW5jdGlvbiBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxNZXNzYWdlKS5jYWxsKHRoaXMpLmNvbnRlbnQgPz8gbnVsbDtcbn0sIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsTWVzc2FnZSA9IGZ1bmN0aW9uIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsTWVzc2FnZSgpIHtcbiAgICBsZXQgaSA9IHRoaXMubWVzc2FnZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW2ldO1xuICAgICAgICBpZiAoaXNBc3Npc3RhbnRNZXNzYWdlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZ1bmN0aW9uX2NhbGwsIC4uLnJlc3QgfSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQgPz8gbnVsbCxcbiAgICAgICAgICAgICAgICByZWZ1c2FsOiBtZXNzYWdlLnJlZnVzYWwgPz8gbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25fY2FsbCkge1xuICAgICAgICAgICAgICAgIHJldC5mdW5jdGlvbl9jYWxsID0gZnVuY3Rpb25fY2FsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKCdzdHJlYW0gZW5kZWQgd2l0aG91dCBwcm9kdWNpbmcgYSBDaGF0Q29tcGxldGlvbk1lc3NhZ2Ugd2l0aCByb2xlPWFzc2lzdGFudCcpO1xufSwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbEZ1bmN0aW9uQ2FsbCgpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5tZXNzYWdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5tZXNzYWdlc1tpXTtcbiAgICAgICAgaWYgKGlzQXNzaXN0YW50TWVzc2FnZShtZXNzYWdlKSAmJiBtZXNzYWdlPy5mdW5jdGlvbl9jYWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2UobWVzc2FnZSkgJiYgbWVzc2FnZT8udG9vbF9jYWxscz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZS50b29sX2NhbGxzLmF0KC0xKT8uZnVuY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufSwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfZ2V0RmluYWxGdW5jdGlvbkNhbGxSZXN1bHQgPSBmdW5jdGlvbiBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbEZ1bmN0aW9uQ2FsbFJlc3VsdCgpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5tZXNzYWdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5tZXNzYWdlc1tpXTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25NZXNzYWdlKG1lc3NhZ2UpICYmIG1lc3NhZ2UuY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Rvb2xNZXNzYWdlKG1lc3NhZ2UpICYmXG4gICAgICAgICAgICBtZXNzYWdlLmNvbnRlbnQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZXMuc29tZSgoeCkgPT4geC5yb2xlID09PSAnYXNzaXN0YW50JyAmJlxuICAgICAgICAgICAgICAgIHgudG9vbF9jYWxscz8uc29tZSgoeSkgPT4geS50eXBlID09PSAnZnVuY3Rpb24nICYmIHkuaWQgPT09IG1lc3NhZ2UudG9vbF9jYWxsX2lkKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufSwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfY2FsY3VsYXRlVG90YWxVc2FnZSA9IGZ1bmN0aW9uIF9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2NhbGN1bGF0ZVRvdGFsVXNhZ2UoKSB7XG4gICAgY29uc3QgdG90YWwgPSB7XG4gICAgICAgIGNvbXBsZXRpb25fdG9rZW5zOiAwLFxuICAgICAgICBwcm9tcHRfdG9rZW5zOiAwLFxuICAgICAgICB0b3RhbF90b2tlbnM6IDAsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHsgdXNhZ2UgfSBvZiB0aGlzLl9jaGF0Q29tcGxldGlvbnMpIHtcbiAgICAgICAgaWYgKHVzYWdlKSB7XG4gICAgICAgICAgICB0b3RhbC5jb21wbGV0aW9uX3Rva2VucyArPSB1c2FnZS5jb21wbGV0aW9uX3Rva2VucztcbiAgICAgICAgICAgIHRvdGFsLnByb21wdF90b2tlbnMgKz0gdXNhZ2UucHJvbXB0X3Rva2VucztcbiAgICAgICAgICAgIHRvdGFsLnRvdGFsX3Rva2VucyArPSB1c2FnZS50b3RhbF90b2tlbnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xufSwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfdmFsaWRhdGVQYXJhbXMgPSBmdW5jdGlvbiBfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl92YWxpZGF0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zLm4gIT0gbnVsbCAmJiBwYXJhbXMubiA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKCdDaGF0Q29tcGxldGlvbiBjb252ZW5pZW5jZSBoZWxwZXJzIG9ubHkgc3VwcG9ydCBuPTEgYXQgdGhpcyB0aW1lLiBUbyB1c2Ugbj4xLCBwbGVhc2UgdXNlIGNoYXQuY29tcGxldGlvbnMuY3JlYXRlKCkgZGlyZWN0bHkuJyk7XG4gICAgfVxufSwgX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfc3RyaW5naWZ5RnVuY3Rpb25DYWxsUmVzdWx0ID0gZnVuY3Rpb24gX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfc3RyaW5naWZ5RnVuY3Rpb25DYWxsUmVzdWx0KHJhd0NvbnRlbnQpIHtcbiAgICByZXR1cm4gKHR5cGVvZiByYXdDb250ZW50ID09PSAnc3RyaW5nJyA/IHJhd0NvbnRlbnRcbiAgICAgICAgOiByYXdDb250ZW50ID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShyYXdDb250ZW50KSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lci5tanMubWFwIiwiaW1wb3J0IHsgQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lciwgfSBmcm9tIFwiLi9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyLm1qc1wiO1xuaW1wb3J0IHsgaXNBc3Npc3RhbnRNZXNzYWdlIH0gZnJvbSBcIi4vY2hhdENvbXBsZXRpb25VdGlscy5tanNcIjtcbmV4cG9ydCBjbGFzcyBDaGF0Q29tcGxldGlvblJ1bm5lciBleHRlbmRzIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXIge1xuICAgIC8qKiBAZGVwcmVjYXRlZCAtIHBsZWFzZSB1c2UgYHJ1blRvb2xzYCBpbnN0ZWFkLiAqL1xuICAgIHN0YXRpYyBydW5GdW5jdGlvbnMoY2xpZW50LCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gbmV3IENoYXRDb21wbGV0aW9uUnVubmVyKCk7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtSGVscGVyLU1ldGhvZCc6ICdydW5GdW5jdGlvbnMnIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fcnVuRnVuY3Rpb25zKGNsaWVudCwgcGFyYW1zLCBvcHRzKSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIHN0YXRpYyBydW5Ub29scyhjbGllbnQsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBuZXcgQ2hhdENvbXBsZXRpb25SdW5uZXIoKTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3J1blRvb2xzJyB9LFxuICAgICAgICB9O1xuICAgICAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX3J1blRvb2xzKGNsaWVudCwgcGFyYW1zLCBvcHRzKSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIF9hZGRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIuX2FkZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2UobWVzc2FnZSkgJiYgbWVzc2FnZS5jb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdjb250ZW50JywgbWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoYXRDb21wbGV0aW9uUnVubmVyLm1qcy5tYXAiLCJjb25zdCB0b2tlbml6ZSA9IChpbnB1dCkgPT4ge1xuICAgIGxldCBjdXJyZW50ID0gMDtcbiAgICBsZXQgdG9rZW5zID0gW107XG4gICAgd2hpbGUgKGN1cnJlbnQgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGNoYXIgPSBpbnB1dFtjdXJyZW50XTtcbiAgICAgICAgaWYgKGNoYXIgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09ICd7Jykge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdicmFjZScsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICd7JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09ICd9Jykge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdicmFjZScsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICd9JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09ICdbJykge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwYXJlbicsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICdbJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09ICddJykge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwYXJlbicsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICddJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09ICc6Jykge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzZXBhcmF0b3InLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnOicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnJlbnQrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSAnLCcpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGVsaW1pdGVyJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJywnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJ1wiJykge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gJyc7XG4gICAgICAgICAgICBsZXQgZGFuZ2xpbmdRdW90ZSA9IGZhbHNlO1xuICAgICAgICAgICAgY2hhciA9IGlucHV0WysrY3VycmVudF07XG4gICAgICAgICAgICB3aGlsZSAoY2hhciAhPT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGFuZ2xpbmdRdW90ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGFuZ2xpbmdRdW90ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBjaGFyICsgaW5wdXRbY3VycmVudF07XG4gICAgICAgICAgICAgICAgICAgIGNoYXIgPSBpbnB1dFsrK2N1cnJlbnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgY2hhciA9IGlucHV0WysrY3VycmVudF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhciA9IGlucHV0WysrY3VycmVudF07XG4gICAgICAgICAgICBpZiAoIWRhbmdsaW5nUXVvdGUpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBXSElURVNQQUNFID0gL1xccy87XG4gICAgICAgIGlmIChjaGFyICYmIFdISVRFU1BBQ0UudGVzdChjaGFyKSkge1xuICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IE5VTUJFUlMgPSAvWzAtOV0vO1xuICAgICAgICBpZiAoKGNoYXIgJiYgTlVNQkVSUy50ZXN0KGNoYXIpKSB8fCBjaGFyID09PSAnLScgfHwgY2hhciA9PT0gJy4nKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBjaGFyO1xuICAgICAgICAgICAgICAgIGNoYXIgPSBpbnB1dFsrK2N1cnJlbnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKChjaGFyICYmIE5VTUJFUlMudGVzdChjaGFyKSkgfHwgY2hhciA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gY2hhcjtcbiAgICAgICAgICAgICAgICBjaGFyID0gaW5wdXRbKytjdXJyZW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IExFVFRFUlMgPSAvW2Etel0vaTtcbiAgICAgICAgaWYgKGNoYXIgJiYgTEVUVEVSUy50ZXN0KGNoYXIpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIHdoaWxlIChjaGFyICYmIExFVFRFUlMudGVzdChjaGFyKSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlICs9IGNoYXI7XG4gICAgICAgICAgICAgICAgY2hhciA9IGlucHV0WysrY3VycmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gJ3RydWUnIHx8IHZhbHVlID09ICdmYWxzZScgfHwgdmFsdWUgPT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ25hbWUnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVua25vd24gdG9rZW4sIGUuZy4gYG51bGAgd2hpY2ggaXNuJ3QgcXVpdGUgYG51bGxgXG4gICAgICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCsrO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zO1xufSwgc3RyaXAgPSAodG9rZW5zKSA9PiB7XG4gICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgbGV0IGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgc3dpdGNoIChsYXN0VG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdzZXBhcmF0b3InOlxuICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLnNsaWNlKDAsIHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJpcCh0b2tlbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBsZXQgbGFzdENoYXJhY3Rlck9mTGFzdFRva2VuID0gbGFzdFRva2VuLnZhbHVlW2xhc3RUb2tlbi52YWx1ZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0Q2hhcmFjdGVyT2ZMYXN0VG9rZW4gPT09ICcuJyB8fCBsYXN0Q2hhcmFjdGVyT2ZMYXN0VG9rZW4gPT09ICctJykge1xuICAgICAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5zbGljZSgwLCB0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmlwKHRva2Vucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBsZXQgdG9rZW5CZWZvcmVUaGVMYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgaWYgKHRva2VuQmVmb3JlVGhlTGFzdFRva2VuPy50eXBlID09PSAnZGVsaW1pdGVyJykge1xuICAgICAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5zbGljZSgwLCB0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmlwKHRva2Vucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbkJlZm9yZVRoZUxhc3RUb2tlbj8udHlwZSA9PT0gJ2JyYWNlJyAmJiB0b2tlbkJlZm9yZVRoZUxhc3RUb2tlbi52YWx1ZSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLnNsaWNlKDAsIHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaXAodG9rZW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkZWxpbWl0ZXInOlxuICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLnNsaWNlKDAsIHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJpcCh0b2tlbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnM7XG59LCB1bnN0cmlwID0gKHRva2VucykgPT4ge1xuICAgIGxldCB0YWlsID0gW107XG4gICAgdG9rZW5zLm1hcCgodG9rZW4pID0+IHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdicmFjZScpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgdGFpbC5wdXNoKCd9Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YWlsLnNwbGljZSh0YWlsLmxhc3RJbmRleE9mKCd9JyksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAncGFyZW4nKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdbJykge1xuICAgICAgICAgICAgICAgIHRhaWwucHVzaCgnXScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFpbC5zcGxpY2UodGFpbC5sYXN0SW5kZXhPZignXScpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0YWlsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGFpbC5yZXZlcnNlKCkubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYnJhY2UnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ30nLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbSA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGFyZW4nLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ10nLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2Vucztcbn0sIGdlbmVyYXRlID0gKHRva2VucykgPT4ge1xuICAgIGxldCBvdXRwdXQgPSAnJztcbiAgICB0b2tlbnMubWFwKCh0b2tlbikgPT4ge1xuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICdcIicgKyB0b2tlbi52YWx1ZSArICdcIic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG91dHB1dCArPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvdXRwdXQ7XG59LCBwYXJ0aWFsUGFyc2UgPSAoaW5wdXQpID0+IEpTT04ucGFyc2UoZ2VuZXJhdGUodW5zdHJpcChzdHJpcCh0b2tlbml6ZShpbnB1dCkpKSkpO1xuZXhwb3J0IHsgcGFydGlhbFBhcnNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZXIubWpzLm1hcCIsInZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQ2hhdENvbXBsZXRpb25TdHJlYW1faW5zdGFuY2VzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fcGFyYW1zLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fY2hvaWNlRXZlbnRTdGF0ZXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9jdXJyZW50Q2hhdENvbXBsZXRpb25TbmFwc2hvdCwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2JlZ2luUmVxdWVzdCwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2dldENob2ljZUV2ZW50U3RhdGUsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9hZGRDaHVuaywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRUb29sQ2FsbERvbmVFdmVudCwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRDb250ZW50RG9uZUV2ZW50cywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VuZFJlcXVlc3QsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9hY2N1bXVsYXRlQ2hhdENvbXBsZXRpb247XG5pbXBvcnQgeyBPcGVuQUlFcnJvciwgQVBJVXNlckFib3J0RXJyb3IsIExlbmd0aEZpbmlzaFJlYXNvbkVycm9yLCBDb250ZW50RmlsdGVyRmluaXNoUmVhc29uRXJyb3IsIH0gZnJvbSAnb3BlbmFpL2Vycm9yJztcbmltcG9ydCB7IEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXIsIH0gZnJvbSBcIi4vQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lci5tanNcIjtcbmltcG9ydCB7IFN0cmVhbSB9IGZyb20gJ29wZW5haS9zdHJlYW1pbmcnO1xuaW1wb3J0IHsgaGFzQXV0b1BhcnNlYWJsZUlucHV0LCBpc0F1dG9QYXJzYWJsZVJlc3BvbnNlRm9ybWF0LCBpc0F1dG9QYXJzYWJsZVRvb2wsIG1heWJlUGFyc2VDaGF0Q29tcGxldGlvbiwgc2hvdWxkUGFyc2VUb29sQ2FsbCwgfSBmcm9tICdvcGVuYWkvbGliL3BhcnNlcic7XG5pbXBvcnQgeyBwYXJ0aWFsUGFyc2UgfSBmcm9tIFwiLi4vX3ZlbmRvci9wYXJ0aWFsLWpzb24tcGFyc2VyL3BhcnNlci5tanNcIjtcbmV4cG9ydCBjbGFzcyBDaGF0Q29tcGxldGlvblN0cmVhbSBleHRlbmRzIEFic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBfQ2hhdENvbXBsZXRpb25TdHJlYW1faW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgX0NoYXRDb21wbGV0aW9uU3RyZWFtX3BhcmFtcy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2Nob2ljZUV2ZW50U3RhdGVzLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ2hhdENvbXBsZXRpb25TdHJlYW1fY3VycmVudENoYXRDb21wbGV0aW9uU25hcHNob3Quc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX3BhcmFtcywgcGFyYW1zLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2Nob2ljZUV2ZW50U3RhdGVzLCBbXSwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudENoYXRDb21wbGV0aW9uU25hcHNob3QoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9jdXJyZW50Q2hhdENvbXBsZXRpb25TbmFwc2hvdCwgXCJmXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlbmRlZCBmb3IgdXNlIG9uIHRoZSBmcm9udGVuZCwgY29uc3VtaW5nIGEgc3RyZWFtIHByb2R1Y2VkIHdpdGhcbiAgICAgKiBgLnRvUmVhZGFibGVTdHJlYW0oKWAgb24gdGhlIGJhY2tlbmQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgbWVzc2FnZXMgc2VudCB0byB0aGUgbW9kZWwgZG8gbm90IGFwcGVhciBpbiBgLm9uKCdtZXNzYWdlJylgXG4gICAgICogaW4gdGhpcyBjb250ZXh0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBDaGF0Q29tcGxldGlvblN0cmVhbShudWxsKTtcbiAgICAgICAgcnVubmVyLl9ydW4oKCkgPT4gcnVubmVyLl9mcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVDaGF0Q29tcGxldGlvbihjbGllbnQsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBuZXcgQ2hhdENvbXBsZXRpb25TdHJlYW0ocGFyYW1zKTtcbiAgICAgICAgcnVubmVyLl9ydW4oKCkgPT4gcnVubmVyLl9ydW5DaGF0Q29tcGxldGlvbihjbGllbnQsIHsgLi4ucGFyYW1zLCBzdHJlYW06IHRydWUgfSwgeyAuLi5vcHRpb25zLCBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3N0cmVhbScgfSB9KSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIGFzeW5jIF9jcmVhdGVDaGF0Q29tcGxldGlvbihjbGllbnQsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBzdXBlci5fY3JlYXRlQ2hhdENvbXBsZXRpb247XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnM/LnNpZ25hbDtcbiAgICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gdGhpcy5jb250cm9sbGVyLmFib3J0KCkpO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9iZWdpblJlcXVlc3QpLmNhbGwodGhpcyk7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IGNsaWVudC5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7IC4uLnBhcmFtcywgc3RyZWFtOiB0cnVlIH0sIHsgLi4ub3B0aW9ucywgc2lnbmFsOiB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsIH0pO1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWQoKTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9hZGRDaHVuaykuY2FsbCh0aGlzLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5jb250cm9sbGVyLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoYXRDb21wbGV0aW9uKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9lbmRSZXF1ZXN0KS5jYWxsKHRoaXMpKTtcbiAgICB9XG4gICAgYXN5bmMgX2Zyb21SZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZClcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRoaXMuY29udHJvbGxlci5hYm9ydCgpKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fYmVnaW5SZXF1ZXN0KS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWQoKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSwgdGhpcy5jb250cm9sbGVyKTtcbiAgICAgICAgbGV0IGNoYXRJZDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgIGlmIChjaGF0SWQgJiYgY2hhdElkICE9PSBjaHVuay5pZCkge1xuICAgICAgICAgICAgICAgIC8vIEEgbmV3IHJlcXVlc3QgaGFzIGJlZW4gbWFkZS5cbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRDaGF0Q29tcGxldGlvbihfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fZW5kUmVxdWVzdCkuY2FsbCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fYWRkQ2h1bmspLmNhbGwodGhpcywgY2h1bmspO1xuICAgICAgICAgICAgY2hhdElkID0gY2h1bmsuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5jb250cm9sbGVyLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoYXRDb21wbGV0aW9uKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9lbmRSZXF1ZXN0KS5jYWxsKHRoaXMpKTtcbiAgICB9XG4gICAgWyhfQ2hhdENvbXBsZXRpb25TdHJlYW1fcGFyYW1zID0gbmV3IFdlYWtNYXAoKSwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2Nob2ljZUV2ZW50U3RhdGVzID0gbmV3IFdlYWtNYXAoKSwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2N1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90ID0gbmV3IFdlYWtNYXAoKSwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9DaGF0Q29tcGxldGlvblN0cmVhbV9iZWdpblJlcXVlc3QgPSBmdW5jdGlvbiBfQ2hhdENvbXBsZXRpb25TdHJlYW1fYmVnaW5SZXF1ZXN0KCkge1xuICAgICAgICBpZiAodGhpcy5lbmRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fY3VycmVudENoYXRDb21wbGV0aW9uU25hcHNob3QsIHVuZGVmaW5lZCwgXCJmXCIpO1xuICAgIH0sIF9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRDaG9pY2VFdmVudFN0YXRlID0gZnVuY3Rpb24gX0NoYXRDb21wbGV0aW9uU3RyZWFtX2dldENob2ljZUV2ZW50U3RhdGUoY2hvaWNlKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2Nob2ljZUV2ZW50U3RhdGVzLCBcImZcIilbY2hvaWNlLmluZGV4XTtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICBjb250ZW50X2RvbmU6IGZhbHNlLFxuICAgICAgICAgICAgcmVmdXNhbF9kb25lOiBmYWxzZSxcbiAgICAgICAgICAgIGxvZ3Byb2JzX2NvbnRlbnRfZG9uZTogZmFsc2UsXG4gICAgICAgICAgICBsb2dwcm9ic19yZWZ1c2FsX2RvbmU6IGZhbHNlLFxuICAgICAgICAgICAgZG9uZV90b29sX2NhbGxzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICBjdXJyZW50X3Rvb2xfY2FsbF9pbmRleDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fY2hvaWNlRXZlbnRTdGF0ZXMsIFwiZlwiKVtjaG9pY2UuaW5kZXhdID0gc3RhdGU7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fYWRkQ2h1bmsgPSBmdW5jdGlvbiBfQ2hhdENvbXBsZXRpb25TdHJlYW1fYWRkQ2h1bmsoY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGNvbXBsZXRpb24gPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fYWNjdW11bGF0ZUNoYXRDb21wbGV0aW9uKS5jYWxsKHRoaXMsIGNodW5rKTtcbiAgICAgICAgdGhpcy5fZW1pdCgnY2h1bmsnLCBjaHVuaywgY29tcGxldGlvbik7XG4gICAgICAgIGZvciAoY29uc3QgY2hvaWNlIG9mIGNodW5rLmNob2ljZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNob2ljZVNuYXBzaG90ID0gY29tcGxldGlvbi5jaG9pY2VzW2Nob2ljZS5pbmRleF07XG4gICAgICAgICAgICBpZiAoY2hvaWNlLmRlbHRhLmNvbnRlbnQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIGNob2ljZVNuYXBzaG90Lm1lc3NhZ2U/LnJvbGUgPT09ICdhc3Npc3RhbnQnICYmXG4gICAgICAgICAgICAgICAgY2hvaWNlU25hcHNob3QubWVzc2FnZT8uY29udGVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2NvbnRlbnQnLCBjaG9pY2UuZGVsdGEuY29udGVudCwgY2hvaWNlU25hcHNob3QubWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCdjb250ZW50LmRlbHRhJywge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YTogY2hvaWNlLmRlbHRhLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHNuYXBzaG90OiBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZDogY2hvaWNlU25hcHNob3QubWVzc2FnZS5wYXJzZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hvaWNlLmRlbHRhLnJlZnVzYWwgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIGNob2ljZVNuYXBzaG90Lm1lc3NhZ2U/LnJvbGUgPT09ICdhc3Npc3RhbnQnICYmXG4gICAgICAgICAgICAgICAgY2hvaWNlU25hcHNob3QubWVzc2FnZT8ucmVmdXNhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3JlZnVzYWwuZGVsdGEnLCB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhOiBjaG9pY2UuZGVsdGEucmVmdXNhbCxcbiAgICAgICAgICAgICAgICAgICAgc25hcHNob3Q6IGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UucmVmdXNhbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaG9pY2UubG9ncHJvYnM/LmNvbnRlbnQgIT0gbnVsbCAmJiBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlPy5yb2xlID09PSAnYXNzaXN0YW50Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2xvZ3Byb2JzLmNvbnRlbnQuZGVsdGEnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNob2ljZS5sb2dwcm9icz8uY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgc25hcHNob3Q6IGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzPy5jb250ZW50ID8/IFtdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNob2ljZS5sb2dwcm9icz8ucmVmdXNhbCAhPSBudWxsICYmIGNob2ljZVNuYXBzaG90Lm1lc3NhZ2U/LnJvbGUgPT09ICdhc3Npc3RhbnQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgnbG9ncHJvYnMucmVmdXNhbC5kZWx0YScsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmdXNhbDogY2hvaWNlLmxvZ3Byb2JzPy5yZWZ1c2FsLFxuICAgICAgICAgICAgICAgICAgICBzbmFwc2hvdDogY2hvaWNlU25hcHNob3QubG9ncHJvYnM/LnJlZnVzYWwgPz8gW10sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRDaG9pY2VFdmVudFN0YXRlKS5jYWxsKHRoaXMsIGNob2ljZVNuYXBzaG90KTtcbiAgICAgICAgICAgIGlmIChjaG9pY2VTbmFwc2hvdC5maW5pc2hfcmVhc29uKSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRDb250ZW50RG9uZUV2ZW50cykuY2FsbCh0aGlzLCBjaG9pY2VTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRfdG9vbF9jYWxsX2luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRUb29sQ2FsbERvbmVFdmVudCkuY2FsbCh0aGlzLCBjaG9pY2VTbmFwc2hvdCwgc3RhdGUuY3VycmVudF90b29sX2NhbGxfaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgY2hvaWNlLmRlbHRhLnRvb2xfY2FsbHMgPz8gW10pIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuY3VycmVudF90b29sX2NhbGxfaW5kZXggIT09IHRvb2xDYWxsLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9lbWl0Q29udGVudERvbmVFdmVudHMpLmNhbGwodGhpcywgY2hvaWNlU25hcHNob3QpO1xuICAgICAgICAgICAgICAgICAgICAvLyBuZXcgdG9vbCBjYWxsIHN0YXJ0ZWQsIHRoZSBwcmV2aW91cyBvbmUgaXMgZG9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuY3VycmVudF90b29sX2NhbGxfaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRUb29sQ2FsbERvbmVFdmVudCkuY2FsbCh0aGlzLCBjaG9pY2VTbmFwc2hvdCwgc3RhdGUuY3VycmVudF90b29sX2NhbGxfaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRfdG9vbF9jYWxsX2luZGV4ID0gdG9vbENhbGwuaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsRGVsdGEgb2YgY2hvaWNlLmRlbHRhLnRvb2xfY2FsbHMgPz8gW10pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sQ2FsbFNuYXBzaG90ID0gY2hvaWNlU25hcHNob3QubWVzc2FnZS50b29sX2NhbGxzPy5bdG9vbENhbGxEZWx0YS5pbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKCF0b29sQ2FsbFNuYXBzaG90Py50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9vbENhbGxTbmFwc2hvdD8udHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCd0b29sX2NhbGxzLmZ1bmN0aW9uLmFyZ3VtZW50cy5kZWx0YScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRvb2xDYWxsU25hcHNob3QuZnVuY3Rpb24/Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogdG9vbENhbGxEZWx0YS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogdG9vbENhbGxTbmFwc2hvdC5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRfYXJndW1lbnRzOiB0b29sQ2FsbFNuYXBzaG90LmZ1bmN0aW9uLnBhcnNlZF9hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNfZGVsdGE6IHRvb2xDYWxsRGVsdGEuZnVuY3Rpb24/LmFyZ3VtZW50cyA/PyAnJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnROZXZlcih0b29sQ2FsbFNuYXBzaG90Py50eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fZW1pdFRvb2xDYWxsRG9uZUV2ZW50ID0gZnVuY3Rpb24gX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRUb29sQ2FsbERvbmVFdmVudChjaG9pY2VTbmFwc2hvdCwgdG9vbENhbGxJbmRleCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRDaG9pY2VFdmVudFN0YXRlKS5jYWxsKHRoaXMsIGNob2ljZVNuYXBzaG90KTtcbiAgICAgICAgaWYgKHN0YXRlLmRvbmVfdG9vbF9jYWxscy5oYXModG9vbENhbGxJbmRleCkpIHtcbiAgICAgICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgZmlyZWQgdGhlIGRvbmUgZXZlbnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b29sQ2FsbFNuYXBzaG90ID0gY2hvaWNlU25hcHNob3QubWVzc2FnZS50b29sX2NhbGxzPy5bdG9vbENhbGxJbmRleF07XG4gICAgICAgIGlmICghdG9vbENhbGxTbmFwc2hvdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyB0b29sIGNhbGwgc25hcHNob3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvb2xDYWxsU25hcHNob3QudHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29sIGNhbGwgc25hcHNob3QgbWlzc2luZyBgdHlwZWAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9vbENhbGxTbmFwc2hvdC50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFRvb2wgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9wYXJhbXMsIFwiZlwiKT8udG9vbHM/LmZpbmQoKHRvb2wpID0+IHRvb2wudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0b29sLmZ1bmN0aW9uLm5hbWUgPT09IHRvb2xDYWxsU25hcHNob3QuZnVuY3Rpb24ubmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCd0b29sX2NhbGxzLmZ1bmN0aW9uLmFyZ3VtZW50cy5kb25lJywge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRvb2xDYWxsU25hcHNob3QuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBpbmRleDogdG9vbENhbGxJbmRleCxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IHRvb2xDYWxsU25hcHNob3QuZnVuY3Rpb24uYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgIHBhcnNlZF9hcmd1bWVudHM6IGlzQXV0b1BhcnNhYmxlVG9vbChpbnB1dFRvb2wpID8gaW5wdXRUb29sLiRwYXJzZVJhdyh0b29sQ2FsbFNuYXBzaG90LmZ1bmN0aW9uLmFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dFRvb2w/LmZ1bmN0aW9uLnN0cmljdCA/IEpTT04ucGFyc2UodG9vbENhbGxTbmFwc2hvdC5mdW5jdGlvbi5hcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydE5ldmVyKHRvb2xDYWxsU25hcHNob3QudHlwZSk7XG4gICAgICAgIH1cbiAgICB9LCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fZW1pdENvbnRlbnREb25lRXZlbnRzID0gZnVuY3Rpb24gX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRDb250ZW50RG9uZUV2ZW50cyhjaG9pY2VTbmFwc2hvdCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRDaG9pY2VFdmVudFN0YXRlKS5jYWxsKHRoaXMsIGNob2ljZVNuYXBzaG90KTtcbiAgICAgICAgaWYgKGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UuY29udGVudCAmJiAhc3RhdGUuY29udGVudF9kb25lKSB7XG4gICAgICAgICAgICBzdGF0ZS5jb250ZW50X2RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VGb3JtYXQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fZ2V0QXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0KS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdCgnY29udGVudC5kb25lJywge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgICAgICAgICBwYXJzZWQ6IHJlc3BvbnNlRm9ybWF0ID8gcmVzcG9uc2VGb3JtYXQuJHBhcnNlUmF3KGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UuY29udGVudCkgOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNob2ljZVNuYXBzaG90Lm1lc3NhZ2UucmVmdXNhbCAmJiAhc3RhdGUucmVmdXNhbF9kb25lKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZWZ1c2FsX2RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZW1pdCgncmVmdXNhbC5kb25lJywgeyByZWZ1c2FsOiBjaG9pY2VTbmFwc2hvdC5tZXNzYWdlLnJlZnVzYWwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzPy5jb250ZW50ICYmICFzdGF0ZS5sb2dwcm9ic19jb250ZW50X2RvbmUpIHtcbiAgICAgICAgICAgIHN0YXRlLmxvZ3Byb2JzX2NvbnRlbnRfZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdsb2dwcm9icy5jb250ZW50LmRvbmUnLCB7IGNvbnRlbnQ6IGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzLmNvbnRlbnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzPy5yZWZ1c2FsICYmICFzdGF0ZS5sb2dwcm9ic19yZWZ1c2FsX2RvbmUpIHtcbiAgICAgICAgICAgIHN0YXRlLmxvZ3Byb2JzX3JlZnVzYWxfZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdsb2dwcm9icy5yZWZ1c2FsLmRvbmUnLCB7IHJlZnVzYWw6IGNob2ljZVNuYXBzaG90LmxvZ3Byb2JzLnJlZnVzYWwgfSk7XG4gICAgICAgIH1cbiAgICB9LCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIF9DaGF0Q29tcGxldGlvblN0cmVhbV9lbmRSZXF1ZXN0KCkge1xuICAgICAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBzdHJlYW0gaGFzIGVuZGVkLCB0aGlzIHNob3VsZG4ndCBoYXBwZW5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzbmFwc2hvdCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2N1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90LCBcImZcIik7XG4gICAgICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgcmVxdWVzdCBlbmRlZCB3aXRob3V0IHNlbmRpbmcgYW55IGNodW5rc2ApO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2N1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90LCB1bmRlZmluZWQsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fY2hvaWNlRXZlbnRTdGF0ZXMsIFtdLCBcImZcIik7XG4gICAgICAgIHJldHVybiBmaW5hbGl6ZUNoYXRDb21wbGV0aW9uKHNuYXBzaG90LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9wYXJhbXMsIFwiZlwiKSk7XG4gICAgfSwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2dldEF1dG9QYXJzZWFibGVSZXNwb25zZUZvcm1hdCA9IGZ1bmN0aW9uIF9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRm9ybWF0ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fcGFyYW1zLCBcImZcIik/LnJlc3BvbnNlX2Zvcm1hdDtcbiAgICAgICAgaWYgKGlzQXV0b1BhcnNhYmxlUmVzcG9uc2VGb3JtYXQocmVzcG9uc2VGb3JtYXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSwgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2FjY3VtdWxhdGVDaGF0Q29tcGxldGlvbiA9IGZ1bmN0aW9uIF9DaGF0Q29tcGxldGlvblN0cmVhbV9hY2N1bXVsYXRlQ2hhdENvbXBsZXRpb24oY2h1bmspIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgc25hcHNob3QgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9jdXJyZW50Q2hhdENvbXBsZXRpb25TbmFwc2hvdCwgXCJmXCIpO1xuICAgICAgICBjb25zdCB7IGNob2ljZXMsIC4uLnJlc3QgfSA9IGNodW5rO1xuICAgICAgICBpZiAoIXNuYXBzaG90KSB7XG4gICAgICAgICAgICBzbmFwc2hvdCA9IF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX2N1cnJlbnRDaGF0Q29tcGxldGlvblNuYXBzaG90LCB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgICAgICBjaG9pY2VzOiBbXSxcbiAgICAgICAgICAgIH0sIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc25hcHNob3QsIHJlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgeyBkZWx0YSwgZmluaXNoX3JlYXNvbiwgaW5kZXgsIGxvZ3Byb2JzID0gbnVsbCwgLi4ub3RoZXIgfSBvZiBjaHVuay5jaG9pY2VzKSB7XG4gICAgICAgICAgICBsZXQgY2hvaWNlID0gc25hcHNob3QuY2hvaWNlc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIWNob2ljZSkge1xuICAgICAgICAgICAgICAgIGNob2ljZSA9IHNuYXBzaG90LmNob2ljZXNbaW5kZXhdID0geyBmaW5pc2hfcmVhc29uLCBpbmRleCwgbWVzc2FnZToge30sIGxvZ3Byb2JzLCAuLi5vdGhlciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvZ3Byb2JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaG9pY2UubG9ncHJvYnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlLmxvZ3Byb2JzID0gT2JqZWN0LmFzc2lnbih7fSwgbG9ncHJvYnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjb250ZW50LCByZWZ1c2FsLCAuLi5yZXN0IH0gPSBsb2dwcm9icztcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0SXNFbXB0eShyZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjaG9pY2UubG9ncHJvYnMsIHJlc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gY2hvaWNlLmxvZ3Byb2JzKS5jb250ZW50ID8/IChfYS5jb250ZW50ID0gW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hvaWNlLmxvZ3Byb2JzLmNvbnRlbnQucHVzaCguLi5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVmdXNhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gY2hvaWNlLmxvZ3Byb2JzKS5yZWZ1c2FsID8/IChfYi5yZWZ1c2FsID0gW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hvaWNlLmxvZ3Byb2JzLnJlZnVzYWwucHVzaCguLi5yZWZ1c2FsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaW5pc2hfcmVhc29uKSB7XG4gICAgICAgICAgICAgICAgY2hvaWNlLmZpbmlzaF9yZWFzb24gPSBmaW5pc2hfcmVhc29uO1xuICAgICAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9wYXJhbXMsIFwiZlwiKSAmJiBoYXNBdXRvUGFyc2VhYmxlSW5wdXQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fcGFyYW1zLCBcImZcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5pc2hfcmVhc29uID09PSAnbGVuZ3RoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IExlbmd0aEZpbmlzaFJlYXNvbkVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmlzaF9yZWFzb24gPT09ICdjb250ZW50X2ZpbHRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb250ZW50RmlsdGVyRmluaXNoUmVhc29uRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY2hvaWNlLCBvdGhlcik7XG4gICAgICAgICAgICBpZiAoIWRlbHRhKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTaG91bGRuJ3QgaGFwcGVuOyBqdXN0IGluIGNhc2UuXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRlbnQsIHJlZnVzYWwsIGZ1bmN0aW9uX2NhbGwsIHJvbGUsIHRvb2xfY2FsbHMsIC4uLnJlc3QgfSA9IGRlbHRhO1xuICAgICAgICAgICAgYXNzZXJ0SXNFbXB0eShyZXN0KTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY2hvaWNlLm1lc3NhZ2UsIHJlc3QpO1xuICAgICAgICAgICAgaWYgKHJlZnVzYWwpIHtcbiAgICAgICAgICAgICAgICBjaG9pY2UubWVzc2FnZS5yZWZ1c2FsID0gKGNob2ljZS5tZXNzYWdlLnJlZnVzYWwgfHwgJycpICsgcmVmdXNhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb2xlKVxuICAgICAgICAgICAgICAgIGNob2ljZS5tZXNzYWdlLnJvbGUgPSByb2xlO1xuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uX2NhbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNob2ljZS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlLm1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9IGZ1bmN0aW9uX2NhbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25fY2FsbC5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hvaWNlLm1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5uYW1lID0gZnVuY3Rpb25fY2FsbC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYyA9IGNob2ljZS5tZXNzYWdlLmZ1bmN0aW9uX2NhbGwpLmFyZ3VtZW50cyA/PyAoX2MuYXJndW1lbnRzID0gJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hvaWNlLm1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgKz0gZnVuY3Rpb25fY2FsbC5hcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgIGNob2ljZS5tZXNzYWdlLmNvbnRlbnQgPSAoY2hvaWNlLm1lc3NhZ2UuY29udGVudCB8fCAnJykgKyBjb250ZW50O1xuICAgICAgICAgICAgICAgIGlmICghY2hvaWNlLm1lc3NhZ2UucmVmdXNhbCAmJiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DaGF0Q29tcGxldGlvblN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQ2hhdENvbXBsZXRpb25TdHJlYW1fZ2V0QXV0b1BhcnNlYWJsZVJlc3BvbnNlRm9ybWF0KS5jYWxsKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNob2ljZS5tZXNzYWdlLnBhcnNlZCA9IHBhcnRpYWxQYXJzZShjaG9pY2UubWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9vbF9jYWxscykge1xuICAgICAgICAgICAgICAgIGlmICghY2hvaWNlLm1lc3NhZ2UudG9vbF9jYWxscylcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlLm1lc3NhZ2UudG9vbF9jYWxscyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBpbmRleCwgaWQsIHR5cGUsIGZ1bmN0aW9uOiBmbiwgLi4ucmVzdCB9IG9mIHRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbF9jYWxsID0gKChfZCA9IGNob2ljZS5tZXNzYWdlLnRvb2xfY2FsbHMpW2luZGV4XSA/PyAoX2RbaW5kZXhdID0ge30pKTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0b29sX2NhbGwsIHJlc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGwuaWQgPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGwudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbC5mdW5jdGlvbiA/PyAodG9vbF9jYWxsLmZ1bmN0aW9uID0geyBuYW1lOiBmbi5uYW1lID8/ICcnLCBhcmd1bWVudHM6ICcnIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm4/Lm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGwuZnVuY3Rpb24ubmFtZSA9IGZuLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbj8uYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGwuZnVuY3Rpb24uYXJndW1lbnRzICs9IGZuLmFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRQYXJzZVRvb2xDYWxsKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NoYXRDb21wbGV0aW9uU3RyZWFtX3BhcmFtcywgXCJmXCIpLCB0b29sX2NhbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsLmZ1bmN0aW9uLnBhcnNlZF9hcmd1bWVudHMgPSBwYXJ0aWFsUGFyc2UodG9vbF9jYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgIH0sIFN5bWJvbC5hc3luY0l0ZXJhdG9yKV0oKSB7XG4gICAgICAgIGNvbnN0IHB1c2hRdWV1ZSA9IFtdO1xuICAgICAgICBjb25zdCByZWFkUXVldWUgPSBbXTtcbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbignY2h1bmsnLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHJlYWRRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHJlYWRlcikge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZXNvbHZlKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHB1c2hRdWV1ZS5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgcmVhZFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRRdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbignYWJvcnQnLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHJlYWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRRdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHJlYWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRRdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXB1c2hRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gcmVhZFF1ZXVlLnB1c2goeyByZXNvbHZlLCByZWplY3QgfSkpLnRoZW4oKGNodW5rKSA9PiAoY2h1bmsgPyB7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfSA6IHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gcHVzaFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHVybjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0b1JlYWRhYmxlU3RyZWFtKCkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgU3RyZWFtKHRoaXNbU3ltYm9sLmFzeW5jSXRlcmF0b3JdLmJpbmQodGhpcyksIHRoaXMuY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiBzdHJlYW0udG9SZWFkYWJsZVN0cmVhbSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmFsaXplQ2hhdENvbXBsZXRpb24oc25hcHNob3QsIHBhcmFtcykge1xuICAgIGNvbnN0IHsgaWQsIGNob2ljZXMsIGNyZWF0ZWQsIG1vZGVsLCBzeXN0ZW1fZmluZ2VycHJpbnQsIC4uLnJlc3QgfSA9IHNuYXBzaG90O1xuICAgIGNvbnN0IGNvbXBsZXRpb24gPSB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGlkLFxuICAgICAgICBjaG9pY2VzOiBjaG9pY2VzLm1hcCgoeyBtZXNzYWdlLCBmaW5pc2hfcmVhc29uLCBpbmRleCwgbG9ncHJvYnMsIC4uLmNob2ljZVJlc3QgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFmaW5pc2hfcmVhc29uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIGZpbmlzaF9yZWFzb24gZm9yIGNob2ljZSAke2luZGV4fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBjb250ZW50ID0gbnVsbCwgZnVuY3Rpb25fY2FsbCwgdG9vbF9jYWxscywgLi4ubWVzc2FnZVJlc3QgfSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBjb25zdCByb2xlID0gbWVzc2FnZS5yb2xlOyAvLyB0aGlzIGlzIHdoYXQgd2UgZXhwZWN0OyBpbiB0aGVvcnkgaXQgY291bGQgYmUgZGlmZmVyZW50IHdoaWNoIHdvdWxkIG1ha2Ugb3VyIHR5cGVzIGEgc2xpZ2h0IGxpZSBidXQgd291bGQgYmUgZmluZS5cbiAgICAgICAgICAgIGlmICghcm9sZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyByb2xlIGZvciBjaG9pY2UgJHtpbmRleH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmdW5jdGlvbl9jYWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhcmd1bWVudHM6IGFyZ3MsIG5hbWUgfSA9IGZ1bmN0aW9uX2NhbGw7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYG1pc3NpbmcgZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgZm9yIGNob2ljZSAke2luZGV4fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIGZ1bmN0aW9uX2NhbGwubmFtZSBmb3IgY2hvaWNlICR7aW5kZXh9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNob2ljZVJlc3QsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiB7IGFyZ3VtZW50czogYXJncywgbmFtZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnVzYWw6IG1lc3NhZ2UucmVmdXNhbCA/PyBudWxsLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hfcmVhc29uLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgbG9ncHJvYnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2hvaWNlUmVzdCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaF9yZWFzb24sXG4gICAgICAgICAgICAgICAgICAgIGxvZ3Byb2JzLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5tZXNzYWdlUmVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmdXNhbDogbWVzc2FnZS5yZWZ1c2FsID8/IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiB0b29sX2NhbGxzLm1hcCgodG9vbF9jYWxsLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmdW5jdGlvbjogZm4sIHR5cGUsIGlkLCAuLi50b29sUmVzdCB9ID0gdG9vbF9jYWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYXJndW1lbnRzOiBhcmdzLCBuYW1lLCAuLi5mblJlc3QgfSA9IGZuIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyBjaG9pY2VzWyR7aW5kZXh9XS50b29sX2NhbGxzWyR7aX1dLmlkXFxuJHtzdHIoc25hcHNob3QpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVuQUlFcnJvcihgbWlzc2luZyBjaG9pY2VzWyR7aW5kZXh9XS50b29sX2NhbGxzWyR7aX1dLnR5cGVcXG4ke3N0cihzbmFwc2hvdCl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBtaXNzaW5nIGNob2ljZXNbJHtpbmRleH1dLnRvb2xfY2FsbHNbJHtpfV0uZnVuY3Rpb24ubmFtZVxcbiR7c3RyKHNuYXBzaG90KX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3BlbkFJRXJyb3IoYG1pc3NpbmcgY2hvaWNlc1ske2luZGV4fV0udG9vbF9jYWxsc1ske2l9XS5mdW5jdGlvbi5hcmd1bWVudHNcXG4ke3N0cihzbmFwc2hvdCl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnRvb2xSZXN0LCBpZCwgdHlwZSwgZnVuY3Rpb246IHsgLi4uZm5SZXN0LCBuYW1lLCBhcmd1bWVudHM6IGFyZ3MgfSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2hvaWNlUmVzdCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB7IC4uLm1lc3NhZ2VSZXN0LCBjb250ZW50LCByb2xlLCByZWZ1c2FsOiBtZXNzYWdlLnJlZnVzYWwgPz8gbnVsbCB9LFxuICAgICAgICAgICAgICAgIGZpbmlzaF9yZWFzb24sXG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgbG9ncHJvYnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgY3JlYXRlZCxcbiAgICAgICAgbW9kZWwsXG4gICAgICAgIG9iamVjdDogJ2NoYXQuY29tcGxldGlvbicsXG4gICAgICAgIC4uLihzeXN0ZW1fZmluZ2VycHJpbnQgPyB7IHN5c3RlbV9maW5nZXJwcmludCB9IDoge30pLFxuICAgIH07XG4gICAgcmV0dXJuIG1heWJlUGFyc2VDaGF0Q29tcGxldGlvbihjb21wbGV0aW9uLCBwYXJhbXMpO1xufVxuZnVuY3Rpb24gc3RyKHgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeCk7XG59XG4vKipcbiAqIEVuc3VyZXMgdGhlIGdpdmVuIGFyZ3VtZW50IGlzIGFuIGVtcHR5IG9iamVjdCwgdXNlZnVsIGZvclxuICogYXNzZXJ0aW5nIHRoYXQgYWxsIGtub3duIHByb3BlcnRpZXMgb24gYW4gb2JqZWN0IGhhdmUgYmVlblxuICogZGVzdHJ1Y3R1cmVkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0VtcHR5KG9iaikge1xuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7IH1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoYXRDb21wbGV0aW9uU3RyZWFtLm1qcy5tYXAiLCJpbXBvcnQgeyBDaGF0Q29tcGxldGlvblN0cmVhbSB9IGZyb20gXCIuL0NoYXRDb21wbGV0aW9uU3RyZWFtLm1qc1wiO1xuZXhwb3J0IGNsYXNzIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25TdHJlYW0ge1xuICAgIHN0YXRpYyBmcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lcihudWxsKTtcbiAgICAgICAgcnVubmVyLl9ydW4oKCkgPT4gcnVubmVyLl9mcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAtIHBsZWFzZSB1c2UgYHJ1blRvb2xzYCBpbnN0ZWFkLiAqL1xuICAgIHN0YXRpYyBydW5GdW5jdGlvbnMoY2xpZW50LCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gbmV3IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyKG51bGwpO1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAncnVuRnVuY3Rpb25zJyB9LFxuICAgICAgICB9O1xuICAgICAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX3J1bkZ1bmN0aW9ucyhjbGllbnQsIHBhcmFtcywgb3B0cykpO1xuICAgICAgICByZXR1cm4gcnVubmVyO1xuICAgIH1cbiAgICBzdGF0aWMgcnVuVG9vbHMoY2xpZW50LCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gbmV3IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gdGhlc2UgdHlwZXMgYXJlIGluY29tcGF0aWJsZVxuICAgICAgICBwYXJhbXMpO1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAncnVuVG9vbHMnIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fcnVuVG9vbHMoY2xpZW50LCBwYXJhbXMsIG9wdHMpKTtcbiAgICAgICAgcmV0dXJuIHJ1bm5lcjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lci5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uLy4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgQ2hhdENvbXBsZXRpb25SdW5uZXIgfSBmcm9tIFwiLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uUnVubmVyLm1qc1wiO1xuZXhwb3J0IHsgQ2hhdENvbXBsZXRpb25SdW5uZXIgfSBmcm9tIFwiLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uUnVubmVyLm1qc1wiO1xuaW1wb3J0IHsgQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXIsIH0gZnJvbSBcIi4uLy4uLy4uL2xpYi9DaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lci5tanNcIjtcbmV4cG9ydCB7IENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyLCB9IGZyb20gXCIuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25TdHJlYW1pbmdSdW5uZXIubWpzXCI7XG5leHBvcnQgeyBQYXJzaW5nRnVuY3Rpb24sIFBhcnNpbmdUb29sRnVuY3Rpb24sIH0gZnJvbSBcIi4uLy4uLy4uL2xpYi9SdW5uYWJsZUZ1bmN0aW9uLm1qc1wiO1xuaW1wb3J0IHsgQ2hhdENvbXBsZXRpb25TdHJlYW0gfSBmcm9tIFwiLi4vLi4vLi4vbGliL0NoYXRDb21wbGV0aW9uU3RyZWFtLm1qc1wiO1xuaW1wb3J0IHsgcGFyc2VDaGF0Q29tcGxldGlvbiwgdmFsaWRhdGVJbnB1dFRvb2xzIH0gZnJvbSBcIi4uLy4uLy4uL2xpYi9wYXJzZXIubWpzXCI7XG5leHBvcnQgeyBDaGF0Q29tcGxldGlvblN0cmVhbSB9IGZyb20gXCIuLi8uLi8uLi9saWIvQ2hhdENvbXBsZXRpb25TdHJlYW0ubWpzXCI7XG5leHBvcnQgY2xhc3MgQ29tcGxldGlvbnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgYXN5bmMgcGFyc2UoYm9keSwgb3B0aW9ucykge1xuICAgICAgICB2YWxpZGF0ZUlucHV0VG9vbHMoYm9keS50b29scyk7XG4gICAgICAgIGNvbnN0IGNvbXBsZXRpb24gPSBhd2FpdCB0aGlzLl9jbGllbnQuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoYm9keSwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ2JldGEuY2hhdC5jb21wbGV0aW9ucy5wYXJzZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlQ2hhdENvbXBsZXRpb24oY29tcGxldGlvbiwgYm9keSk7XG4gICAgfVxuICAgIHJ1bkZ1bmN0aW9ucyhib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChib2R5LnN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIENoYXRDb21wbGV0aW9uU3RyZWFtaW5nUnVubmVyLnJ1bkZ1bmN0aW9ucyh0aGlzLl9jbGllbnQsIGJvZHksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDaGF0Q29tcGxldGlvblJ1bm5lci5ydW5GdW5jdGlvbnModGhpcy5fY2xpZW50LCBib2R5LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcnVuVG9vbHMoYm9keSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoYm9keS5zdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybiBDaGF0Q29tcGxldGlvblN0cmVhbWluZ1J1bm5lci5ydW5Ub29scyh0aGlzLl9jbGllbnQsIGJvZHksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDaGF0Q29tcGxldGlvblJ1bm5lci5ydW5Ub29scyh0aGlzLl9jbGllbnQsIGJvZHksIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2hhdCBjb21wbGV0aW9uIHN0cmVhbVxuICAgICAqL1xuICAgIHN0cmVhbShib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBDaGF0Q29tcGxldGlvblN0cmVhbS5jcmVhdGVDaGF0Q29tcGxldGlvbih0aGlzLl9jbGllbnQsIGJvZHksIG9wdGlvbnMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBsZXRpb25zLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vLi4vcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgKiBhcyBDb21wbGV0aW9uc0FQSSBmcm9tIFwiLi9jb21wbGV0aW9ucy5tanNcIjtcbmV4cG9ydCBjbGFzcyBDaGF0IGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNvbXBsZXRpb25zID0gbmV3IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25zKHRoaXMuX2NsaWVudCk7XG4gICAgfVxufVxuKGZ1bmN0aW9uIChDaGF0KSB7XG4gICAgQ2hhdC5Db21wbGV0aW9ucyA9IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25zO1xufSkoQ2hhdCB8fCAoQ2hhdCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGF0Lm1qcy5tYXAiLCJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX0Fzc2lzdGFudFN0cmVhbV9pbnN0YW5jZXMsIF9Bc3Npc3RhbnRTdHJlYW1fZXZlbnRzLCBfQXNzaXN0YW50U3RyZWFtX3J1blN0ZXBTbmFwc2hvdHMsIF9Bc3Npc3RhbnRTdHJlYW1fbWVzc2FnZVNuYXBzaG90cywgX0Fzc2lzdGFudFN0cmVhbV9tZXNzYWdlU25hcHNob3QsIF9Bc3Npc3RhbnRTdHJlYW1fZmluYWxSdW4sIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudENvbnRlbnRJbmRleCwgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50Q29udGVudCwgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50VG9vbENhbGxJbmRleCwgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50VG9vbENhbGwsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudEV2ZW50LCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRSdW5TbmFwc2hvdCwgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50UnVuU3RlcFNuYXBzaG90LCBfQXNzaXN0YW50U3RyZWFtX2FkZEV2ZW50LCBfQXNzaXN0YW50U3RyZWFtX2VuZFJlcXVlc3QsIF9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlTWVzc2FnZSwgX0Fzc2lzdGFudFN0cmVhbV9oYW5kbGVSdW5TdGVwLCBfQXNzaXN0YW50U3RyZWFtX2hhbmRsZUV2ZW50LCBfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVSdW5TdGVwLCBfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVNZXNzYWdlLCBfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVDb250ZW50LCBfQXNzaXN0YW50U3RyZWFtX2hhbmRsZVJ1bjtcbmltcG9ydCAqIGFzIENvcmUgZnJvbSAnb3BlbmFpL2NvcmUnO1xuaW1wb3J0IHsgU3RyZWFtIH0gZnJvbSAnb3BlbmFpL3N0cmVhbWluZyc7XG5pbXBvcnQgeyBBUElVc2VyQWJvcnRFcnJvciwgT3BlbkFJRXJyb3IgfSBmcm9tICdvcGVuYWkvZXJyb3InO1xuaW1wb3J0IHsgRXZlbnRTdHJlYW0gfSBmcm9tIFwiLi9FdmVudFN0cmVhbS5tanNcIjtcbmV4cG9ydCBjbGFzcyBBc3Npc3RhbnRTdHJlYW0gZXh0ZW5kcyBFdmVudFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIF9Bc3Npc3RhbnRTdHJlYW1faW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgLy9UcmFjayBhbGwgZXZlbnRzIGluIGEgc2luZ2xlIGxpc3QgZm9yIHJlZmVyZW5jZVxuICAgICAgICBfQXNzaXN0YW50U3RyZWFtX2V2ZW50cy5zZXQodGhpcywgW10pO1xuICAgICAgICAvL1VzZWQgdG8gYWNjdW11bGF0ZSBkZWx0YXNcbiAgICAgICAgLy9XZSBhcmUgYWNjdW11bGF0aW5nIG1hbnkgdHlwZXMgc28gdGhlIHZhbHVlIGhlcmUgaXMgbm90IHN0cmljdFxuICAgICAgICBfQXNzaXN0YW50U3RyZWFtX3J1blN0ZXBTbmFwc2hvdHMuc2V0KHRoaXMsIHt9KTtcbiAgICAgICAgX0Fzc2lzdGFudFN0cmVhbV9tZXNzYWdlU25hcHNob3RzLnNldCh0aGlzLCB7fSk7XG4gICAgICAgIF9Bc3Npc3RhbnRTdHJlYW1fbWVzc2FnZVNuYXBzaG90LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQXNzaXN0YW50U3RyZWFtX2ZpbmFsUnVuLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRDb250ZW50SW5kZXguc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudENvbnRlbnQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsSW5kZXguc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICAvL0ZvciBjdXJyZW50IHNuYXBzaG90IG1ldGhvZHNcbiAgICAgICAgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50RXZlbnQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFJ1blNuYXBzaG90LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRSdW5TdGVwU25hcHNob3Quc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgfVxuICAgIFsoX0Fzc2lzdGFudFN0cmVhbV9ldmVudHMgPSBuZXcgV2Vha01hcCgpLCBfQXNzaXN0YW50U3RyZWFtX3J1blN0ZXBTbmFwc2hvdHMgPSBuZXcgV2Vha01hcCgpLCBfQXNzaXN0YW50U3RyZWFtX21lc3NhZ2VTbmFwc2hvdHMgPSBuZXcgV2Vha01hcCgpLCBfQXNzaXN0YW50U3RyZWFtX21lc3NhZ2VTbmFwc2hvdCA9IG5ldyBXZWFrTWFwKCksIF9Bc3Npc3RhbnRTdHJlYW1fZmluYWxSdW4gPSBuZXcgV2Vha01hcCgpLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRDb250ZW50SW5kZXggPSBuZXcgV2Vha01hcCgpLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRDb250ZW50ID0gbmV3IFdlYWtNYXAoKSwgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50VG9vbENhbGxJbmRleCA9IG5ldyBXZWFrTWFwKCksIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsID0gbmV3IFdlYWtNYXAoKSwgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50RXZlbnQgPSBuZXcgV2Vha01hcCgpLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRSdW5TbmFwc2hvdCA9IG5ldyBXZWFrTWFwKCksIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFJ1blN0ZXBTbmFwc2hvdCA9IG5ldyBXZWFrTWFwKCksIF9Bc3Npc3RhbnRTdHJlYW1faW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgU3ltYm9sLmFzeW5jSXRlcmF0b3IpXSgpIHtcbiAgICAgICAgY29uc3QgcHVzaFF1ZXVlID0gW107XG4gICAgICAgIGNvbnN0IHJlYWRRdWV1ZSA9IFtdO1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAvL0NhdGNoIGFsbCBmb3IgcGFzc2luZyBhbG9uZyBhbGwgZXZlbnRzXG4gICAgICAgIHRoaXMub24oJ2V2ZW50JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSByZWFkUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVzb2x2ZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdXNoUXVldWUucHVzaChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHJlYWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2Fib3J0JywgKGVycikgPT4ge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiByZWFkUXVldWUpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiByZWFkUXVldWUpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwdXNoUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHJlYWRRdWV1ZS5wdXNoKHsgcmVzb2x2ZSwgcmVqZWN0IH0pKS50aGVuKChjaHVuaykgPT4gKGNodW5rID8geyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0gOiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IHB1c2hRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXR1cm46IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21SZWFkYWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gbmV3IEFzc2lzdGFudFN0cmVhbSgpO1xuICAgICAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX2Zyb21SZWFkYWJsZVN0cmVhbShzdHJlYW0pKTtcbiAgICAgICAgcmV0dXJuIHJ1bm5lcjtcbiAgICB9XG4gICAgYXN5bmMgX2Zyb21SZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZClcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRoaXMuY29udHJvbGxlci5hYm9ydCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25uZWN0ZWQoKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSwgdGhpcy5jb250cm9sbGVyKTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBldmVudCBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQXNzaXN0YW50U3RyZWFtX2FkZEV2ZW50KS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLmNvbnRyb2xsZXIuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkUnVuKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQXNzaXN0YW50U3RyZWFtX2VuZFJlcXVlc3QpLmNhbGwodGhpcykpO1xuICAgIH1cbiAgICB0b1JlYWRhYmxlU3RyZWFtKCkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgU3RyZWFtKHRoaXNbU3ltYm9sLmFzeW5jSXRlcmF0b3JdLmJpbmQodGhpcyksIHRoaXMuY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiBzdHJlYW0udG9SZWFkYWJsZVN0cmVhbSgpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlVG9vbEFzc2lzdGFudFN0cmVhbSh0aHJlYWRJZCwgcnVuSWQsIHJ1bnMsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBuZXcgQXNzaXN0YW50U3RyZWFtKCk7XG4gICAgICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fcnVuVG9vbEFzc2lzdGFudFN0cmVhbSh0aHJlYWRJZCwgcnVuSWQsIHJ1bnMsIHBhcmFtcywge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAnc3RyZWFtJyB9LFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIGFzeW5jIF9jcmVhdGVUb29sQXNzaXN0YW50U3RyZWFtKHJ1biwgdGhyZWFkSWQsIHJ1bklkLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHsgLi4ucGFyYW1zLCBzdHJlYW06IHRydWUgfTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgcnVuLnN1Ym1pdFRvb2xPdXRwdXRzKHRocmVhZElkLCBydW5JZCwgYm9keSwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHNpZ25hbDogdGhpcy5jb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCgpO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGV2ZW50IG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9Bc3Npc3RhbnRTdHJlYW1fYWRkRXZlbnQpLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uY29udHJvbGxlci5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSdW4oX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9Bc3Npc3RhbnRTdHJlYW1fZW5kUmVxdWVzdCkuY2FsbCh0aGlzKSk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVUaHJlYWRBc3Npc3RhbnRTdHJlYW0ocGFyYW1zLCB0aHJlYWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gbmV3IEFzc2lzdGFudFN0cmVhbSgpO1xuICAgICAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX3RocmVhZEFzc2lzdGFudFN0cmVhbShwYXJhbXMsIHRocmVhZCwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLUhlbHBlci1NZXRob2QnOiAnc3RyZWFtJyB9LFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVBc3Npc3RhbnRTdHJlYW0odGhyZWFkSWQsIHJ1bnMsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBuZXcgQXNzaXN0YW50U3RyZWFtKCk7XG4gICAgICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fcnVuQXNzaXN0YW50U3RyZWFtKHRocmVhZElkLCBydW5zLCBwYXJhbXMsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3N0cmVhbScgfSxcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gcnVubmVyO1xuICAgIH1cbiAgICBjdXJyZW50RXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudEV2ZW50LCBcImZcIik7XG4gICAgfVxuICAgIGN1cnJlbnRSdW4oKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFJ1blNuYXBzaG90LCBcImZcIik7XG4gICAgfVxuICAgIGN1cnJlbnRNZXNzYWdlU25hcHNob3QoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fbWVzc2FnZVNuYXBzaG90LCBcImZcIik7XG4gICAgfVxuICAgIGN1cnJlbnRSdW5TdGVwU25hcHNob3QoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFJ1blN0ZXBTbmFwc2hvdCwgXCJmXCIpO1xuICAgIH1cbiAgICBhc3luYyBmaW5hbFJ1blN0ZXBzKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX3J1blN0ZXBTbmFwc2hvdHMsIFwiZlwiKSk7XG4gICAgfVxuICAgIGFzeW5jIGZpbmFsTWVzc2FnZXMoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fbWVzc2FnZVNuYXBzaG90cywgXCJmXCIpKTtcbiAgICB9XG4gICAgYXN5bmMgZmluYWxSdW4oKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9maW5hbFJ1biwgXCJmXCIpKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ZpbmFsIHJ1biB3YXMgbm90IHJlY2VpdmVkLicpO1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2ZpbmFsUnVuLCBcImZcIik7XG4gICAgfVxuICAgIGFzeW5jIF9jcmVhdGVUaHJlYWRBc3Npc3RhbnRTdHJlYW0odGhyZWFkLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHsgLi4ucGFyYW1zLCBzdHJlYW06IHRydWUgfTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgdGhyZWFkLmNyZWF0ZUFuZFJ1bihib2R5LCB7IC4uLm9wdGlvbnMsIHNpZ25hbDogdGhpcy5jb250cm9sbGVyLnNpZ25hbCB9KTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkKCk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgZXZlbnQgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX0Fzc2lzdGFudFN0cmVhbV9hZGRFdmVudCkuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5jb250cm9sbGVyLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJ1bihfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX0Fzc2lzdGFudFN0cmVhbV9lbmRSZXF1ZXN0KS5jYWxsKHRoaXMpKTtcbiAgICB9XG4gICAgYXN5bmMgX2NyZWF0ZUFzc2lzdGFudFN0cmVhbShydW4sIHRocmVhZElkLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHsgLi4ucGFyYW1zLCBzdHJlYW06IHRydWUgfTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgcnVuLmNyZWF0ZSh0aHJlYWRJZCwgYm9keSwgeyAuLi5vcHRpb25zLCBzaWduYWw6IHRoaXMuY29udHJvbGxlci5zaWduYWwgfSk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCgpO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGV2ZW50IG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9Bc3Npc3RhbnRTdHJlYW1fYWRkRXZlbnQpLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uY29udHJvbGxlci5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSdW4oX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9Bc3Npc3RhbnRTdHJlYW1fZW5kUmVxdWVzdCkuY2FsbCh0aGlzKSk7XG4gICAgfVxuICAgIHN0YXRpYyBhY2N1bXVsYXRlRGVsdGEoYWNjLCBkZWx0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGRlbHRhVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRlbHRhKSkge1xuICAgICAgICAgICAgaWYgKCFhY2MuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gZGVsdGFWYWx1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhY2NWYWx1ZSA9IGFjY1trZXldO1xuICAgICAgICAgICAgaWYgKGFjY1ZhbHVlID09PSBudWxsIHx8IGFjY1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IGRlbHRhVmFsdWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBhY2N1bXVsYXRlIHRoZXNlIHNwZWNpYWwgcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2luZGV4JyB8fCBrZXkgPT09ICd0eXBlJykge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gZGVsdGFWYWx1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFR5cGUtc3BlY2lmaWMgYWNjdW11bGF0aW9uIGxvZ2ljXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFjY1ZhbHVlID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGVsdGFWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBhY2NWYWx1ZSArPSBkZWx0YVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFjY1ZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgZGVsdGFWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBhY2NWYWx1ZSArPSBkZWx0YVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQ29yZS5pc09iaihhY2NWYWx1ZSkgJiYgQ29yZS5pc09iaihkZWx0YVZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGFjY1ZhbHVlID0gdGhpcy5hY2N1bXVsYXRlRGVsdGEoYWNjVmFsdWUsIGRlbHRhVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhY2NWYWx1ZSkgJiYgQXJyYXkuaXNBcnJheShkZWx0YVZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChhY2NWYWx1ZS5ldmVyeSgoeCkgPT4gdHlwZW9mIHggPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB4ID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjVmFsdWUucHVzaCguLi5kZWx0YVZhbHVlKTsgLy8gVXNlIHNwcmVhZCBzeW50YXggZm9yIGVmZmljaWVudCBhZGRpdGlvblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgVW5oYW5kbGVkIHJlY29yZCB0eXBlOiAke2tleX0sIGRlbHRhVmFsdWU6ICR7ZGVsdGFWYWx1ZX0sIGFjY1ZhbHVlOiAke2FjY1ZhbHVlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjW2tleV0gPSBhY2NWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBfYWRkUnVuKHJ1bikge1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBfdGhyZWFkQXNzaXN0YW50U3RyZWFtKHBhcmFtcywgdGhyZWFkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9jcmVhdGVUaHJlYWRBc3Npc3RhbnRTdHJlYW0odGhyZWFkLCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBfcnVuQXNzaXN0YW50U3RyZWFtKHRocmVhZElkLCBydW5zLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2NyZWF0ZUFzc2lzdGFudFN0cmVhbShydW5zLCB0aHJlYWRJZCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgX3J1blRvb2xBc3Npc3RhbnRTdHJlYW0odGhyZWFkSWQsIHJ1bklkLCBydW5zLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2NyZWF0ZVRvb2xBc3Npc3RhbnRTdHJlYW0ocnVucywgdGhyZWFkSWQsIHJ1bklkLCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgIH1cbn1cbl9Bc3Npc3RhbnRTdHJlYW1fYWRkRXZlbnQgPSBmdW5jdGlvbiBfQXNzaXN0YW50U3RyZWFtX2FkZEV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZW5kZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudEV2ZW50LCBldmVudCwgXCJmXCIpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQXNzaXN0YW50U3RyZWFtX2hhbmRsZUV2ZW50KS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICBzd2l0Y2ggKGV2ZW50LmV2ZW50KSB7XG4gICAgICAgIGNhc2UgJ3RocmVhZC5jcmVhdGVkJzpcbiAgICAgICAgICAgIC8vTm8gYWN0aW9uIG9uIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jcmVhdGVkJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5xdWV1ZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLmluX3Byb2dyZXNzJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5yZXF1aXJlc19hY3Rpb24nOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLmNvbXBsZXRlZCc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uZmFpbGVkJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jYW5jZWxsaW5nJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jYW5jZWxsZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLmV4cGlyZWQnOlxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlUnVuKS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY3JlYXRlZCc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5pbl9wcm9ncmVzcyc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5kZWx0YSc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jb21wbGV0ZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZmFpbGVkJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmNhbmNlbGxlZCc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5leHBpcmVkJzpcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQXNzaXN0YW50U3RyZWFtX2hhbmRsZVJ1blN0ZXApLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmNyZWF0ZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5pbl9wcm9ncmVzcyc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmRlbHRhJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuY29tcGxldGVkJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuaW5jb21wbGV0ZSc6XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX0Fzc2lzdGFudFN0cmVhbV9oYW5kbGVNZXNzYWdlKS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAvL1RoaXMgaXMgaW5jbHVkZWQgZm9yIGNvbXBsZXRlbmVzcywgYnV0IGVycm9ycyBhcmUgcHJvY2Vzc2VkIGluIHRoZSBTU0UgZXZlbnQgcHJvY2Vzc2luZyBzbyB0aGlzIHNob3VsZCBub3Qgb2NjdXJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jb3VudGVyZWQgYW4gZXJyb3IgZXZlbnQgaW4gZXZlbnQgcHJvY2Vzc2luZyAtIGVycm9ycyBzaG91bGQgYmUgcHJvY2Vzc2VkIGVhcmxpZXInKTtcbiAgICB9XG59LCBfQXNzaXN0YW50U3RyZWFtX2VuZFJlcXVlc3QgPSBmdW5jdGlvbiBfQXNzaXN0YW50U3RyZWFtX2VuZFJlcXVlc3QoKSB7XG4gICAgaWYgKHRoaXMuZW5kZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9wZW5BSUVycm9yKGBzdHJlYW0gaGFzIGVuZGVkLCB0aGlzIHNob3VsZG4ndCBoYXBwZW5gKTtcbiAgICB9XG4gICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fZmluYWxSdW4sIFwiZlwiKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ZpbmFsIHJ1biBoYXMgbm90IGJlZW4gcmVjZWl2ZWQnKTtcbiAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2ZpbmFsUnVuLCBcImZcIik7XG59LCBfQXNzaXN0YW50U3RyZWFtX2hhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiBfQXNzaXN0YW50U3RyZWFtX2hhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICBjb25zdCBbYWNjdW11bGF0ZWRNZXNzYWdlLCBuZXdDb250ZW50XSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVNZXNzYWdlKS5jYWxsKHRoaXMsIGV2ZW50LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fbWVzc2FnZVNuYXBzaG90LCBcImZcIikpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9tZXNzYWdlU25hcHNob3QsIGFjY3VtdWxhdGVkTWVzc2FnZSwgXCJmXCIpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9tZXNzYWdlU25hcHNob3RzLCBcImZcIilbYWNjdW11bGF0ZWRNZXNzYWdlLmlkXSA9IGFjY3VtdWxhdGVkTWVzc2FnZTtcbiAgICBmb3IgKGNvbnN0IGNvbnRlbnQgb2YgbmV3Q29udGVudCkge1xuICAgICAgICBjb25zdCBzbmFwc2hvdENvbnRlbnQgPSBhY2N1bXVsYXRlZE1lc3NhZ2UuY29udGVudFtjb250ZW50LmluZGV4XTtcbiAgICAgICAgaWYgKHNuYXBzaG90Q29udGVudD8udHlwZSA9PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3RleHRDcmVhdGVkJywgc25hcHNob3RDb250ZW50LnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoZXZlbnQuZXZlbnQpIHtcbiAgICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuY3JlYXRlZCc6XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdtZXNzYWdlQ3JlYXRlZCcsIGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmluX3Byb2dyZXNzJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5kZWx0YSc6XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdtZXNzYWdlRGVsdGEnLCBldmVudC5kYXRhLmRlbHRhLCBhY2N1bXVsYXRlZE1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEuZGVsdGEuY29udGVudCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udGVudCBvZiBldmVudC5kYXRhLmRlbHRhLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9JZiBpdCBpcyB0ZXh0IGRlbHRhLCBlbWl0IGEgdGV4dCBkZWx0YSBldmVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09ICd0ZXh0JyAmJiBjb250ZW50LnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0RGVsdGEgPSBjb250ZW50LnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc25hcHNob3QgPSBhY2N1bXVsYXRlZE1lc3NhZ2UuY29udGVudFtjb250ZW50LmluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbmFwc2hvdCAmJiBzbmFwc2hvdC50eXBlID09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3RleHREZWx0YScsIHRleHREZWx0YSwgc25hcHNob3QudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVGhlIHNuYXBzaG90IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRleHQgZGVsdGEgaXMgbm90IHRleHQgb3IgbWlzc2luZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50LmluZGV4ICE9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50Q29udGVudEluZGV4LCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vU2VlIGlmIHdlIGhhdmUgaW4gcHJvZ3Jlc3MgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50Q29udGVudCwgXCJmXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudENvbnRlbnQsIFwiZlwiKS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgndGV4dERvbmUnLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudENvbnRlbnQsIFwiZlwiKS50ZXh0LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fbWVzc2FnZVNuYXBzaG90LCBcImZcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ltYWdlX2ZpbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgnaW1hZ2VGaWxlRG9uZScsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50Q29udGVudCwgXCJmXCIpLmltYWdlX2ZpbGUsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9tZXNzYWdlU25hcHNob3QsIFwiZlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudENvbnRlbnRJbmRleCwgY29udGVudC5pbmRleCwgXCJmXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50Q29udGVudCwgYWNjdW11bGF0ZWRNZXNzYWdlLmNvbnRlbnRbY29udGVudC5pbmRleF0sIFwiZlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuY29tcGxldGVkJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuaW5jb21wbGV0ZSc6XG4gICAgICAgICAgICAvL1dlIGVtaXQgdGhlIGxhdGVzdCBjb250ZW50IHdlIHdlcmUgd29ya2luZyBvbiBvbiBjb21wbGV0aW9uIChpbmNsdWRpbmcgaW5jb21wbGV0ZSlcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudENvbnRlbnRJbmRleCwgXCJmXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q29udGVudCA9IGV2ZW50LmRhdGEuY29udGVudFtfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudENvbnRlbnRJbmRleCwgXCJmXCIpXTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjdXJyZW50Q29udGVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbWFnZV9maWxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCdpbWFnZUZpbGVEb25lJywgY3VycmVudENvbnRlbnQuaW1hZ2VfZmlsZSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX21lc3NhZ2VTbmFwc2hvdCwgXCJmXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3RleHREb25lJywgY3VycmVudENvbnRlbnQudGV4dCwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX21lc3NhZ2VTbmFwc2hvdCwgXCJmXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fbWVzc2FnZVNuYXBzaG90LCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCdtZXNzYWdlRG9uZScsIGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX21lc3NhZ2VTbmFwc2hvdCwgdW5kZWZpbmVkLCBcImZcIik7XG4gICAgfVxufSwgX0Fzc2lzdGFudFN0cmVhbV9oYW5kbGVSdW5TdGVwID0gZnVuY3Rpb24gX0Fzc2lzdGFudFN0cmVhbV9oYW5kbGVSdW5TdGVwKGV2ZW50KSB7XG4gICAgY29uc3QgYWNjdW11bGF0ZWRSdW5TdGVwID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9Bc3Npc3RhbnRTdHJlYW1fYWNjdW11bGF0ZVJ1blN0ZXApLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50UnVuU3RlcFNuYXBzaG90LCBhY2N1bXVsYXRlZFJ1blN0ZXAsIFwiZlwiKTtcbiAgICBzd2l0Y2ggKGV2ZW50LmV2ZW50KSB7XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jcmVhdGVkJzpcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3J1blN0ZXBDcmVhdGVkJywgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmRlbHRhJzpcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZXZlbnQuZGF0YS5kZWx0YTtcbiAgICAgICAgICAgIGlmIChkZWx0YS5zdGVwX2RldGFpbHMgJiZcbiAgICAgICAgICAgICAgICBkZWx0YS5zdGVwX2RldGFpbHMudHlwZSA9PSAndG9vbF9jYWxscycgJiZcbiAgICAgICAgICAgICAgICBkZWx0YS5zdGVwX2RldGFpbHMudG9vbF9jYWxscyAmJlxuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkUnVuU3RlcC5zdGVwX2RldGFpbHMudHlwZSA9PSAndG9vbF9jYWxscycpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIGRlbHRhLnN0ZXBfZGV0YWlscy50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29sQ2FsbC5pbmRleCA9PSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsSW5kZXgsIFwiZlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgndG9vbENhbGxEZWx0YScsIHRvb2xDYWxsLCBhY2N1bXVsYXRlZFJ1blN0ZXAuc3RlcF9kZXRhaWxzLnRvb2xfY2FsbHNbdG9vbENhbGwuaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsLCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCd0b29sQ2FsbERvbmUnLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsLCBcImZcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRUb29sQ2FsbEluZGV4LCB0b29sQ2FsbC5pbmRleCwgXCJmXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRUb29sQ2FsbCwgYWNjdW11bGF0ZWRSdW5TdGVwLnN0ZXBfZGV0YWlscy50b29sX2NhbGxzW3Rvb2xDYWxsLmluZGV4XSwgXCJmXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9jdXJyZW50VG9vbENhbGwsIFwiZlwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCd0b29sQ2FsbENyZWF0ZWQnLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsLCBcImZcIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZW1pdCgncnVuU3RlcERlbHRhJywgZXZlbnQuZGF0YS5kZWx0YSwgYWNjdW11bGF0ZWRSdW5TdGVwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY29tcGxldGVkJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmZhaWxlZCc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5jYW5jZWxsZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZXhwaXJlZCc6XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFJ1blN0ZXBTbmFwc2hvdCwgdW5kZWZpbmVkLCBcImZcIik7XG4gICAgICAgICAgICBjb25zdCBkZXRhaWxzID0gZXZlbnQuZGF0YS5zdGVwX2RldGFpbHM7XG4gICAgICAgICAgICBpZiAoZGV0YWlscy50eXBlID09ICd0b29sX2NhbGxzJykge1xuICAgICAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsLCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgndG9vbENhbGxEb25lJywgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRUb29sQ2FsbCwgXCJmXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRUb29sQ2FsbCwgdW5kZWZpbmVkLCBcImZcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZW1pdCgncnVuU3RlcERvbmUnLCBldmVudC5kYXRhLCBhY2N1bXVsYXRlZFJ1blN0ZXApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5pbl9wcm9ncmVzcyc6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59LCBfQXNzaXN0YW50U3RyZWFtX2hhbmRsZUV2ZW50ID0gZnVuY3Rpb24gX0Fzc2lzdGFudFN0cmVhbV9oYW5kbGVFdmVudChldmVudCkge1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9ldmVudHMsIFwiZlwiKS5wdXNoKGV2ZW50KTtcbiAgICB0aGlzLl9lbWl0KCdldmVudCcsIGV2ZW50KTtcbn0sIF9Bc3Npc3RhbnRTdHJlYW1fYWNjdW11bGF0ZVJ1blN0ZXAgPSBmdW5jdGlvbiBfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVSdW5TdGVwKGV2ZW50KSB7XG4gICAgc3dpdGNoIChldmVudC5ldmVudCkge1xuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY3JlYXRlZCc6XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fcnVuU3RlcFNuYXBzaG90cywgXCJmXCIpW2V2ZW50LmRhdGEuaWRdID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJldHVybiBldmVudC5kYXRhO1xuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuZGVsdGEnOlxuICAgICAgICAgICAgbGV0IHNuYXBzaG90ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX3J1blN0ZXBTbmFwc2hvdHMsIFwiZlwiKVtldmVudC5kYXRhLmlkXTtcbiAgICAgICAgICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignUmVjZWl2ZWQgYSBSdW5TdGVwRGVsdGEgYmVmb3JlIGNyZWF0aW9uIG9mIGEgc25hcHNob3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhLmRlbHRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjdW11bGF0ZWQgPSBBc3Npc3RhbnRTdHJlYW0uYWNjdW11bGF0ZURlbHRhKHNuYXBzaG90LCBkYXRhLmRlbHRhKTtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fcnVuU3RlcFNuYXBzaG90cywgXCJmXCIpW2V2ZW50LmRhdGEuaWRdID0gYWNjdW11bGF0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX3J1blN0ZXBTbmFwc2hvdHMsIFwiZlwiKVtldmVudC5kYXRhLmlkXTtcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmNvbXBsZXRlZCc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uc3RlcC5mYWlsZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuY2FuY2VsbGVkJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5zdGVwLmV4cGlyZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnN0ZXAuaW5fcHJvZ3Jlc3MnOlxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX3J1blN0ZXBTbmFwc2hvdHMsIFwiZlwiKVtldmVudC5kYXRhLmlkXSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fzc2lzdGFudFN0cmVhbV9ydW5TdGVwU25hcHNob3RzLCBcImZcIilbZXZlbnQuZGF0YS5pZF0pXG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fcnVuU3RlcFNuYXBzaG90cywgXCJmXCIpW2V2ZW50LmRhdGEuaWRdO1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gc25hcHNob3QgYXZhaWxhYmxlJyk7XG59LCBfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVNZXNzYWdlID0gZnVuY3Rpb24gX0Fzc2lzdGFudFN0cmVhbV9hY2N1bXVsYXRlTWVzc2FnZShldmVudCwgc25hcHNob3QpIHtcbiAgICBsZXQgbmV3Q29udGVudCA9IFtdO1xuICAgIHN3aXRjaCAoZXZlbnQuZXZlbnQpIHtcbiAgICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuY3JlYXRlZCc6XG4gICAgICAgICAgICAvL09uIGNyZWF0aW9uIHRoZSBzbmFwc2hvdCBpcyBqdXN0IHRoZSBpbml0aWFsIG1lc3NhZ2VcbiAgICAgICAgICAgIHJldHVybiBbZXZlbnQuZGF0YSwgbmV3Q29udGVudF07XG4gICAgICAgIGNhc2UgJ3RocmVhZC5tZXNzYWdlLmRlbHRhJzpcbiAgICAgICAgICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignUmVjZWl2ZWQgYSBkZWx0YSB3aXRoIG5vIGV4aXN0aW5nIHNuYXBzaG90ICh0aGVyZSBzaG91bGQgYmUgb25lIGZyb20gbWVzc2FnZSBjcmVhdGlvbiknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIC8vSWYgdGhpcyBkZWx0YSBkb2VzIG5vdCBoYXZlIGNvbnRlbnQsIG5vdGhpbmcgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKGRhdGEuZGVsdGEuY29udGVudCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udGVudEVsZW1lbnQgb2YgZGF0YS5kZWx0YS5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50RWxlbWVudC5pbmRleCBpbiBzbmFwc2hvdC5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudENvbnRlbnQgPSBzbmFwc2hvdC5jb250ZW50W2NvbnRlbnRFbGVtZW50LmluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBzaG90LmNvbnRlbnRbY29udGVudEVsZW1lbnQuaW5kZXhdID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9Bc3Npc3RhbnRTdHJlYW1fYWNjdW11bGF0ZUNvbnRlbnQpLmNhbGwodGhpcywgY29udGVudEVsZW1lbnQsIGN1cnJlbnRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBzaG90LmNvbnRlbnRbY29udGVudEVsZW1lbnQuaW5kZXhdID0gY29udGVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRlbnQucHVzaChjb250ZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3NuYXBzaG90LCBuZXdDb250ZW50XTtcbiAgICAgICAgY2FzZSAndGhyZWFkLm1lc3NhZ2UuaW5fcHJvZ3Jlc3MnOlxuICAgICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5jb21wbGV0ZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQubWVzc2FnZS5pbmNvbXBsZXRlJzpcbiAgICAgICAgICAgIC8vTm8gY2hhbmdlcyBvbiBvdGhlciB0aHJlYWQgZXZlbnRzXG4gICAgICAgICAgICBpZiAoc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NuYXBzaG90LCBuZXdDb250ZW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdSZWNlaXZlZCB0aHJlYWQgbWVzc2FnZSBldmVudCB3aXRoIG5vIGV4aXN0aW5nIHNuYXBzaG90Jyk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdUcmllZCB0byBhY2N1bXVsYXRlIGEgbm9uLW1lc3NhZ2UgZXZlbnQnKTtcbn0sIF9Bc3Npc3RhbnRTdHJlYW1fYWNjdW11bGF0ZUNvbnRlbnQgPSBmdW5jdGlvbiBfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVDb250ZW50KGNvbnRlbnRFbGVtZW50LCBjdXJyZW50Q29udGVudCkge1xuICAgIHJldHVybiBBc3Npc3RhbnRTdHJlYW0uYWNjdW11bGF0ZURlbHRhKGN1cnJlbnRDb250ZW50LCBjb250ZW50RWxlbWVudCk7XG59LCBfQXNzaXN0YW50U3RyZWFtX2hhbmRsZVJ1biA9IGZ1bmN0aW9uIF9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlUnVuKGV2ZW50KSB7XG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRSdW5TbmFwc2hvdCwgZXZlbnQuZGF0YSwgXCJmXCIpO1xuICAgIHN3aXRjaCAoZXZlbnQuZXZlbnQpIHtcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jcmVhdGVkJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0aHJlYWQucnVuLnF1ZXVlZCc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5pbl9wcm9ncmVzcyc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5yZXF1aXJlc19hY3Rpb24nOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLmNhbmNlbGxlZCc6XG4gICAgICAgIGNhc2UgJ3RocmVhZC5ydW4uZmFpbGVkJzpcbiAgICAgICAgY2FzZSAndGhyZWFkLnJ1bi5jb21wbGV0ZWQnOlxuICAgICAgICBjYXNlICd0aHJlYWQucnVuLmV4cGlyZWQnOlxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2ZpbmFsUnVuLCBldmVudC5kYXRhLCBcImZcIik7XG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRUb29sQ2FsbCwgXCJmXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgndG9vbENhbGxEb25lJywgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXNzaXN0YW50U3RyZWFtX2N1cnJlbnRUb29sQ2FsbCwgXCJmXCIpKTtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Bc3Npc3RhbnRTdHJlYW1fY3VycmVudFRvb2xDYWxsLCB1bmRlZmluZWQsIFwiZlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0aHJlYWQucnVuLmNhbmNlbGxpbmcnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzc2lzdGFudFN0cmVhbS5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uLy4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCIuLi8uLi8uLi9jb3JlLm1qc1wiO1xuaW1wb3J0ICogYXMgTWVzc2FnZXNBUEkgZnJvbSBcIi4vbWVzc2FnZXMubWpzXCI7XG5pbXBvcnQgeyBDdXJzb3JQYWdlIH0gZnJvbSBcIi4uLy4uLy4uL3BhZ2luYXRpb24ubWpzXCI7XG5leHBvcnQgY2xhc3MgTWVzc2FnZXMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBjcmVhdGUodGhyZWFkSWQsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9tZXNzYWdlc2AsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgbWVzc2FnZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZSh0aHJlYWRJZCwgbWVzc2FnZUlkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9tZXNzYWdlcy8ke21lc3NhZ2VJZH1gLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIGEgbWVzc2FnZS5cbiAgICAgKi9cbiAgICB1cGRhdGUodGhyZWFkSWQsIG1lc3NhZ2VJZCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L21lc3NhZ2VzLyR7bWVzc2FnZUlkfWAsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3QodGhyZWFkSWQsIHF1ZXJ5ID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0KHRocmVhZElkLCB7fSwgcXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vbWVzc2FnZXNgLCBNZXNzYWdlc1BhZ2UsIHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBkZWwodGhyZWFkSWQsIG1lc3NhZ2VJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL3RocmVhZHMvJHt0aHJlYWRJZH0vbWVzc2FnZXMvJHttZXNzYWdlSWR9YCwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBNZXNzYWdlc1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlIHtcbn1cbihmdW5jdGlvbiAoTWVzc2FnZXMpIHtcbiAgICBNZXNzYWdlcy5NZXNzYWdlc1BhZ2UgPSBNZXNzYWdlc0FQSS5NZXNzYWdlc1BhZ2U7XG59KShNZXNzYWdlcyB8fCAoTWVzc2FnZXMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZXMubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9yZXNvdXJjZS5tanNcIjtcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vY29yZS5tanNcIjtcbmltcG9ydCAqIGFzIFN0ZXBzQVBJIGZyb20gXCIuL3N0ZXBzLm1qc1wiO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9wYWdpbmF0aW9uLm1qc1wiO1xuZXhwb3J0IGNsYXNzIFN0ZXBzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIHJ1biBzdGVwLlxuICAgICAqL1xuICAgIHJldHJpZXZlKHRocmVhZElkLCBydW5JZCwgc3RlcElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9L3N0ZXBzLyR7c3RlcElkfWAsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGlzdCh0aHJlYWRJZCwgcnVuSWQsIHF1ZXJ5ID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0KHRocmVhZElkLCBydW5JZCwge30sIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvJHtydW5JZH0vc3RlcHNgLCBSdW5TdGVwc1BhZ2UsIHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSdW5TdGVwc1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlIHtcbn1cbihmdW5jdGlvbiAoU3RlcHMpIHtcbiAgICBTdGVwcy5SdW5TdGVwc1BhZ2UgPSBTdGVwc0FQSS5SdW5TdGVwc1BhZ2U7XG59KShTdGVwcyB8fCAoU3RlcHMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RlcHMubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9yZXNvdXJjZS5tanNcIjtcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vY29yZS5tanNcIjtcbmltcG9ydCB7IEFzc2lzdGFudFN0cmVhbSB9IGZyb20gXCIuLi8uLi8uLi8uLi9saWIvQXNzaXN0YW50U3RyZWFtLm1qc1wiO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tIFwiLi4vLi4vLi4vLi4vY29yZS5tanNcIjtcbmltcG9ydCAqIGFzIFJ1bnNBUEkgZnJvbSBcIi4vcnVucy5tanNcIjtcbmltcG9ydCAqIGFzIFN0ZXBzQVBJIGZyb20gXCIuL3N0ZXBzLm1qc1wiO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9wYWdpbmF0aW9uLm1qc1wiO1xuZXhwb3J0IGNsYXNzIFJ1bnMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RlcHMgPSBuZXcgU3RlcHNBUEkuU3RlcHModGhpcy5fY2xpZW50KTtcbiAgICB9XG4gICAgY3JlYXRlKHRocmVhZElkLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVuc2AsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgICAgIHN0cmVhbTogYm9keS5zdHJlYW0gPz8gZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBydW4uXG4gICAgICovXG4gICAgcmV0cmlldmUodGhyZWFkSWQsIHJ1bklkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9YCwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb2RpZmllcyBhIHJ1bi5cbiAgICAgKi9cbiAgICB1cGRhdGUodGhyZWFkSWQsIHJ1bklkLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfWAsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3QodGhyZWFkSWQsIHF1ZXJ5ID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0KHRocmVhZElkLCB7fSwgcXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVuc2AsIFJ1bnNQYWdlLCB7XG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhIHJ1biB0aGF0IGlzIGBpbl9wcm9ncmVzc2AuXG4gICAgICovXG4gICAgY2FuY2VsKHRocmVhZElkLCBydW5JZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvJHtydW5JZH0vY2FuY2VsYCwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciB0byBjcmVhdGUgYSBydW4gYW4gcG9sbCBmb3IgYSB0ZXJtaW5hbCBzdGF0ZS4gTW9yZSBpbmZvcm1hdGlvbiBvbiBSdW5cbiAgICAgKiBsaWZlY3ljbGVzIGNhbiBiZSBmb3VuZCBoZXJlOlxuICAgICAqIGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvaG93LWl0LXdvcmtzL3J1bnMtYW5kLXJ1bi1zdGVwc1xuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUFuZFBvbGwodGhyZWFkSWQsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcnVuID0gYXdhaXQgdGhpcy5jcmVhdGUodGhyZWFkSWQsIGJvZHksIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb2xsKHRocmVhZElkLCBydW4uaWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBSdW4gc3RyZWFtXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2UgYHN0cmVhbWAgaW5zdGVhZFxuICAgICAqL1xuICAgIGNyZWF0ZUFuZFN0cmVhbSh0aHJlYWRJZCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gQXNzaXN0YW50U3RyZWFtLmNyZWF0ZUFzc2lzdGFudFN0cmVhbSh0aHJlYWRJZCwgdGhpcy5fY2xpZW50LmJldGEudGhyZWFkcy5ydW5zLCBib2R5LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgdG8gcG9sbCBhIHJ1biBzdGF0dXMgdW50aWwgaXQgcmVhY2hlcyBhIHRlcm1pbmFsIHN0YXRlLiBNb3JlXG4gICAgICogaW5mb3JtYXRpb24gb24gUnVuIGxpZmVjeWNsZXMgY2FuIGJlIGZvdW5kIGhlcmU6XG4gICAgICogaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy9ob3ctaXQtd29ya3MvcnVucy1hbmQtcnVuLXN0ZXBzXG4gICAgICovXG4gICAgYXN5bmMgcG9sbCh0aHJlYWRJZCwgcnVuSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLVBvbGwtSGVscGVyJzogJ3RydWUnIH07XG4gICAgICAgIGlmIChvcHRpb25zPy5wb2xsSW50ZXJ2YWxNcykge1xuICAgICAgICAgICAgaGVhZGVyc1snWC1TdGFpbmxlc3MtQ3VzdG9tLVBvbGwtSW50ZXJ2YWwnXSA9IG9wdGlvbnMucG9sbEludGVydmFsTXMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBydW4sIHJlc3BvbnNlIH0gPSBhd2FpdCB0aGlzLnJldHJpZXZlKHRocmVhZElkLCBydW5JZCwge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi5vcHRpb25zPy5oZWFkZXJzLCAuLi5oZWFkZXJzIH0sXG4gICAgICAgICAgICB9KS53aXRoUmVzcG9uc2UoKTtcbiAgICAgICAgICAgIHN3aXRjaCAocnVuLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIC8vSWYgd2UgYXJlIGluIGFueSBzb3J0IG9mIGludGVybWVkaWF0ZSBzdGF0ZSB3ZSBwb2xsXG4gICAgICAgICAgICAgICAgY2FzZSAncXVldWVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdpbl9wcm9ncmVzcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY2FuY2VsbGluZyc6XG4gICAgICAgICAgICAgICAgICAgIGxldCBzbGVlcEludGVydmFsID0gNTAwMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnM/LnBvbGxJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbGVlcEludGVydmFsID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlckludGVydmFsID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ29wZW5haS1wb2xsLWFmdGVyLW1zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVySW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJJbnRlcnZhbE1zID0gcGFyc2VJbnQoaGVhZGVySW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4oaGVhZGVySW50ZXJ2YWxNcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xlZXBJbnRlcnZhbCA9IGhlYWRlckludGVydmFsTXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKHNsZWVwSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvL1dlIHJldHVybiB0aGUgcnVuIGluIGFueSB0ZXJtaW5hbCBzdGF0ZS5cbiAgICAgICAgICAgICAgICBjYXNlICdyZXF1aXJlc19hY3Rpb24nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2luY29tcGxldGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NhbmNlbGxlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2V4cGlyZWQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFJ1biBzdHJlYW1cbiAgICAgKi9cbiAgICBzdHJlYW0odGhyZWFkSWQsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIEFzc2lzdGFudFN0cmVhbS5jcmVhdGVBc3Npc3RhbnRTdHJlYW0odGhyZWFkSWQsIHRoaXMuX2NsaWVudC5iZXRhLnRocmVhZHMucnVucywgYm9keSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN1Ym1pdFRvb2xPdXRwdXRzKHRocmVhZElkLCBydW5JZCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvJHtydW5JZH0vc3VibWl0X3Rvb2xfb3V0cHV0c2AsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgICAgIHN0cmVhbTogYm9keS5zdHJlYW0gPz8gZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciB0byBzdWJtaXQgYSB0b29sIG91dHB1dCB0byBhIHJ1biBhbmQgcG9sbCBmb3IgYSB0ZXJtaW5hbCBydW4gc3RhdGUuXG4gICAgICogTW9yZSBpbmZvcm1hdGlvbiBvbiBSdW4gbGlmZWN5Y2xlcyBjYW4gYmUgZm91bmQgaGVyZTpcbiAgICAgKiBodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL2hvdy1pdC13b3Jrcy9ydW5zLWFuZC1ydW4tc3RlcHNcbiAgICAgKi9cbiAgICBhc3luYyBzdWJtaXRUb29sT3V0cHV0c0FuZFBvbGwodGhyZWFkSWQsIHJ1bklkLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IGF3YWl0IHRoaXMuc3VibWl0VG9vbE91dHB1dHModGhyZWFkSWQsIHJ1bklkLCBib2R5LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9sbCh0aHJlYWRJZCwgcnVuLmlkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VibWl0IHRoZSB0b29sIG91dHB1dHMgZnJvbSBhIHByZXZpb3VzIHJ1biBhbmQgc3RyZWFtIHRoZSBydW4gdG8gYSB0ZXJtaW5hbFxuICAgICAqIHN0YXRlLiBNb3JlIGluZm9ybWF0aW9uIG9uIFJ1biBsaWZlY3ljbGVzIGNhbiBiZSBmb3VuZCBoZXJlOlxuICAgICAqIGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvaG93LWl0LXdvcmtzL3J1bnMtYW5kLXJ1bi1zdGVwc1xuICAgICAqL1xuICAgIHN1Ym1pdFRvb2xPdXRwdXRzU3RyZWFtKHRocmVhZElkLCBydW5JZCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gQXNzaXN0YW50U3RyZWFtLmNyZWF0ZVRvb2xBc3Npc3RhbnRTdHJlYW0odGhyZWFkSWQsIHJ1bklkLCB0aGlzLl9jbGllbnQuYmV0YS50aHJlYWRzLnJ1bnMsIGJvZHksIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSdW5zUGFnZSBleHRlbmRzIEN1cnNvclBhZ2Uge1xufVxuKGZ1bmN0aW9uIChSdW5zKSB7XG4gICAgUnVucy5SdW5zUGFnZSA9IFJ1bnNBUEkuUnVuc1BhZ2U7XG4gICAgUnVucy5TdGVwcyA9IFN0ZXBzQVBJLlN0ZXBzO1xuICAgIFJ1bnMuUnVuU3RlcHNQYWdlID0gU3RlcHNBUEkuUnVuU3RlcHNQYWdlO1xufSkoUnVucyB8fCAoUnVucyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ydW5zLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vLi4vcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUubWpzXCI7XG5pbXBvcnQgeyBBc3Npc3RhbnRTdHJlYW0gfSBmcm9tIFwiLi4vLi4vLi4vbGliL0Fzc2lzdGFudFN0cmVhbS5tanNcIjtcbmltcG9ydCAqIGFzIE1lc3NhZ2VzQVBJIGZyb20gXCIuL21lc3NhZ2VzLm1qc1wiO1xuaW1wb3J0ICogYXMgUnVuc0FQSSBmcm9tIFwiLi9ydW5zL3J1bnMubWpzXCI7XG5leHBvcnQgY2xhc3MgVGhyZWFkcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ydW5zID0gbmV3IFJ1bnNBUEkuUnVucyh0aGlzLl9jbGllbnQpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gbmV3IE1lc3NhZ2VzQVBJLk1lc3NhZ2VzKHRoaXMuX2NsaWVudCk7XG4gICAgfVxuICAgIGNyZWF0ZShib2R5ID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMoYm9keSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh7fSwgYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvdGhyZWFkcycsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIHRocmVhZC5cbiAgICAgKi9cbiAgICByZXRyaWV2ZSh0aHJlYWRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL3RocmVhZHMvJHt0aHJlYWRJZH1gLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIGEgdGhyZWFkLlxuICAgICAqL1xuICAgIHVwZGF0ZSh0aHJlYWRJZCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC90aHJlYWRzLyR7dGhyZWFkSWR9YCwge1xuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgdGhyZWFkLlxuICAgICAqL1xuICAgIGRlbCh0aHJlYWRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL3RocmVhZHMvJHt0aHJlYWRJZH1gLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZUFuZFJ1bihib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL3RocmVhZHMvcnVucycsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgICAgIHN0cmVhbTogYm9keS5zdHJlYW0gPz8gZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciB0byBjcmVhdGUgYSB0aHJlYWQsIHN0YXJ0IGEgcnVuIGFuZCB0aGVuIHBvbGwgZm9yIGEgdGVybWluYWwgc3RhdGUuXG4gICAgICogTW9yZSBpbmZvcm1hdGlvbiBvbiBSdW4gbGlmZWN5Y2xlcyBjYW4gYmUgZm91bmQgaGVyZTpcbiAgICAgKiBodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hc3Npc3RhbnRzL2hvdy1pdC13b3Jrcy9ydW5zLWFuZC1ydW4tc3RlcHNcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVBbmRSdW5Qb2xsKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcnVuID0gYXdhaXQgdGhpcy5jcmVhdGVBbmRSdW4oYm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJ1bnMucG9sbChydW4udGhyZWFkX2lkLCBydW4uaWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB0aHJlYWQgYW5kIHN0cmVhbSB0aGUgcnVuIGJhY2tcbiAgICAgKi9cbiAgICBjcmVhdGVBbmRSdW5TdHJlYW0oYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gQXNzaXN0YW50U3RyZWFtLmNyZWF0ZVRocmVhZEFzc2lzdGFudFN0cmVhbShib2R5LCB0aGlzLl9jbGllbnQuYmV0YS50aHJlYWRzLCBvcHRpb25zKTtcbiAgICB9XG59XG4oZnVuY3Rpb24gKFRocmVhZHMpIHtcbiAgICBUaHJlYWRzLlJ1bnMgPSBSdW5zQVBJLlJ1bnM7XG4gICAgVGhyZWFkcy5SdW5zUGFnZSA9IFJ1bnNBUEkuUnVuc1BhZ2U7XG4gICAgVGhyZWFkcy5NZXNzYWdlcyA9IE1lc3NhZ2VzQVBJLk1lc3NhZ2VzO1xuICAgIFRocmVhZHMuTWVzc2FnZXNQYWdlID0gTWVzc2FnZXNBUEkuTWVzc2FnZXNQYWdlO1xufSkoVGhyZWFkcyB8fCAoVGhyZWFkcyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJlYWRzLm1qcy5tYXAiLCIvKipcbiAqIExpa2UgYFByb21pc2UuYWxsU2V0dGxlZCgpYCBidXQgdGhyb3dzIGFuIGVycm9yIGlmIGFueSBwcm9taXNlcyBhcmUgcmVqZWN0ZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBhbGxTZXR0bGVkV2l0aFRocm93ID0gYXN5bmMgKHByb21pc2VzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChwcm9taXNlcyk7XG4gICAgY29uc3QgcmVqZWN0ZWQgPSByZXN1bHRzLmZpbHRlcigocmVzdWx0KSA9PiByZXN1bHQuc3RhdHVzID09PSAncmVqZWN0ZWQnKTtcbiAgICBpZiAocmVqZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlamVjdGVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlc3VsdC5yZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZWplY3RlZC5sZW5ndGh9IHByb21pc2UocykgZmFpbGVkIC0gc2VlIHRoZSBhYm92ZSBlcnJvcnNgKTtcbiAgICB9XG4gICAgLy8gTm90ZTogVFMgd2FzIGNvbXBsYWluaW5nIGFib3V0IHVzaW5nIGAuZmlsdGVyKCkubWFwKClgIGhlcmUgZm9yIHNvbWUgcmVhc29uXG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VdGlsLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vLi4vcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBzbGVlcCwgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCIuLi8uLi8uLi9jb3JlLm1qc1wiO1xuaW1wb3J0ICogYXMgRmlsZXNBUEkgZnJvbSBcIi4vZmlsZXMubWpzXCI7XG5pbXBvcnQgeyBDdXJzb3JQYWdlIH0gZnJvbSBcIi4uLy4uLy4uL3BhZ2luYXRpb24ubWpzXCI7XG5leHBvcnQgY2xhc3MgRmlsZXMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdmVjdG9yIHN0b3JlIGZpbGUgYnkgYXR0YWNoaW5nIGFcbiAgICAgKiBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcykgdG8gYVxuICAgICAqIFt2ZWN0b3Igc3RvcmVdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdmVjdG9yLXN0b3Jlcy9vYmplY3QpLlxuICAgICAqL1xuICAgIGNyZWF0ZSh2ZWN0b3JTdG9yZUlkLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlc2AsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIHZlY3RvciBzdG9yZSBmaWxlLlxuICAgICAqL1xuICAgIHJldHJpZXZlKHZlY3RvclN0b3JlSWQsIGZpbGVJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlcy8ke2ZpbGVJZH1gLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3QodmVjdG9yU3RvcmVJZCwgcXVlcnkgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3QodmVjdG9yU3RvcmVJZCwge30sIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH0vZmlsZXNgLCBWZWN0b3JTdG9yZUZpbGVzUGFnZSwge1xuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHZlY3RvciBzdG9yZSBmaWxlLiBUaGlzIHdpbGwgcmVtb3ZlIHRoZSBmaWxlIGZyb20gdGhlIHZlY3RvciBzdG9yZSBidXRcbiAgICAgKiB0aGUgZmlsZSBpdHNlbGYgd2lsbCBub3QgYmUgZGVsZXRlZC4gVG8gZGVsZXRlIHRoZSBmaWxlLCB1c2UgdGhlXG4gICAgICogW2RlbGV0ZSBmaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL2RlbGV0ZSlcbiAgICAgKiBlbmRwb2ludC5cbiAgICAgKi9cbiAgICBkZWwodmVjdG9yU3RvcmVJZCwgZmlsZUlkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZGVsZXRlKGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9L2ZpbGVzLyR7ZmlsZUlkfWAsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoIGEgZmlsZSB0byB0aGUgZ2l2ZW4gdmVjdG9yIHN0b3JlIGFuZCB3YWl0IGZvciBpdCB0byBiZSBwcm9jZXNzZWQuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQW5kUG9sbCh2ZWN0b3JTdG9yZUlkLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0aGlzLmNyZWF0ZSh2ZWN0b3JTdG9yZUlkLCBib2R5LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9sbCh2ZWN0b3JTdG9yZUlkLCBmaWxlLmlkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdCBmb3IgdGhlIHZlY3RvciBzdG9yZSBmaWxlIHRvIGZpbmlzaCBwcm9jZXNzaW5nLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyB3aWxsIHJldHVybiBldmVuIGlmIHRoZSBmaWxlIGZhaWxlZCB0byBwcm9jZXNzLCB5b3UgbmVlZCB0byBjaGVja1xuICAgICAqIGZpbGUubGFzdF9lcnJvciBhbmQgZmlsZS5zdGF0dXMgdG8gaGFuZGxlIHRoZXNlIGNhc2VzXG4gICAgICovXG4gICAgYXN5bmMgcG9sbCh2ZWN0b3JTdG9yZUlkLCBmaWxlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHsgLi4ub3B0aW9ucz8uaGVhZGVycywgJ1gtU3RhaW5sZXNzLVBvbGwtSGVscGVyJzogJ3RydWUnIH07XG4gICAgICAgIGlmIChvcHRpb25zPy5wb2xsSW50ZXJ2YWxNcykge1xuICAgICAgICAgICAgaGVhZGVyc1snWC1TdGFpbmxlc3MtQ3VzdG9tLVBvbGwtSW50ZXJ2YWwnXSA9IG9wdGlvbnMucG9sbEludGVydmFsTXMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgZmlsZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXRyaWV2ZSh2ZWN0b3JTdG9yZUlkLCBmaWxlSWQsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICB9KS53aXRoUmVzcG9uc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBmaWxlUmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmlsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpbl9wcm9ncmVzcyc6XG4gICAgICAgICAgICAgICAgICAgIGxldCBzbGVlcEludGVydmFsID0gNTAwMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnM/LnBvbGxJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbGVlcEludGVydmFsID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlckludGVydmFsID0gZmlsZVJlc3BvbnNlLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdvcGVuYWktcG9sbC1hZnRlci1tcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlckludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVySW50ZXJ2YWxNcyA9IHBhcnNlSW50KGhlYWRlckludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGhlYWRlckludGVydmFsTXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsZWVwSW50ZXJ2YWwgPSBoZWFkZXJJbnRlcnZhbE1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcChzbGVlcEludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYSBmaWxlIHRvIHRoZSBgZmlsZXNgIEFQSSBhbmQgdGhlbiBhdHRhY2ggaXQgdG8gdGhlIGdpdmVuIHZlY3RvciBzdG9yZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhlIGZpbGUgd2lsbCBiZSBhc3luY2hyb25vdXNseSBwcm9jZXNzZWQgKHlvdSBjYW4gdXNlIHRoZSBhbHRlcm5hdGl2ZVxuICAgICAqIHBvbGxpbmcgaGVscGVyIG1ldGhvZCB0byB3YWl0IGZvciBwcm9jZXNzaW5nIHRvIGNvbXBsZXRlKS5cbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWQodmVjdG9yU3RvcmVJZCwgZmlsZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBmaWxlSW5mbyA9IGF3YWl0IHRoaXMuX2NsaWVudC5maWxlcy5jcmVhdGUoeyBmaWxlOiBmaWxlLCBwdXJwb3NlOiAnYXNzaXN0YW50cycgfSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh2ZWN0b3JTdG9yZUlkLCB7IGZpbGVfaWQ6IGZpbGVJbmZvLmlkIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBmaWxlIHRvIGEgdmVjdG9yIHN0b3JlIGFuZCBwb2xsIHVudGlsIHByb2Nlc3NpbmcgaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkQW5kUG9sbCh2ZWN0b3JTdG9yZUlkLCBmaWxlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZpbGVJbmZvID0gYXdhaXQgdGhpcy51cGxvYWQodmVjdG9yU3RvcmVJZCwgZmlsZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvbGwodmVjdG9yU3RvcmVJZCwgZmlsZUluZm8uaWQsIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBWZWN0b3JTdG9yZUZpbGVzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2Uge1xufVxuKGZ1bmN0aW9uIChGaWxlcykge1xuICAgIEZpbGVzLlZlY3RvclN0b3JlRmlsZXNQYWdlID0gRmlsZXNBUEkuVmVjdG9yU3RvcmVGaWxlc1BhZ2U7XG59KShGaWxlcyB8fCAoRmlsZXMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsZXMubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi8uLi9yZXNvdXJjZS5tanNcIjtcbmltcG9ydCB7IGlzUmVxdWVzdE9wdGlvbnMgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS5tanNcIjtcbmltcG9ydCB7IHNsZWVwIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUubWpzXCI7XG5pbXBvcnQgeyBhbGxTZXR0bGVkV2l0aFRocm93IH0gZnJvbSBcIi4uLy4uLy4uL2xpYi9VdGlsLm1qc1wiO1xuaW1wb3J0IHsgVmVjdG9yU3RvcmVGaWxlc1BhZ2UgfSBmcm9tIFwiLi9maWxlcy5tanNcIjtcbmV4cG9ydCBjbGFzcyBGaWxlQmF0Y2hlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB2ZWN0b3Igc3RvcmUgZmlsZSBiYXRjaC5cbiAgICAgKi9cbiAgICBjcmVhdGUodmVjdG9yU3RvcmVJZCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH0vZmlsZV9iYXRjaGVzYCwge1xuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgdmVjdG9yIHN0b3JlIGZpbGUgYmF0Y2guXG4gICAgICovXG4gICAgcmV0cmlldmUodmVjdG9yU3RvcmVJZCwgYmF0Y2hJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlX2JhdGNoZXMvJHtiYXRjaElkfWAsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VsIGEgdmVjdG9yIHN0b3JlIGZpbGUgYmF0Y2guIFRoaXMgYXR0ZW1wdHMgdG8gY2FuY2VsIHRoZSBwcm9jZXNzaW5nIG9mXG4gICAgICogZmlsZXMgaW4gdGhpcyBiYXRjaCBhcyBzb29uIGFzIHBvc3NpYmxlLlxuICAgICAqL1xuICAgIGNhbmNlbCh2ZWN0b3JTdG9yZUlkLCBiYXRjaElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfS9maWxlX2JhdGNoZXMvJHtiYXRjaElkfS9jYW5jZWxgLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHZlY3RvciBzdG9yZSBiYXRjaCBhbmQgcG9sbCB1bnRpbCBhbGwgZmlsZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZC5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVBbmRQb2xsKHZlY3RvclN0b3JlSWQsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYmF0Y2ggPSBhd2FpdCB0aGlzLmNyZWF0ZSh2ZWN0b3JTdG9yZUlkLCBib2R5KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9sbCh2ZWN0b3JTdG9yZUlkLCBiYXRjaC5pZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGxpc3RGaWxlcyh2ZWN0b3JTdG9yZUlkLCBiYXRjaElkLCBxdWVyeSA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdEZpbGVzKHZlY3RvclN0b3JlSWQsIGJhdGNoSWQsIHt9LCBxdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KGAvdmVjdG9yX3N0b3Jlcy8ke3ZlY3RvclN0b3JlSWR9L2ZpbGVfYmF0Y2hlcy8ke2JhdGNoSWR9L2ZpbGVzYCwgVmVjdG9yU3RvcmVGaWxlc1BhZ2UsIHsgcXVlcnksIC4uLm9wdGlvbnMsIGhlYWRlcnM6IHsgJ09wZW5BSS1CZXRhJzogJ2Fzc2lzdGFudHM9djInLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXQgZm9yIHRoZSBnaXZlbiBmaWxlIGJhdGNoIHRvIGJlIHByb2Nlc3NlZC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgd2lsbCByZXR1cm4gZXZlbiBpZiBvbmUgb2YgdGhlIGZpbGVzIGZhaWxlZCB0byBwcm9jZXNzLCB5b3UgbmVlZCB0b1xuICAgICAqIGNoZWNrIGJhdGNoLmZpbGVfY291bnRzLmZhaWxlZF9jb3VudCB0byBoYW5kbGUgdGhpcyBjYXNlLlxuICAgICAqL1xuICAgIGFzeW5jIHBvbGwodmVjdG9yU3RvcmVJZCwgYmF0Y2hJZCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0geyAuLi5vcHRpb25zPy5oZWFkZXJzLCAnWC1TdGFpbmxlc3MtUG9sbC1IZWxwZXInOiAndHJ1ZScgfTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LnBvbGxJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydYLVN0YWlubGVzcy1DdXN0b20tUG9sbC1JbnRlcnZhbCddID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNcy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGJhdGNoLCByZXNwb25zZSB9ID0gYXdhaXQgdGhpcy5yZXRyaWV2ZSh2ZWN0b3JTdG9yZUlkLCBiYXRjaElkLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgfSkud2l0aFJlc3BvbnNlKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGJhdGNoLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2luX3Byb2dyZXNzJzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNsZWVwSW50ZXJ2YWwgPSA1MDAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucz8ucG9sbEludGVydmFsTXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsZWVwSW50ZXJ2YWwgPSBvcHRpb25zLnBvbGxJbnRlcnZhbE1zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVySW50ZXJ2YWwgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnb3BlbmFpLXBvbGwtYWZ0ZXItbXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZWFkZXJJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlckludGVydmFsTXMgPSBwYXJzZUludChoZWFkZXJJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihoZWFkZXJJbnRlcnZhbE1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGVlcEludGVydmFsID0gaGVhZGVySW50ZXJ2YWxNcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAoc2xlZXBJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY2FuY2VsbGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyB0aGUgZ2l2ZW4gZmlsZXMgY29uY3VycmVudGx5IGFuZCB0aGVuIGNyZWF0ZXMgYSB2ZWN0b3Igc3RvcmUgZmlsZSBiYXRjaC5cbiAgICAgKlxuICAgICAqIFRoZSBjb25jdXJyZW5jeSBsaW1pdCBpcyBjb25maWd1cmFibGUgdXNpbmcgdGhlIGBtYXhDb25jdXJyZW5jeWAgcGFyYW1ldGVyLlxuICAgICAqL1xuICAgIGFzeW5jIHVwbG9hZEFuZFBvbGwodmVjdG9yU3RvcmVJZCwgeyBmaWxlcywgZmlsZUlkcyA9IFtdIH0sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGZpbGVzID09IG51bGwgfHwgZmlsZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gXFxgZmlsZXNcXGAgcHJvdmlkZWQgdG8gcHJvY2Vzcy4gSWYgeW91J3ZlIGFscmVhZHkgdXBsb2FkZWQgZmlsZXMgeW91IHNob3VsZCB1c2UgXFxgLmNyZWF0ZUFuZFBvbGwoKVxcYCBpbnN0ZWFkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlndXJlZENvbmN1cnJlbmN5ID0gb3B0aW9ucz8ubWF4Q29uY3VycmVuY3kgPz8gNTtcbiAgICAgICAgLy8gV2UgY2FwIHRoZSBudW1iZXIgb2Ygd29ya2VycyBhdCB0aGUgbnVtYmVyIG9mIGZpbGVzIChzbyB3ZSBkb24ndCBzdGFydCBhbnkgdW5uZWNlc3Nhcnkgd29ya2VycylcbiAgICAgICAgY29uc3QgY29uY3VycmVuY3lMaW1pdCA9IE1hdGgubWluKGNvbmZpZ3VyZWRDb25jdXJyZW5jeSwgZmlsZXMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5fY2xpZW50O1xuICAgICAgICBjb25zdCBmaWxlSXRlcmF0b3IgPSBmaWxlcy52YWx1ZXMoKTtcbiAgICAgICAgY29uc3QgYWxsRmlsZUlkcyA9IFsuLi5maWxlSWRzXTtcbiAgICAgICAgLy8gVGhpcyBjb2RlIGlzIGJhc2VkIG9uIHRoaXMgZGVzaWduLiBUaGUgbGlicmFyaWVzIGRvbid0IGFjY29tbW9kYXRlIG91ciBlbnZpcm9ubWVudCBsaW1pdHMuXG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQwNjM5NDMyL3doYXQtaXMtdGhlLWJlc3Qtd2F5LXRvLWxpbWl0LWNvbmN1cnJlbmN5LXdoZW4tdXNpbmctZXM2cy1wcm9taXNlLWFsbFxuICAgICAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzRmlsZXMoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgaXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlT2JqID0gYXdhaXQgY2xpZW50LmZpbGVzLmNyZWF0ZSh7IGZpbGU6IGl0ZW0sIHB1cnBvc2U6ICdhc3Npc3RhbnRzJyB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBhbGxGaWxlSWRzLnB1c2goZmlsZU9iai5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQgd29ya2VycyB0byBwcm9jZXNzIHJlc3VsdHNcbiAgICAgICAgY29uc3Qgd29ya2VycyA9IEFycmF5KGNvbmN1cnJlbmN5TGltaXQpLmZpbGwoZmlsZUl0ZXJhdG9yKS5tYXAocHJvY2Vzc0ZpbGVzKTtcbiAgICAgICAgLy8gV2FpdCBmb3IgYWxsIHByb2Nlc3NpbmcgdG8gY29tcGxldGUuXG4gICAgICAgIGF3YWl0IGFsbFNldHRsZWRXaXRoVGhyb3cod29ya2Vycyk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZUFuZFBvbGwodmVjdG9yU3RvcmVJZCwge1xuICAgICAgICAgICAgZmlsZV9pZHM6IGFsbEZpbGVJZHMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbihmdW5jdGlvbiAoRmlsZUJhdGNoZXMpIHtcbn0pKEZpbGVCYXRjaGVzIHx8IChGaWxlQmF0Y2hlcyA9IHt9KSk7XG5leHBvcnQgeyBWZWN0b3JTdG9yZUZpbGVzUGFnZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsZS1iYXRjaGVzLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vLi4vcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUubWpzXCI7XG5pbXBvcnQgKiBhcyBWZWN0b3JTdG9yZXNBUEkgZnJvbSBcIi4vdmVjdG9yLXN0b3Jlcy5tanNcIjtcbmltcG9ydCAqIGFzIEZpbGVCYXRjaGVzQVBJIGZyb20gXCIuL2ZpbGUtYmF0Y2hlcy5tanNcIjtcbmltcG9ydCAqIGFzIEZpbGVzQVBJIGZyb20gXCIuL2ZpbGVzLm1qc1wiO1xuaW1wb3J0IHsgQ3Vyc29yUGFnZSB9IGZyb20gXCIuLi8uLi8uLi9wYWdpbmF0aW9uLm1qc1wiO1xuZXhwb3J0IGNsYXNzIFZlY3RvclN0b3JlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5maWxlcyA9IG5ldyBGaWxlc0FQSS5GaWxlcyh0aGlzLl9jbGllbnQpO1xuICAgICAgICB0aGlzLmZpbGVCYXRjaGVzID0gbmV3IEZpbGVCYXRjaGVzQVBJLkZpbGVCYXRjaGVzKHRoaXMuX2NsaWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHZlY3RvciBzdG9yZS5cbiAgICAgKi9cbiAgICBjcmVhdGUoYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy92ZWN0b3Jfc3RvcmVzJywge1xuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgdmVjdG9yIHN0b3JlLlxuICAgICAqL1xuICAgIHJldHJpZXZlKHZlY3RvclN0b3JlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC92ZWN0b3Jfc3RvcmVzLyR7dmVjdG9yU3RvcmVJZH1gLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIGEgdmVjdG9yIHN0b3JlLlxuICAgICAqL1xuICAgIHVwZGF0ZSh2ZWN0b3JTdG9yZUlkLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfWAsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3QocXVlcnkgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoaXNSZXF1ZXN0T3B0aW9ucyhxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3Qoe30sIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoJy92ZWN0b3Jfc3RvcmVzJywgVmVjdG9yU3RvcmVzUGFnZSwge1xuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnT3BlbkFJLUJldGEnOiAnYXNzaXN0YW50cz12MicsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHZlY3RvciBzdG9yZS5cbiAgICAgKi9cbiAgICBkZWwodmVjdG9yU3RvcmVJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL3ZlY3Rvcl9zdG9yZXMvJHt2ZWN0b3JTdG9yZUlkfWAsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdPcGVuQUktQmV0YSc6ICdhc3Npc3RhbnRzPXYyJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVmVjdG9yU3RvcmVzUGFnZSBleHRlbmRzIEN1cnNvclBhZ2Uge1xufVxuKGZ1bmN0aW9uIChWZWN0b3JTdG9yZXMpIHtcbiAgICBWZWN0b3JTdG9yZXMuVmVjdG9yU3RvcmVzUGFnZSA9IFZlY3RvclN0b3Jlc0FQSS5WZWN0b3JTdG9yZXNQYWdlO1xuICAgIFZlY3RvclN0b3Jlcy5GaWxlcyA9IEZpbGVzQVBJLkZpbGVzO1xuICAgIFZlY3RvclN0b3Jlcy5WZWN0b3JTdG9yZUZpbGVzUGFnZSA9IEZpbGVzQVBJLlZlY3RvclN0b3JlRmlsZXNQYWdlO1xuICAgIFZlY3RvclN0b3Jlcy5GaWxlQmF0Y2hlcyA9IEZpbGVCYXRjaGVzQVBJLkZpbGVCYXRjaGVzO1xufSkoVmVjdG9yU3RvcmVzIHx8IChWZWN0b3JTdG9yZXMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVjdG9yLXN0b3Jlcy5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0ICogYXMgQXNzaXN0YW50c0FQSSBmcm9tIFwiLi9hc3Npc3RhbnRzLm1qc1wiO1xuaW1wb3J0ICogYXMgQ2hhdEFQSSBmcm9tIFwiLi9jaGF0L2NoYXQubWpzXCI7XG5pbXBvcnQgKiBhcyBUaHJlYWRzQVBJIGZyb20gXCIuL3RocmVhZHMvdGhyZWFkcy5tanNcIjtcbmltcG9ydCAqIGFzIFZlY3RvclN0b3Jlc0FQSSBmcm9tIFwiLi92ZWN0b3Itc3RvcmVzL3ZlY3Rvci1zdG9yZXMubWpzXCI7XG5leHBvcnQgY2xhc3MgQmV0YSBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52ZWN0b3JTdG9yZXMgPSBuZXcgVmVjdG9yU3RvcmVzQVBJLlZlY3RvclN0b3Jlcyh0aGlzLl9jbGllbnQpO1xuICAgICAgICB0aGlzLmNoYXQgPSBuZXcgQ2hhdEFQSS5DaGF0KHRoaXMuX2NsaWVudCk7XG4gICAgICAgIHRoaXMuYXNzaXN0YW50cyA9IG5ldyBBc3Npc3RhbnRzQVBJLkFzc2lzdGFudHModGhpcy5fY2xpZW50KTtcbiAgICAgICAgdGhpcy50aHJlYWRzID0gbmV3IFRocmVhZHNBUEkuVGhyZWFkcyh0aGlzLl9jbGllbnQpO1xuICAgIH1cbn1cbihmdW5jdGlvbiAoQmV0YSkge1xuICAgIEJldGEuVmVjdG9yU3RvcmVzID0gVmVjdG9yU3RvcmVzQVBJLlZlY3RvclN0b3JlcztcbiAgICBCZXRhLlZlY3RvclN0b3Jlc1BhZ2UgPSBWZWN0b3JTdG9yZXNBUEkuVmVjdG9yU3RvcmVzUGFnZTtcbiAgICBCZXRhLkNoYXQgPSBDaGF0QVBJLkNoYXQ7XG4gICAgQmV0YS5Bc3Npc3RhbnRzID0gQXNzaXN0YW50c0FQSS5Bc3Npc3RhbnRzO1xuICAgIEJldGEuQXNzaXN0YW50c1BhZ2UgPSBBc3Npc3RhbnRzQVBJLkFzc2lzdGFudHNQYWdlO1xuICAgIEJldGEuVGhyZWFkcyA9IFRocmVhZHNBUEkuVGhyZWFkcztcbn0pKEJldGEgfHwgKEJldGEgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmV0YS5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uL3Jlc291cmNlLm1qc1wiO1xuZXhwb3J0IGNsYXNzIENvbXBsZXRpb25zIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIGNyZWF0ZShib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2NvbXBsZXRpb25zJywgeyBib2R5LCAuLi5vcHRpb25zLCBzdHJlYW06IGJvZHkuc3RyZWFtID8/IGZhbHNlIH0pO1xuICAgIH1cbn1cbihmdW5jdGlvbiAoQ29tcGxldGlvbnMpIHtcbn0pKENvbXBsZXRpb25zIHx8IChDb21wbGV0aW9ucyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wbGV0aW9ucy5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uL3Jlc291cmNlLm1qc1wiO1xuZXhwb3J0IGNsYXNzIEVtYmVkZGluZ3MgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlbWJlZGRpbmcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgaW5wdXQgdGV4dC5cbiAgICAgKi9cbiAgICBjcmVhdGUoYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9lbWJlZGRpbmdzJywgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICAgIH1cbn1cbihmdW5jdGlvbiAoRW1iZWRkaW5ncykge1xufSkoRW1iZWRkaW5ncyB8fCAoRW1iZWRkaW5ncyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbWJlZGRpbmdzLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBpc1JlcXVlc3RPcHRpb25zIH0gZnJvbSBcIi4uL2NvcmUubWpzXCI7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gXCIuLi9jb3JlLm1qc1wiO1xuaW1wb3J0IHsgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvciB9IGZyb20gXCIuLi9lcnJvci5tanNcIjtcbmltcG9ydCAqIGFzIENvcmUgZnJvbSBcIi4uL2NvcmUubWpzXCI7XG5pbXBvcnQgKiBhcyBGaWxlc0FQSSBmcm9tIFwiLi9maWxlcy5tanNcIjtcbmltcG9ydCB7IFBhZ2UgfSBmcm9tIFwiLi4vcGFnaW5hdGlvbi5tanNcIjtcbmV4cG9ydCBjbGFzcyBGaWxlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYSBmaWxlIHRoYXQgY2FuIGJlIHVzZWQgYWNyb3NzIHZhcmlvdXMgZW5kcG9pbnRzLiBJbmRpdmlkdWFsIGZpbGVzIGNhbiBiZVxuICAgICAqIHVwIHRvIDUxMiBNQiwgYW5kIHRoZSBzaXplIG9mIGFsbCBmaWxlcyB1cGxvYWRlZCBieSBvbmUgb3JnYW5pemF0aW9uIGNhbiBiZSB1cFxuICAgICAqIHRvIDEwMCBHQi5cbiAgICAgKlxuICAgICAqIFRoZSBBc3Npc3RhbnRzIEFQSSBzdXBwb3J0cyBmaWxlcyB1cCB0byAyIG1pbGxpb24gdG9rZW5zIGFuZCBvZiBzcGVjaWZpYyBmaWxlXG4gICAgICogdHlwZXMuIFNlZSB0aGVcbiAgICAgKiBbQXNzaXN0YW50cyBUb29scyBndWlkZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXNzaXN0YW50cy90b29scykgZm9yXG4gICAgICogZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoZSBGaW5lLXR1bmluZyBBUEkgb25seSBzdXBwb3J0cyBgLmpzb25sYCBmaWxlcy4gVGhlIGlucHV0IGFsc28gaGFzIGNlcnRhaW5cbiAgICAgKiByZXF1aXJlZCBmb3JtYXRzIGZvciBmaW5lLXR1bmluZ1xuICAgICAqIFtjaGF0XShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbmUtdHVuaW5nL2NoYXQtaW5wdXQpIG9yXG4gICAgICogW2NvbXBsZXRpb25zXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbmUtdHVuaW5nL2NvbXBsZXRpb25zLWlucHV0KVxuICAgICAqIG1vZGVscy5cbiAgICAgKlxuICAgICAqIFRoZSBCYXRjaCBBUEkgb25seSBzdXBwb3J0cyBgLmpzb25sYCBmaWxlcyB1cCB0byAxMDAgTUIgaW4gc2l6ZS4gVGhlIGlucHV0IGFsc29cbiAgICAgKiBoYXMgYSBzcGVjaWZpYyByZXF1aXJlZFxuICAgICAqIFtmb3JtYXRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvYmF0Y2gvcmVxdWVzdC1pbnB1dCkuXG4gICAgICpcbiAgICAgKiBQbGVhc2UgW2NvbnRhY3QgdXNdKGh0dHBzOi8vaGVscC5vcGVuYWkuY29tLykgaWYgeW91IG5lZWQgdG8gaW5jcmVhc2UgdGhlc2VcbiAgICAgKiBzdG9yYWdlIGxpbWl0cy5cbiAgICAgKi9cbiAgICBjcmVhdGUoYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9maWxlcycsIENvcmUubXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zKHsgYm9keSwgLi4ub3B0aW9ucyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgYSBzcGVjaWZpYyBmaWxlLlxuICAgICAqL1xuICAgIHJldHJpZXZlKGZpbGVJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL2ZpbGVzLyR7ZmlsZUlkfWAsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBsaXN0KHF1ZXJ5ID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0KHt9LCBxdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KCcvZmlsZXMnLCBGaWxlT2JqZWN0c1BhZ2UsIHsgcXVlcnksIC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIGZpbGUuXG4gICAgICovXG4gICAgZGVsKGZpbGVJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShgL2ZpbGVzLyR7ZmlsZUlkfWAsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiB0aGUgc3BlY2lmaWVkIGZpbGUuXG4gICAgICovXG4gICAgY29udGVudChmaWxlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC9maWxlcy8ke2ZpbGVJZH0vY29udGVudGAsIHsgLi4ub3B0aW9ucywgX19iaW5hcnlSZXNwb25zZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlIHNwZWNpZmllZCBmaWxlLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhlIGAuY29udGVudCgpYCBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZFxuICAgICAqL1xuICAgIHJldHJpZXZlQ29udGVudChmaWxlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoYC9maWxlcy8ke2ZpbGVJZH0vY29udGVudGAsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgdGhlIGdpdmVuIGZpbGUgdG8gYmUgcHJvY2Vzc2VkLCBkZWZhdWx0IHRpbWVvdXQgaXMgMzAgbWlucy5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yUHJvY2Vzc2luZyhpZCwgeyBwb2xsSW50ZXJ2YWwgPSA1MDAwLCBtYXhXYWl0ID0gMzAgKiA2MCAqIDEwMDAgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IFRFUk1JTkFMX1NUQVRFUyA9IG5ldyBTZXQoWydwcm9jZXNzZWQnLCAnZXJyb3InLCAnZGVsZXRlZCddKTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICBsZXQgZmlsZSA9IGF3YWl0IHRoaXMucmV0cmlldmUoaWQpO1xuICAgICAgICB3aGlsZSAoIWZpbGUuc3RhdHVzIHx8ICFURVJNSU5BTF9TVEFURVMuaGFzKGZpbGUuc3RhdHVzKSkge1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAocG9sbEludGVydmFsKTtcbiAgICAgICAgICAgIGZpbGUgPSBhd2FpdCB0aGlzLnJldHJpZXZlKGlkKTtcbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnQgPiBtYXhXYWl0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgR2l2aW5nIHVwIG9uIHdhaXRpbmcgZm9yIGZpbGUgJHtpZH0gdG8gZmluaXNoIHByb2Nlc3NpbmcgYWZ0ZXIgJHttYXhXYWl0fSBtaWxsaXNlY29uZHMuYCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICB9XG59XG4vKipcbiAqIE5vdGU6IG5vIHBhZ2luYXRpb24gYWN0dWFsbHkgb2NjdXJzIHlldCwgdGhpcyBpcyBmb3IgZm9yd2FyZHMtY29tcGF0aWJpbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVPYmplY3RzUGFnZSBleHRlbmRzIFBhZ2Uge1xufVxuKGZ1bmN0aW9uIChGaWxlcykge1xuICAgIEZpbGVzLkZpbGVPYmplY3RzUGFnZSA9IEZpbGVzQVBJLkZpbGVPYmplY3RzUGFnZTtcbn0pKEZpbGVzIHx8IChGaWxlcyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWxlcy5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uLy4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCIuLi8uLi8uLi9jb3JlLm1qc1wiO1xuaW1wb3J0ICogYXMgQ2hlY2twb2ludHNBUEkgZnJvbSBcIi4vY2hlY2twb2ludHMubWpzXCI7XG5pbXBvcnQgeyBDdXJzb3JQYWdlIH0gZnJvbSBcIi4uLy4uLy4uL3BhZ2luYXRpb24ubWpzXCI7XG5leHBvcnQgY2xhc3MgQ2hlY2twb2ludHMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgbGlzdChmaW5lVHVuaW5nSm9iSWQsIHF1ZXJ5ID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0KGZpbmVUdW5pbmdKb2JJZCwge30sIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoYC9maW5lX3R1bmluZy9qb2JzLyR7ZmluZVR1bmluZ0pvYklkfS9jaGVja3BvaW50c2AsIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UsIHsgcXVlcnksIC4uLm9wdGlvbnMgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlIHtcbn1cbihmdW5jdGlvbiAoQ2hlY2twb2ludHMpIHtcbiAgICBDaGVja3BvaW50cy5GaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlID0gQ2hlY2twb2ludHNBUEkuRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZTtcbn0pKENoZWNrcG9pbnRzIHx8IChDaGVja3BvaW50cyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3BvaW50cy5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uLy4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgaXNSZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCIuLi8uLi8uLi9jb3JlLm1qc1wiO1xuaW1wb3J0ICogYXMgSm9ic0FQSSBmcm9tIFwiLi9qb2JzLm1qc1wiO1xuaW1wb3J0ICogYXMgQ2hlY2twb2ludHNBUEkgZnJvbSBcIi4vY2hlY2twb2ludHMubWpzXCI7XG5pbXBvcnQgeyBDdXJzb3JQYWdlIH0gZnJvbSBcIi4uLy4uLy4uL3BhZ2luYXRpb24ubWpzXCI7XG5leHBvcnQgY2xhc3MgSm9icyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jaGVja3BvaW50cyA9IG5ldyBDaGVja3BvaW50c0FQSS5DaGVja3BvaW50cyh0aGlzLl9jbGllbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmluZS10dW5pbmcgam9iIHdoaWNoIGJlZ2lucyB0aGUgcHJvY2VzcyBvZiBjcmVhdGluZyBhIG5ldyBtb2RlbCBmcm9tXG4gICAgICogYSBnaXZlbiBkYXRhc2V0LlxuICAgICAqXG4gICAgICogUmVzcG9uc2UgaW5jbHVkZXMgZGV0YWlscyBvZiB0aGUgZW5xdWV1ZWQgam9iIGluY2x1ZGluZyBqb2Igc3RhdHVzIGFuZCB0aGUgbmFtZVxuICAgICAqIG9mIHRoZSBmaW5lLXR1bmVkIG1vZGVscyBvbmNlIGNvbXBsZXRlLlxuICAgICAqXG4gICAgICogW0xlYXJuIG1vcmUgYWJvdXQgZmluZS10dW5pbmddKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2d1aWRlcy9maW5lLXR1bmluZylcbiAgICAgKi9cbiAgICBjcmVhdGUoYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9maW5lX3R1bmluZy9qb2JzJywgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgaW5mbyBhYm91dCBhIGZpbmUtdHVuaW5nIGpvYi5cbiAgICAgKlxuICAgICAqIFtMZWFybiBtb3JlIGFib3V0IGZpbmUtdHVuaW5nXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9ndWlkZXMvZmluZS10dW5pbmcpXG4gICAgICovXG4gICAgcmV0cmlldmUoZmluZVR1bmluZ0pvYklkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvZmluZV90dW5pbmcvam9icy8ke2ZpbmVUdW5pbmdKb2JJZH1gLCBvcHRpb25zKTtcbiAgICB9XG4gICAgbGlzdChxdWVyeSA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChpc1JlcXVlc3RPcHRpb25zKHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdCh7fSwgcXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdCgnL2ZpbmVfdHVuaW5nL2pvYnMnLCBGaW5lVHVuaW5nSm9ic1BhZ2UsIHsgcXVlcnksIC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IGNhbmNlbCBhIGZpbmUtdHVuZSBqb2IuXG4gICAgICovXG4gICAgY2FuY2VsKGZpbmVUdW5pbmdKb2JJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoYC9maW5lX3R1bmluZy9qb2JzLyR7ZmluZVR1bmluZ0pvYklkfS9jYW5jZWxgLCBvcHRpb25zKTtcbiAgICB9XG4gICAgbGlzdEV2ZW50cyhmaW5lVHVuaW5nSm9iSWQsIHF1ZXJ5ID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzUmVxdWVzdE9wdGlvbnMocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0RXZlbnRzKGZpbmVUdW5pbmdKb2JJZCwge30sIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoYC9maW5lX3R1bmluZy9qb2JzLyR7ZmluZVR1bmluZ0pvYklkfS9ldmVudHNgLCBGaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSwge1xuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRmluZVR1bmluZ0pvYnNQYWdlIGV4dGVuZHMgQ3Vyc29yUGFnZSB7XG59XG5leHBvcnQgY2xhc3MgRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2UgZXh0ZW5kcyBDdXJzb3JQYWdlIHtcbn1cbihmdW5jdGlvbiAoSm9icykge1xuICAgIEpvYnMuRmluZVR1bmluZ0pvYnNQYWdlID0gSm9ic0FQSS5GaW5lVHVuaW5nSm9ic1BhZ2U7XG4gICAgSm9icy5GaW5lVHVuaW5nSm9iRXZlbnRzUGFnZSA9IEpvYnNBUEkuRmluZVR1bmluZ0pvYkV2ZW50c1BhZ2U7XG4gICAgSm9icy5DaGVja3BvaW50cyA9IENoZWNrcG9pbnRzQVBJLkNoZWNrcG9pbnRzO1xuICAgIEpvYnMuRmluZVR1bmluZ0pvYkNoZWNrcG9pbnRzUGFnZSA9IENoZWNrcG9pbnRzQVBJLkZpbmVUdW5pbmdKb2JDaGVja3BvaW50c1BhZ2U7XG59KShKb2JzIHx8IChKb2JzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpvYnMubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi9yZXNvdXJjZS5tanNcIjtcbmltcG9ydCAqIGFzIEpvYnNBUEkgZnJvbSBcIi4vam9icy9qb2JzLm1qc1wiO1xuZXhwb3J0IGNsYXNzIEZpbmVUdW5pbmcgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuam9icyA9IG5ldyBKb2JzQVBJLkpvYnModGhpcy5fY2xpZW50KTtcbiAgICB9XG59XG4oZnVuY3Rpb24gKEZpbmVUdW5pbmcpIHtcbiAgICBGaW5lVHVuaW5nLkpvYnMgPSBKb2JzQVBJLkpvYnM7XG4gICAgRmluZVR1bmluZy5GaW5lVHVuaW5nSm9ic1BhZ2UgPSBKb2JzQVBJLkZpbmVUdW5pbmdKb2JzUGFnZTtcbiAgICBGaW5lVHVuaW5nLkZpbmVUdW5pbmdKb2JFdmVudHNQYWdlID0gSm9ic0FQSS5GaW5lVHVuaW5nSm9iRXZlbnRzUGFnZTtcbn0pKEZpbmVUdW5pbmcgfHwgKEZpbmVUdW5pbmcgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZS10dW5pbmcubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi9yZXNvdXJjZS5tanNcIjtcbmltcG9ydCAqIGFzIENvcmUgZnJvbSBcIi4uL2NvcmUubWpzXCI7XG5leHBvcnQgY2xhc3MgSW1hZ2VzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB2YXJpYXRpb24gb2YgYSBnaXZlbiBpbWFnZS5cbiAgICAgKi9cbiAgICBjcmVhdGVWYXJpYXRpb24oYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9pbWFnZXMvdmFyaWF0aW9ucycsIENvcmUubXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zKHsgYm9keSwgLi4ub3B0aW9ucyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZWRpdGVkIG9yIGV4dGVuZGVkIGltYWdlIGdpdmVuIGFuIG9yaWdpbmFsIGltYWdlIGFuZCBhIHByb21wdC5cbiAgICAgKi9cbiAgICBlZGl0KGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvaW1hZ2VzL2VkaXRzJywgQ29yZS5tdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbWFnZSBnaXZlbiBhIHByb21wdC5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZShib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL2ltYWdlcy9nZW5lcmF0aW9ucycsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgICB9XG59XG4oZnVuY3Rpb24gKEltYWdlcykge1xufSkoSW1hZ2VzIHx8IChJbWFnZXMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2VzLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgKiBhcyBNb2RlbHNBUEkgZnJvbSBcIi4vbW9kZWxzLm1qc1wiO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gXCIuLi9wYWdpbmF0aW9uLm1qc1wiO1xuZXhwb3J0IGNsYXNzIE1vZGVscyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBtb2RlbCBpbnN0YW5jZSwgcHJvdmlkaW5nIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IHRoZSBtb2RlbCBzdWNoIGFzXG4gICAgICogdGhlIG93bmVyIGFuZCBwZXJtaXNzaW9uaW5nLlxuICAgICAqL1xuICAgIHJldHJpZXZlKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KGAvbW9kZWxzLyR7bW9kZWx9YCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIHRoZSBjdXJyZW50bHkgYXZhaWxhYmxlIG1vZGVscywgYW5kIHByb3ZpZGVzIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IGVhY2hcbiAgICAgKiBvbmUgc3VjaCBhcyB0aGUgb3duZXIgYW5kIGF2YWlsYWJpbGl0eS5cbiAgICAgKi9cbiAgICBsaXN0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KCcvbW9kZWxzJywgTW9kZWxzUGFnZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIGZpbmUtdHVuZWQgbW9kZWwuIFlvdSBtdXN0IGhhdmUgdGhlIE93bmVyIHJvbGUgaW4geW91ciBvcmdhbml6YXRpb24gdG9cbiAgICAgKiBkZWxldGUgYSBtb2RlbC5cbiAgICAgKi9cbiAgICBkZWwobW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5kZWxldGUoYC9tb2RlbHMvJHttb2RlbH1gLCBvcHRpb25zKTtcbiAgICB9XG59XG4vKipcbiAqIE5vdGU6IG5vIHBhZ2luYXRpb24gYWN0dWFsbHkgb2NjdXJzIHlldCwgdGhpcyBpcyBmb3IgZm9yd2FyZHMtY29tcGF0aWJpbGl0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIE1vZGVsc1BhZ2UgZXh0ZW5kcyBQYWdlIHtcbn1cbihmdW5jdGlvbiAoTW9kZWxzKSB7XG4gICAgTW9kZWxzLk1vZGVsc1BhZ2UgPSBNb2RlbHNBUEkuTW9kZWxzUGFnZTtcbn0pKE1vZGVscyB8fCAoTW9kZWxzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVscy5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uL3Jlc291cmNlLm1qc1wiO1xuZXhwb3J0IGNsYXNzIE1vZGVyYXRpb25zIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIC8qKlxuICAgICAqIENsYXNzaWZpZXMgaWYgdGV4dCBpcyBwb3RlbnRpYWxseSBoYXJtZnVsLlxuICAgICAqL1xuICAgIGNyZWF0ZShib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL21vZGVyYXRpb25zJywgeyBib2R5LCAuLi5vcHRpb25zIH0pO1xuICAgIH1cbn1cbihmdW5jdGlvbiAoTW9kZXJhdGlvbnMpIHtcbn0pKE1vZGVyYXRpb25zIHx8IChNb2RlcmF0aW9ucyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlcmF0aW9ucy5tanMubWFwIiwiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0ICogYXMgQ29yZSBmcm9tIFwiLi4vLi4vY29yZS5tanNcIjtcbmV4cG9ydCBjbGFzcyBQYXJ0cyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICAvKipcbiAgICAgKiBBZGRzIGFcbiAgICAgKiBbUGFydF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS91cGxvYWRzL3BhcnQtb2JqZWN0KSB0byBhblxuICAgICAqIFtVcGxvYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdXBsb2Fkcy9vYmplY3QpIG9iamVjdC5cbiAgICAgKiBBIFBhcnQgcmVwcmVzZW50cyBhIGNodW5rIG9mIGJ5dGVzIGZyb20gdGhlIGZpbGUgeW91IGFyZSB0cnlpbmcgdG8gdXBsb2FkLlxuICAgICAqXG4gICAgICogRWFjaCBQYXJ0IGNhbiBiZSBhdCBtb3N0IDY0IE1CLCBhbmQgeW91IGNhbiBhZGQgUGFydHMgdW50aWwgeW91IGhpdCB0aGUgVXBsb2FkXG4gICAgICogbWF4aW11bSBvZiA4IEdCLlxuICAgICAqXG4gICAgICogSXQgaXMgcG9zc2libGUgdG8gYWRkIG11bHRpcGxlIFBhcnRzIGluIHBhcmFsbGVsLiBZb3UgY2FuIGRlY2lkZSB0aGUgaW50ZW5kZWRcbiAgICAgKiBvcmRlciBvZiB0aGUgUGFydHMgd2hlbiB5b3VcbiAgICAgKiBbY29tcGxldGUgdGhlIFVwbG9hZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS91cGxvYWRzL2NvbXBsZXRlKS5cbiAgICAgKi9cbiAgICBjcmVhdGUodXBsb2FkSWQsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdXBsb2Fkcy8ke3VwbG9hZElkfS9wYXJ0c2AsIENvcmUubXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zKHsgYm9keSwgLi4ub3B0aW9ucyB9KSk7XG4gICAgfVxufVxuKGZ1bmN0aW9uIChQYXJ0cykge1xufSkoUGFydHMgfHwgKFBhcnRzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnRzLm1qcy5tYXAiLCIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgKiBhcyBQYXJ0c0FQSSBmcm9tIFwiLi9wYXJ0cy5tanNcIjtcbmV4cG9ydCBjbGFzcyBVcGxvYWRzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnBhcnRzID0gbmV3IFBhcnRzQVBJLlBhcnRzKHRoaXMuX2NsaWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW50ZXJtZWRpYXRlXG4gICAgICogW1VwbG9hZF0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS91cGxvYWRzL29iamVjdCkgb2JqZWN0XG4gICAgICogdGhhdCB5b3UgY2FuIGFkZFxuICAgICAqIFtQYXJ0c10oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS91cGxvYWRzL3BhcnQtb2JqZWN0KSB0by5cbiAgICAgKiBDdXJyZW50bHksIGFuIFVwbG9hZCBjYW4gYWNjZXB0IGF0IG1vc3QgOCBHQiBpbiB0b3RhbCBhbmQgZXhwaXJlcyBhZnRlciBhbiBob3VyXG4gICAgICogYWZ0ZXIgeW91IGNyZWF0ZSBpdC5cbiAgICAgKlxuICAgICAqIE9uY2UgeW91IGNvbXBsZXRlIHRoZSBVcGxvYWQsIHdlIHdpbGwgY3JlYXRlIGFcbiAgICAgKiBbRmlsZV0oaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS9maWxlcy9vYmplY3QpIG9iamVjdCB0aGF0XG4gICAgICogY29udGFpbnMgYWxsIHRoZSBwYXJ0cyB5b3UgdXBsb2FkZWQuIFRoaXMgRmlsZSBpcyB1c2FibGUgaW4gdGhlIHJlc3Qgb2Ygb3VyXG4gICAgICogcGxhdGZvcm0gYXMgYSByZWd1bGFyIEZpbGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogRm9yIGNlcnRhaW4gYHB1cnBvc2VgcywgdGhlIGNvcnJlY3QgYG1pbWVfdHlwZWAgbXVzdCBiZSBzcGVjaWZpZWQuIFBsZWFzZSByZWZlclxuICAgICAqIHRvIGRvY3VtZW50YXRpb24gZm9yIHRoZSBzdXBwb3J0ZWQgTUlNRSB0eXBlcyBmb3IgeW91ciB1c2UgY2FzZTpcbiAgICAgKlxuICAgICAqIC0gW0Fzc2lzdGFudHNdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2Fzc2lzdGFudHMvdG9vbHMvZmlsZS1zZWFyY2gvc3VwcG9ydGVkLWZpbGVzKVxuICAgICAqXG4gICAgICogRm9yIGd1aWRhbmNlIG9uIHRoZSBwcm9wZXIgZmlsZW5hbWUgZXh0ZW5zaW9ucyBmb3IgZWFjaCBwdXJwb3NlLCBwbGVhc2UgZm9sbG93XG4gICAgICogdGhlIGRvY3VtZW50YXRpb24gb25cbiAgICAgKiBbY3JlYXRpbmcgYSBGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL2NyZWF0ZSkuXG4gICAgICovXG4gICAgY3JlYXRlKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvdXBsb2FkcycsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyB0aGUgVXBsb2FkLiBObyBQYXJ0cyBtYXkgYmUgYWRkZWQgYWZ0ZXIgYW4gVXBsb2FkIGlzIGNhbmNlbGxlZC5cbiAgICAgKi9cbiAgICBjYW5jZWwodXBsb2FkSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdXBsb2Fkcy8ke3VwbG9hZElkfS9jYW5jZWxgLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGxldGVzIHRoZVxuICAgICAqIFtVcGxvYWRdKGh0dHBzOi8vcGxhdGZvcm0ub3BlbmFpLmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvdXBsb2Fkcy9vYmplY3QpLlxuICAgICAqXG4gICAgICogV2l0aGluIHRoZSByZXR1cm5lZCBVcGxvYWQgb2JqZWN0LCB0aGVyZSBpcyBhIG5lc3RlZFxuICAgICAqIFtGaWxlXShodHRwczovL3BsYXRmb3JtLm9wZW5haS5jb20vZG9jcy9hcGktcmVmZXJlbmNlL2ZpbGVzL29iamVjdCkgb2JqZWN0IHRoYXRcbiAgICAgKiBpcyByZWFkeSB0byB1c2UgaW4gdGhlIHJlc3Qgb2YgdGhlIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogWW91IGNhbiBzcGVjaWZ5IHRoZSBvcmRlciBvZiB0aGUgUGFydHMgYnkgcGFzc2luZyBpbiBhbiBvcmRlcmVkIGxpc3Qgb2YgdGhlIFBhcnRcbiAgICAgKiBJRHMuXG4gICAgICpcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHVwbG9hZGVkIHVwb24gY29tcGxldGlvbiBtdXN0IG1hdGNoIHRoZSBudW1iZXIgb2YgYnl0ZXNcbiAgICAgKiBpbml0aWFsbHkgc3BlY2lmaWVkIHdoZW4gY3JlYXRpbmcgdGhlIFVwbG9hZCBvYmplY3QuIE5vIFBhcnRzIG1heSBiZSBhZGRlZCBhZnRlclxuICAgICAqIGFuIFVwbG9hZCBpcyBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgY29tcGxldGUodXBsb2FkSWQsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KGAvdXBsb2Fkcy8ke3VwbG9hZElkfS9jb21wbGV0ZWAsIHsgYm9keSwgLi4ub3B0aW9ucyB9KTtcbiAgICB9XG59XG4oZnVuY3Rpb24gKFVwbG9hZHMpIHtcbiAgICBVcGxvYWRzLlBhcnRzID0gUGFydHNBUEkuUGFydHM7XG59KShVcGxvYWRzIHx8IChVcGxvYWRzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVwbG9hZHMubWpzLm1hcCIsIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG52YXIgX2E7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSBcIi4vZXJyb3IubWpzXCI7XG5pbXBvcnQgKiBhcyBVcGxvYWRzIGZyb20gXCIuL3VwbG9hZHMubWpzXCI7XG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gXCIuL2NvcmUubWpzXCI7XG5pbXBvcnQgKiBhcyBQYWdpbmF0aW9uIGZyb20gXCIuL3BhZ2luYXRpb24ubWpzXCI7XG5pbXBvcnQgKiBhcyBBUEkgZnJvbSBcIi4vcmVzb3VyY2VzL2luZGV4Lm1qc1wiO1xuLyoqXG4gKiBBUEkgQ2xpZW50IGZvciBpbnRlcmZhY2luZyB3aXRoIHRoZSBPcGVuQUkgQVBJLlxuICovXG5leHBvcnQgY2xhc3MgT3BlbkFJIGV4dGVuZHMgQ29yZS5BUElDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEFQSSBDbGllbnQgZm9yIGludGVyZmFjaW5nIHdpdGggdGhlIE9wZW5BSSBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW29wdHMuYXBpS2V5PXByb2Nlc3MuZW52WydPUEVOQUlfQVBJX0tFWSddID8/IHVuZGVmaW5lZF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRzLm9yZ2FuaXphdGlvbj1wcm9jZXNzLmVudlsnT1BFTkFJX09SR19JRCddID8/IG51bGxdXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0cy5wcm9qZWN0PXByb2Nlc3MuZW52WydPUEVOQUlfUFJPSkVDVF9JRCddID8/IG51bGxdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhc2VVUkw9cHJvY2Vzcy5lbnZbJ09QRU5BSV9CQVNFX1VSTCddID8/IGh0dHBzOi8vYXBpLm9wZW5haS5jb20vdjFdIC0gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmFzZSBVUkwgZm9yIHRoZSBBUEkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVvdXQ9MTAgbWludXRlc10gLSBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSB0aGUgY2xpZW50IHdpbGwgd2FpdCBmb3IgYSByZXNwb25zZSBiZWZvcmUgdGltaW5nIG91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaHR0cEFnZW50XSAtIEFuIEhUVFAgYWdlbnQgdXNlZCB0byBtYW5hZ2UgSFRUUChzKSBjb25uZWN0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0NvcmUuRmV0Y2h9IFtvcHRzLmZldGNoXSAtIFNwZWNpZnkgYSBjdXN0b20gYGZldGNoYCBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMubWF4UmV0cmllcz0yXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyB0aGUgY2xpZW50IHdpbGwgcmV0cnkgYSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7Q29yZS5IZWFkZXJzfSBvcHRzLmRlZmF1bHRIZWFkZXJzIC0gRGVmYXVsdCBoZWFkZXJzIHRvIGluY2x1ZGUgd2l0aCBldmVyeSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAgICogQHBhcmFtIHtDb3JlLkRlZmF1bHRRdWVyeX0gb3B0cy5kZWZhdWx0UXVlcnkgLSBEZWZhdWx0IHF1ZXJ5IHBhcmFtZXRlcnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIEFQSS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmRhbmdlcm91c2x5QWxsb3dCcm93c2VyPWZhbHNlXSAtIEJ5IGRlZmF1bHQsIGNsaWVudC1zaWRlIHVzZSBvZiB0aGlzIGxpYnJhcnkgaXMgbm90IGFsbG93ZWQsIGFzIGl0IHJpc2tzIGV4cG9zaW5nIHlvdXIgc2VjcmV0IEFQSSBjcmVkZW50aWFscyB0byBhdHRhY2tlcnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBiYXNlVVJMID0gQ29yZS5yZWFkRW52KCdPUEVOQUlfQkFTRV9VUkwnKSwgYXBpS2V5ID0gQ29yZS5yZWFkRW52KCdPUEVOQUlfQVBJX0tFWScpLCBvcmdhbml6YXRpb24gPSBDb3JlLnJlYWRFbnYoJ09QRU5BSV9PUkdfSUQnKSA/PyBudWxsLCBwcm9qZWN0ID0gQ29yZS5yZWFkRW52KCdPUEVOQUlfUFJPSkVDVF9JRCcpID8/IG51bGwsIC4uLm9wdHMgfSA9IHt9KSB7XG4gICAgICAgIGlmIChhcGlLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcihcIlRoZSBPUEVOQUlfQVBJX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBtaXNzaW5nIG9yIGVtcHR5OyBlaXRoZXIgcHJvdmlkZSBpdCwgb3IgaW5zdGFudGlhdGUgdGhlIE9wZW5BSSBjbGllbnQgd2l0aCBhbiBhcGlLZXkgb3B0aW9uLCBsaWtlIG5ldyBPcGVuQUkoeyBhcGlLZXk6ICdNeSBBUEkgS2V5JyB9KS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFwaUtleSxcbiAgICAgICAgICAgIG9yZ2FuaXphdGlvbixcbiAgICAgICAgICAgIHByb2plY3QsXG4gICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgYmFzZVVSTDogYmFzZVVSTCB8fCBgaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MWAsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93QnJvd3NlciAmJiBDb3JlLmlzUnVubmluZ0luQnJvd3NlcigpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKFwiSXQgbG9va3MgbGlrZSB5b3UncmUgcnVubmluZyBpbiBhIGJyb3dzZXItbGlrZSBlbnZpcm9ubWVudC5cXG5cXG5UaGlzIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGFzIGl0IHJpc2tzIGV4cG9zaW5nIHlvdXIgc2VjcmV0IEFQSSBjcmVkZW50aWFscyB0byBhdHRhY2tlcnMuXFxuSWYgeW91IHVuZGVyc3RhbmQgdGhlIHJpc2tzIGFuZCBoYXZlIGFwcHJvcHJpYXRlIG1pdGlnYXRpb25zIGluIHBsYWNlLFxcbnlvdSBjYW4gc2V0IHRoZSBgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXJgIG9wdGlvbiB0byBgdHJ1ZWAsIGUuZy4sXFxuXFxubmV3IE9wZW5BSSh7IGFwaUtleSwgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI6IHRydWUgfSk7XFxuXFxuaHR0cHM6Ly9oZWxwLm9wZW5haS5jb20vZW4vYXJ0aWNsZXMvNTExMjU5NS1iZXN0LXByYWN0aWNlcy1mb3ItYXBpLWtleS1zYWZldHlcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgYmFzZVVSTDogb3B0aW9ucy5iYXNlVVJMLFxuICAgICAgICAgICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0ID8/IDYwMDAwMCAvKiAxMCBtaW51dGVzICovLFxuICAgICAgICAgICAgaHR0cEFnZW50OiBvcHRpb25zLmh0dHBBZ2VudCxcbiAgICAgICAgICAgIG1heFJldHJpZXM6IG9wdGlvbnMubWF4UmV0cmllcyxcbiAgICAgICAgICAgIGZldGNoOiBvcHRpb25zLmZldGNoLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21wbGV0aW9ucyA9IG5ldyBBUEkuQ29tcGxldGlvbnModGhpcyk7XG4gICAgICAgIHRoaXMuY2hhdCA9IG5ldyBBUEkuQ2hhdCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbWJlZGRpbmdzID0gbmV3IEFQSS5FbWJlZGRpbmdzKHRoaXMpO1xuICAgICAgICB0aGlzLmZpbGVzID0gbmV3IEFQSS5GaWxlcyh0aGlzKTtcbiAgICAgICAgdGhpcy5pbWFnZXMgPSBuZXcgQVBJLkltYWdlcyh0aGlzKTtcbiAgICAgICAgdGhpcy5hdWRpbyA9IG5ldyBBUEkuQXVkaW8odGhpcyk7XG4gICAgICAgIHRoaXMubW9kZXJhdGlvbnMgPSBuZXcgQVBJLk1vZGVyYXRpb25zKHRoaXMpO1xuICAgICAgICB0aGlzLm1vZGVscyA9IG5ldyBBUEkuTW9kZWxzKHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmVUdW5pbmcgPSBuZXcgQVBJLkZpbmVUdW5pbmcodGhpcyk7XG4gICAgICAgIHRoaXMuYmV0YSA9IG5ldyBBUEkuQmV0YSh0aGlzKTtcbiAgICAgICAgdGhpcy5iYXRjaGVzID0gbmV3IEFQSS5CYXRjaGVzKHRoaXMpO1xuICAgICAgICB0aGlzLnVwbG9hZHMgPSBuZXcgQVBJLlVwbG9hZHModGhpcyk7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICAgICAgdGhpcy5vcmdhbml6YXRpb24gPSBvcmdhbml6YXRpb247XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgfVxuICAgIGRlZmF1bHRRdWVyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZGVmYXVsdFF1ZXJ5O1xuICAgIH1cbiAgICBkZWZhdWx0SGVhZGVycyhvcHRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci5kZWZhdWx0SGVhZGVycyhvcHRzKSxcbiAgICAgICAgICAgICdPcGVuQUktT3JnYW5pemF0aW9uJzogdGhpcy5vcmdhbml6YXRpb24sXG4gICAgICAgICAgICAnT3BlbkFJLVByb2plY3QnOiB0aGlzLnByb2plY3QsXG4gICAgICAgICAgICAuLi50aGlzLl9vcHRpb25zLmRlZmF1bHRIZWFkZXJzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhdXRoSGVhZGVycyhvcHRzKSB7XG4gICAgICAgIHJldHVybiB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLmFwaUtleX1gIH07XG4gICAgfVxufVxuX2EgPSBPcGVuQUk7XG5PcGVuQUkuT3BlbkFJID0gX2E7XG5PcGVuQUkuREVGQVVMVF9USU1FT1VUID0gNjAwMDAwOyAvLyAxMCBtaW51dGVzXG5PcGVuQUkuT3BlbkFJRXJyb3IgPSBFcnJvcnMuT3BlbkFJRXJyb3I7XG5PcGVuQUkuQVBJRXJyb3IgPSBFcnJvcnMuQVBJRXJyb3I7XG5PcGVuQUkuQVBJQ29ubmVjdGlvbkVycm9yID0gRXJyb3JzLkFQSUNvbm5lY3Rpb25FcnJvcjtcbk9wZW5BSS5BUElDb25uZWN0aW9uVGltZW91dEVycm9yID0gRXJyb3JzLkFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3I7XG5PcGVuQUkuQVBJVXNlckFib3J0RXJyb3IgPSBFcnJvcnMuQVBJVXNlckFib3J0RXJyb3I7XG5PcGVuQUkuTm90Rm91bmRFcnJvciA9IEVycm9ycy5Ob3RGb3VuZEVycm9yO1xuT3BlbkFJLkNvbmZsaWN0RXJyb3IgPSBFcnJvcnMuQ29uZmxpY3RFcnJvcjtcbk9wZW5BSS5SYXRlTGltaXRFcnJvciA9IEVycm9ycy5SYXRlTGltaXRFcnJvcjtcbk9wZW5BSS5CYWRSZXF1ZXN0RXJyb3IgPSBFcnJvcnMuQmFkUmVxdWVzdEVycm9yO1xuT3BlbkFJLkF1dGhlbnRpY2F0aW9uRXJyb3IgPSBFcnJvcnMuQXV0aGVudGljYXRpb25FcnJvcjtcbk9wZW5BSS5JbnRlcm5hbFNlcnZlckVycm9yID0gRXJyb3JzLkludGVybmFsU2VydmVyRXJyb3I7XG5PcGVuQUkuUGVybWlzc2lvbkRlbmllZEVycm9yID0gRXJyb3JzLlBlcm1pc3Npb25EZW5pZWRFcnJvcjtcbk9wZW5BSS5VbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IgPSBFcnJvcnMuVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yO1xuT3BlbkFJLnRvRmlsZSA9IFVwbG9hZHMudG9GaWxlO1xuT3BlbkFJLmZpbGVGcm9tUGF0aCA9IFVwbG9hZHMuZmlsZUZyb21QYXRoO1xuZXhwb3J0IGNvbnN0IHsgT3BlbkFJRXJyb3IsIEFQSUVycm9yLCBBUElDb25uZWN0aW9uRXJyb3IsIEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IsIEFQSVVzZXJBYm9ydEVycm9yLCBOb3RGb3VuZEVycm9yLCBDb25mbGljdEVycm9yLCBSYXRlTGltaXRFcnJvciwgQmFkUmVxdWVzdEVycm9yLCBBdXRoZW50aWNhdGlvbkVycm9yLCBJbnRlcm5hbFNlcnZlckVycm9yLCBQZXJtaXNzaW9uRGVuaWVkRXJyb3IsIFVucHJvY2Vzc2FibGVFbnRpdHlFcnJvciwgfSA9IEVycm9ycztcbmV4cG9ydCB2YXIgdG9GaWxlID0gVXBsb2Fkcy50b0ZpbGU7XG5leHBvcnQgdmFyIGZpbGVGcm9tUGF0aCA9IFVwbG9hZHMuZmlsZUZyb21QYXRoO1xuKGZ1bmN0aW9uIChPcGVuQUkpIHtcbiAgICBPcGVuQUkuUGFnZSA9IFBhZ2luYXRpb24uUGFnZTtcbiAgICBPcGVuQUkuQ3Vyc29yUGFnZSA9IFBhZ2luYXRpb24uQ3Vyc29yUGFnZTtcbiAgICBPcGVuQUkuQ29tcGxldGlvbnMgPSBBUEkuQ29tcGxldGlvbnM7XG4gICAgT3BlbkFJLkNoYXQgPSBBUEkuQ2hhdDtcbiAgICBPcGVuQUkuRW1iZWRkaW5ncyA9IEFQSS5FbWJlZGRpbmdzO1xuICAgIE9wZW5BSS5GaWxlcyA9IEFQSS5GaWxlcztcbiAgICBPcGVuQUkuRmlsZU9iamVjdHNQYWdlID0gQVBJLkZpbGVPYmplY3RzUGFnZTtcbiAgICBPcGVuQUkuSW1hZ2VzID0gQVBJLkltYWdlcztcbiAgICBPcGVuQUkuQXVkaW8gPSBBUEkuQXVkaW87XG4gICAgT3BlbkFJLk1vZGVyYXRpb25zID0gQVBJLk1vZGVyYXRpb25zO1xuICAgIE9wZW5BSS5Nb2RlbHMgPSBBUEkuTW9kZWxzO1xuICAgIE9wZW5BSS5Nb2RlbHNQYWdlID0gQVBJLk1vZGVsc1BhZ2U7XG4gICAgT3BlbkFJLkZpbmVUdW5pbmcgPSBBUEkuRmluZVR1bmluZztcbiAgICBPcGVuQUkuQmV0YSA9IEFQSS5CZXRhO1xuICAgIE9wZW5BSS5CYXRjaGVzID0gQVBJLkJhdGNoZXM7XG4gICAgT3BlbkFJLkJhdGNoZXNQYWdlID0gQVBJLkJhdGNoZXNQYWdlO1xuICAgIE9wZW5BSS5VcGxvYWRzID0gQVBJLlVwbG9hZHM7XG59KShPcGVuQUkgfHwgKE9wZW5BSSA9IHt9KSk7XG4vKiogQVBJIENsaWVudCBmb3IgaW50ZXJmYWNpbmcgd2l0aCB0aGUgQXp1cmUgT3BlbkFJIEFQSS4gKi9cbmV4cG9ydCBjbGFzcyBBenVyZU9wZW5BSSBleHRlbmRzIE9wZW5BSSB7XG4gICAgLyoqXG4gICAgICogQVBJIENsaWVudCBmb3IgaW50ZXJmYWNpbmcgd2l0aCB0aGUgQXp1cmUgT3BlbkFJIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbb3B0cy5hcGlWZXJzaW9uPXByb2Nlc3MuZW52WydPUEVOQUlfQVBJX1ZFUlNJT04nXSA/PyB1bmRlZmluZWRdXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtvcHRzLmVuZHBvaW50PXByb2Nlc3MuZW52WydBWlVSRV9PUEVOQUlfRU5EUE9JTlQnXSA/PyB1bmRlZmluZWRdIC0gWW91ciBBenVyZSBlbmRwb2ludCwgaW5jbHVkaW5nIHRoZSByZXNvdXJjZSwgZS5nLiBgaHR0cHM6Ly9leGFtcGxlLXJlc291cmNlLmF6dXJlLm9wZW5haS5jb20vYFxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbb3B0cy5hcGlLZXk9cHJvY2Vzcy5lbnZbJ0FaVVJFX09QRU5BSV9BUElfS0VZJ10gPz8gdW5kZWZpbmVkXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBvcHRzLmRlcGxveW1lbnQgLSBBIG1vZGVsIGRlcGxveW1lbnQsIGlmIGdpdmVuLCBzZXRzIHRoZSBiYXNlIGNsaWVudCBVUkwgdG8gaW5jbHVkZSBgL2RlcGxveW1lbnRzL3tkZXBsb3ltZW50fWAuXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0cy5vcmdhbml6YXRpb249cHJvY2Vzcy5lbnZbJ09QRU5BSV9PUkdfSUQnXSA/PyBudWxsXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYXNlVVJMPXByb2Nlc3MuZW52WydPUEVOQUlfQkFTRV9VUkwnXV0gLSBTZXRzIHRoZSBiYXNlIFVSTCBmb3IgdGhlIEFQSS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZW91dD0xMCBtaW51dGVzXSAtIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRoZSBjbGllbnQgd2lsbCB3YWl0IGZvciBhIHJlc3BvbnNlIGJlZm9yZSB0aW1pbmcgb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5odHRwQWdlbnRdIC0gQW4gSFRUUCBhZ2VudCB1c2VkIHRvIG1hbmFnZSBIVFRQKHMpIGNvbm5lY3Rpb25zLlxuICAgICAqIEBwYXJhbSB7Q29yZS5GZXRjaH0gW29wdHMuZmV0Y2hdIC0gU3BlY2lmeSBhIGN1c3RvbSBgZmV0Y2hgIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5tYXhSZXRyaWVzPTJdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHRoZSBjbGllbnQgd2lsbCByZXRyeSBhIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHtDb3JlLkhlYWRlcnN9IG9wdHMuZGVmYXVsdEhlYWRlcnMgLSBEZWZhdWx0IGhlYWRlcnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIEFQSS5cbiAgICAgKiBAcGFyYW0ge0NvcmUuRGVmYXVsdFF1ZXJ5fSBvcHRzLmRlZmF1bHRRdWVyeSAtIERlZmF1bHQgcXVlcnkgcGFyYW1ldGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI9ZmFsc2VdIC0gQnkgZGVmYXVsdCwgY2xpZW50LXNpZGUgdXNlIG9mIHRoaXMgbGlicmFyeSBpcyBub3QgYWxsb3dlZCwgYXMgaXQgcmlza3MgZXhwb3NpbmcgeW91ciBzZWNyZXQgQVBJIGNyZWRlbnRpYWxzIHRvIGF0dGFja2Vycy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGJhc2VVUkwgPSBDb3JlLnJlYWRFbnYoJ09QRU5BSV9CQVNFX1VSTCcpLCBhcGlLZXkgPSBDb3JlLnJlYWRFbnYoJ0FaVVJFX09QRU5BSV9BUElfS0VZJyksIGFwaVZlcnNpb24gPSBDb3JlLnJlYWRFbnYoJ09QRU5BSV9BUElfVkVSU0lPTicpLCBlbmRwb2ludCwgZGVwbG95bWVudCwgYXp1cmVBRFRva2VuUHJvdmlkZXIsIGRhbmdlcm91c2x5QWxsb3dCcm93c2VyLCAuLi5vcHRzIH0gPSB7fSkge1xuICAgICAgICBpZiAoIWFwaVZlcnNpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcnMuT3BlbkFJRXJyb3IoXCJUaGUgT1BFTkFJX0FQSV9WRVJTSU9OIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG1pc3Npbmcgb3IgZW1wdHk7IGVpdGhlciBwcm92aWRlIGl0LCBvciBpbnN0YW50aWF0ZSB0aGUgQXp1cmVPcGVuQUkgY2xpZW50IHdpdGggYW4gYXBpVmVyc2lvbiBvcHRpb24sIGxpa2UgbmV3IEF6dXJlT3BlbkFJKHsgYXBpVmVyc2lvbjogJ015IEFQSSBWZXJzaW9uJyB9KS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhenVyZUFEVG9rZW5Qcm92aWRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXp1cmVBRFRva2VuUHJvdmlkZXIgJiYgIWFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcignTWlzc2luZyBjcmVkZW50aWFscy4gUGxlYXNlIHBhc3Mgb25lIG9mIGBhcGlLZXlgIGFuZCBgYXp1cmVBRFRva2VuUHJvdmlkZXJgLCBvciBzZXQgdGhlIGBBWlVSRV9PUEVOQUlfQVBJX0tFWWAgZW52aXJvbm1lbnQgdmFyaWFibGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF6dXJlQURUb2tlblByb3ZpZGVyICYmIGFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcignVGhlIGBhcGlLZXlgIGFuZCBgYXp1cmVBRFRva2VuUHJvdmlkZXJgIGFyZ3VtZW50cyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlOyBvbmx5IG9uZSBjYW4gYmUgcGFzc2VkIGF0IGEgdGltZS4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWZpbmUgYSBzZW50aW5lbCB2YWx1ZSB0byBhdm9pZCBhbnkgdHlwaW5nIGlzc3Vlc1xuICAgICAgICBhcGlLZXkgPz8gKGFwaUtleSA9IEFQSV9LRVlfU0VOVElORUwpO1xuICAgICAgICBvcHRzLmRlZmF1bHRRdWVyeSA9IHsgLi4ub3B0cy5kZWZhdWx0UXVlcnksICdhcGktdmVyc2lvbic6IGFwaVZlcnNpb24gfTtcbiAgICAgICAgaWYgKCFiYXNlVVJMKSB7XG4gICAgICAgICAgICBpZiAoIWVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgZW5kcG9pbnQgPSBwcm9jZXNzLmVudlsnQVpVUkVfT1BFTkFJX0VORFBPSU5UJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcignTXVzdCBwcm92aWRlIG9uZSBvZiB0aGUgYGJhc2VVUkxgIG9yIGBlbmRwb2ludGAgYXJndW1lbnRzLCBvciB0aGUgYEFaVVJFX09QRU5BSV9FTkRQT0lOVGAgZW52aXJvbm1lbnQgdmFyaWFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2VVUkwgPSBgJHtlbmRwb2ludH0vb3BlbmFpYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcnMuT3BlbkFJRXJyb3IoJ2Jhc2VVUkwgYW5kIGVuZHBvaW50IGFyZSBtdXR1YWxseSBleGNsdXNpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICBiYXNlVVJMLFxuICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgIC4uLihkYW5nZXJvdXNseUFsbG93QnJvd3NlciAhPT0gdW5kZWZpbmVkID8geyBkYW5nZXJvdXNseUFsbG93QnJvd3NlciB9IDoge30pLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcGlWZXJzaW9uID0gJyc7XG4gICAgICAgIHRoaXMuX2F6dXJlQURUb2tlblByb3ZpZGVyID0gYXp1cmVBRFRva2VuUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuYXBpVmVyc2lvbiA9IGFwaVZlcnNpb247XG4gICAgICAgIHRoaXMuX2RlcGxveW1lbnQgPSBkZXBsb3ltZW50O1xuICAgIH1cbiAgICBidWlsZFJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICBpZiAoX2RlcGxveW1lbnRzX2VuZHBvaW50cy5oYXMob3B0aW9ucy5wYXRoKSAmJiBvcHRpb25zLm1ldGhvZCA9PT0gJ3Bvc3QnICYmIG9wdGlvbnMuYm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUNvcmUuaXNPYmoob3B0aW9ucy5ib2R5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmVxdWVzdCBib2R5IHRvIGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9kZXBsb3ltZW50IHx8IG9wdGlvbnMuYm9keVsnbW9kZWwnXTtcbiAgICAgICAgICAgIGlmIChtb2RlbCAhPT0gdW5kZWZpbmVkICYmICF0aGlzLmJhc2VVUkwuaW5jbHVkZXMoJy9kZXBsb3ltZW50cycpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoID0gYC9kZXBsb3ltZW50cy8ke21vZGVsfSR7b3B0aW9ucy5wYXRofWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmJ1aWxkUmVxdWVzdChvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgX2dldEF6dXJlQURUb2tlbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9henVyZUFEVG9rZW5Qcm92aWRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLl9henVyZUFEVG9rZW5Qcm92aWRlcigpO1xuICAgICAgICAgICAgaWYgKCF0b2tlbiB8fCB0eXBlb2YgdG9rZW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5PcGVuQUlFcnJvcihgRXhwZWN0ZWQgJ2F6dXJlQURUb2tlblByb3ZpZGVyJyBhcmd1bWVudCB0byByZXR1cm4gYSBzdHJpbmcgYnV0IGl0IHJldHVybmVkICR7dG9rZW59YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXV0aEhlYWRlcnMob3B0cykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGFzeW5jIHByZXBhcmVPcHRpb25zKG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMuaGVhZGVycz8uWydBdXRob3JpemF0aW9uJ10gfHwgb3B0cy5oZWFkZXJzPy5bJ2FwaS1rZXknXSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnByZXBhcmVPcHRpb25zKG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdGhpcy5fZ2V0QXp1cmVBRFRva2VuKCk7XG4gICAgICAgIG9wdHMuaGVhZGVycyA/PyAob3B0cy5oZWFkZXJzID0ge30pO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3Rva2VufWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcGlLZXkgIT09IEFQSV9LRVlfU0VOVElORUwpIHtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVyc1snYXBpLWtleSddID0gdGhpcy5hcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLk9wZW5BSUVycm9yKCdVbmFibGUgdG8gaGFuZGxlIGF1dGgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIucHJlcGFyZU9wdGlvbnMob3B0cyk7XG4gICAgfVxufVxuY29uc3QgX2RlcGxveW1lbnRzX2VuZHBvaW50cyA9IG5ldyBTZXQoW1xuICAgICcvY29tcGxldGlvbnMnLFxuICAgICcvY2hhdC9jb21wbGV0aW9ucycsXG4gICAgJy9lbWJlZGRpbmdzJyxcbiAgICAnL2F1ZGlvL3RyYW5zY3JpcHRpb25zJyxcbiAgICAnL2F1ZGlvL3RyYW5zbGF0aW9ucycsXG4gICAgJy9hdWRpby9zcGVlY2gnLFxuICAgICcvaW1hZ2VzL2dlbmVyYXRpb25zJyxcbl0pO1xuY29uc3QgQVBJX0tFWV9TRU5USU5FTCA9ICc8TWlzc2luZyBLZXk+Jztcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRW5kIEF6dXJlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBkZWZhdWx0IE9wZW5BSTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiLCJpbXBvcnQgKiBhcyBWdWUgZnJvbSAndnVlJ1xuXG52YXIgaXNWdWUyID0gZmFsc2VcbnZhciBpc1Z1ZTMgPSB0cnVlXG52YXIgVnVlMiA9IHVuZGVmaW5lZFxuXG5mdW5jdGlvbiBpbnN0YWxsKCkge31cblxuZXhwb3J0IGZ1bmN0aW9uIHNldCh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KVxuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpXG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHRhcmdldFtrZXldID0gdmFsXG4gIHJldHVybiB2YWxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbCh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpXG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldXG59XG5cbmV4cG9ydCAqIGZyb20gJ3Z1ZSdcbmV4cG9ydCB7XG4gIFZ1ZSxcbiAgVnVlMixcbiAgaXNWdWUyLFxuICBpc1Z1ZTMsXG4gIGluc3RhbGwsXG59XG4iLCIvKiFcbiAqIHBpbmlhIHYyLjIuNFxuICogKGMpIDIwMjQgRWR1YXJkbyBTYW4gTWFydGluIE1vcm90ZVxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IGhhc0luamVjdGlvbkNvbnRleHQsIGluamVjdCwgdG9SYXcsIHdhdGNoLCB1bnJlZiwgbWFya1JhdywgZWZmZWN0U2NvcGUsIHJlZiwgaXNWdWUyLCBpc1JlZiwgaXNSZWFjdGl2ZSwgc2V0LCBnZXRDdXJyZW50U2NvcGUsIG9uU2NvcGVEaXNwb3NlLCBnZXRDdXJyZW50SW5zdGFuY2UsIHJlYWN0aXZlLCB0b1JlZiwgZGVsLCBuZXh0VGljaywgY29tcHV0ZWQsIHRvUmVmcyB9IGZyb20gJ3Z1ZS1kZW1pJztcbmltcG9ydCB7IHNldHVwRGV2dG9vbHNQbHVnaW4gfSBmcm9tICdAdnVlL2RldnRvb2xzLWFwaSc7XG5cbi8qKlxuICogc2V0QWN0aXZlUGluaWEgbXVzdCBiZSBjYWxsZWQgdG8gaGFuZGxlIFNTUiBhdCB0aGUgdG9wIG9mIGZ1bmN0aW9ucyBsaWtlXG4gKiBgZmV0Y2hgLCBgc2V0dXBgLCBgc2VydmVyUHJlZmV0Y2hgIGFuZCBvdGhlcnNcbiAqL1xubGV0IGFjdGl2ZVBpbmlhO1xuLyoqXG4gKiBTZXRzIG9yIHVuc2V0cyB0aGUgYWN0aXZlIHBpbmlhLiBVc2VkIGluIFNTUiBhbmQgaW50ZXJuYWxseSB3aGVuIGNhbGxpbmdcbiAqIGFjdGlvbnMgYW5kIGdldHRlcnNcbiAqXG4gKiBAcGFyYW0gcGluaWEgLSBQaW5pYSBpbnN0YW5jZVxuICovXG4vLyBAdHMtZXhwZWN0LWVycm9yOiBjYW5ub3QgY29uc3RyYWluIHRoZSB0eXBlIG9mIHRoZSByZXR1cm5cbmNvbnN0IHNldEFjdGl2ZVBpbmlhID0gKHBpbmlhKSA9PiAoYWN0aXZlUGluaWEgPSBwaW5pYSk7XG4vKipcbiAqIEdldCB0aGUgY3VycmVudGx5IGFjdGl2ZSBwaW5pYSBpZiB0aGVyZSBpcyBhbnkuXG4gKi9cbmNvbnN0IGdldEFjdGl2ZVBpbmlhID0gKCkgPT4gKGhhc0luamVjdGlvbkNvbnRleHQoKSAmJiBpbmplY3QocGluaWFTeW1ib2wpKSB8fCBhY3RpdmVQaW5pYTtcbmNvbnN0IHBpbmlhU3ltYm9sID0gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IFN5bWJvbCgncGluaWEnKSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFN5bWJvbCgpKTtcblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5vKSB7XG4gICAgcmV0dXJuIChvICYmXG4gICAgICAgIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmXG4gICAgICAgIHR5cGVvZiBvLnRvSlNPTiAhPT0gJ2Z1bmN0aW9uJyk7XG59XG4vLyB0eXBlIERlZXBSZWFkb25seTxUPiA9IHsgcmVhZG9ubHkgW1AgaW4ga2V5b2YgVF06IERlZXBSZWFkb25seTxUW1BdPiB9XG4vLyBUT0RPOiBjYW4gd2UgY2hhbmdlIHRoZXNlIHRvIG51bWJlcnM/XG4vKipcbiAqIFBvc3NpYmxlIHR5cGVzIGZvciBTdWJzY3JpcHRpb25DYWxsYmFja1xuICovXG52YXIgTXV0YXRpb25UeXBlO1xuKGZ1bmN0aW9uIChNdXRhdGlvblR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBEaXJlY3QgbXV0YXRpb24gb2YgdGhlIHN0YXRlOlxuICAgICAqXG4gICAgICogLSBgc3RvcmUubmFtZSA9ICduZXcgbmFtZSdgXG4gICAgICogLSBgc3RvcmUuJHN0YXRlLm5hbWUgPSAnbmV3IG5hbWUnYFxuICAgICAqIC0gYHN0b3JlLmxpc3QucHVzaCgnbmV3IGl0ZW0nKWBcbiAgICAgKi9cbiAgICBNdXRhdGlvblR5cGVbXCJkaXJlY3RcIl0gPSBcImRpcmVjdFwiO1xuICAgIC8qKlxuICAgICAqIE11dGF0ZWQgdGhlIHN0YXRlIHdpdGggYCRwYXRjaGAgYW5kIGFuIG9iamVjdFxuICAgICAqXG4gICAgICogLSBgc3RvcmUuJHBhdGNoKHsgbmFtZTogJ25ld05hbWUnIH0pYFxuICAgICAqL1xuICAgIE11dGF0aW9uVHlwZVtcInBhdGNoT2JqZWN0XCJdID0gXCJwYXRjaCBvYmplY3RcIjtcbiAgICAvKipcbiAgICAgKiBNdXRhdGVkIHRoZSBzdGF0ZSB3aXRoIGAkcGF0Y2hgIGFuZCBhIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiAtIGBzdG9yZS4kcGF0Y2goc3RhdGUgPT4gc3RhdGUubmFtZSA9ICduZXdOYW1lJylgXG4gICAgICovXG4gICAgTXV0YXRpb25UeXBlW1wicGF0Y2hGdW5jdGlvblwiXSA9IFwicGF0Y2ggZnVuY3Rpb25cIjtcbiAgICAvLyBtYXliZSByZXNldD8gZm9yICRzdGF0ZSA9IHt9IGFuZCAkcmVzZXRcbn0pKE11dGF0aW9uVHlwZSB8fCAoTXV0YXRpb25UeXBlID0ge30pKTtcblxuY29uc3QgSVNfQ0xJRU5UID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qXG4gKiBGaWxlU2F2ZXIuanMgQSBzYXZlQXMoKSBGaWxlU2F2ZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogT3JpZ2luYWxseSBieSBFbGkgR3JleSwgYWRhcHRlZCBhcyBhbiBFU00gbW9kdWxlIGJ5IEVkdWFyZG8gU2FuIE1hcnRpblxuICogTW9yb3RlLlxuICpcbiAqIExpY2Vuc2UgOiBNSVRcbiAqL1xuLy8gVGhlIG9uZSBhbmQgb25seSB3YXkgb2YgZ2V0dGluZyBnbG9iYWwgc2NvcGUgaW4gYWxsIGVudmlyb25tZW50c1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzMyNzcxODIvMTAwODk5OVxuY29uc3QgX2dsb2JhbCA9IC8qI19fUFVSRV9fKi8gKCgpID0+IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy53aW5kb3cgPT09IHdpbmRvd1xuICAgID8gd2luZG93XG4gICAgOiB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgc2VsZi5zZWxmID09PSBzZWxmXG4gICAgICAgID8gc2VsZlxuICAgICAgICA6IHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnICYmIGdsb2JhbC5nbG9iYWwgPT09IGdsb2JhbFxuICAgICAgICAgICAgPyBnbG9iYWxcbiAgICAgICAgICAgIDogdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzXG4gICAgICAgICAgICAgICAgOiB7IEhUTUxFbGVtZW50OiBudWxsIH0pKCk7XG5mdW5jdGlvbiBib20oYmxvYiwgeyBhdXRvQm9tID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgLy8gcHJlcGVuZCBCT00gZm9yIFVURi04IFhNTCBhbmQgdGV4dC8qIHR5cGVzIChpbmNsdWRpbmcgSFRNTClcbiAgICAvLyBub3RlOiB5b3VyIGJyb3dzZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgVVRGLTE2IFUrRkVGRiB0byBFRiBCQiBCRlxuICAgIGlmIChhdXRvQm9tICYmXG4gICAgICAgIC9eXFxzKig/OnRleHRcXC9cXFMqfGFwcGxpY2F0aW9uXFwveG1sfFxcUypcXC9cXFMqXFwreG1sKVxccyo7LipjaGFyc2V0XFxzKj1cXHMqdXRmLTgvaS50ZXN0KGJsb2IudHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFtTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZmVmZiksIGJsb2JdLCB7IHR5cGU6IGJsb2IudHlwZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2I7XG59XG5mdW5jdGlvbiBkb3dubG9hZCh1cmwsIG5hbWUsIG9wdHMpIHtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNhdmVBcyh4aHIucmVzcG9uc2UsIG5hbWUsIG9wdHMpO1xuICAgIH07XG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2NvdWxkIG5vdCBkb3dubG9hZCBmaWxlJyk7XG4gICAgfTtcbiAgICB4aHIuc2VuZCgpO1xufVxuZnVuY3Rpb24gY29yc0VuYWJsZWQodXJsKSB7XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgLy8gdXNlIHN5bmMgdG8gYXZvaWQgcG9wdXAgYmxvY2tlclxuICAgIHhoci5vcGVuKCdIRUFEJywgdXJsLCBmYWxzZSk7XG4gICAgdHJ5IHtcbiAgICAgICAgeGhyLnNlbmQoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIHJldHVybiB4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDw9IDI5OTtcbn1cbi8vIGBhLmNsaWNrKClgIGRvZXNuJ3Qgd29yayBmb3IgYWxsIGJyb3dzZXJzICgjNDY1KVxuZnVuY3Rpb24gY2xpY2sobm9kZSkge1xuICAgIHRyeSB7XG4gICAgICAgIG5vZGUuZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudCgnY2xpY2snKSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuICAgICAgICBldnQuaW5pdE1vdXNlRXZlbnQoJ2NsaWNrJywgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAwLCAwLCAwLCA4MCwgMjAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgfVxufVxuY29uc3QgX25hdmlnYXRvciA9IHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnID8gbmF2aWdhdG9yIDogeyB1c2VyQWdlbnQ6ICcnIH07XG4vLyBEZXRlY3QgV2ViVmlldyBpbnNpZGUgYSBuYXRpdmUgbWFjT1MgYXBwIGJ5IHJ1bGluZyBvdXQgYWxsIGJyb3dzZXJzXG4vLyBXZSBqdXN0IG5lZWQgdG8gY2hlY2sgZm9yICdTYWZhcmknIGJlY2F1c2UgYWxsIG90aGVyIGJyb3dzZXJzIChiZXNpZGVzIEZpcmVmb3gpIGluY2x1ZGUgdGhhdCB0b29cbi8vIGh0dHBzOi8vd3d3LndoYXRpc215YnJvd3Nlci5jb20vZ3VpZGVzL3RoZS1sYXRlc3QtdXNlci1hZ2VudC9tYWNvc1xuY29uc3QgaXNNYWNPU1dlYlZpZXcgPSAvKiNfX1BVUkVfXyovICgoKSA9PiAvTWFjaW50b3NoLy50ZXN0KF9uYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgIC9BcHBsZVdlYktpdC8udGVzdChfbmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAhL1NhZmFyaS8udGVzdChfbmF2aWdhdG9yLnVzZXJBZ2VudCkpKCk7XG5jb25zdCBzYXZlQXMgPSAhSVNfQ0xJRU5UXG4gICAgPyAoKSA9PiB7IH0gLy8gbm9vcFxuICAgIDogLy8gVXNlIGRvd25sb2FkIGF0dHJpYnV0ZSBmaXJzdCBpZiBwb3NzaWJsZSAoIzE5MyBMdW1pYSBtb2JpbGUpIHVubGVzcyB0aGlzIGlzIGEgbWFjT1MgV2ViVmlldyBvciBtaW5pIHByb2dyYW1cbiAgICAgICAgdHlwZW9mIEhUTUxBbmNob3JFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgJ2Rvd25sb2FkJyBpbiBIVE1MQW5jaG9yRWxlbWVudC5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgICFpc01hY09TV2ViVmlld1xuICAgICAgICAgICAgPyBkb3dubG9hZFNhdmVBc1xuICAgICAgICAgICAgOiAvLyBVc2UgbXNTYXZlT3JPcGVuQmxvYiBhcyBhIHNlY29uZCBhcHByb2FjaFxuICAgICAgICAgICAgICAgICdtc1NhdmVPck9wZW5CbG9iJyBpbiBfbmF2aWdhdG9yXG4gICAgICAgICAgICAgICAgICAgID8gbXNTYXZlQXNcbiAgICAgICAgICAgICAgICAgICAgOiAvLyBGYWxsYmFjayB0byB1c2luZyBGaWxlUmVhZGVyIGFuZCBhIHBvcHVwXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlU2F2ZXJTYXZlQXM7XG5mdW5jdGlvbiBkb3dubG9hZFNhdmVBcyhibG9iLCBuYW1lID0gJ2Rvd25sb2FkJywgb3B0cykge1xuICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgYS5kb3dubG9hZCA9IG5hbWU7XG4gICAgYS5yZWwgPSAnbm9vcGVuZXInOyAvLyB0YWJuYWJiaW5nXG4gICAgLy8gVE9ETzogZGV0ZWN0IGNocm9tZSBleHRlbnNpb25zICYgcGFja2FnZWQgYXBwc1xuICAgIC8vIGEudGFyZ2V0ID0gJ19ibGFuaydcbiAgICBpZiAodHlwZW9mIGJsb2IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgcmVndWxhciBsaW5rc1xuICAgICAgICBhLmhyZWYgPSBibG9iO1xuICAgICAgICBpZiAoYS5vcmlnaW4gIT09IGxvY2F0aW9uLm9yaWdpbikge1xuICAgICAgICAgICAgaWYgKGNvcnNFbmFibGVkKGEuaHJlZikpIHtcbiAgICAgICAgICAgICAgICBkb3dubG9hZChibG9iLCBuYW1lLCBvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGEudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgICAgICAgICAgY2xpY2soYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGljayhhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gU3VwcG9ydCBibG9ic1xuICAgICAgICBhLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYS5ocmVmKTtcbiAgICAgICAgfSwgNGU0KTsgLy8gNDBzXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xpY2soYSk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1zU2F2ZUFzKGJsb2IsIG5hbWUgPSAnZG93bmxvYWQnLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBibG9iID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoY29yc0VuYWJsZWQoYmxvYikpIHtcbiAgICAgICAgICAgIGRvd25sb2FkKGJsb2IsIG5hbWUsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgICAgIGEuaHJlZiA9IGJsb2I7XG4gICAgICAgICAgICBhLnRhcmdldCA9ICdfYmxhbmsnO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2xpY2soYSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZTogd29ya3Mgb24gd2luZG93c1xuICAgICAgICBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYihib20oYmxvYiwgb3B0cyksIG5hbWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbGVTYXZlclNhdmVBcyhibG9iLCBuYW1lLCBvcHRzLCBwb3B1cCkge1xuICAgIC8vIE9wZW4gYSBwb3B1cCBpbW1lZGlhdGVseSBkbyBnbyBhcm91bmQgcG9wdXAgYmxvY2tlclxuICAgIC8vIE1vc3RseSBvbmx5IGF2YWlsYWJsZSBvbiB1c2VyIGludGVyYWN0aW9uIGFuZCB0aGUgZmlsZVJlYWRlciBpcyBhc3luYyBzby4uLlxuICAgIHBvcHVwID0gcG9wdXAgfHwgb3BlbignJywgJ19ibGFuaycpO1xuICAgIGlmIChwb3B1cCkge1xuICAgICAgICBwb3B1cC5kb2N1bWVudC50aXRsZSA9IHBvcHVwLmRvY3VtZW50LmJvZHkuaW5uZXJUZXh0ID0gJ2Rvd25sb2FkaW5nLi4uJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBibG9iID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGRvd25sb2FkKGJsb2IsIG5hbWUsIG9wdHMpO1xuICAgIGNvbnN0IGZvcmNlID0gYmxvYi50eXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICBjb25zdCBpc1NhZmFyaSA9IC9jb25zdHJ1Y3Rvci9pLnRlc3QoU3RyaW5nKF9nbG9iYWwuSFRNTEVsZW1lbnQpKSB8fCAnc2FmYXJpJyBpbiBfZ2xvYmFsO1xuICAgIGNvbnN0IGlzQ2hyb21lSU9TID0gL0NyaU9TXFwvW1xcZF0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIGlmICgoaXNDaHJvbWVJT1MgfHwgKGZvcmNlICYmIGlzU2FmYXJpKSB8fCBpc01hY09TV2ViVmlldykgJiZcbiAgICAgICAgdHlwZW9mIEZpbGVSZWFkZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IGFsbG93IGRvd25sb2FkaW5nIG9mIGJsb2IgVVJMc1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGV0IHVybCA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwb3B1cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyByZWFkZXIucmVzdWx0IHR5cGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybCA9IGlzQ2hyb21lSU9TXG4gICAgICAgICAgICAgICAgPyB1cmxcbiAgICAgICAgICAgICAgICA6IHVybC5yZXBsYWNlKC9eZGF0YTpbXjtdKjsvLCAnZGF0YTphdHRhY2htZW50L2ZpbGU7Jyk7XG4gICAgICAgICAgICBpZiAocG9wdXApIHtcbiAgICAgICAgICAgICAgICBwb3B1cC5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3B1cCA9IG51bGw7IC8vIHJldmVyc2UtdGFibmFiYmluZyAjNDYwXG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgaWYgKHBvcHVwKVxuICAgICAgICAgICAgcG9wdXAubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgIHBvcHVwID0gbnVsbDsgLy8gcmV2ZXJzZS10YWJuYWJiaW5nICM0NjBcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICAgIH0sIDRlNCk7IC8vIDQwc1xuICAgIH1cbn1cblxuLyoqXG4gKiBTaG93cyBhIHRvYXN0IG9yIGNvbnNvbGUubG9nXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIHRvIGxvZ1xuICogQHBhcmFtIHR5cGUgLSBkaWZmZXJlbnQgY29sb3Igb2YgdGhlIHRvb2x0aXBcbiAqL1xuZnVuY3Rpb24gdG9hc3RNZXNzYWdlKG1lc3NhZ2UsIHR5cGUpIHtcbiAgICBjb25zdCBwaW5pYU1lc3NhZ2UgPSAn8J+NjSAnICsgbWVzc2FnZTtcbiAgICBpZiAodHlwZW9mIF9fVlVFX0RFVlRPT0xTX1RPQVNUX18gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gTm8gbG9uZ2VyIGF2YWlsYWJsZSA6KFxuICAgICAgICBfX1ZVRV9ERVZUT09MU19UT0FTVF9fKHBpbmlhTWVzc2FnZSwgdHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihwaW5pYU1lc3NhZ2UpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnd2FybicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKHBpbmlhTWVzc2FnZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhwaW5pYU1lc3NhZ2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUGluaWEobykge1xuICAgIHJldHVybiAnX2EnIGluIG8gJiYgJ2luc3RhbGwnIGluIG87XG59XG5cbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW4gZGV2dG9vbHMgYWN0aW9ucywgdGhleSBhcmUgbm90IFBpbmlhIGFjdGlvbnMuXG4gKi9cbi8vIC0tLVxuZnVuY3Rpb24gY2hlY2tDbGlwYm9hcmRBY2Nlc3MoKSB7XG4gICAgaWYgKCEoJ2NsaXBib2FyZCcgaW4gbmF2aWdhdG9yKSkge1xuICAgICAgICB0b2FzdE1lc3NhZ2UoYFlvdXIgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIENsaXBib2FyZCBBUElgLCAnZXJyb3InKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tOb3RGb2N1c2VkRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICBlcnJvci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2RvY3VtZW50IGlzIG5vdCBmb2N1c2VkJykpIHtcbiAgICAgICAgdG9hc3RNZXNzYWdlKCdZb3UgbmVlZCB0byBhY3RpdmF0ZSB0aGUgXCJFbXVsYXRlIGEgZm9jdXNlZCBwYWdlXCIgc2V0dGluZyBpbiB0aGUgXCJSZW5kZXJpbmdcIiBwYW5lbCBvZiBkZXZ0b29scy4nLCAnd2FybicpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuYXN5bmMgZnVuY3Rpb24gYWN0aW9uR2xvYmFsQ29weVN0YXRlKHBpbmlhKSB7XG4gICAgaWYgKGNoZWNrQ2xpcGJvYXJkQWNjZXNzKCkpXG4gICAgICAgIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChKU09OLnN0cmluZ2lmeShwaW5pYS5zdGF0ZS52YWx1ZSkpO1xuICAgICAgICB0b2FzdE1lc3NhZ2UoJ0dsb2JhbCBzdGF0ZSBjb3BpZWQgdG8gY2xpcGJvYXJkLicpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGNoZWNrTm90Rm9jdXNlZEVycm9yKGVycm9yKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdG9hc3RNZXNzYWdlKGBGYWlsZWQgdG8gc2VyaWFsaXplIHRoZSBzdGF0ZS4gQ2hlY2sgdGhlIGNvbnNvbGUgZm9yIG1vcmUgZGV0YWlscy5gLCAnZXJyb3InKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gYWN0aW9uR2xvYmFsUGFzdGVTdGF0ZShwaW5pYSkge1xuICAgIGlmIChjaGVja0NsaXBib2FyZEFjY2VzcygpKVxuICAgICAgICByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgICAgbG9hZFN0b3Jlc1N0YXRlKHBpbmlhLCBKU09OLnBhcnNlKGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQucmVhZFRleHQoKSkpO1xuICAgICAgICB0b2FzdE1lc3NhZ2UoJ0dsb2JhbCBzdGF0ZSBwYXN0ZWQgZnJvbSBjbGlwYm9hcmQuJyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoY2hlY2tOb3RGb2N1c2VkRXJyb3IoZXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0b2FzdE1lc3NhZ2UoYEZhaWxlZCB0byBkZXNlcmlhbGl6ZSB0aGUgc3RhdGUgZnJvbSBjbGlwYm9hcmQuIENoZWNrIHRoZSBjb25zb2xlIGZvciBtb3JlIGRldGFpbHMuYCwgJ2Vycm9yJyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGFjdGlvbkdsb2JhbFNhdmVTdGF0ZShwaW5pYSkge1xuICAgIHRyeSB7XG4gICAgICAgIHNhdmVBcyhuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkocGluaWEuc3RhdGUudmFsdWUpXSwge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQvcGxhaW47Y2hhcnNldD11dGYtOCcsXG4gICAgICAgIH0pLCAncGluaWEtc3RhdGUuanNvbicpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdG9hc3RNZXNzYWdlKGBGYWlsZWQgdG8gZXhwb3J0IHRoZSBzdGF0ZSBhcyBKU09OLiBDaGVjayB0aGUgY29uc29sZSBmb3IgbW9yZSBkZXRhaWxzLmAsICdlcnJvcicpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG59XG5sZXQgZmlsZUlucHV0O1xuZnVuY3Rpb24gZ2V0RmlsZU9wZW5lcigpIHtcbiAgICBpZiAoIWZpbGVJbnB1dCkge1xuICAgICAgICBmaWxlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBmaWxlSW5wdXQudHlwZSA9ICdmaWxlJztcbiAgICAgICAgZmlsZUlucHV0LmFjY2VwdCA9ICcuanNvbic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9wZW5GaWxlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZmlsZUlucHV0Lm9uY2hhbmdlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gZmlsZUlucHV0LmZpbGVzO1xuICAgICAgICAgICAgICAgIGlmICghZmlsZXMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBmaWxlcy5pdGVtKDApO1xuICAgICAgICAgICAgICAgIGlmICghZmlsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyB0ZXh0OiBhd2FpdCBmaWxlLnRleHQoKSwgZmlsZSB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlOiBUT0RPOiBjaGFuZ2VkIGZyb20gNC4zIHRvIDQuNFxuICAgICAgICAgICAgZmlsZUlucHV0Lm9uY2FuY2VsID0gKCkgPT4gcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIGZpbGVJbnB1dC5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgICAgZmlsZUlucHV0LmNsaWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3BlbkZpbGU7XG59XG5hc3luYyBmdW5jdGlvbiBhY3Rpb25HbG9iYWxPcGVuU3RhdGVGaWxlKHBpbmlhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3BlbiA9IGdldEZpbGVPcGVuZXIoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3BlbigpO1xuICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyB0ZXh0LCBmaWxlIH0gPSByZXN1bHQ7XG4gICAgICAgIGxvYWRTdG9yZXNTdGF0ZShwaW5pYSwgSlNPTi5wYXJzZSh0ZXh0KSk7XG4gICAgICAgIHRvYXN0TWVzc2FnZShgR2xvYmFsIHN0YXRlIGltcG9ydGVkIGZyb20gXCIke2ZpbGUubmFtZX1cIi5gKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRvYXN0TWVzc2FnZShgRmFpbGVkIHRvIGltcG9ydCB0aGUgc3RhdGUgZnJvbSBKU09OLiBDaGVjayB0aGUgY29uc29sZSBmb3IgbW9yZSBkZXRhaWxzLmAsICdlcnJvcicpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsb2FkU3RvcmVzU3RhdGUocGluaWEsIHN0YXRlKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHBpbmlhLnN0YXRlLnZhbHVlW2tleV07XG4gICAgICAgIC8vIHN0b3JlIGlzIGFscmVhZHkgaW5zdGFudGlhdGVkLCBwYXRjaCBpdFxuICAgICAgICBpZiAoc3RvcmVTdGF0ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdG9yZVN0YXRlLCBzdGF0ZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIGlzIG5vdCBpbnN0YW50aWF0ZWQsIHNldCB0aGUgaW5pdGlhbCBzdGF0ZVxuICAgICAgICAgICAgcGluaWEuc3RhdGUudmFsdWVba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERpc3BsYXkoZGlzcGxheSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIF9jdXN0b206IHtcbiAgICAgICAgICAgIGRpc3BsYXksXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmNvbnN0IFBJTklBX1JPT1RfTEFCRUwgPSAn8J+NjSBQaW5pYSAocm9vdCknO1xuY29uc3QgUElOSUFfUk9PVF9JRCA9ICdfcm9vdCc7XG5mdW5jdGlvbiBmb3JtYXRTdG9yZUZvckluc3BlY3RvclRyZWUoc3RvcmUpIHtcbiAgICByZXR1cm4gaXNQaW5pYShzdG9yZSlcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBpZDogUElOSUFfUk9PVF9JRCxcbiAgICAgICAgICAgIGxhYmVsOiBQSU5JQV9ST09UX0xBQkVMLFxuICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgaWQ6IHN0b3JlLiRpZCxcbiAgICAgICAgICAgIGxhYmVsOiBzdG9yZS4kaWQsXG4gICAgICAgIH07XG59XG5mdW5jdGlvbiBmb3JtYXRTdG9yZUZvckluc3BlY3RvclN0YXRlKHN0b3JlKSB7XG4gICAgaWYgKGlzUGluaWEoc3RvcmUpKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlTmFtZXMgPSBBcnJheS5mcm9tKHN0b3JlLl9zLmtleXMoKSk7XG4gICAgICAgIGNvbnN0IHN0b3JlTWFwID0gc3RvcmUuX3M7XG4gICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgc3RhdGU6IHN0b3JlTmFtZXMubWFwKChzdG9yZUlkKSA9PiAoe1xuICAgICAgICAgICAgICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtleTogc3RvcmVJZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3RvcmUuc3RhdGUudmFsdWVbc3RvcmVJZF0sXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBnZXR0ZXJzOiBzdG9yZU5hbWVzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoaWQpID0+IHN0b3JlTWFwLmdldChpZCkuX2dldHRlcnMpXG4gICAgICAgICAgICAgICAgLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHN0b3JlTWFwLmdldChpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGlkLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3RvcmUuX2dldHRlcnMucmVkdWNlKChnZXR0ZXJzLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldHRlcnNba2V5XSA9IHN0b3JlW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVycztcbiAgICAgICAgICAgICAgICAgICAgfSwge30pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgc3RhdGU6IE9iamVjdC5rZXlzKHN0b3JlLiRzdGF0ZSkubWFwKChrZXkpID0+ICh7XG4gICAgICAgICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBzdG9yZS4kc3RhdGVba2V5XSxcbiAgICAgICAgfSkpLFxuICAgIH07XG4gICAgLy8gYXZvaWQgYWRkaW5nIGVtcHR5IGdldHRlcnNcbiAgICBpZiAoc3RvcmUuX2dldHRlcnMgJiYgc3RvcmUuX2dldHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHN0YXRlLmdldHRlcnMgPSBzdG9yZS5fZ2V0dGVycy5tYXAoKGdldHRlck5hbWUpID0+ICh7XG4gICAgICAgICAgICBlZGl0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBrZXk6IGdldHRlck5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogc3RvcmVbZ2V0dGVyTmFtZV0sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHN0b3JlLl9jdXN0b21Qcm9wZXJ0aWVzLnNpemUpIHtcbiAgICAgICAgc3RhdGUuY3VzdG9tUHJvcGVydGllcyA9IEFycmF5LmZyb20oc3RvcmUuX2N1c3RvbVByb3BlcnRpZXMpLm1hcCgoa2V5KSA9PiAoe1xuICAgICAgICAgICAgZWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZTogc3RvcmVba2V5XSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBmb3JtYXRFdmVudERhdGEoZXZlbnRzKSB7XG4gICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudHMpKSB7XG4gICAgICAgIC8vIFRPRE86IGhhbmRsZSBhZGQgYW5kIGRlbGV0ZSBmb3IgYXJyYXlzIGFuZCBvYmplY3RzXG4gICAgICAgIHJldHVybiBldmVudHMucmVkdWNlKChkYXRhLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgZGF0YS5rZXlzLnB1c2goZXZlbnQua2V5KTtcbiAgICAgICAgICAgIGRhdGEub3BlcmF0aW9ucy5wdXNoKGV2ZW50LnR5cGUpO1xuICAgICAgICAgICAgZGF0YS5vbGRWYWx1ZVtldmVudC5rZXldID0gZXZlbnQub2xkVmFsdWU7XG4gICAgICAgICAgICBkYXRhLm5ld1ZhbHVlW2V2ZW50LmtleV0gPSBldmVudC5uZXdWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvbGRWYWx1ZToge30sXG4gICAgICAgICAgICBrZXlzOiBbXSxcbiAgICAgICAgICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgICAgICAgICAgbmV3VmFsdWU6IHt9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcGVyYXRpb246IGZvcm1hdERpc3BsYXkoZXZlbnRzLnR5cGUpLFxuICAgICAgICAgICAga2V5OiBmb3JtYXREaXNwbGF5KGV2ZW50cy5rZXkpLFxuICAgICAgICAgICAgb2xkVmFsdWU6IGV2ZW50cy5vbGRWYWx1ZSxcbiAgICAgICAgICAgIG5ld1ZhbHVlOiBldmVudHMubmV3VmFsdWUsXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZm9ybWF0TXV0YXRpb25UeXBlKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBNdXRhdGlvblR5cGUuZGlyZWN0OlxuICAgICAgICAgICAgcmV0dXJuICdtdXRhdGlvbic7XG4gICAgICAgIGNhc2UgTXV0YXRpb25UeXBlLnBhdGNoRnVuY3Rpb246XG4gICAgICAgICAgICByZXR1cm4gJyRwYXRjaCc7XG4gICAgICAgIGNhc2UgTXV0YXRpb25UeXBlLnBhdGNoT2JqZWN0OlxuICAgICAgICAgICAgcmV0dXJuICckcGF0Y2gnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICB9XG59XG5cbi8vIHRpbWVsaW5lIGNhbiBiZSBwYXVzZWQgd2hlbiBkaXJlY3RseSBjaGFuZ2luZyB0aGUgc3RhdGVcbmxldCBpc1RpbWVsaW5lQWN0aXZlID0gdHJ1ZTtcbmNvbnN0IGNvbXBvbmVudFN0YXRlVHlwZXMgPSBbXTtcbmNvbnN0IE1VVEFUSU9OU19MQVlFUl9JRCA9ICdwaW5pYTptdXRhdGlvbnMnO1xuY29uc3QgSU5TUEVDVE9SX0lEID0gJ3BpbmlhJztcbmNvbnN0IHsgYXNzaWduOiBhc3NpZ24kMSB9ID0gT2JqZWN0O1xuLyoqXG4gKiBHZXRzIHRoZSBkaXNwbGF5ZWQgbmFtZSBvZiBhIHN0b3JlIGluIGRldnRvb2xzXG4gKlxuICogQHBhcmFtIGlkIC0gaWQgb2YgdGhlIHN0b3JlXG4gKiBAcmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmdcbiAqL1xuY29uc3QgZ2V0U3RvcmVUeXBlID0gKGlkKSA9PiAn8J+NjSAnICsgaWQ7XG4vKipcbiAqIEFkZCB0aGUgcGluaWEgcGx1Z2luIHdpdGhvdXQgYW55IHN0b3JlLiBBbGxvd3MgZGlzcGxheWluZyBhIFBpbmlhIHBsdWdpbiB0YWJcbiAqIGFzIHNvb24gYXMgaXQgaXMgYWRkZWQgdG8gdGhlIGFwcGxpY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBhcHAgLSBWdWUgYXBwbGljYXRpb25cbiAqIEBwYXJhbSBwaW5pYSAtIHBpbmlhIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyUGluaWFEZXZ0b29scyhhcHAsIHBpbmlhKSB7XG4gICAgc2V0dXBEZXZ0b29sc1BsdWdpbih7XG4gICAgICAgIGlkOiAnZGV2LmVzbS5waW5pYScsXG4gICAgICAgIGxhYmVsOiAnUGluaWEg8J+NjScsXG4gICAgICAgIGxvZ286ICdodHRwczovL3BpbmlhLnZ1ZWpzLm9yZy9sb2dvLnN2ZycsXG4gICAgICAgIHBhY2thZ2VOYW1lOiAncGluaWEnLFxuICAgICAgICBob21lcGFnZTogJ2h0dHBzOi8vcGluaWEudnVlanMub3JnJyxcbiAgICAgICAgY29tcG9uZW50U3RhdGVUeXBlcyxcbiAgICAgICAgYXBwLFxuICAgIH0sIChhcGkpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcGkubm93ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0b2FzdE1lc3NhZ2UoJ1lvdSBzZWVtIHRvIGJlIHVzaW5nIGFuIG91dGRhdGVkIHZlcnNpb24gb2YgVnVlIERldnRvb2xzLiBBcmUgeW91IHN0aWxsIHVzaW5nIHRoZSBCZXRhIHJlbGVhc2UgaW5zdGVhZCBvZiB0aGUgc3RhYmxlIG9uZT8gWW91IGNhbiBmaW5kIHRoZSBsaW5rcyBhdCBodHRwczovL2RldnRvb2xzLnZ1ZWpzLm9yZy9ndWlkZS9pbnN0YWxsYXRpb24uaHRtbC4nKTtcbiAgICAgICAgfVxuICAgICAgICBhcGkuYWRkVGltZWxpbmVMYXllcih7XG4gICAgICAgICAgICBpZDogTVVUQVRJT05TX0xBWUVSX0lELFxuICAgICAgICAgICAgbGFiZWw6IGBQaW5pYSDwn42NYCxcbiAgICAgICAgICAgIGNvbG9yOiAweGU1ZGY4OCxcbiAgICAgICAgfSk7XG4gICAgICAgIGFwaS5hZGRJbnNwZWN0b3Ioe1xuICAgICAgICAgICAgaWQ6IElOU1BFQ1RPUl9JRCxcbiAgICAgICAgICAgIGxhYmVsOiAnUGluaWEg8J+NjScsXG4gICAgICAgICAgICBpY29uOiAnc3RvcmFnZScsXG4gICAgICAgICAgICB0cmVlRmlsdGVyUGxhY2Vob2xkZXI6ICdTZWFyY2ggc3RvcmVzJyxcbiAgICAgICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGljb246ICdjb250ZW50X2NvcHknLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkdsb2JhbENvcHlTdGF0ZShwaW5pYSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdTZXJpYWxpemUgYW5kIGNvcHkgdGhlIHN0YXRlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2NvbnRlbnRfcGFzdGUnLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGFjdGlvbkdsb2JhbFBhc3RlU3RhdGUocGluaWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JUcmVlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclN0YXRlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdSZXBsYWNlIHRoZSBzdGF0ZSB3aXRoIHRoZSBjb250ZW50IG9mIHlvdXIgY2xpcGJvYXJkJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ3NhdmUnLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkdsb2JhbFNhdmVTdGF0ZShwaW5pYSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdTYXZlIHRoZSBzdGF0ZSBhcyBhIEpTT04gZmlsZScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGljb246ICdmb2xkZXJfb3BlbicsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgYWN0aW9uR2xvYmFsT3BlblN0YXRlRmlsZShwaW5pYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclRyZWUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ0ltcG9ydCB0aGUgc3RhdGUgZnJvbSBhIEpTT04gZmlsZScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBub2RlQWN0aW9uczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ3Jlc3RvcmUnLFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiAnUmVzZXQgdGhlIHN0YXRlICh3aXRoIFwiJHJlc2V0XCIpJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAobm9kZUlkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHBpbmlhLl9zLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvYXN0TWVzc2FnZShgQ2Fubm90IHJlc2V0IFwiJHtub2RlSWR9XCIgc3RvcmUgYmVjYXVzZSBpdCB3YXNuJ3QgZm91bmQuYCwgJ3dhcm4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdG9yZS4kcmVzZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2FzdE1lc3NhZ2UoYENhbm5vdCByZXNldCBcIiR7bm9kZUlkfVwiIHN0b3JlIGJlY2F1c2UgaXQgZG9lc24ndCBoYXZlIGEgXCIkcmVzZXRcIiBtZXRob2QgaW1wbGVtZW50ZWQuYCwgJ3dhcm4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLiRyZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvYXN0TWVzc2FnZShgU3RvcmUgXCIke25vZGVJZH1cIiByZXNldC5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGFwaS5vbi5pbnNwZWN0Q29tcG9uZW50KChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gKHBheWxvYWQuY29tcG9uZW50SW5zdGFuY2UgJiZcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmNvbXBvbmVudEluc3RhbmNlLnByb3h5KTtcbiAgICAgICAgICAgIGlmIChwcm94eSAmJiBwcm94eS5fcFN0b3Jlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpbmlhU3RvcmVzID0gcGF5bG9hZC5jb21wb25lbnRJbnN0YW5jZS5wcm94eS5fcFN0b3JlcztcbiAgICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKHBpbmlhU3RvcmVzKS5mb3JFYWNoKChzdG9yZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmluc3RhbmNlRGF0YS5zdGF0ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGdldFN0b3JlVHlwZShzdG9yZS4kaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnc3RhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3RvcmUuX2lzT3B0aW9uc0FQSVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3VzdG9tOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG9SYXcoc3RvcmUuJHN0YXRlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb246ICdyZXN0b3JlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ1Jlc2V0IHRoZSBzdGF0ZSBvZiB0aGlzIHN0b3JlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAoKSA9PiBzdG9yZS4kcmVzZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAvLyBOT1RFOiB3b3JrYXJvdW5kIHRvIHVud3JhcCB0cmFuc2ZlcnJlZCByZWZzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0b3JlLiRzdGF0ZSkucmVkdWNlKChzdGF0ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVtrZXldID0gc3RvcmUuJHN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9yZS5fZ2V0dGVycyAmJiBzdG9yZS5fZ2V0dGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaW5zdGFuY2VEYXRhLnN0YXRlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGdldFN0b3JlVHlwZShzdG9yZS4kaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2dldHRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3RvcmUuX2dldHRlcnMucmVkdWNlKChnZXR0ZXJzLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldHRlcnNba2V5XSA9IHN0b3JlW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZSBqdXN0IHdhbnQgdG8gc2hvdyBpdCBpbiBkZXZ0b29sc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGVyc1trZXldID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldHRlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFwaS5vbi5nZXRJbnNwZWN0b3JUcmVlKChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5hcHAgPT09IGFwcCAmJiBwYXlsb2FkLmluc3BlY3RvcklkID09PSBJTlNQRUNUT1JfSUQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RvcmVzID0gW3BpbmlhXTtcbiAgICAgICAgICAgICAgICBzdG9yZXMgPSBzdG9yZXMuY29uY2F0KEFycmF5LmZyb20ocGluaWEuX3MudmFsdWVzKCkpKTtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnJvb3ROb2RlcyA9IChwYXlsb2FkLmZpbHRlclxuICAgICAgICAgICAgICAgICAgICA/IHN0b3Jlcy5maWx0ZXIoKHN0b3JlKSA9PiAnJGlkJyBpbiBzdG9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzdG9yZS4kaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbmNsdWRlcyhwYXlsb2FkLmZpbHRlci50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBQSU5JQV9ST09UX0xBQkVMLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocGF5bG9hZC5maWx0ZXIudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgICAgICAgICAgICAgIDogc3RvcmVzKS5tYXAoZm9ybWF0U3RvcmVGb3JJbnNwZWN0b3JUcmVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEV4cG9zZSBwaW5pYSBpbnN0YW5jZSBhcyAkcGluaWEgdG8gd2luZG93XG4gICAgICAgIGdsb2JhbFRoaXMuJHBpbmlhID0gcGluaWE7XG4gICAgICAgIGFwaS5vbi5nZXRJbnNwZWN0b3JTdGF0ZSgocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQuYXBwID09PSBhcHAgJiYgcGF5bG9hZC5pbnNwZWN0b3JJZCA9PT0gSU5TUEVDVE9SX0lEKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zcGVjdGVkU3RvcmUgPSBwYXlsb2FkLm5vZGVJZCA9PT0gUElOSUFfUk9PVF9JRFxuICAgICAgICAgICAgICAgICAgICA/IHBpbmlhXG4gICAgICAgICAgICAgICAgICAgIDogcGluaWEuX3MuZ2V0KHBheWxvYWQubm9kZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWluc3BlY3RlZFN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY291bGQgYmUgdGhlIHNlbGVjdGVkIHN0b3JlIHJlc3RvcmVkIGZvciBhIGRpZmZlcmVudCBwcm9qZWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGl0J3MgYmV0dGVyIG5vdCB0byBzYXkgYW55dGhpbmcgaGVyZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbnNwZWN0ZWRTdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHBvc2Ugc2VsZWN0ZWQgc3RvcmUgYXMgJHN0b3JlIHRvIHdpbmRvd1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5ub2RlSWQgIT09IFBJTklBX1JPT1RfSUQpXG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLiRzdG9yZSA9IHRvUmF3KGluc3BlY3RlZFN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5zdGF0ZSA9IGZvcm1hdFN0b3JlRm9ySW5zcGVjdG9yU3RhdGUoaW5zcGVjdGVkU3RvcmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFwaS5vbi5lZGl0SW5zcGVjdG9yU3RhdGUoKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQuYXBwID09PSBhcHAgJiYgcGF5bG9hZC5pbnNwZWN0b3JJZCA9PT0gSU5TUEVDVE9SX0lEKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zcGVjdGVkU3RvcmUgPSBwYXlsb2FkLm5vZGVJZCA9PT0gUElOSUFfUk9PVF9JRFxuICAgICAgICAgICAgICAgICAgICA/IHBpbmlhXG4gICAgICAgICAgICAgICAgICAgIDogcGluaWEuX3MuZ2V0KHBheWxvYWQubm9kZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWluc3BlY3RlZFN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2FzdE1lc3NhZ2UoYHN0b3JlIFwiJHtwYXlsb2FkLm5vZGVJZH1cIiBub3QgZm91bmRgLCAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXRoIH0gPSBwYXlsb2FkO1xuICAgICAgICAgICAgICAgIGlmICghaXNQaW5pYShpbnNwZWN0ZWRTdG9yZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXNzIG9ubHkgdGhlIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWluc3BlY3RlZFN0b3JlLl9jdXN0b21Qcm9wZXJ0aWVzLmhhcyhwYXRoWzBdKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFswXSBpbiBpbnNwZWN0ZWRTdG9yZS4kc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgudW5zaGlmdCgnJHN0YXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJvb3QgYWNjZXNzLCB3ZSBjYW4gb21pdCB0aGUgYC52YWx1ZWAgYmVjYXVzZSB0aGUgZGV2dG9vbHMgQVBJIGRvZXMgaXQgZm9yIHVzXG4gICAgICAgICAgICAgICAgICAgIHBhdGgudW5zaGlmdCgnc3RhdGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXNUaW1lbGluZUFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHBheWxvYWQuc2V0KGluc3BlY3RlZFN0b3JlLCBwYXRoLCBwYXlsb2FkLnN0YXRlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpc1RpbWVsaW5lQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFwaS5vbi5lZGl0Q29tcG9uZW50U3RhdGUoKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLnR5cGUuc3RhcnRzV2l0aCgn8J+NjScpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmVJZCA9IHBheWxvYWQudHlwZS5yZXBsYWNlKC9e8J+NjVxccyovLCAnJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSBwaW5pYS5fcy5nZXQoc3RvcmVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9hc3RNZXNzYWdlKGBzdG9yZSBcIiR7c3RvcmVJZH1cIiBub3QgZm91bmRgLCAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXRoIH0gPSBwYXlsb2FkO1xuICAgICAgICAgICAgICAgIGlmIChwYXRoWzBdICE9PSAnc3RhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2FzdE1lc3NhZ2UoYEludmFsaWQgcGF0aCBmb3Igc3RvcmUgXCIke3N0b3JlSWR9XCI6XFxuJHtwYXRofVxcbk9ubHkgc3RhdGUgY2FuIGJlIG1vZGlmaWVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZXdyaXRlIHRoZSBmaXJzdCBlbnRyeSB0byBiZSBhYmxlIHRvIGRpcmVjdGx5IHNldCB0aGUgc3RhdGUgYXNcbiAgICAgICAgICAgICAgICAvLyB3ZWxsIGFzIGFueSBvdGhlciBwYXRoXG4gICAgICAgICAgICAgICAgcGF0aFswXSA9ICckc3RhdGUnO1xuICAgICAgICAgICAgICAgIGlzVGltZWxpbmVBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnNldChzdG9yZSwgcGF0aCwgcGF5bG9hZC5zdGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaXNUaW1lbGluZUFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYWRkU3RvcmVUb0RldnRvb2xzKGFwcCwgc3RvcmUpIHtcbiAgICBpZiAoIWNvbXBvbmVudFN0YXRlVHlwZXMuaW5jbHVkZXMoZ2V0U3RvcmVUeXBlKHN0b3JlLiRpZCkpKSB7XG4gICAgICAgIGNvbXBvbmVudFN0YXRlVHlwZXMucHVzaChnZXRTdG9yZVR5cGUoc3RvcmUuJGlkKSk7XG4gICAgfVxuICAgIHNldHVwRGV2dG9vbHNQbHVnaW4oe1xuICAgICAgICBpZDogJ2Rldi5lc20ucGluaWEnLFxuICAgICAgICBsYWJlbDogJ1BpbmlhIPCfjY0nLFxuICAgICAgICBsb2dvOiAnaHR0cHM6Ly9waW5pYS52dWVqcy5vcmcvbG9nby5zdmcnLFxuICAgICAgICBwYWNrYWdlTmFtZTogJ3BpbmlhJyxcbiAgICAgICAgaG9tZXBhZ2U6ICdodHRwczovL3BpbmlhLnZ1ZWpzLm9yZycsXG4gICAgICAgIGNvbXBvbmVudFN0YXRlVHlwZXMsXG4gICAgICAgIGFwcCxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxvZ1N0b3JlQ2hhbmdlczoge1xuICAgICAgICAgICAgICAgIGxhYmVsOiAnTm90aWZ5IGFib3V0IG5ldy9kZWxldGVkIHN0b3JlcycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyB1c2VFbW9qaXM6IHtcbiAgICAgICAgICAgIC8vICAgbGFiZWw6ICdVc2UgZW1vamlzIGluIG1lc3NhZ2VzIOKaoe+4jycsXG4gICAgICAgICAgICAvLyAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgIC8vICAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgLy8gfSxcbiAgICAgICAgfSxcbiAgICB9LCAoYXBpKSA9PiB7XG4gICAgICAgIC8vIGdyYWNlZnVsbHkgaGFuZGxlIGVycm9yc1xuICAgICAgICBjb25zdCBub3cgPSB0eXBlb2YgYXBpLm5vdyA9PT0gJ2Z1bmN0aW9uJyA/IGFwaS5ub3cuYmluZChhcGkpIDogRGF0ZS5ub3c7XG4gICAgICAgIHN0b3JlLiRvbkFjdGlvbigoeyBhZnRlciwgb25FcnJvciwgbmFtZSwgYXJncyB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBncm91cElkID0gcnVubmluZ0FjdGlvbklkKys7XG4gICAgICAgICAgICBhcGkuYWRkVGltZWxpbmVFdmVudCh7XG4gICAgICAgICAgICAgICAgbGF5ZXJJZDogTVVUQVRJT05TX0xBWUVSX0lELFxuICAgICAgICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5vdygpLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ/Cfm6sgJyArIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlOiAnc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZTogZm9ybWF0RGlzcGxheShzdG9yZS4kaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmb3JtYXREaXNwbGF5KG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhZnRlcigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlQWN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZDogTVVUQVRJT05TX0xBWUVSX0lELFxuICAgICAgICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogbm93KCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ/Cfm6wgJyArIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZTogJ2VuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmU6IGZvcm1hdERpc3BsYXkoc3RvcmUuJGlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGZvcm1hdERpc3BsYXkobmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb25FcnJvcigoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBhY3RpdmVBY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYXBpLmFkZFRpbWVsaW5lRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBsYXllcklkOiBNVVRBVElPTlNfTEFZRVJfSUQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBub3coKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ1R5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ/CfkqUgJyArIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZTogJ2VuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmU6IGZvcm1hdERpc3BsYXkoc3RvcmUuJGlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGZvcm1hdERpc3BsYXkobmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cElkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBzdG9yZS5fY3VzdG9tUHJvcGVydGllcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICB3YXRjaCgoKSA9PiB1bnJlZihzdG9yZVtuYW1lXSksIChuZXdWYWx1ZSwgb2xkVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBhcGkubm90aWZ5Q29tcG9uZW50VXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JTdGF0ZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICAgICAgICAgIGlmIChpc1RpbWVsaW5lQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVySWQ6IE1VVEFUSU9OU19MQVlFUl9JRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogbm93KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdDaGFuZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZDogYWN0aXZlQWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgeyBkZWVwOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RvcmUuJHN1YnNjcmliZSgoeyBldmVudHMsIHR5cGUgfSwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgIGFwaS5ub3RpZnlDb21wb25lbnRVcGRhdGUoKTtcbiAgICAgICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgICAgIGlmICghaXNUaW1lbGluZUFjdGl2ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyByb290U3RvcmUuc3RhdGVbc3RvcmUuaWRdID0gc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IHtcbiAgICAgICAgICAgICAgICB0aW1lOiBub3coKSxcbiAgICAgICAgICAgICAgICB0aXRsZTogZm9ybWF0TXV0YXRpb25UeXBlKHR5cGUpLFxuICAgICAgICAgICAgICAgIGRhdGE6IGFzc2lnbiQxKHsgc3RvcmU6IGZvcm1hdERpc3BsYXkoc3RvcmUuJGlkKSB9LCBmb3JtYXRFdmVudERhdGEoZXZlbnRzKSksXG4gICAgICAgICAgICAgICAgZ3JvdXBJZDogYWN0aXZlQWN0aW9uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBNdXRhdGlvblR5cGUucGF0Y2hGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGV2ZW50RGF0YS5zdWJ0aXRsZSA9ICfipLXvuI8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gTXV0YXRpb25UeXBlLnBhdGNoT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZXZlbnREYXRhLnN1YnRpdGxlID0gJ/Cfp6knO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRzICYmICFBcnJheS5pc0FycmF5KGV2ZW50cykpIHtcbiAgICAgICAgICAgICAgICBldmVudERhdGEuc3VidGl0bGUgPSBldmVudHMudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgICAgICAgICBldmVudERhdGEuZGF0YVsncmF3RXZlbnQocyknXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgX2N1c3RvbToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ0RlYnVnZ2VyRXZlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiAncmF3IERlYnVnZ2VyRXZlbnRbXScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcGkuYWRkVGltZWxpbmVFdmVudCh7XG4gICAgICAgICAgICAgICAgbGF5ZXJJZDogTVVUQVRJT05TX0xBWUVSX0lELFxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudERhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgeyBkZXRhY2hlZDogdHJ1ZSwgZmx1c2g6ICdzeW5jJyB9KTtcbiAgICAgICAgY29uc3QgaG90VXBkYXRlID0gc3RvcmUuX2hvdFVwZGF0ZTtcbiAgICAgICAgc3RvcmUuX2hvdFVwZGF0ZSA9IG1hcmtSYXcoKG5ld1N0b3JlKSA9PiB7XG4gICAgICAgICAgICBob3RVcGRhdGUobmV3U3RvcmUpO1xuICAgICAgICAgICAgYXBpLmFkZFRpbWVsaW5lRXZlbnQoe1xuICAgICAgICAgICAgICAgIGxheWVySWQ6IE1VVEFUSU9OU19MQVlFUl9JRCxcbiAgICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiBub3coKSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICfwn5SlICcgKyBzdG9yZS4kaWQsXG4gICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlOiAnSE1SIHVwZGF0ZScsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlOiBmb3JtYXREaXNwbGF5KHN0b3JlLiRpZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvOiBmb3JtYXREaXNwbGF5KGBITVIgdXBkYXRlYCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBkZXZ0b29scyB0b29cbiAgICAgICAgICAgIGFwaS5ub3RpZnlDb21wb25lbnRVcGRhdGUoKTtcbiAgICAgICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yVHJlZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JTdGF0ZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyAkZGlzcG9zZSB9ID0gc3RvcmU7XG4gICAgICAgIHN0b3JlLiRkaXNwb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgJGRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGFwaS5ub3RpZnlDb21wb25lbnRVcGRhdGUoKTtcbiAgICAgICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yVHJlZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JTdGF0ZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICAgICAgYXBpLmdldFNldHRpbmdzKCkubG9nU3RvcmVDaGFuZ2VzICYmXG4gICAgICAgICAgICAgICAgdG9hc3RNZXNzYWdlKGBEaXNwb3NlZCBcIiR7c3RvcmUuJGlkfVwiIHN0b3JlIPCfl5FgKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdHJpZ2dlciBhbiB1cGRhdGUgc28gaXQgY2FuIGRpc3BsYXkgbmV3IHJlZ2lzdGVyZWQgc3RvcmVzXG4gICAgICAgIGFwaS5ub3RpZnlDb21wb25lbnRVcGRhdGUoKTtcbiAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JUcmVlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgYXBpLmdldFNldHRpbmdzKCkubG9nU3RvcmVDaGFuZ2VzICYmXG4gICAgICAgICAgICB0b2FzdE1lc3NhZ2UoYFwiJHtzdG9yZS4kaWR9XCIgc3RvcmUgaW5zdGFsbGVkIPCfhpVgKTtcbiAgICB9KTtcbn1cbmxldCBydW5uaW5nQWN0aW9uSWQgPSAwO1xubGV0IGFjdGl2ZUFjdGlvbjtcbi8qKlxuICogUGF0Y2hlcyBhIHN0b3JlIHRvIGVuYWJsZSBhY3Rpb24gZ3JvdXBpbmcgaW4gZGV2dG9vbHMgYnkgd3JhcHBpbmcgdGhlIHN0b3JlIHdpdGggYSBQcm94eSB0aGF0IGlzIHBhc3NlZCBhcyB0aGVcbiAqIGNvbnRleHQgb2YgYWxsIGFjdGlvbnMsIGFsbG93aW5nIHVzIHRvIHNldCBgcnVubmluZ0FjdGlvbmAgb24gZWFjaCBhY2Nlc3MgYW5kIGVmZmVjdGl2ZWx5IGFzc29jaWF0aW5nIGFueSBzdGF0ZVxuICogbXV0YXRpb24gdG8gdGhlIGFjdGlvbi5cbiAqXG4gKiBAcGFyYW0gc3RvcmUgLSBzdG9yZSB0byBwYXRjaFxuICogQHBhcmFtIGFjdGlvbk5hbWVzIC0gbGlzdCBvZiBhY3Rpb25zdCB0byBwYXRjaFxuICovXG5mdW5jdGlvbiBwYXRjaEFjdGlvbkZvckdyb3VwaW5nKHN0b3JlLCBhY3Rpb25OYW1lcywgd3JhcFdpdGhQcm94eSkge1xuICAgIC8vIG9yaWdpbmFsIGFjdGlvbnMgb2YgdGhlIHN0b3JlIGFzIHRoZXkgYXJlIGdpdmVuIGJ5IHBpbmlhLiBXZSBhcmUgZ29pbmcgdG8gb3ZlcnJpZGUgdGhlbVxuICAgIGNvbnN0IGFjdGlvbnMgPSBhY3Rpb25OYW1lcy5yZWR1Y2UoKHN0b3JlQWN0aW9ucywgYWN0aW9uTmFtZSkgPT4ge1xuICAgICAgICAvLyB1c2UgdG9SYXcgdG8gYXZvaWQgdHJhY2tpbmcgIzU0MVxuICAgICAgICBzdG9yZUFjdGlvbnNbYWN0aW9uTmFtZV0gPSB0b1JhdyhzdG9yZSlbYWN0aW9uTmFtZV07XG4gICAgICAgIHJldHVybiBzdG9yZUFjdGlvbnM7XG4gICAgfSwge30pO1xuICAgIGZvciAoY29uc3QgYWN0aW9uTmFtZSBpbiBhY3Rpb25zKSB7XG4gICAgICAgIHN0b3JlW2FjdGlvbk5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gdGhlIHJ1bm5pbmcgYWN0aW9uIGlkIGlzIGluY3JlbWVudGVkIGluIGEgYmVmb3JlIGFjdGlvbiBob29rXG4gICAgICAgICAgICBjb25zdCBfYWN0aW9uSWQgPSBydW5uaW5nQWN0aW9uSWQ7XG4gICAgICAgICAgICBjb25zdCB0cmFja2VkU3RvcmUgPSB3cmFwV2l0aFByb3h5XG4gICAgICAgICAgICAgICAgPyBuZXcgUHJveHkoc3RvcmUsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0KC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUFjdGlvbiA9IF9hY3Rpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0KC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUFjdGlvbiA9IF9hY3Rpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LnNldCguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIDogc3RvcmU7XG4gICAgICAgICAgICAvLyBGb3IgU2V0dXAgU3RvcmVzIHdlIG5lZWQgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXN5bmMtY29udGV4dFxuICAgICAgICAgICAgYWN0aXZlQWN0aW9uID0gX2FjdGlvbklkO1xuICAgICAgICAgICAgY29uc3QgcmV0VmFsdWUgPSBhY3Rpb25zW2FjdGlvbk5hbWVdLmFwcGx5KHRyYWNrZWRTdG9yZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgc2FmZXIgYXMgYXN5bmMgYWN0aW9ucyBpbiBTZXR1cCBTdG9yZXMgd291bGQgYXNzb2NpYXRlIG11dGF0aW9ucyBkb25lIG91dHNpZGUgb2YgdGhlIGFjdGlvblxuICAgICAgICAgICAgYWN0aXZlQWN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIHJldFZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogcGluaWEudXNlKGRldnRvb2xzUGx1Z2luKVxuICovXG5mdW5jdGlvbiBkZXZ0b29sc1BsdWdpbih7IGFwcCwgc3RvcmUsIG9wdGlvbnMgfSkge1xuICAgIC8vIEhNUiBtb2R1bGVcbiAgICBpZiAoc3RvcmUuJGlkLnN0YXJ0c1dpdGgoJ19faG90OicpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZGV0ZWN0IG9wdGlvbiBhcGkgdnMgc2V0dXAgYXBpXG4gICAgc3RvcmUuX2lzT3B0aW9uc0FQSSA9ICEhb3B0aW9ucy5zdGF0ZTtcbiAgICAvLyBEbyBub3Qgb3ZlcndyaXRlIGFjdGlvbnMgbW9ja2VkIGJ5IEBwaW5pYS90ZXN0aW5nICgjMjI5OClcbiAgICBpZiAoIXN0b3JlLl9wLl90ZXN0aW5nKSB7XG4gICAgICAgIHBhdGNoQWN0aW9uRm9yR3JvdXBpbmcoc3RvcmUsIE9iamVjdC5rZXlzKG9wdGlvbnMuYWN0aW9ucyksIHN0b3JlLl9pc09wdGlvbnNBUEkpO1xuICAgICAgICAvLyBVcGdyYWRlIHRoZSBITVIgdG8gYWxzbyB1cGRhdGUgdGhlIG5ldyBhY3Rpb25zXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSG90VXBkYXRlID0gc3RvcmUuX2hvdFVwZGF0ZTtcbiAgICAgICAgdG9SYXcoc3RvcmUpLl9ob3RVcGRhdGUgPSBmdW5jdGlvbiAobmV3U3RvcmUpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsSG90VXBkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBwYXRjaEFjdGlvbkZvckdyb3VwaW5nKHN0b3JlLCBPYmplY3Qua2V5cyhuZXdTdG9yZS5faG1yUGF5bG9hZC5hY3Rpb25zKSwgISFzdG9yZS5faXNPcHRpb25zQVBJKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYWRkU3RvcmVUb0RldnRvb2xzKGFwcCwgXG4gICAgLy8gRklYTUU6IGlzIHRoZXJlIGEgd2F5IHRvIGFsbG93IHRoZSBhc3NpZ25tZW50IGZyb20gU3RvcmU8SWQsIFMsIEcsIEE+IHRvIFN0b3JlR2VuZXJpYz9cbiAgICBzdG9yZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFBpbmlhIGluc3RhbmNlIHRvIGJlIHVzZWQgYnkgdGhlIGFwcGxpY2F0aW9uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBpbmlhKCkge1xuICAgIGNvbnN0IHNjb3BlID0gZWZmZWN0U2NvcGUodHJ1ZSk7XG4gICAgLy8gTk9URTogaGVyZSB3ZSBjb3VsZCBjaGVjayB0aGUgd2luZG93IG9iamVjdCBmb3IgYSBzdGF0ZSBhbmQgZGlyZWN0bHkgc2V0IGl0XG4gICAgLy8gaWYgdGhlcmUgaXMgYW55dGhpbmcgbGlrZSBpdCB3aXRoIFZ1ZSAzIFNTUlxuICAgIGNvbnN0IHN0YXRlID0gc2NvcGUucnVuKCgpID0+IHJlZih7fSkpO1xuICAgIGxldCBfcCA9IFtdO1xuICAgIC8vIHBsdWdpbnMgYWRkZWQgYmVmb3JlIGNhbGxpbmcgYXBwLnVzZShwaW5pYSlcbiAgICBsZXQgdG9CZUluc3RhbGxlZCA9IFtdO1xuICAgIGNvbnN0IHBpbmlhID0gbWFya1Jhdyh7XG4gICAgICAgIGluc3RhbGwoYXBwKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGFsbG93cyBjYWxsaW5nIHVzZVN0b3JlKCkgb3V0c2lkZSBvZiBhIGNvbXBvbmVudCBzZXR1cCBhZnRlclxuICAgICAgICAgICAgLy8gaW5zdGFsbGluZyBwaW5pYSdzIHBsdWdpblxuICAgICAgICAgICAgc2V0QWN0aXZlUGluaWEocGluaWEpO1xuICAgICAgICAgICAgaWYgKCFpc1Z1ZTIpIHtcbiAgICAgICAgICAgICAgICBwaW5pYS5fYSA9IGFwcDtcbiAgICAgICAgICAgICAgICBhcHAucHJvdmlkZShwaW5pYVN5bWJvbCwgcGluaWEpO1xuICAgICAgICAgICAgICAgIGFwcC5jb25maWcuZ2xvYmFsUHJvcGVydGllcy4kcGluaWEgPSBwaW5pYTtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmICgoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgX19WVUVfUFJPRF9ERVZUT09MU19fKSkgJiYgIShwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSkgJiYgSVNfQ0xJRU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyUGluaWFEZXZ0b29scyhhcHAsIHBpbmlhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9CZUluc3RhbGxlZC5mb3JFYWNoKChwbHVnaW4pID0+IF9wLnB1c2gocGx1Z2luKSk7XG4gICAgICAgICAgICAgICAgdG9CZUluc3RhbGxlZCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1c2UocGx1Z2luKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2EgJiYgIWlzVnVlMikge1xuICAgICAgICAgICAgICAgIHRvQmVJbnN0YWxsZWQucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3AucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIF9wLFxuICAgICAgICAvLyBpdCdzIGFjdHVhbGx5IHVuZGVmaW5lZCBoZXJlXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgX2E6IG51bGwsXG4gICAgICAgIF9lOiBzY29wZSxcbiAgICAgICAgX3M6IG5ldyBNYXAoKSxcbiAgICAgICAgc3RhdGUsXG4gICAgfSk7XG4gICAgLy8gcGluaWEgZGV2dG9vbHMgcmVseSBvbiBkZXYgb25seSBmZWF0dXJlcyBzbyB0aGV5IGNhbm5vdCBiZSBmb3JjZWQgdW5sZXNzXG4gICAgLy8gdGhlIGRldiBidWlsZCBvZiBWdWUgaXMgdXNlZC4gQXZvaWQgb2xkIGJyb3dzZXJzIGxpa2UgSUUxMS5cbiAgICBpZiAoKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgKHR5cGVvZiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18gIT09ICd1bmRlZmluZWQnICYmIF9fVlVFX1BST0RfREVWVE9PTFNfXykpICYmICEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0JykpICYmIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGluaWEudXNlKGRldnRvb2xzUGx1Z2luKTtcbiAgICB9XG4gICAgcmV0dXJuIHBpbmlhO1xufVxuLyoqXG4gKiBEaXNwb3NlIGEgUGluaWEgaW5zdGFuY2UgYnkgc3RvcHBpbmcgaXRzIGVmZmVjdFNjb3BlIGFuZCByZW1vdmluZyB0aGUgc3RhdGUsIHBsdWdpbnMgYW5kIHN0b3Jlcy4gVGhpcyBpcyBtb3N0bHlcbiAqIHVzZWZ1bCBpbiB0ZXN0cywgd2l0aCBib3RoIGEgdGVzdGluZyBwaW5pYSBvciBhIHJlZ3VsYXIgcGluaWEgYW5kIGluIGFwcGxpY2F0aW9ucyB0aGF0IHVzZSBtdWx0aXBsZSBwaW5pYSBpbnN0YW5jZXMuXG4gKiBPbmNlIGRpc3Bvc2VkLCB0aGUgcGluaWEgaW5zdGFuY2UgY2Fubm90IGJlIHVzZWQgYW55bW9yZS5cbiAqXG4gKiBAcGFyYW0gcGluaWEgLSBwaW5pYSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBkaXNwb3NlUGluaWEocGluaWEpIHtcbiAgICBwaW5pYS5fZS5zdG9wKCk7XG4gICAgcGluaWEuX3MuY2xlYXIoKTtcbiAgICBwaW5pYS5fcC5zcGxpY2UoMCk7XG4gICAgcGluaWEuc3RhdGUudmFsdWUgPSB7fTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBub24gdmFsaWRcbiAgICBwaW5pYS5fYSA9IG51bGw7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZnVuY3Rpb24gaXMgYSBgU3RvcmVEZWZpbml0aW9uYC5cbiAqXG4gKiBAcGFyYW0gZm4gLSBvYmplY3QgdG8gdGVzdFxuICogQHJldHVybnMgdHJ1ZSBpZiBgZm5gIGlzIGEgU3RvcmVEZWZpbml0aW9uXG4gKi9cbmNvbnN0IGlzVXNlU3RvcmUgPSAoZm4pID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBmbi4kaWQgPT09ICdzdHJpbmcnO1xufTtcbi8qKlxuICogTXV0YXRlcyBpbiBwbGFjZSBgbmV3U3RhdGVgIHdpdGggYG9sZFN0YXRlYCB0byBfaG90IHVwZGF0ZV8gaXQuIEl0IHdpbGxcbiAqIHJlbW92ZSBhbnkga2V5IG5vdCBleGlzdGluZyBpbiBgbmV3U3RhdGVgIGFuZCByZWN1cnNpdmVseSBtZXJnZSBwbGFpblxuICogb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gbmV3U3RhdGUgLSBuZXcgc3RhdGUgb2JqZWN0IHRvIGJlIHBhdGNoZWRcbiAqIEBwYXJhbSBvbGRTdGF0ZSAtIG9sZCBzdGF0ZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHBhdGNoIG5ld1N0YXRlXG4gKiBAcmV0dXJucyAtIG5ld1N0YXRlXG4gKi9cbmZ1bmN0aW9uIHBhdGNoT2JqZWN0KG5ld1N0YXRlLCBvbGRTdGF0ZSkge1xuICAgIC8vIG5vIG5lZWQgdG8gZ28gdGhyb3VnaCBzeW1ib2xzIGJlY2F1c2UgdGhleSBjYW5ub3QgYmUgc2VyaWFsaXplZCBhbnl3YXlcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRTdGF0ZSkge1xuICAgICAgICBjb25zdCBzdWJQYXRjaCA9IG9sZFN0YXRlW2tleV07XG4gICAgICAgIC8vIHNraXAgdGhlIHdob2xlIHN1YiB0cmVlXG4gICAgICAgIGlmICghKGtleSBpbiBuZXdTdGF0ZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gbmV3U3RhdGVba2V5XTtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0VmFsdWUpICYmXG4gICAgICAgICAgICBpc1BsYWluT2JqZWN0KHN1YlBhdGNoKSAmJlxuICAgICAgICAgICAgIWlzUmVmKHN1YlBhdGNoKSAmJlxuICAgICAgICAgICAgIWlzUmVhY3RpdmUoc3ViUGF0Y2gpKSB7XG4gICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gcGF0Y2hPYmplY3QodGFyZ2V0VmFsdWUsIHN1YlBhdGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG9iamVjdHMgYXJlIGVpdGhlciBhIGJpdCBtb3JlIGNvbXBsZXggKGUuZy4gcmVmcykgb3IgcHJpbWl0aXZlcywgc28gd2VcbiAgICAgICAgICAgIC8vIGp1c3Qgc2V0IHRoZSB3aG9sZSB0aGluZ1xuICAgICAgICAgICAgaWYgKGlzVnVlMikge1xuICAgICAgICAgICAgICAgIHNldChuZXdTdGF0ZSwga2V5LCBzdWJQYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gc3ViUGF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIF9hY2NlcHRfIGZ1bmN0aW9uIHRvIHBhc3MgdG8gYGltcG9ydC5tZXRhLmhvdGAgaW4gVml0ZSBhcHBsaWNhdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCB1c2VVc2VyID0gZGVmaW5lU3RvcmUoLi4uKVxuICogaWYgKGltcG9ydC5tZXRhLmhvdCkge1xuICogICBpbXBvcnQubWV0YS5ob3QuYWNjZXB0KGFjY2VwdEhNUlVwZGF0ZSh1c2VVc2VyLCBpbXBvcnQubWV0YS5ob3QpKVxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGluaXRpYWxVc2VTdG9yZSAtIHJldHVybiBvZiB0aGUgZGVmaW5lU3RvcmUgdG8gaG90IHVwZGF0ZVxuICogQHBhcmFtIGhvdCAtIGBpbXBvcnQubWV0YS5ob3RgXG4gKi9cbmZ1bmN0aW9uIGFjY2VwdEhNUlVwZGF0ZShpbml0aWFsVXNlU3RvcmUsIGhvdCkge1xuICAgIC8vIHN0cmlwIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpaWZlLnByb2RcbiAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuICAgIH1cbiAgICByZXR1cm4gKG5ld01vZHVsZSkgPT4ge1xuICAgICAgICBjb25zdCBwaW5pYSA9IGhvdC5kYXRhLnBpbmlhIHx8IGluaXRpYWxVc2VTdG9yZS5fcGluaWE7XG4gICAgICAgIGlmICghcGluaWEpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgc3RvcmUgaXMgc3RpbGwgbm90IHVzZWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmVzZXJ2ZSB0aGUgcGluaWEgaW5zdGFuY2UgYWNyb3NzIGxvYWRzXG4gICAgICAgIGhvdC5kYXRhLnBpbmlhID0gcGluaWE7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdnb3QgZGF0YScsIG5ld1N0b3JlKVxuICAgICAgICBmb3IgKGNvbnN0IGV4cG9ydE5hbWUgaW4gbmV3TW9kdWxlKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VTdG9yZSA9IG5ld01vZHVsZVtleHBvcnROYW1lXTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjaGVja2luZyBmb3InLCBleHBvcnROYW1lKVxuICAgICAgICAgICAgaWYgKGlzVXNlU3RvcmUodXNlU3RvcmUpICYmIHBpbmlhLl9zLmhhcyh1c2VTdG9yZS4kaWQpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0FjY2VwdGluZyB1cGRhdGUgZm9yJywgdXNlU3RvcmUuJGlkKVxuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gdXNlU3RvcmUuJGlkO1xuICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gaW5pdGlhbFVzZVN0b3JlLiRpZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoZSBpZCBvZiB0aGUgc3RvcmUgY2hhbmdlZCBmcm9tIFwiJHtpbml0aWFsVXNlU3RvcmUuJGlkfVwiIHRvIFwiJHtpZH1cIi4gUmVsb2FkaW5nLmApO1xuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gaW1wb3J0Lm1ldGEuaG90LmludmFsaWRhdGUoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaG90LmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdTdG9yZSA9IHBpbmlhLl9zLmdldChpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZ1N0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbUGluaWFdOiBza2lwcGluZyBobXIgYmVjYXVzZSBzdG9yZSBkb2Vzbid0IGV4aXN0IHlldGApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVzZVN0b3JlKHBpbmlhLCBleGlzdGluZ1N0b3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG5mdW5jdGlvbiBhZGRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9ucywgY2FsbGJhY2ssIGRldGFjaGVkLCBvbkNsZWFudXAgPSBub29wKSB7XG4gICAgc3Vic2NyaXB0aW9ucy5wdXNoKGNhbGxiYWNrKTtcbiAgICBjb25zdCByZW1vdmVTdWJzY3JpcHRpb24gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHN1YnNjcmlwdGlvbnMuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIG9uQ2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoIWRldGFjaGVkICYmIGdldEN1cnJlbnRTY29wZSgpKSB7XG4gICAgICAgIG9uU2NvcGVEaXNwb3NlKHJlbW92ZVN1YnNjcmlwdGlvbik7XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVTdWJzY3JpcHRpb247XG59XG5mdW5jdGlvbiB0cmlnZ2VyU3Vic2NyaXB0aW9ucyhzdWJzY3JpcHRpb25zLCAuLi5hcmdzKSB7XG4gICAgc3Vic2NyaXB0aW9ucy5zbGljZSgpLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgIH0pO1xufVxuXG5jb25zdCBmYWxsYmFja1J1bldpdGhDb250ZXh0ID0gKGZuKSA9PiBmbigpO1xuLyoqXG4gKiBNYXJrcyBhIGZ1bmN0aW9uIGFzIGFuIGFjdGlvbiBmb3IgYCRvbkFjdGlvbmBcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBBQ1RJT05fTUFSS0VSID0gU3ltYm9sKCk7XG4vKipcbiAqIEFjdGlvbiBuYW1lIHN5bWJvbC4gQWxsb3dzIHRvIGFkZCBhIG5hbWUgdG8gYW4gYWN0aW9uIGFmdGVyIGRlZmluaW5nIGl0XG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQUNUSU9OX05BTUUgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIG1lcmdlUmVhY3RpdmVPYmplY3RzKHRhcmdldCwgcGF0Y2hUb0FwcGx5KSB7XG4gICAgLy8gSGFuZGxlIE1hcCBpbnN0YW5jZXNcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWFwICYmIHBhdGNoVG9BcHBseSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBwYXRjaFRvQXBwbHkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdGFyZ2V0LnNldChrZXksIHZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFNldCAmJiBwYXRjaFRvQXBwbHkgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgLy8gSGFuZGxlIFNldCBpbnN0YW5jZXNcbiAgICAgICAgcGF0Y2hUb0FwcGx5LmZvckVhY2godGFyZ2V0LmFkZCwgdGFyZ2V0KTtcbiAgICB9XG4gICAgLy8gbm8gbmVlZCB0byBnbyB0aHJvdWdoIHN5bWJvbHMgYmVjYXVzZSB0aGV5IGNhbm5vdCBiZSBzZXJpYWxpemVkIGFueXdheVxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoVG9BcHBseSkge1xuICAgICAgICBpZiAoIXBhdGNoVG9BcHBseS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHN1YlBhdGNoID0gcGF0Y2hUb0FwcGx5W2tleV07XG4gICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldFZhbHVlKSAmJlxuICAgICAgICAgICAgaXNQbGFpbk9iamVjdChzdWJQYXRjaCkgJiZcbiAgICAgICAgICAgIHRhcmdldC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgICAgICAgICAhaXNSZWYoc3ViUGF0Y2gpICYmXG4gICAgICAgICAgICAhaXNSZWFjdGl2ZShzdWJQYXRjaCkpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IGhlcmUgSSB3YW50ZWQgdG8gd2FybiBhYm91dCBpbmNvbnNpc3RlbnQgdHlwZXMgYnV0IGl0J3Mgbm90IHBvc3NpYmxlIGJlY2F1c2UgaW4gc2V0dXAgc3RvcmVzIG9uZSBtaWdodFxuICAgICAgICAgICAgLy8gc3RhcnQgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgYXMgYSBjZXJ0YWluIHR5cGUgZS5nLiBhIE1hcCwgYW5kIHRoZW4gZm9yIHNvbWUgcmVhc29uLCBkdXJpbmcgU1NSLCBjaGFuZ2UgdGhhdFxuICAgICAgICAgICAgLy8gdG8gYHVuZGVmaW5lZGAuIFdoZW4gdHJ5aW5nIHRvIGh5ZHJhdGUsIHdlIHdhbnQgdG8gb3ZlcnJpZGUgdGhlIE1hcCB3aXRoIGB1bmRlZmluZWRgLlxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZVJlYWN0aXZlT2JqZWN0cyh0YXJnZXRWYWx1ZSwgc3ViUGF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogc3ViUGF0Y2ggaXMgYSB2YWxpZCB2YWx1ZVxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzdWJQYXRjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuY29uc3Qgc2tpcEh5ZHJhdGVTeW1ib2wgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICA/IFN5bWJvbCgncGluaWE6c2tpcEh5ZHJhdGlvbicpXG4gICAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBTeW1ib2woKTtcbmNvbnN0IHNraXBIeWRyYXRlTWFwID0gLyojX19QVVJFX18qLyBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBUZWxscyBQaW5pYSB0byBza2lwIHRoZSBoeWRyYXRpb24gcHJvY2VzcyBvZiBhIGdpdmVuIG9iamVjdC4gVGhpcyBpcyB1c2VmdWwgaW4gc2V0dXAgc3RvcmVzIChvbmx5KSB3aGVuIHlvdSByZXR1cm4gYVxuICogc3RhdGVmdWwgb2JqZWN0IGluIHRoZSBzdG9yZSBidXQgaXQgaXNuJ3QgcmVhbGx5IHN0YXRlLiBlLmcuIHJldHVybmluZyBhIHJvdXRlciBpbnN0YW5jZSBpbiBhIHNldHVwIHN0b3JlLlxuICpcbiAqIEBwYXJhbSBvYmogLSB0YXJnZXQgb2JqZWN0XG4gKiBAcmV0dXJucyBvYmpcbiAqL1xuZnVuY3Rpb24gc2tpcEh5ZHJhdGUob2JqKSB7XG4gICAgcmV0dXJuIGlzVnVlMlxuICAgICAgICA/IC8vIGluIEB2dWUvY29tcG9zaXRpb24tYXBpLCB0aGUgcmVmcyBhcmUgc2VhbGVkIHNvIGRlZmluZVByb3BlcnR5IGRvZXNuJ3Qgd29yay4uLlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gc2tpcEh5ZHJhdGVNYXAuc2V0KG9iaiwgMSkgJiYgb2JqXG4gICAgICAgIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgc2tpcEh5ZHJhdGVTeW1ib2wsIHt9KTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgdmFsdWUgc2hvdWxkIGJlIGh5ZHJhdGVkXG4gKlxuICogQHBhcmFtIG9iaiAtIHRhcmdldCB2YXJpYWJsZVxuICogQHJldHVybnMgdHJ1ZSBpZiBgb2JqYCBzaG91bGQgYmUgaHlkcmF0ZWRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkSHlkcmF0ZShvYmopIHtcbiAgICByZXR1cm4gaXNWdWUyXG4gICAgICAgID8gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gIXNraXBIeWRyYXRlTWFwLmhhcyhvYmopXG4gICAgICAgIDogIWlzUGxhaW5PYmplY3Qob2JqKSB8fCAhb2JqLmhhc093blByb3BlcnR5KHNraXBIeWRyYXRlU3ltYm9sKTtcbn1cbmNvbnN0IHsgYXNzaWduIH0gPSBPYmplY3Q7XG5mdW5jdGlvbiBpc0NvbXB1dGVkKG8pIHtcbiAgICByZXR1cm4gISEoaXNSZWYobykgJiYgby5lZmZlY3QpO1xufVxuZnVuY3Rpb24gY3JlYXRlT3B0aW9uc1N0b3JlKGlkLCBvcHRpb25zLCBwaW5pYSwgaG90KSB7XG4gICAgY29uc3QgeyBzdGF0ZSwgYWN0aW9ucywgZ2V0dGVycyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSBwaW5pYS5zdGF0ZS52YWx1ZVtpZF07XG4gICAgbGV0IHN0b3JlO1xuICAgIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgICAgICBpZiAoIWluaXRpYWxTdGF0ZSAmJiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAhaG90KSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoaXNWdWUyKSB7XG4gICAgICAgICAgICAgICAgc2V0KHBpbmlhLnN0YXRlLnZhbHVlLCBpZCwgc3RhdGUgPyBzdGF0ZSgpIDoge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGluaWEuc3RhdGUudmFsdWVbaWRdID0gc3RhdGUgPyBzdGF0ZSgpIDoge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXZvaWQgY3JlYXRpbmcgYSBzdGF0ZSBpbiBwaW5pYS5zdGF0ZS52YWx1ZVxuICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGhvdFxuICAgICAgICAgICAgPyAvLyB1c2UgcmVmKCkgdG8gdW53cmFwIHJlZnMgaW5zaWRlIHN0YXRlIFRPRE86IGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgdG9SZWZzKHJlZihzdGF0ZSA/IHN0YXRlKCkgOiB7fSkudmFsdWUpXG4gICAgICAgICAgICA6IHRvUmVmcyhwaW5pYS5zdGF0ZS52YWx1ZVtpZF0pO1xuICAgICAgICByZXR1cm4gYXNzaWduKGxvY2FsU3RhdGUsIGFjdGlvbnMsIE9iamVjdC5rZXlzKGdldHRlcnMgfHwge30pLnJlZHVjZSgoY29tcHV0ZWRHZXR0ZXJzLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5hbWUgaW4gbG9jYWxTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW/CfjY1dOiBBIGdldHRlciBjYW5ub3QgaGF2ZSB0aGUgc2FtZSBuYW1lIGFzIGFub3RoZXIgc3RhdGUgcHJvcGVydHkuIFJlbmFtZSBvbmUgb2YgdGhlbS4gRm91bmQgd2l0aCBcIiR7bmFtZX1cIiBpbiBzdG9yZSBcIiR7aWR9XCIuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wdXRlZEdldHRlcnNbbmFtZV0gPSBtYXJrUmF3KGNvbXB1dGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVQaW5pYShwaW5pYSk7XG4gICAgICAgICAgICAgICAgLy8gaXQgd2FzIGNyZWF0ZWQganVzdCBiZWZvcmVcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHBpbmlhLl9zLmdldChpZCk7XG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgY3Jvc3MgdXNpbmcgc3RvcmVzXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKGlzVnVlMiAmJiAhc3RvcmUuX3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGdldHRlcnMhW25hbWVdLmNhbGwoY29udGV4dCwgY29udGV4dClcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhdm9pZCByZWFkaW5nIHRoZSBnZXR0ZXIgd2hpbGUgYXNzaWduaW5nIHdpdGggYSBnbG9iYWwgdmFyaWFibGVcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyc1tuYW1lXS5jYWxsKHN0b3JlLCBzdG9yZSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZWRHZXR0ZXJzO1xuICAgICAgICB9LCB7fSkpO1xuICAgIH1cbiAgICBzdG9yZSA9IGNyZWF0ZVNldHVwU3RvcmUoaWQsIHNldHVwLCBvcHRpb25zLCBwaW5pYSwgaG90LCB0cnVlKTtcbiAgICByZXR1cm4gc3RvcmU7XG59XG5mdW5jdGlvbiBjcmVhdGVTZXR1cFN0b3JlKCRpZCwgc2V0dXAsIG9wdGlvbnMgPSB7fSwgcGluaWEsIGhvdCwgaXNPcHRpb25zU3RvcmUpIHtcbiAgICBsZXQgc2NvcGU7XG4gICAgY29uc3Qgb3B0aW9uc0ZvclBsdWdpbiA9IGFzc2lnbih7IGFjdGlvbnM6IHt9IH0sIG9wdGlvbnMpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXBpbmlhLl9lLmFjdGl2ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpbmlhIGRlc3Ryb3llZCcpO1xuICAgIH1cbiAgICAvLyB3YXRjaGVyIG9wdGlvbnMgZm9yICRzdWJzY3JpYmVcbiAgICBjb25zdCAkc3Vic2NyaWJlT3B0aW9ucyA9IHsgZGVlcDogdHJ1ZSB9O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNWdWUyKSB7XG4gICAgICAgICRzdWJzY3JpYmVPcHRpb25zLm9uVHJpZ2dlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChpc0xpc3RlbmluZykge1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyRXZlbnRzID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgLy8gYXZvaWQgdHJpZ2dlcmluZyB0aGlzIHdoaWxlIHRoZSBzdG9yZSBpcyBiZWluZyBidWlsdCBhbmQgdGhlIHN0YXRlIGlzIGJlaW5nIHNldCBpbiBwaW5pYVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNMaXN0ZW5pbmcgPT0gZmFsc2UgJiYgIXN0b3JlLl9ob3RVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIC8vIGxldCBwYXRjaCBzZW5kIGFsbCB0aGUgZXZlbnRzIHRvZ2V0aGVyIGxhdGVyXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZWJ1Z2dlckV2ZW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdnZXJFdmVudHMucHVzaChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfwn42NIGRlYnVnZ2VyRXZlbnRzIHNob3VsZCBiZSBhbiBhcnJheS4gVGhpcyBpcyBtb3N0IGxpa2VseSBhbiBpbnRlcm5hbCBQaW5pYSBidWcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBpbnRlcm5hbCBzdGF0ZVxuICAgIGxldCBpc0xpc3RlbmluZzsgLy8gc2V0IHRvIHRydWUgYXQgdGhlIGVuZFxuICAgIGxldCBpc1N5bmNMaXN0ZW5pbmc7IC8vIHNldCB0byB0cnVlIGF0IHRoZSBlbmRcbiAgICBsZXQgc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgIGxldCBhY3Rpb25TdWJzY3JpcHRpb25zID0gW107XG4gICAgbGV0IGRlYnVnZ2VyRXZlbnRzO1xuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHBpbmlhLnN0YXRlLnZhbHVlWyRpZF07XG4gICAgLy8gYXZvaWQgc2V0dGluZyB0aGUgc3RhdGUgZm9yIG9wdGlvbiBzdG9yZXMgaWYgaXQgaXMgc2V0XG4gICAgLy8gYnkgdGhlIHNldHVwXG4gICAgaWYgKCFpc09wdGlvbnNTdG9yZSAmJiAhaW5pdGlhbFN0YXRlICYmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICFob3QpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNWdWUyKSB7XG4gICAgICAgICAgICBzZXQocGluaWEuc3RhdGUudmFsdWUsICRpZCwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGluaWEuc3RhdGUudmFsdWVbJGlkXSA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhvdFN0YXRlID0gcmVmKHt9KTtcbiAgICAvLyBhdm9pZCB0cmlnZ2VyaW5nIHRvbyBtYW55IGxpc3RlbmVyc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9waW5pYS9pc3N1ZXMvMTEyOVxuICAgIGxldCBhY3RpdmVMaXN0ZW5lcjtcbiAgICBmdW5jdGlvbiAkcGF0Y2gocGFydGlhbFN0YXRlT3JNdXRhdG9yKSB7XG4gICAgICAgIGxldCBzdWJzY3JpcHRpb25NdXRhdGlvbjtcbiAgICAgICAgaXNMaXN0ZW5pbmcgPSBpc1N5bmNMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gcmVzZXQgdGhlIGRlYnVnZ2VyIGV2ZW50cyBzaW5jZSBwYXRjaGVzIGFyZSBzeW5jXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIGRlYnVnZ2VyRXZlbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJ0aWFsU3RhdGVPck11dGF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBhcnRpYWxTdGF0ZU9yTXV0YXRvcihwaW5pYS5zdGF0ZS52YWx1ZVskaWRdKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbk11dGF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IE11dGF0aW9uVHlwZS5wYXRjaEZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHN0b3JlSWQ6ICRpZCxcbiAgICAgICAgICAgICAgICBldmVudHM6IGRlYnVnZ2VyRXZlbnRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lcmdlUmVhY3RpdmVPYmplY3RzKHBpbmlhLnN0YXRlLnZhbHVlWyRpZF0sIHBhcnRpYWxTdGF0ZU9yTXV0YXRvcik7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25NdXRhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNdXRhdGlvblR5cGUucGF0Y2hPYmplY3QsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogcGFydGlhbFN0YXRlT3JNdXRhdG9yLFxuICAgICAgICAgICAgICAgIHN0b3JlSWQ6ICRpZCxcbiAgICAgICAgICAgICAgICBldmVudHM6IGRlYnVnZ2VyRXZlbnRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBteUxpc3RlbmVySWQgPSAoYWN0aXZlTGlzdGVuZXIgPSBTeW1ib2woKSk7XG4gICAgICAgIG5leHRUaWNrKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlTGlzdGVuZXIgPT09IG15TGlzdGVuZXJJZCkge1xuICAgICAgICAgICAgICAgIGlzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3luY0xpc3RlbmluZyA9IHRydWU7XG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgcGF1c2VkIHRoZSB3YXRjaGVyLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IGNhbGwgdGhlIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgdHJpZ2dlclN1YnNjcmlwdGlvbnMoc3Vic2NyaXB0aW9ucywgc3Vic2NyaXB0aW9uTXV0YXRpb24sIHBpbmlhLnN0YXRlLnZhbHVlWyRpZF0pO1xuICAgIH1cbiAgICBjb25zdCAkcmVzZXQgPSBpc09wdGlvbnNTdG9yZVxuICAgICAgICA/IGZ1bmN0aW9uICRyZXNldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlID8gc3RhdGUoKSA6IHt9O1xuICAgICAgICAgICAgLy8gd2UgdXNlIGEgcGF0Y2ggdG8gZ3JvdXAgYWxsIGNoYW5nZXMgaW50byBvbmUgc2luZ2xlIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgdGhpcy4kcGF0Y2goKCRzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEZJWE1FOiBzaG91bGRuJ3QgZXJyb3I/XG4gICAgICAgICAgICAgICAgYXNzaWduKCRzdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgICAgICAgICAgPyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihg8J+NjTogU3RvcmUgXCIkeyRpZH1cIiBpcyBidWlsdCB1c2luZyB0aGUgc2V0dXAgc3ludGF4IGFuZCBkb2VzIG5vdCBpbXBsZW1lbnQgJHJlc2V0KCkuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogbm9vcDtcbiAgICBmdW5jdGlvbiAkZGlzcG9zZSgpIHtcbiAgICAgICAgc2NvcGUuc3RvcCgpO1xuICAgICAgICBzdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIGFjdGlvblN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgcGluaWEuX3MuZGVsZXRlKCRpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciB0aGF0IHdyYXBzIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSB0cmFja2VkIHdpdGggJG9uQWN0aW9uXG4gICAgICogQHBhcmFtIGZuIC0gYWN0aW9uIHRvIHdyYXBcbiAgICAgKiBAcGFyYW0gbmFtZSAtIG5hbWUgb2YgdGhlIGFjdGlvblxuICAgICAqL1xuICAgIGNvbnN0IGFjdGlvbiA9IChmbiwgbmFtZSA9ICcnKSA9PiB7XG4gICAgICAgIGlmIChBQ1RJT05fTUFSS0VSIGluIGZuKSB7XG4gICAgICAgICAgICBmbltBQ1RJT05fTkFNRV0gPSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyYXBwZWRBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRBY3RpdmVQaW5pYShwaW5pYSk7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgICAgICAgICAgY29uc3QgYWZ0ZXJDYWxsYmFja0xpc3QgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3JDYWxsYmFja0xpc3QgPSBbXTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFmdGVyKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXJDYWxsYmFja0xpc3QucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBvbkVycm9yKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvckNhbGxiYWNrTGlzdC5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHRyaWdnZXJTdWJzY3JpcHRpb25zKGFjdGlvblN1YnNjcmlwdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgIG5hbWU6IHdyYXBwZWRBY3Rpb25bQUNUSU9OX05BTUVdLFxuICAgICAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgICAgIGFmdGVyLFxuICAgICAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCByZXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldCA9IGZuLmFwcGx5KHRoaXMgJiYgdGhpcy4kaWQgPT09ICRpZCA/IHRoaXMgOiBzdG9yZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHN5bmMgZXJyb3JzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyU3Vic2NyaXB0aW9ucyhvbkVycm9yQ2FsbGJhY2tMaXN0LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXRcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJTdWJzY3JpcHRpb25zKGFmdGVyQ2FsbGJhY2tMaXN0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJTdWJzY3JpcHRpb25zKG9uRXJyb3JDYWxsYmFja0xpc3QsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyaWdnZXIgYWZ0ZXIgY2FsbGJhY2tzXG4gICAgICAgICAgICB0cmlnZ2VyU3Vic2NyaXB0aW9ucyhhZnRlckNhbGxiYWNrTGlzdCwgcmV0KTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHdyYXBwZWRBY3Rpb25bQUNUSU9OX01BUktFUl0gPSB0cnVlO1xuICAgICAgICB3cmFwcGVkQWN0aW9uW0FDVElPTl9OQU1FXSA9IG5hbWU7IC8vIHdpbGwgYmUgc2V0IGxhdGVyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHdlIGFyZSBpbnRlbnRpb25hbGx5IGxpbWl0aW5nIHRoZSByZXR1cm5lZCB0eXBlIHRvIGp1c3QgRm5cbiAgICAgICAgLy8gYmVjYXVzZSBhbGwgdGhlIGFkZGVkIHByb3BlcnRpZXMgYXJlIGludGVybmFscyB0aGF0IGFyZSBleHBvc2VkIHRocm91Z2ggYCRvbkFjdGlvbigpYCBvbmx5XG4gICAgICAgIHJldHVybiB3cmFwcGVkQWN0aW9uO1xuICAgIH07XG4gICAgY29uc3QgX2htclBheWxvYWQgPSAvKiNfX1BVUkVfXyovIG1hcmtSYXcoe1xuICAgICAgICBhY3Rpb25zOiB7fSxcbiAgICAgICAgZ2V0dGVyczoge30sXG4gICAgICAgIHN0YXRlOiBbXSxcbiAgICAgICAgaG90U3RhdGUsXG4gICAgfSk7XG4gICAgY29uc3QgcGFydGlhbFN0b3JlID0ge1xuICAgICAgICBfcDogcGluaWEsXG4gICAgICAgIC8vIF9zOiBzY29wZSxcbiAgICAgICAgJGlkLFxuICAgICAgICAkb25BY3Rpb246IGFkZFN1YnNjcmlwdGlvbi5iaW5kKG51bGwsIGFjdGlvblN1YnNjcmlwdGlvbnMpLFxuICAgICAgICAkcGF0Y2gsXG4gICAgICAgICRyZXNldCxcbiAgICAgICAgJHN1YnNjcmliZShjYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVTdWJzY3JpcHRpb24gPSBhZGRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9ucywgY2FsbGJhY2ssIG9wdGlvbnMuZGV0YWNoZWQsICgpID0+IHN0b3BXYXRjaGVyKCkpO1xuICAgICAgICAgICAgY29uc3Qgc3RvcFdhdGNoZXIgPSBzY29wZS5ydW4oKCkgPT4gd2F0Y2goKCkgPT4gcGluaWEuc3RhdGUudmFsdWVbJGlkXSwgKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmx1c2ggPT09ICdzeW5jJyA/IGlzU3luY0xpc3RlbmluZyA6IGlzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlSWQ6ICRpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE11dGF0aW9uVHlwZS5kaXJlY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHM6IGRlYnVnZ2VyRXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICB9LCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgYXNzaWduKHt9LCAkc3Vic2NyaWJlT3B0aW9ucywgb3B0aW9ucykpKTtcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVTdWJzY3JpcHRpb247XG4gICAgICAgIH0sXG4gICAgICAgICRkaXNwb3NlLFxuICAgIH07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzVnVlMikge1xuICAgICAgICAvLyBzdGFydCBhcyBub24gcmVhZHlcbiAgICAgICAgcGFydGlhbFN0b3JlLl9yID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlID0gcmVhY3RpdmUoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICgoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgX19WVUVfUFJPRF9ERVZUT09MU19fKSkgJiYgIShwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSkgJiYgSVNfQ0xJRU5UKVxuICAgICAgICA/IGFzc2lnbih7XG4gICAgICAgICAgICBfaG1yUGF5bG9hZCxcbiAgICAgICAgICAgIF9jdXN0b21Qcm9wZXJ0aWVzOiBtYXJrUmF3KG5ldyBTZXQoKSksIC8vIGRldnRvb2xzIGN1c3RvbSBwcm9wZXJ0aWVzXG4gICAgICAgIH0sIHBhcnRpYWxTdG9yZVxuICAgICAgICAvLyBtdXN0IGJlIGFkZGVkIGxhdGVyXG4gICAgICAgIC8vIHNldHVwU3RvcmVcbiAgICAgICAgKVxuICAgICAgICA6IHBhcnRpYWxTdG9yZSk7XG4gICAgLy8gc3RvcmUgdGhlIHBhcnRpYWwgc3RvcmUgbm93IHNvIHRoZSBzZXR1cCBvZiBzdG9yZXMgY2FuIGluc3RhbnRpYXRlIGVhY2ggb3RoZXIgYmVmb3JlIHRoZXkgYXJlIGZpbmlzaGVkIHdpdGhvdXRcbiAgICAvLyBjcmVhdGluZyBpbmZpbml0ZSBsb29wcy5cbiAgICBwaW5pYS5fcy5zZXQoJGlkLCBzdG9yZSk7XG4gICAgY29uc3QgcnVuV2l0aENvbnRleHQgPSAocGluaWEuX2EgJiYgcGluaWEuX2EucnVuV2l0aENvbnRleHQpIHx8IGZhbGxiYWNrUnVuV2l0aENvbnRleHQ7XG4gICAgLy8gVE9ETzogaWRlYSBjcmVhdGUgc2tpcFNlcmlhbGl6ZSB0aGF0IG1hcmtzIHByb3BlcnRpZXMgYXMgbm9uIHNlcmlhbGl6YWJsZSBhbmQgdGhleSBhcmUgc2tpcHBlZFxuICAgIGNvbnN0IHNldHVwU3RvcmUgPSBydW5XaXRoQ29udGV4dCgoKSA9PiBwaW5pYS5fZS5ydW4oKCkgPT4gKHNjb3BlID0gZWZmZWN0U2NvcGUoKSkucnVuKCgpID0+IHNldHVwKHsgYWN0aW9uIH0pKSkpO1xuICAgIC8vIG92ZXJ3cml0ZSBleGlzdGluZyBhY3Rpb25zIHRvIHN1cHBvcnQgJG9uQWN0aW9uXG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2V0dXBTdG9yZSkge1xuICAgICAgICBjb25zdCBwcm9wID0gc2V0dXBTdG9yZVtrZXldO1xuICAgICAgICBpZiAoKGlzUmVmKHByb3ApICYmICFpc0NvbXB1dGVkKHByb3ApKSB8fCBpc1JlYWN0aXZlKHByb3ApKSB7XG4gICAgICAgICAgICAvLyBtYXJrIGl0IGFzIGEgcGllY2Ugb2Ygc3RhdGUgdG8gYmUgc2VyaWFsaXplZFxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBob3QpIHtcbiAgICAgICAgICAgICAgICBzZXQoaG90U3RhdGUudmFsdWUsIGtleSwgdG9SZWYoc2V0dXBTdG9yZSwga2V5KSk7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlT3B0aW9uU3RvcmUgZGlyZWN0bHkgc2V0cyB0aGUgc3RhdGUgaW4gcGluaWEuc3RhdGUudmFsdWUgc28gd2VcbiAgICAgICAgICAgICAgICAvLyBjYW4ganVzdCBza2lwIHRoYXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc09wdGlvbnNTdG9yZSkge1xuICAgICAgICAgICAgICAgIC8vIGluIHNldHVwIHN0b3JlcyB3ZSBtdXN0IGh5ZHJhdGUgdGhlIHN0YXRlIGFuZCBzeW5jIHBpbmlhIHN0YXRlIHRyZWUgd2l0aCB0aGUgcmVmcyB0aGUgdXNlciBqdXN0IGNyZWF0ZWRcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFN0YXRlICYmIHNob3VsZEh5ZHJhdGUocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVmKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLnZhbHVlID0gaW5pdGlhbFN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9iYWJseSBhIHJlYWN0aXZlIG9iamVjdCwgbGV0cyByZWN1cnNpdmVseSBhc3NpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByb3AgaXMgdW5rbm93blxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VSZWFjdGl2ZU9iamVjdHMocHJvcCwgaW5pdGlhbFN0YXRlW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRyYW5zZmVyIHRoZSByZWYgdG8gdGhlIHBpbmlhIHN0YXRlIHRvIGtlZXAgZXZlcnl0aGluZyBpbiBzeW5jXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKGlzVnVlMikge1xuICAgICAgICAgICAgICAgICAgICBzZXQocGluaWEuc3RhdGUudmFsdWVbJGlkXSwga2V5LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBpbmlhLnN0YXRlLnZhbHVlWyRpZF1ba2V5XSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBfaG1yUGF5bG9hZC5zdGF0ZS5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhY3Rpb25cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uVmFsdWUgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaG90ID8gcHJvcCA6IGFjdGlvbihwcm9wLCBrZXkpO1xuICAgICAgICAgICAgLy8gdGhpcyBhIGhvdCBtb2R1bGUgcmVwbGFjZW1lbnQgc3RvcmUgYmVjYXVzZSB0aGUgaG90VXBkYXRlIG1ldGhvZCBuZWVkc1xuICAgICAgICAgICAgLy8gdG8gZG8gaXQgd2l0aCB0aGUgcmlnaHQgY29udGV4dFxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoaXNWdWUyKSB7XG4gICAgICAgICAgICAgICAgc2V0KHNldHVwU3RvcmUsIGtleSwgYWN0aW9uVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHNldHVwU3RvcmVba2V5XSA9IGFjdGlvblZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBfaG1yUGF5bG9hZC5hY3Rpb25zW2tleV0gPSBwcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGlzdCBhY3Rpb25zIHNvIHRoZXkgY2FuIGJlIHVzZWQgaW4gcGx1Z2luc1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgb3B0aW9uc0ZvclBsdWdpbi5hY3Rpb25zW2tleV0gPSBwcm9wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgLy8gYWRkIGdldHRlcnMgZm9yIGRldnRvb2xzXG4gICAgICAgICAgICBpZiAoaXNDb21wdXRlZChwcm9wKSkge1xuICAgICAgICAgICAgICAgIF9obXJQYXlsb2FkLmdldHRlcnNba2V5XSA9IGlzT3B0aW9uc1N0b3JlXG4gICAgICAgICAgICAgICAgICAgID8gLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5nZXR0ZXJzW2tleV1cbiAgICAgICAgICAgICAgICAgICAgOiBwcm9wO1xuICAgICAgICAgICAgICAgIGlmIChJU19DTElFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2V0dGVycyA9IHNldHVwU3RvcmUuX2dldHRlcnMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHNhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXR1cFN0b3JlLl9nZXR0ZXJzID0gbWFya1JhdyhbXSkpO1xuICAgICAgICAgICAgICAgICAgICBnZXR0ZXJzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIHRoZSBzdGF0ZSwgZ2V0dGVycywgYW5kIGFjdGlvbiBwcm9wZXJ0aWVzXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzVnVlMikge1xuICAgICAgICBPYmplY3Qua2V5cyhzZXR1cFN0b3JlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIHNldChzdG9yZSwga2V5LCBzZXR1cFN0b3JlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2lnbihzdG9yZSwgc2V0dXBTdG9yZSk7XG4gICAgICAgIC8vIGFsbG93cyByZXRyaWV2aW5nIHJlYWN0aXZlIG9iamVjdHMgd2l0aCBgc3RvcmVUb1JlZnMoKWAuIE11c3QgYmUgY2FsbGVkIGFmdGVyIGFzc2lnbmluZyB0byB0aGUgcmVhY3RpdmUgb2JqZWN0LlxuICAgICAgICAvLyBNYWtlIGBzdG9yZVRvUmVmcygpYCB3b3JrIHdpdGggYHJlYWN0aXZlKClgICM3OTlcbiAgICAgICAgYXNzaWduKHRvUmF3KHN0b3JlKSwgc2V0dXBTdG9yZSk7XG4gICAgfVxuICAgIC8vIHVzZSB0aGlzIGluc3RlYWQgb2YgYSBjb21wdXRlZCB3aXRoIHNldHRlciB0byBiZSBhYmxlIHRvIGNyZWF0ZSBpdCBhbnl3aGVyZVxuICAgIC8vIHdpdGhvdXQgbGlua2luZyB0aGUgY29tcHV0ZWQgbGlmZXNwYW4gdG8gd2hlcmV2ZXIgdGhlIHN0b3JlIGlzIGZpcnN0XG4gICAgLy8gY3JlYXRlZC5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RvcmUsICckc3RhdGUnLCB7XG4gICAgICAgIGdldDogKCkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBob3QgPyBob3RTdGF0ZS52YWx1ZSA6IHBpbmlhLnN0YXRlLnZhbHVlWyRpZF0pLFxuICAgICAgICBzZXQ6IChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGhvdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNldCBob3RTdGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHBhdGNoKCgkc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBGSVhNRTogc2hvdWxkbid0IGVycm9yP1xuICAgICAgICAgICAgICAgIGFzc2lnbigkc3RhdGUsIHN0YXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIC8vIGFkZCB0aGUgaG90VXBkYXRlIGJlZm9yZSBwbHVnaW5zIHRvIGFsbG93IHRoZW0gdG8gb3ZlcnJpZGUgaXRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgc3RvcmUuX2hvdFVwZGF0ZSA9IG1hcmtSYXcoKG5ld1N0b3JlKSA9PiB7XG4gICAgICAgICAgICBzdG9yZS5faG90VXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgbmV3U3RvcmUuX2htclBheWxvYWQuc3RhdGUuZm9yRWFjaCgoc3RhdGVLZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVLZXkgaW4gc3RvcmUuJHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlVGFyZ2V0ID0gbmV3U3RvcmUuJHN0YXRlW3N0YXRlS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkU3RhdGVTb3VyY2UgPSBzdG9yZS4kc3RhdGVbc3RhdGVLZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld1N0YXRlVGFyZ2V0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQbGFpbk9iamVjdChuZXdTdGF0ZVRhcmdldCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGxhaW5PYmplY3Qob2xkU3RhdGVTb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaE9iamVjdChuZXdTdGF0ZVRhcmdldCwgb2xkU3RhdGVTb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmZXIgdGhlIHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RvcmUuJHN0YXRlW3N0YXRlS2V5XSA9IG9sZFN0YXRlU291cmNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHBhdGNoIGRpcmVjdCBhY2Nlc3MgcHJvcGVydGllcyB0byBhbGxvdyBzdG9yZS5zdGF0ZVByb3BlcnR5IHRvIHdvcmsgYXNcbiAgICAgICAgICAgICAgICAvLyBzdG9yZS4kc3RhdGUuc3RhdGVQcm9wZXJ0eVxuICAgICAgICAgICAgICAgIHNldChzdG9yZSwgc3RhdGVLZXksIHRvUmVmKG5ld1N0b3JlLiRzdGF0ZSwgc3RhdGVLZXkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGRlbGV0ZWQgc3RhdGUgcHJvcGVydGllc1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3RvcmUuJHN0YXRlKS5mb3JFYWNoKChzdGF0ZUtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghKHN0YXRlS2V5IGluIG5ld1N0b3JlLiRzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsKHN0b3JlLCBzdGF0ZUtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBhdm9pZCBkZXZ0b29scyBsb2dnaW5nIHRoaXMgYXMgYSBtdXRhdGlvblxuICAgICAgICAgICAgaXNMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlzU3luY0xpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcGluaWEuc3RhdGUudmFsdWVbJGlkXSA9IHRvUmVmKG5ld1N0b3JlLl9obXJQYXlsb2FkLCAnaG90U3RhdGUnKTtcbiAgICAgICAgICAgIGlzU3luY0xpc3RlbmluZyA9IHRydWU7XG4gICAgICAgICAgICBuZXh0VGljaygpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhY3Rpb25OYW1lIGluIG5ld1N0b3JlLl9obXJQYXlsb2FkLmFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb25GbiA9IG5ld1N0b3JlW2FjdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgIHNldChzdG9yZSwgYWN0aW9uTmFtZSwgYWN0aW9uKGFjdGlvbkZuLCBhY3Rpb25OYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBkb2VzIHRoaXMgd29yayBpbiBib3RoIHNldHVwIGFuZCBvcHRpb24gc3RvcmU/XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGdldHRlck5hbWUgaW4gbmV3U3RvcmUuX2htclBheWxvYWQuZ2V0dGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdldHRlciA9IG5ld1N0b3JlLl9obXJQYXlsb2FkLmdldHRlcnNbZ2V0dGVyTmFtZV07XG4gICAgICAgICAgICAgICAgY29uc3QgZ2V0dGVyVmFsdWUgPSBpc09wdGlvbnNTdG9yZVxuICAgICAgICAgICAgICAgICAgICA/IC8vIHNwZWNpYWwgaGFuZGxpbmcgb2Ygb3B0aW9ucyBhcGlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmVQaW5pYShwaW5pYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldHRlci5jYWxsKHN0b3JlLCBzdG9yZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICA6IGdldHRlcjtcbiAgICAgICAgICAgICAgICBzZXQoc3RvcmUsIGdldHRlck5hbWUsIGdldHRlclZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbW92ZSBkZWxldGVkIGdldHRlcnNcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0b3JlLl9obXJQYXlsb2FkLmdldHRlcnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBuZXdTdG9yZS5faG1yUGF5bG9hZC5nZXR0ZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWwoc3RvcmUsIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgb2xkIGFjdGlvbnNcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0b3JlLl9obXJQYXlsb2FkLmFjdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBuZXdTdG9yZS5faG1yUGF5bG9hZC5hY3Rpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWwoc3RvcmUsIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHZhbHVlcyB1c2VkIGluIGRldnRvb2xzIGFuZCB0byBhbGxvdyBkZWxldGluZyBuZXcgcHJvcGVydGllcyBsYXRlciBvblxuICAgICAgICAgICAgc3RvcmUuX2htclBheWxvYWQgPSBuZXdTdG9yZS5faG1yUGF5bG9hZDtcbiAgICAgICAgICAgIHN0b3JlLl9nZXR0ZXJzID0gbmV3U3RvcmUuX2dldHRlcnM7XG4gICAgICAgICAgICBzdG9yZS5faG90VXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICgoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgX19WVUVfUFJPRF9ERVZUT09MU19fKSkgJiYgIShwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSkgJiYgSVNfQ0xJRU5UKSB7XG4gICAgICAgIGNvbnN0IG5vbkVudW1lcmFibGUgPSB7XG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIC8vIGF2b2lkIHdhcm5pbmcgb24gZGV2dG9vbHMgdHJ5aW5nIHRvIGRpc3BsYXkgdGhpcyBwcm9wZXJ0eVxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIFsnX3AnLCAnX2htclBheWxvYWQnLCAnX2dldHRlcnMnLCAnX2N1c3RvbVByb3BlcnRpZXMnXS5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RvcmUsIHAsIGFzc2lnbih7IHZhbHVlOiBzdG9yZVtwXSB9LCBub25FbnVtZXJhYmxlKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNWdWUyKSB7XG4gICAgICAgIC8vIG1hcmsgdGhlIHN0b3JlIGFzIHJlYWR5IGJlZm9yZSBwbHVnaW5zXG4gICAgICAgIHN0b3JlLl9yID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gYXBwbHkgYWxsIHBsdWdpbnNcbiAgICBwaW5pYS5fcC5mb3JFYWNoKChleHRlbmRlcikgPT4ge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgKHR5cGVvZiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18gIT09ICd1bmRlZmluZWQnICYmIF9fVlVFX1BST0RfREVWVE9PTFNfXykpICYmICEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0JykpICYmIElTX0NMSUVOVCkge1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IHNjb3BlLnJ1bigoKSA9PiBleHRlbmRlcih7XG4gICAgICAgICAgICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgICAgICAgICAgIGFwcDogcGluaWEuX2EsXG4gICAgICAgICAgICAgICAgcGluaWEsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc0ZvclBsdWdpbixcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMgfHwge30pLmZvckVhY2goKGtleSkgPT4gc3RvcmUuX2N1c3RvbVByb3BlcnRpZXMuYWRkKGtleSkpO1xuICAgICAgICAgICAgYXNzaWduKHN0b3JlLCBleHRlbnNpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2lnbihzdG9yZSwgc2NvcGUucnVuKCgpID0+IGV4dGVuZGVyKHtcbiAgICAgICAgICAgICAgICBzdG9yZTogc3RvcmUsXG4gICAgICAgICAgICAgICAgYXBwOiBwaW5pYS5fYSxcbiAgICAgICAgICAgICAgICBwaW5pYSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zRm9yUGx1Z2luLFxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgc3RvcmUuJHN0YXRlICYmXG4gICAgICAgIHR5cGVvZiBzdG9yZS4kc3RhdGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR5cGVvZiBzdG9yZS4kc3RhdGUuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgIXN0b3JlLiRzdGF0ZS5jb25zdHJ1Y3Rvci50b1N0cmluZygpLmluY2x1ZGVzKCdbbmF0aXZlIGNvZGVdJykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBb8J+NjV06IFRoZSBcInN0YXRlXCIgbXVzdCBiZSBhIHBsYWluIG9iamVjdC4gSXQgY2Fubm90IGJlXFxuYCArXG4gICAgICAgICAgICBgXFx0c3RhdGU6ICgpID0+IG5ldyBNeUNsYXNzKClcXG5gICtcbiAgICAgICAgICAgIGBGb3VuZCBpbiBzdG9yZSBcIiR7c3RvcmUuJGlkfVwiLmApO1xuICAgIH1cbiAgICAvLyBvbmx5IGFwcGx5IGh5ZHJhdGUgdG8gb3B0aW9uIHN0b3JlcyB3aXRoIGFuIGluaXRpYWwgc3RhdGUgaW4gcGluaWFcbiAgICBpZiAoaW5pdGlhbFN0YXRlICYmXG4gICAgICAgIGlzT3B0aW9uc1N0b3JlICYmXG4gICAgICAgIG9wdGlvbnMuaHlkcmF0ZSkge1xuICAgICAgICBvcHRpb25zLmh5ZHJhdGUoc3RvcmUuJHN0YXRlLCBpbml0aWFsU3RhdGUpO1xuICAgIH1cbiAgICBpc0xpc3RlbmluZyA9IHRydWU7XG4gICAgaXNTeW5jTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RvcmU7XG59XG4vLyBpbXByb3ZlcyB0cmVlIHNoYWtpbmdcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gZGVmaW5lU3RvcmUoXG4vLyBUT0RPOiBhZGQgcHJvcGVyIHR5cGVzIGZyb20gYWJvdmVcbmlkT3JPcHRpb25zLCBzZXR1cCwgc2V0dXBPcHRpb25zKSB7XG4gICAgbGV0IGlkO1xuICAgIGxldCBvcHRpb25zO1xuICAgIGNvbnN0IGlzU2V0dXBTdG9yZSA9IHR5cGVvZiBzZXR1cCA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAodHlwZW9mIGlkT3JPcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZCA9IGlkT3JPcHRpb25zO1xuICAgICAgICAvLyB0aGUgb3B0aW9uIHN0b3JlIHNldHVwIHdpbGwgY29udGFpbiB0aGUgYWN0dWFsIG9wdGlvbnMgaW4gdGhpcyBjYXNlXG4gICAgICAgIG9wdGlvbnMgPSBpc1NldHVwU3RvcmUgPyBzZXR1cE9wdGlvbnMgOiBzZXR1cDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSBpZE9yT3B0aW9ucztcbiAgICAgICAgaWQgPSBpZE9yT3B0aW9ucy5pZDtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFvwn42NXTogXCJkZWZpbmVTdG9yZSgpXCIgbXVzdCBiZSBwYXNzZWQgYSBzdG9yZSBpZCBhcyBpdHMgZmlyc3QgYXJndW1lbnQuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlU3RvcmUocGluaWEsIGhvdCkge1xuICAgICAgICBjb25zdCBoYXNDb250ZXh0ID0gaGFzSW5qZWN0aW9uQ29udGV4dCgpO1xuICAgICAgICBwaW5pYSA9XG4gICAgICAgICAgICAvLyBpbiB0ZXN0IG1vZGUsIGlnbm9yZSB0aGUgYXJndW1lbnQgcHJvdmlkZWQgYXMgd2UgY2FuIGFsd2F5cyByZXRyaWV2ZSBhXG4gICAgICAgICAgICAvLyBwaW5pYSBpbnN0YW5jZSB3aXRoIGdldEFjdGl2ZVBpbmlhKClcbiAgICAgICAgICAgICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0JykgJiYgYWN0aXZlUGluaWEgJiYgYWN0aXZlUGluaWEuX3Rlc3RpbmcgPyBudWxsIDogcGluaWEpIHx8XG4gICAgICAgICAgICAgICAgKGhhc0NvbnRleHQgPyBpbmplY3QocGluaWFTeW1ib2wsIG51bGwpIDogbnVsbCk7XG4gICAgICAgIGlmIChwaW5pYSlcbiAgICAgICAgICAgIHNldEFjdGl2ZVBpbmlhKHBpbmlhKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhYWN0aXZlUGluaWEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW/CfjY1dOiBcImdldEFjdGl2ZVBpbmlhKClcIiB3YXMgY2FsbGVkIGJ1dCB0aGVyZSB3YXMgbm8gYWN0aXZlIFBpbmlhLiBBcmUgeW91IHRyeWluZyB0byB1c2UgYSBzdG9yZSBiZWZvcmUgY2FsbGluZyBcImFwcC51c2UocGluaWEpXCI/XFxuYCArXG4gICAgICAgICAgICAgICAgYFNlZSBodHRwczovL3BpbmlhLnZ1ZWpzLm9yZy9jb3JlLWNvbmNlcHRzL291dHNpZGUtY29tcG9uZW50LXVzYWdlLmh0bWwgZm9yIGhlbHAuXFxuYCArXG4gICAgICAgICAgICAgICAgYFRoaXMgd2lsbCBmYWlsIGluIHByb2R1Y3Rpb24uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcGluaWEgPSBhY3RpdmVQaW5pYTtcbiAgICAgICAgaWYgKCFwaW5pYS5fcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGluZyB0aGUgc3RvcmUgcmVnaXN0ZXJzIGl0IGluIGBwaW5pYS5fc2BcbiAgICAgICAgICAgIGlmIChpc1NldHVwU3RvcmUpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVTZXR1cFN0b3JlKGlkLCBzZXR1cCwgb3B0aW9ucywgcGluaWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlT3B0aW9uc1N0b3JlKGlkLCBvcHRpb25zLCBwaW5pYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG5vdCB0aGUgcmlnaHQgaW5mZXJyZWQgdHlwZVxuICAgICAgICAgICAgICAgIHVzZVN0b3JlLl9waW5pYSA9IHBpbmlhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0b3JlID0gcGluaWEuX3MuZ2V0KGlkKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBob3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvdElkID0gJ19faG90OicgKyBpZDtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0b3JlID0gaXNTZXR1cFN0b3JlXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVTZXR1cFN0b3JlKGhvdElkLCBzZXR1cCwgb3B0aW9ucywgcGluaWEsIHRydWUpXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVPcHRpb25zU3RvcmUoaG90SWQsIGFzc2lnbih7fSwgb3B0aW9ucyksIHBpbmlhLCB0cnVlKTtcbiAgICAgICAgICAgIGhvdC5faG90VXBkYXRlKG5ld1N0b3JlKTtcbiAgICAgICAgICAgIC8vIGNsZWFudXAgdGhlIHN0YXRlIHByb3BlcnRpZXMgYW5kIHRoZSBzdG9yZSBmcm9tIHRoZSBjYWNoZVxuICAgICAgICAgICAgZGVsZXRlIHBpbmlhLnN0YXRlLnZhbHVlW2hvdElkXTtcbiAgICAgICAgICAgIHBpbmlhLl9zLmRlbGV0ZShob3RJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBJU19DTElFTlQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgLy8gc2F2ZSBzdG9yZXMgaW4gaW5zdGFuY2VzIHRvIGFjY2VzcyB0aGVtIGRldnRvb2xzXG4gICAgICAgICAgICBpZiAoY3VycmVudEluc3RhbmNlICYmXG4gICAgICAgICAgICAgICAgY3VycmVudEluc3RhbmNlLnByb3h5ICYmXG4gICAgICAgICAgICAgICAgLy8gYXZvaWQgYWRkaW5nIHN0b3JlcyB0aGF0IGFyZSBqdXN0IGJ1aWx0IGZvciBob3QgbW9kdWxlIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgIWhvdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZtID0gY3VycmVudEluc3RhbmNlLnByb3h5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gJ19wU3RvcmVzJyBpbiB2bSA/IHZtLl9wU3RvcmVzIDogKHZtLl9wU3RvcmVzID0ge30pO1xuICAgICAgICAgICAgICAgIGNhY2hlW2lkXSA9IHN0b3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlR2VuZXJpYyBjYW5ub3QgYmUgY2FzdGVkIHRvd2FyZHMgU3RvcmVcbiAgICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH1cbiAgICB1c2VTdG9yZS4kaWQgPSBpZDtcbiAgICByZXR1cm4gdXNlU3RvcmU7XG59XG5cbmxldCBtYXBTdG9yZVN1ZmZpeCA9ICdTdG9yZSc7XG4vKipcbiAqIENoYW5nZXMgdGhlIHN1ZmZpeCBhZGRlZCBieSBgbWFwU3RvcmVzKClgLiBDYW4gYmUgc2V0IHRvIGFuIGVtcHR5IHN0cmluZy5cbiAqIERlZmF1bHRzIHRvIGBcIlN0b3JlXCJgLiBNYWtlIHN1cmUgdG8gZXh0ZW5kIHRoZSBNYXBTdG9yZXNDdXN0b21pemF0aW9uXG4gKiBpbnRlcmZhY2UgaWYgeW91IGFyZSB1c2luZyBUeXBlU2NyaXB0LlxuICpcbiAqIEBwYXJhbSBzdWZmaXggLSBuZXcgc3VmZml4XG4gKi9cbmZ1bmN0aW9uIHNldE1hcFN0b3JlU3VmZml4KHN1ZmZpeCAvLyBjb3VsZCBiZSAnU3RvcmUnIGJ1dCB0aGF0IHdvdWxkIGJlIGFubm95aW5nIGZvciBKU1xuKSB7XG4gICAgbWFwU3RvcmVTdWZmaXggPSBzdWZmaXg7XG59XG4vKipcbiAqIEFsbG93cyB1c2luZyBzdG9yZXMgd2l0aG91dCB0aGUgY29tcG9zaXRpb24gQVBJIChgc2V0dXAoKWApIGJ5IGdlbmVyYXRpbmcgYW5cbiAqIG9iamVjdCB0byBiZSBzcHJlYWQgaW4gdGhlIGBjb21wdXRlZGAgZmllbGQgb2YgYSBjb21wb25lbnQuIEl0IGFjY2VwdHMgYSBsaXN0XG4gKiBvZiBzdG9yZSBkZWZpbml0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGV4cG9ydCBkZWZhdWx0IHtcbiAqICAgY29tcHV0ZWQ6IHtcbiAqICAgICAvLyBvdGhlciBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gKiAgICAgLi4ubWFwU3RvcmVzKHVzZVVzZXJTdG9yZSwgdXNlQ2FydFN0b3JlKVxuICogICB9LFxuICpcbiAqICAgY3JlYXRlZCgpIHtcbiAqICAgICB0aGlzLnVzZXJTdG9yZSAvLyBzdG9yZSB3aXRoIGlkIFwidXNlclwiXG4gKiAgICAgdGhpcy5jYXJ0U3RvcmUgLy8gc3RvcmUgd2l0aCBpZCBcImNhcnRcIlxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc3RvcmVzIC0gbGlzdCBvZiBzdG9yZXMgdG8gbWFwIHRvIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiBtYXBTdG9yZXMoLi4uc3RvcmVzKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBBcnJheS5pc0FycmF5KHN0b3Jlc1swXSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBb8J+NjV06IERpcmVjdGx5IHBhc3MgYWxsIHN0b3JlcyB0byBcIm1hcFN0b3JlcygpXCIgd2l0aG91dCBwdXR0aW5nIHRoZW0gaW4gYW4gYXJyYXk6XFxuYCArXG4gICAgICAgICAgICBgUmVwbGFjZVxcbmAgK1xuICAgICAgICAgICAgYFxcdG1hcFN0b3JlcyhbdXNlQXV0aFN0b3JlLCB1c2VDYXJ0U3RvcmVdKVxcbmAgK1xuICAgICAgICAgICAgYHdpdGhcXG5gICtcbiAgICAgICAgICAgIGBcXHRtYXBTdG9yZXModXNlQXV0aFN0b3JlLCB1c2VDYXJ0U3RvcmUpXFxuYCArXG4gICAgICAgICAgICBgVGhpcyB3aWxsIGZhaWwgaW4gcHJvZHVjdGlvbiBpZiBub3QgZml4ZWQuYCk7XG4gICAgICAgIHN0b3JlcyA9IHN0b3Jlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3Jlcy5yZWR1Y2UoKHJlZHVjZWQsIHVzZVN0b3JlKSA9PiB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6ICRpZCBpcyBhZGRlZCBieSBkZWZpbmVTdG9yZVxuICAgICAgICByZWR1Y2VkW3VzZVN0b3JlLiRpZCArIG1hcFN0b3JlU3VmZml4XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VTdG9yZSh0aGlzLiRwaW5pYSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgIH0sIHt9KTtcbn1cbi8qKlxuICogQWxsb3dzIHVzaW5nIHN0YXRlIGFuZCBnZXR0ZXJzIGZyb20gb25lIHN0b3JlIHdpdGhvdXQgdXNpbmcgdGhlIGNvbXBvc2l0aW9uXG4gKiBBUEkgKGBzZXR1cCgpYCkgYnkgZ2VuZXJhdGluZyBhbiBvYmplY3QgdG8gYmUgc3ByZWFkIGluIHRoZSBgY29tcHV0ZWRgIGZpZWxkXG4gKiBvZiBhIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0gdXNlU3RvcmUgLSBzdG9yZSB0byBtYXAgZnJvbVxuICogQHBhcmFtIGtleXNPck1hcHBlciAtIGFycmF5IG9yIG9iamVjdFxuICovXG5mdW5jdGlvbiBtYXBTdGF0ZSh1c2VTdG9yZSwga2V5c09yTWFwcGVyKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoa2V5c09yTWFwcGVyKVxuICAgICAgICA/IGtleXNPck1hcHBlci5yZWR1Y2UoKHJlZHVjZWQsIGtleSkgPT4ge1xuICAgICAgICAgICAgcmVkdWNlZFtrZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEZJWE1FOiBzaG91bGQgd29yaz9cbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlU3RvcmUodGhpcy4kcGluaWEpW2tleV07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZWQ7XG4gICAgICAgIH0sIHt9KVxuICAgICAgICA6IE9iamVjdC5rZXlzKGtleXNPck1hcHBlcikucmVkdWNlKChyZWR1Y2VkLCBrZXkpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHJlZHVjZWRba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKHRoaXMuJHBpbmlhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZUtleSA9IGtleXNPck1hcHBlcltrZXldO1xuICAgICAgICAgICAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBUUyBpcyB1bmFibGUgdG8gaW5mZXIgdGhlIHR5cGUgb2Ygc3RvcmVLZXkgdG8gYmUgYVxuICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBzdG9yZUtleSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICA/IHN0b3JlS2V5LmNhbGwodGhpcywgc3RvcmUpXG4gICAgICAgICAgICAgICAgICAgIDogLy8gQHRzLWV4cGVjdC1lcnJvcjogRklYTUU6IHNob3VsZCB3b3JrP1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVbc3RvcmVLZXldO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgICAgICB9LCB7fSk7XG59XG4vKipcbiAqIEFsaWFzIGZvciBgbWFwU3RhdGUoKWAuIFlvdSBzaG91bGQgdXNlIGBtYXBTdGF0ZSgpYCBpbnN0ZWFkLlxuICogQGRlcHJlY2F0ZWQgdXNlIGBtYXBTdGF0ZSgpYCBpbnN0ZWFkLlxuICovXG5jb25zdCBtYXBHZXR0ZXJzID0gbWFwU3RhdGU7XG4vKipcbiAqIEFsbG93cyBkaXJlY3RseSB1c2luZyBhY3Rpb25zIGZyb20geW91ciBzdG9yZSB3aXRob3V0IHVzaW5nIHRoZSBjb21wb3NpdGlvblxuICogQVBJIChgc2V0dXAoKWApIGJ5IGdlbmVyYXRpbmcgYW4gb2JqZWN0IHRvIGJlIHNwcmVhZCBpbiB0aGUgYG1ldGhvZHNgIGZpZWxkXG4gKiBvZiBhIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0gdXNlU3RvcmUgLSBzdG9yZSB0byBtYXAgZnJvbVxuICogQHBhcmFtIGtleXNPck1hcHBlciAtIGFycmF5IG9yIG9iamVjdFxuICovXG5mdW5jdGlvbiBtYXBBY3Rpb25zKHVzZVN0b3JlLCBrZXlzT3JNYXBwZXIpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShrZXlzT3JNYXBwZXIpXG4gICAgICAgID8ga2V5c09yTWFwcGVyLnJlZHVjZSgocmVkdWNlZCwga2V5KSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICByZWR1Y2VkW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEZJWE1FOiBzaG91bGQgd29yaz9cbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlU3RvcmUodGhpcy4kcGluaWEpW2tleV0oLi4uYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZWQ7XG4gICAgICAgIH0sIHt9KVxuICAgICAgICA6IE9iamVjdC5rZXlzKGtleXNPck1hcHBlcikucmVkdWNlKChyZWR1Y2VkLCBrZXkpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHJlZHVjZWRba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogRklYTUU6IHNob3VsZCB3b3JrP1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VTdG9yZSh0aGlzLiRwaW5pYSlba2V5c09yTWFwcGVyW2tleV1dKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgICAgICB9LCB7fSk7XG59XG4vKipcbiAqIEFsbG93cyB1c2luZyBzdGF0ZSBhbmQgZ2V0dGVycyBmcm9tIG9uZSBzdG9yZSB3aXRob3V0IHVzaW5nIHRoZSBjb21wb3NpdGlvblxuICogQVBJIChgc2V0dXAoKWApIGJ5IGdlbmVyYXRpbmcgYW4gb2JqZWN0IHRvIGJlIHNwcmVhZCBpbiB0aGUgYGNvbXB1dGVkYCBmaWVsZFxuICogb2YgYSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHVzZVN0b3JlIC0gc3RvcmUgdG8gbWFwIGZyb21cbiAqIEBwYXJhbSBrZXlzT3JNYXBwZXIgLSBhcnJheSBvciBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbWFwV3JpdGFibGVTdGF0ZSh1c2VTdG9yZSwga2V5c09yTWFwcGVyKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoa2V5c09yTWFwcGVyKVxuICAgICAgICA/IGtleXNPck1hcHBlci5yZWR1Y2UoKHJlZHVjZWQsIGtleSkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmVkdWNlZFtrZXldID0ge1xuICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogRklYTUU6IHNob3VsZCB3b3JrP1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNlU3RvcmUodGhpcy4kcGluaWEpW2tleV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogRklYTUU6IHNob3VsZCB3b3JrP1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHVzZVN0b3JlKHRoaXMuJHBpbmlhKVtrZXldID0gdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZWQ7XG4gICAgICAgIH0sIHt9KVxuICAgICAgICA6IE9iamVjdC5rZXlzKGtleXNPck1hcHBlcikucmVkdWNlKChyZWR1Y2VkLCBrZXkpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHJlZHVjZWRba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEZJWE1FOiBzaG91bGQgd29yaz9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVzZVN0b3JlKHRoaXMuJHBpbmlhKVtrZXlzT3JNYXBwZXJba2V5XV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogRklYTUU6IHNob3VsZCB3b3JrP1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHVzZVN0b3JlKHRoaXMuJHBpbmlhKVtrZXlzT3JNYXBwZXJba2V5XV0gPSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVkdWNlZDtcbiAgICAgICAgfSwge30pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IG9mIHJlZmVyZW5jZXMgd2l0aCBhbGwgdGhlIHN0YXRlLCBnZXR0ZXJzLCBhbmQgcGx1Z2luLWFkZGVkXG4gKiBzdGF0ZSBwcm9wZXJ0aWVzIG9mIHRoZSBzdG9yZS4gU2ltaWxhciB0byBgdG9SZWZzKClgIGJ1dCBzcGVjaWZpY2FsbHlcbiAqIGRlc2lnbmVkIGZvciBQaW5pYSBzdG9yZXMgc28gbWV0aG9kcyBhbmQgbm9uIHJlYWN0aXZlIHByb3BlcnRpZXMgYXJlXG4gKiBjb21wbGV0ZWx5IGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHN0b3JlIC0gc3RvcmUgdG8gZXh0cmFjdCB0aGUgcmVmcyBmcm9tXG4gKi9cbmZ1bmN0aW9uIHN0b3JlVG9SZWZzKHN0b3JlKSB7XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9waW5pYS9pc3N1ZXMvODUyXG4gICAgLy8gSXQncyBlYXNpZXIgdG8ganVzdCB1c2UgdG9SZWZzKCkgZXZlbiBpZiBpdCBpbmNsdWRlcyBtb3JlIHN0dWZmXG4gICAgaWYgKGlzVnVlMikge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB0b1JlZnMgaW5jbHVkZSBtZXRob2RzIGFuZCBvdGhlcnNcbiAgICAgICAgcmV0dXJuIHRvUmVmcyhzdG9yZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdG9yZSA9IHRvUmF3KHN0b3JlKTtcbiAgICAgICAgY29uc3QgcmVmcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzdG9yZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzdG9yZVtrZXldO1xuICAgICAgICAgICAgaWYgKGlzUmVmKHZhbHVlKSB8fCBpc1JlYWN0aXZlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHRoZSBrZXkgaXMgc3RhdGUgb3IgZ2V0dGVyXG4gICAgICAgICAgICAgICAgcmVmc1trZXldID1cbiAgICAgICAgICAgICAgICAgICAgLy8gLS0tXG4gICAgICAgICAgICAgICAgICAgIHRvUmVmKHN0b3JlLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWZzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWdWUgMiBQbHVnaW4gdGhhdCBtdXN0IGJlIGluc3RhbGxlZCBmb3IgcGluaWEgdG8gd29yay4gTm90ZSAqKnlvdSBkb24ndCBuZWVkXG4gKiB0aGlzIHBsdWdpbiBpZiB5b3UgYXJlIHVzaW5nIE51eHQuanMqKi4gVXNlIHRoZSBgYnVpbGRNb2R1bGVgIGluc3RlYWQ6XG4gKiBodHRwczovL3BpbmlhLnZ1ZWpzLm9yZy9zc3IvbnV4dC5odG1sLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXG4gKiBpbXBvcnQgeyBQaW5pYVZ1ZVBsdWdpbiwgY3JlYXRlUGluaWEgfSBmcm9tICdwaW5pYSdcbiAqXG4gKiBWdWUudXNlKFBpbmlhVnVlUGx1Z2luKVxuICogY29uc3QgcGluaWEgPSBjcmVhdGVQaW5pYSgpXG4gKlxuICogbmV3IFZ1ZSh7XG4gKiAgIGVsOiAnI2FwcCcsXG4gKiAgIC8vIC4uLlxuICogICBwaW5pYSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gX1Z1ZSAtIGBWdWVgIGltcG9ydGVkIGZyb20gJ3Z1ZScuXG4gKi9cbmNvbnN0IFBpbmlhVnVlUGx1Z2luID0gZnVuY3Rpb24gKF9WdWUpIHtcbiAgICAvLyBFcXVpdmFsZW50IG9mXG4gICAgLy8gYXBwLmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLiRwaW5pYSA9IHBpbmlhXG4gICAgX1Z1ZS5taXhpbih7XG4gICAgICAgIGJlZm9yZUNyZWF0ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGluaWEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaW5pYSA9IG9wdGlvbnMucGluaWE7XG4gICAgICAgICAgICAgICAgLy8gSEFDSzogdGFrZW4gZnJvbSBwcm92aWRlKCk6IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9jb21wb3NpdGlvbi1hcGkvYmxvYi9tYWluL3NyYy9hcGlzL2luamVjdC50cyNMMzFcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcHJvdmlkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZUNhY2hlID0ge307XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX3Byb3ZpZGVkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBwcm92aWRlQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQ6ICh2KSA9PiBPYmplY3QuYXNzaWduKHByb3ZpZGVDYWNoZSwgdiksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9wcm92aWRlZFtwaW5pYVN5bWJvbF0gPSBwaW5pYTtcbiAgICAgICAgICAgICAgICAvLyBwcm9wYWdhdGUgdGhlIHBpbmlhIGluc3RhbmNlIGluIGFuIFNTUiBmcmllbmRseSB3YXlcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCBhZGRpbmcgaXQgdG8gbnV4dCB0d2ljZVxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLiRwaW5pYSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRwaW5pYSA9IHBpbmlhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwaW5pYS5fYSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKElTX0NMSUVOVCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGFsbG93cyBjYWxsaW5nIHVzZVN0b3JlKCkgb3V0c2lkZSBvZiBhIGNvbXBvbmVudCBzZXR1cCBhZnRlclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnN0YWxsaW5nIHBpbmlhJ3MgcGx1Z2luXG4gICAgICAgICAgICAgICAgICAgIHNldEFjdGl2ZVBpbmlhKHBpbmlhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSAndW5kZWZpbmVkJyAmJiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pKSAmJiAhKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpKSAmJiBJU19DTElFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJQaW5pYURldnRvb2xzKHBpbmlhLl9hLCBwaW5pYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuJHBpbmlhICYmIG9wdGlvbnMucGFyZW50ICYmIG9wdGlvbnMucGFyZW50LiRwaW5pYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHBpbmlhID0gb3B0aW9ucy5wYXJlbnQuJHBpbmlhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95ZWQoKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcFN0b3JlcztcbiAgICAgICAgfSxcbiAgICB9KTtcbn07XG5cbmV4cG9ydCB7IE11dGF0aW9uVHlwZSwgUGluaWFWdWVQbHVnaW4sIGFjY2VwdEhNUlVwZGF0ZSwgY3JlYXRlUGluaWEsIGRlZmluZVN0b3JlLCBkaXNwb3NlUGluaWEsIGdldEFjdGl2ZVBpbmlhLCBtYXBBY3Rpb25zLCBtYXBHZXR0ZXJzLCBtYXBTdGF0ZSwgbWFwU3RvcmVzLCBtYXBXcml0YWJsZVN0YXRlLCBzZXRBY3RpdmVQaW5pYSwgc2V0TWFwU3RvcmVTdWZmaXgsIHNraXBIeWRyYXRlLCBzdG9yZVRvUmVmcyB9O1xuIiwiLyoqXG4gKiByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHByb21pc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnQgdmFyIFBST01JU0VfUkVTT0xWRURfRkFMU0UgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuZXhwb3J0IHZhciBQUk9NSVNFX1JFU09MVkVEX1RSVUUgPSBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG5leHBvcnQgdmFyIFBST01JU0VfUkVTT0xWRURfVk9JRCA9IFByb21pc2UucmVzb2x2ZSgpO1xuZXhwb3J0IGZ1bmN0aW9uIHNsZWVwKHRpbWUsIHJlc29sdmVXaXRoKSB7XG4gIGlmICghdGltZSkgdGltZSA9IDA7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlcyhyZXNvbHZlV2l0aCk7XG4gICAgfSwgdGltZSk7XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUludChtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpICsgbWluKTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODA4NDI0OFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tVG9rZW4oKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMik7XG59XG52YXIgbGFzdE1zID0gMDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHVuaXggdGltZSBpbiBtaWNyby1zZWNvbmRzLFxuICogV0FSTklORzogVGhpcyBpcyBhIHBzZXVkby1mdW5jdGlvblxuICogUGVyZm9ybWFuY2Uubm93IGlzIG5vdCByZWxpYWJsZSBpbiB3ZWJ3b3JrZXJzLCBzbyB3ZSBqdXN0IG1ha2Ugc3VyZSB0byBuZXZlciByZXR1cm4gdGhlIHNhbWUgdGltZS5cbiAqIFRoaXMgaXMgZW5vdWdoIGluIGJyb3dzZXJzLCBhbmQgdGhpcyBmdW5jdGlvbiB3aWxsIG5vdCBiZSB1c2VkIGluIG5vZGVqcy5cbiAqIFRoZSBtYWluIHJlYXNvbiBmb3IgdGhpcyBoYWNrIGlzIHRvIGVuc3VyZSB0aGF0IEJyb2FkY2FzdENoYW5uZWwgYmVoYXZlcyBlcXVhbCB0byBwcm9kdWN0aW9uIHdoZW4gaXQgaXMgdXNlZCBpbiBmYXN0LXJ1bm5pbmcgdW5pdCB0ZXN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1pY3JvU2Vjb25kcygpIHtcbiAgdmFyIHJldCA9IERhdGUubm93KCkgKiAxMDAwOyAvLyBtaWxsaXNlY29uZHMgdG8gbWljcm9zZWNvbmRzXG4gIGlmIChyZXQgPD0gbGFzdE1zKSB7XG4gICAgcmV0ID0gbGFzdE1zICsgMTtcbiAgfVxuICBsYXN0TXMgPSByZXQ7XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgV2ViTG9jayBBUEkgaXMgc3VwcG9ydGVkLlxuICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9Mb2Nrc19BUElcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRzV2ViTG9ja0FQSSgpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IubG9ja3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IubG9ja3MucmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSIsImltcG9ydCB7IG1pY3JvU2Vjb25kcyBhcyBtaWNybywgUFJPTUlTRV9SRVNPTFZFRF9WT0lEIH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5leHBvcnQgdmFyIG1pY3JvU2Vjb25kcyA9IG1pY3JvO1xuZXhwb3J0IHZhciB0eXBlID0gJ25hdGl2ZSc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKGNoYW5uZWxOYW1lKSB7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICB0aW1lOiBtaWNybygpLFxuICAgIG1lc3NhZ2VzQ2FsbGJhY2s6IG51bGwsXG4gICAgYmM6IG5ldyBCcm9hZGNhc3RDaGFubmVsKGNoYW5uZWxOYW1lKSxcbiAgICBzdWJGbnM6IFtdIC8vIHN1YnNjcmliZXJGdW5jdGlvbnNcbiAgfTtcblxuICBzdGF0ZS5iYy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAobXNnRXZlbnQpIHtcbiAgICBpZiAoc3RhdGUubWVzc2FnZXNDYWxsYmFjaykge1xuICAgICAgc3RhdGUubWVzc2FnZXNDYWxsYmFjayhtc2dFdmVudC5kYXRhKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBzdGF0ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZShjaGFubmVsU3RhdGUpIHtcbiAgY2hhbm5lbFN0YXRlLmJjLmNsb3NlKCk7XG4gIGNoYW5uZWxTdGF0ZS5zdWJGbnMgPSBbXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3N0TWVzc2FnZShjaGFubmVsU3RhdGUsIG1lc3NhZ2VKc29uKSB7XG4gIHRyeSB7XG4gICAgY2hhbm5lbFN0YXRlLmJjLnBvc3RNZXNzYWdlKG1lc3NhZ2VKc29uLCBmYWxzZSk7XG4gICAgcmV0dXJuIFBST01JU0VfUkVTT0xWRURfVk9JRDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBvbk1lc3NhZ2UoY2hhbm5lbFN0YXRlLCBmbikge1xuICBjaGFubmVsU3RhdGUubWVzc2FnZXNDYWxsYmFjayA9IGZuO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNhbkJlVXNlZCgpIHtcbiAgLy8gRGVubyBydW50aW1lXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuRGVubyAmJiBnbG9iYWxUaGlzLkRlbm8uYXJncykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gQnJvd3NlciBydW50aW1lXG4gIGlmICgodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSAmJiB0eXBlb2YgQnJvYWRjYXN0Q2hhbm5lbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChCcm9hZGNhc3RDaGFubmVsLl9wdWJrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQnJvYWRjYXN0Q2hhbm5lbDogRG8gbm90IG92ZXJ3cml0ZSB3aW5kb3cuQnJvYWRjYXN0Q2hhbm5lbCB3aXRoIHRoaXMgbW9kdWxlLCB0aGlzIGlzIG5vdCBhIHBvbHlmaWxsJyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGF2ZXJhZ2VSZXNwb25zZVRpbWUoKSB7XG4gIHJldHVybiAxNTA7XG59XG5leHBvcnQgdmFyIE5hdGl2ZU1ldGhvZCA9IHtcbiAgY3JlYXRlOiBjcmVhdGUsXG4gIGNsb3NlOiBjbG9zZSxcbiAgb25NZXNzYWdlOiBvbk1lc3NhZ2UsXG4gIHBvc3RNZXNzYWdlOiBwb3N0TWVzc2FnZSxcbiAgY2FuQmVVc2VkOiBjYW5CZVVzZWQsXG4gIHR5cGU6IHR5cGUsXG4gIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IGF2ZXJhZ2VSZXNwb25zZVRpbWUsXG4gIG1pY3JvU2Vjb25kczogbWljcm9TZWNvbmRzXG59OyIsIi8qKlxuICogdGhpcyBpcyBhIHNldCB3aGljaCBhdXRvbWF0aWNhbGx5IGZvcmdldHNcbiAqIGEgZ2l2ZW4gZW50cnkgd2hlbiBhIG5ldyBlbnRyeSBpcyBzZXQgYW5kIHRoZSB0dGxcbiAqIG9mIHRoZSBvbGQgb25lIGlzIG92ZXJcbiAqL1xuZXhwb3J0IGNsYXNzIE9ibGl2aW91c1NldCB7XG4gICAgdHRsO1xuICAgIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGluZyBjYWxscyB0byBzZXRUaW1lb3V0KCkgaXMgZXhwZW5zaXZlLFxuICAgICAqIHNvIHdlIG9ubHkgZG8gdGhhdCBpZiB0aGVyZSBpcyBub3QgdGltZW91dCBhbHJlYWR5IG9wZW4uXG4gICAgICovXG4gICAgX3RvID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IodHRsKSB7XG4gICAgICAgIHRoaXMudHRsID0gdHRsO1xuICAgIH1cbiAgICBoYXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmhhcyh2YWx1ZSk7XG4gICAgfVxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1hcC5zZXQodmFsdWUsIG5vdygpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gYSBuZXcgdmFsdWUgaXMgYWRkZWQsXG4gICAgICAgICAqIHN0YXJ0IHRoZSBjbGVhbnVwIGF0IHRoZSBuZXh0IHRpY2tcbiAgICAgICAgICogdG8gbm90IGJsb2NrIHRoZSBjcHUgZm9yIG1vcmUgaW1wb3J0YW50IHN0dWZmXG4gICAgICAgICAqIHRoYXQgbWlnaHQgaGFwcGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCF0aGlzLl90bykge1xuICAgICAgICAgICAgdGhpcy5fdG8gPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG8gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZW1vdmVUb29PbGRWYWx1ZXModGhpcyk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5tYXAuY2xlYXIoKTtcbiAgICB9XG59XG4vKipcbiAqIFJlbW92ZXMgYWxsIGVudHJpZXMgZnJvbSB0aGUgc2V0XG4gKiB3aGVyZSB0aGUgVFRMIGhhcyBleHBpcmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVUb29PbGRWYWx1ZXMob2JsaXZpb3VzU2V0KSB7XG4gICAgY29uc3Qgb2xkZXJUaGVuID0gbm93KCkgLSBvYmxpdmlvdXNTZXQudHRsO1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gb2JsaXZpb3VzU2V0Lm1hcFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgLyoqXG4gICAgICogQmVjYXVzZSB3ZSBjYW4gYXNzdW1lIHRoZSBuZXcgdmFsdWVzIGFyZSBhZGRlZCBhdCB0aGUgYm90dG9tLFxuICAgICAqIHdlIHN0YXJ0IGZyb20gdGhlIHRvcCBhbmQgc3RvcCBhcyBzb29uIGFzIHdlIHJlYWNoIGEgbm9uLXRvby1vbGQgdmFsdWUuXG4gICAgICovXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIG5vIG1vcmUgZWxlbWVudHNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IG5leHRbMF07XG4gICAgICAgIGNvbnN0IHRpbWUgPSBuZXh0WzFdO1xuICAgICAgICBpZiAodGltZSA8IG9sZGVyVGhlbikge1xuICAgICAgICAgICAgb2JsaXZpb3VzU2V0Lm1hcC5kZWxldGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgcmVhY2hlZCBhIHZhbHVlIHRoYXQgaXMgbm90IG9sZCBlbm91Z2hcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gZmlsbE9wdGlvbnNXaXRoRGVmYXVsdHMoKSB7XG4gIHZhciBvcmlnaW5hbE9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgb3B0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3JpZ2luYWxPcHRpb25zKSk7XG5cbiAgLy8gbWFpblxuICBpZiAodHlwZW9mIG9wdGlvbnMud2ViV29ya2VyU3VwcG9ydCA9PT0gJ3VuZGVmaW5lZCcpIG9wdGlvbnMud2ViV29ya2VyU3VwcG9ydCA9IHRydWU7XG5cbiAgLy8gaW5kZXhlZC1kYlxuICBpZiAoIW9wdGlvbnMuaWRiKSBvcHRpb25zLmlkYiA9IHt9O1xuICAvLyAgYWZ0ZXIgdGhpcyB0aW1lIHRoZSBtZXNzYWdlcyBnZXQgZGVsZXRlZFxuICBpZiAoIW9wdGlvbnMuaWRiLnR0bCkgb3B0aW9ucy5pZGIudHRsID0gMTAwMCAqIDQ1O1xuICBpZiAoIW9wdGlvbnMuaWRiLmZhbGxiYWNrSW50ZXJ2YWwpIG9wdGlvbnMuaWRiLmZhbGxiYWNrSW50ZXJ2YWwgPSAxNTA7XG4gIC8vICBoYW5kbGVzIGFicnVwdCBkYiBvbmNsb3NlIGV2ZW50cy5cbiAgaWYgKG9yaWdpbmFsT3B0aW9ucy5pZGIgJiYgdHlwZW9mIG9yaWdpbmFsT3B0aW9ucy5pZGIub25jbG9zZSA9PT0gJ2Z1bmN0aW9uJykgb3B0aW9ucy5pZGIub25jbG9zZSA9IG9yaWdpbmFsT3B0aW9ucy5pZGIub25jbG9zZTtcblxuICAvLyBsb2NhbHN0b3JhZ2VcbiAgaWYgKCFvcHRpb25zLmxvY2Fsc3RvcmFnZSkgb3B0aW9ucy5sb2NhbHN0b3JhZ2UgPSB7fTtcbiAgaWYgKCFvcHRpb25zLmxvY2Fsc3RvcmFnZS5yZW1vdmVUaW1lb3V0KSBvcHRpb25zLmxvY2Fsc3RvcmFnZS5yZW1vdmVUaW1lb3V0ID0gMTAwMCAqIDYwO1xuXG4gIC8vIGN1c3RvbSBtZXRob2RzXG4gIGlmIChvcmlnaW5hbE9wdGlvbnMubWV0aG9kcykgb3B0aW9ucy5tZXRob2RzID0gb3JpZ2luYWxPcHRpb25zLm1ldGhvZHM7XG5cbiAgLy8gbm9kZVxuICBpZiAoIW9wdGlvbnMubm9kZSkgb3B0aW9ucy5ub2RlID0ge307XG4gIGlmICghb3B0aW9ucy5ub2RlLnR0bCkgb3B0aW9ucy5ub2RlLnR0bCA9IDEwMDAgKiA2MCAqIDI7IC8vIDIgbWludXRlcztcbiAgLyoqXG4gICAqIE9uIGxpbnV4IHVzZSAndWxpbWl0IC1IbicgdG8gZ2V0IHRoZSBsaW1pdCBvZiBvcGVuIGZpbGVzLlxuICAgKiBPbiB1YnVudHUgdGhpcyB3YXMgNDA5NiBmb3IgbWUsIHNvIHdlIHVzZSBoYWxmIG9mIHRoYXQgYXMgbWF4UGFyYWxsZWxXcml0ZXMgZGVmYXVsdC5cbiAgICovXG4gIGlmICghb3B0aW9ucy5ub2RlLm1heFBhcmFsbGVsV3JpdGVzKSBvcHRpb25zLm5vZGUubWF4UGFyYWxsZWxXcml0ZXMgPSAyMDQ4O1xuICBpZiAodHlwZW9mIG9wdGlvbnMubm9kZS51c2VGYXN0UGF0aCA9PT0gJ3VuZGVmaW5lZCcpIG9wdGlvbnMubm9kZS51c2VGYXN0UGF0aCA9IHRydWU7XG4gIHJldHVybiBvcHRpb25zO1xufSIsIi8qKlxuICogdGhpcyBtZXRob2QgdXNlcyBpbmRleGVkZGIgdG8gc3RvcmUgdGhlIG1lc3NhZ2VzXG4gKiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gb2JzZXJ2ZXJBUEkgZm9yIGlkYlxuICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3czYy9JbmRleGVkREIvaXNzdWVzLzUxXG4gKiBcbiAqIFdoZW4gd29ya2luZyBvbiB0aGlzLCBlbnN1cmUgdG8gdXNlIHRoZXNlIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiBAbGluayBodHRwczovL3J4ZGIuaW5mby9zbG93LWluZGV4ZWRkYi5odG1sXG4gKi9cblxuaW1wb3J0IHsgc2xlZXAsIHJhbmRvbUludCwgcmFuZG9tVG9rZW4sIG1pY3JvU2Vjb25kcyBhcyBtaWNybywgUFJPTUlTRV9SRVNPTFZFRF9WT0lEIH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5leHBvcnQgdmFyIG1pY3JvU2Vjb25kcyA9IG1pY3JvO1xuaW1wb3J0IHsgT2JsaXZpb3VzU2V0IH0gZnJvbSAnb2JsaXZpb3VzLXNldCc7XG5pbXBvcnQgeyBmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyB9IGZyb20gJy4uL29wdGlvbnMuanMnO1xudmFyIERCX1BSRUZJWCA9ICdwdWJrZXkuYnJvYWRjYXN0LWNoYW5uZWwtMC0nO1xudmFyIE9CSkVDVF9TVE9SRV9JRCA9ICdtZXNzYWdlcyc7XG5cbi8qKlxuICogVXNlIHJlbGF4ZWQgZHVyYWJpbGl0eSBmb3IgZmFzdGVyIHBlcmZvcm1hbmNlIG9uIGFsbCB0cmFuc2FjdGlvbnMuXG4gKiBAbGluayBodHRwczovL25vbGFubGF3c29uLmNvbS8yMDIxLzA4LzIyL3NwZWVkaW5nLXVwLWluZGV4ZWRkYi1yZWFkcy1hbmQtd3JpdGVzL1xuICovXG5leHBvcnQgdmFyIFRSQU5TQUNUSU9OX1NFVFRJTkdTID0ge1xuICBkdXJhYmlsaXR5OiAncmVsYXhlZCdcbn07XG5leHBvcnQgdmFyIHR5cGUgPSAnaWRiJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRJZGIoKSB7XG4gIGlmICh0eXBlb2YgaW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGluZGV4ZWREQjtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cubW96SW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHdpbmRvdy5tb3pJbmRleGVkREI7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cud2Via2l0SW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHdpbmRvdy53ZWJraXRJbmRleGVkREI7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cubXNJbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gd2luZG93Lm1zSW5kZXhlZERCO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBJZiBwb3NzaWJsZSwgd2Ugc2hvdWxkIGV4cGxpY2l0bHkgY29tbWl0IEluZGV4ZWREQiB0cmFuc2FjdGlvbnNcbiAqIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gKiBAbGluayBodHRwczovL25vbGFubGF3c29uLmNvbS8yMDIxLzA4LzIyL3NwZWVkaW5nLXVwLWluZGV4ZWRkYi1yZWFkcy1hbmQtd3JpdGVzL1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbWl0SW5kZXhlZERCVHJhbnNhY3Rpb24odHgpIHtcbiAgaWYgKHR4LmNvbW1pdCkge1xuICAgIHR4LmNvbW1pdCgpO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGF0YWJhc2UoY2hhbm5lbE5hbWUpIHtcbiAgdmFyIEluZGV4ZWREQiA9IGdldElkYigpO1xuXG4gIC8vIGNyZWF0ZSB0YWJsZVxuICB2YXIgZGJOYW1lID0gREJfUFJFRklYICsgY2hhbm5lbE5hbWU7XG5cbiAgLyoqXG4gICAqIEFsbCBJbmRleGVkREIgZGF0YWJhc2VzIGFyZSBvcGVuZWQgd2l0aG91dCB2ZXJzaW9uXG4gICAqIGJlY2F1c2UgaXQgaXMgYSBiaXQgZmFzdGVyLCBlc3BlY2lhbGx5IG9uIGZpcmVmb3hcbiAgICogQGxpbmsgaHR0cDovL25wYXJhc2h1cmFtLmNvbS9JbmRleGVkREIvcGVyZi8jT3BlbiUyMERhdGFiYXNlJTIwd2l0aCUyMHZlcnNpb25cbiAgICovXG4gIHZhciBvcGVuUmVxdWVzdCA9IEluZGV4ZWREQi5vcGVuKGRiTmFtZSk7XG4gIG9wZW5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IGZ1bmN0aW9uIChldikge1xuICAgIHZhciBkYiA9IGV2LnRhcmdldC5yZXN1bHQ7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lELCB7XG4gICAgICBrZXlQYXRoOiAnaWQnLFxuICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgb3BlblJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgcmV0dXJuIHJlaihldik7XG4gICAgfTtcbiAgICBvcGVuUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXMob3BlblJlcXVlc3QucmVzdWx0KTtcbiAgICB9O1xuICB9KTtcbn1cblxuLyoqXG4gKiB3cml0ZXMgdGhlIG5ldyBtZXNzYWdlIHRvIHRoZSBkYXRhYmFzZVxuICogc28gb3RoZXIgcmVhZGVycyBjYW4gZmluZCBpdFxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVNZXNzYWdlKGRiLCByZWFkZXJVdWlkLCBtZXNzYWdlSnNvbikge1xuICB2YXIgdGltZSA9IERhdGUubm93KCk7XG4gIHZhciB3cml0ZU9iamVjdCA9IHtcbiAgICB1dWlkOiByZWFkZXJVdWlkLFxuICAgIHRpbWU6IHRpbWUsXG4gICAgZGF0YTogbWVzc2FnZUpzb25cbiAgfTtcbiAgdmFyIHR4ID0gZGIudHJhbnNhY3Rpb24oW09CSkVDVF9TVE9SRV9JRF0sICdyZWFkd3JpdGUnLCBUUkFOU0FDVElPTl9TRVRUSU5HUyk7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcbiAgICB0eC5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlcygpO1xuICAgIH07XG4gICAgdHgub25lcnJvciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgcmV0dXJuIHJlaihldik7XG4gICAgfTtcbiAgICB2YXIgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfSUQpO1xuICAgIG9iamVjdFN0b3JlLmFkZCh3cml0ZU9iamVjdCk7XG4gICAgY29tbWl0SW5kZXhlZERCVHJhbnNhY3Rpb24odHgpO1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxNZXNzYWdlcyhkYikge1xuICB2YXIgdHggPSBkYi50cmFuc2FjdGlvbihPQkpFQ1RfU1RPUkVfSUQsICdyZWFkb25seScsIFRSQU5TQUNUSU9OX1NFVFRJTkdTKTtcbiAgdmFyIG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lEKTtcbiAgdmFyIHJldCA9IFtdO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcykge1xuICAgIG9iamVjdFN0b3JlLm9wZW5DdXJzb3IoKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHZhciBjdXJzb3IgPSBldi50YXJnZXQucmVzdWx0O1xuICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICByZXQucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICAvL2FsZXJ0KFwiTmFtZSBmb3IgU1NOIFwiICsgY3Vyc29yLmtleSArIFwiIGlzIFwiICsgY3Vyc29yLnZhbHVlLm5hbWUpO1xuICAgICAgICBjdXJzb3JbXCJjb250aW51ZVwiXSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWl0SW5kZXhlZERCVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXMocmV0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZXNzYWdlc0hpZ2hlclRoYW4oZGIsIGxhc3RDdXJzb3JJZCkge1xuICB2YXIgdHggPSBkYi50cmFuc2FjdGlvbihPQkpFQ1RfU1RPUkVfSUQsICdyZWFkb25seScsIFRSQU5TQUNUSU9OX1NFVFRJTkdTKTtcbiAgdmFyIG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lEKTtcbiAgdmFyIHJldCA9IFtdO1xuICB2YXIga2V5UmFuZ2VWYWx1ZSA9IElEQktleVJhbmdlLmJvdW5kKGxhc3RDdXJzb3JJZCArIDEsIEluZmluaXR5KTtcblxuICAvKipcbiAgICogT3B0aW1pemF0aW9uIHNob3J0Y3V0LFxuICAgKiBpZiBnZXRBbGwoKSBjYW4gYmUgdXNlZCwgZG8gbm90IHVzZSBhIGN1cnNvci5cbiAgICogQGxpbmsgaHR0cHM6Ly9yeGRiLmluZm8vc2xvdy1pbmRleGVkZGIuaHRtbFxuICAgKi9cbiAgaWYgKG9iamVjdFN0b3JlLmdldEFsbCkge1xuICAgIHZhciBnZXRBbGxSZXF1ZXN0ID0gb2JqZWN0U3RvcmUuZ2V0QWxsKGtleVJhbmdlVmFsdWUpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcbiAgICAgIGdldEFsbFJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlaihlcnIpO1xuICAgICAgfTtcbiAgICAgIGdldEFsbFJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmVzKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIG9wZW5DdXJzb3IoKSB7XG4gICAgLy8gT2NjYXNpb25hbGx5IFNhZmFyaSB3aWxsIGZhaWwgb24gSURCS2V5UmFuZ2UuYm91bmQsIHRoaXNcbiAgICAvLyBjYXRjaGVzIHRoYXQgZXJyb3IsIGhhdmluZyBpdCBvcGVuIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0XG4gICAgLy8gaXRlbS4gV2hlbiBpdCBnZXRzIGRhdGEgaXQgd2lsbCBhZHZhbmNlIHRvIHRoZSBkZXNpcmVkIGtleS5cbiAgICB0cnkge1xuICAgICAga2V5UmFuZ2VWYWx1ZSA9IElEQktleVJhbmdlLmJvdW5kKGxhc3RDdXJzb3JJZCArIDEsIEluZmluaXR5KTtcbiAgICAgIHJldHVybiBvYmplY3RTdG9yZS5vcGVuQ3Vyc29yKGtleVJhbmdlVmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RTdG9yZS5vcGVuQ3Vyc29yKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcbiAgICB2YXIgb3BlbkN1cnNvclJlcXVlc3QgPSBvcGVuQ3Vyc29yKCk7XG4gICAgb3BlbkN1cnNvclJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHJldHVybiByZWooZXJyKTtcbiAgICB9O1xuICAgIG9wZW5DdXJzb3JSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIGN1cnNvciA9IGV2LnRhcmdldC5yZXN1bHQ7XG4gICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgIGlmIChjdXJzb3IudmFsdWUuaWQgPCBsYXN0Q3Vyc29ySWQgKyAxKSB7XG4gICAgICAgICAgY3Vyc29yW1wiY29udGludWVcIl0obGFzdEN1cnNvcklkICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0LnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgICBjdXJzb3JbXCJjb250aW51ZVwiXSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21taXRJbmRleGVkREJUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIHJlcyhyZXQpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU1lc3NhZ2VzQnlJZChjaGFubmVsU3RhdGUsIGlkcykge1xuICBpZiAoY2hhbm5lbFN0YXRlLmNsb3NlZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICB9XG4gIHZhciB0eCA9IGNoYW5uZWxTdGF0ZS5kYi50cmFuc2FjdGlvbihPQkpFQ1RfU1RPUkVfSUQsICdyZWFkd3JpdGUnLCBUUkFOU0FDVElPTl9TRVRUSU5HUyk7XG4gIHZhciBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9JRCk7XG4gIHJldHVybiBQcm9taXNlLmFsbChpZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBkZWxldGVSZXF1ZXN0ID0gb2JqZWN0U3RvcmVbXCJkZWxldGVcIl0oaWQpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICBkZWxldGVSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcygpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE9sZE1lc3NhZ2VzKGRiLCB0dGwpIHtcbiAgdmFyIG9sZGVyVGhlbiA9IERhdGUubm93KCkgLSB0dGw7XG4gIHZhciB0eCA9IGRiLnRyYW5zYWN0aW9uKE9CSkVDVF9TVE9SRV9JRCwgJ3JlYWRvbmx5JywgVFJBTlNBQ1RJT05fU0VUVElOR1MpO1xuICB2YXIgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfSUQpO1xuICB2YXIgcmV0ID0gW107XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7XG4gICAgb2JqZWN0U3RvcmUub3BlbkN1cnNvcigpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIGN1cnNvciA9IGV2LnRhcmdldC5yZXN1bHQ7XG4gICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgIHZhciBtc2dPYmsgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgIGlmIChtc2dPYmsudGltZSA8IG9sZGVyVGhlbikge1xuICAgICAgICAgIHJldC5wdXNoKG1zZ09iayk7XG4gICAgICAgICAgLy9hbGVydChcIk5hbWUgZm9yIFNTTiBcIiArIGN1cnNvci5rZXkgKyBcIiBpcyBcIiArIGN1cnNvci52YWx1ZS5uYW1lKTtcbiAgICAgICAgICBjdXJzb3JbXCJjb250aW51ZVwiXSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIG1vcmUgb2xkIG1lc3NhZ2VzLFxuICAgICAgICAgIGNvbW1pdEluZGV4ZWREQlRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgICByZXMocmV0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzKHJldCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY2xlYW5PbGRNZXNzYWdlcyhjaGFubmVsU3RhdGUpIHtcbiAgcmV0dXJuIGdldE9sZE1lc3NhZ2VzKGNoYW5uZWxTdGF0ZS5kYiwgY2hhbm5lbFN0YXRlLm9wdGlvbnMuaWRiLnR0bCkudGhlbihmdW5jdGlvbiAodG9vT2xkKSB7XG4gICAgcmV0dXJuIHJlbW92ZU1lc3NhZ2VzQnlJZChjaGFubmVsU3RhdGUsIHRvb09sZC5tYXAoZnVuY3Rpb24gKG1zZykge1xuICAgICAgcmV0dXJuIG1zZy5pZDtcbiAgICB9KSk7XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShjaGFubmVsTmFtZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gZmlsbE9wdGlvbnNXaXRoRGVmYXVsdHMob3B0aW9ucyk7XG4gIHJldHVybiBjcmVhdGVEYXRhYmFzZShjaGFubmVsTmFtZSkudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBjbG9zZWQ6IGZhbHNlLFxuICAgICAgbGFzdEN1cnNvcklkOiAwLFxuICAgICAgY2hhbm5lbE5hbWU6IGNoYW5uZWxOYW1lLFxuICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgIHV1aWQ6IHJhbmRvbVRva2VuKCksXG4gICAgICAvKipcbiAgICAgICAqIGVtaXR0ZWRNZXNzYWdlc0lkc1xuICAgICAgICogY29udGFpbnMgYWxsIG1lc3NhZ2VzIHRoYXQgaGF2ZSBiZWVuIGVtaXR0ZWQgYmVmb3JlXG4gICAgICAgKiBAdHlwZSB7T2JsaXZpb3VzU2V0fVxuICAgICAgICovXG4gICAgICBlTUlzOiBuZXcgT2JsaXZpb3VzU2V0KG9wdGlvbnMuaWRiLnR0bCAqIDIpLFxuICAgICAgLy8gZW5zdXJlcyB3ZSBkbyBub3QgcmVhZCBtZXNzYWdlcyBpbiBwYXJhbGxlbFxuICAgICAgd3JpdGVCbG9ja1Byb21pc2U6IFBST01JU0VfUkVTT0xWRURfVk9JRCxcbiAgICAgIG1lc3NhZ2VzQ2FsbGJhY2s6IG51bGwsXG4gICAgICByZWFkUXVldWVQcm9taXNlczogW10sXG4gICAgICBkYjogZGJcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFicnVwdCBjbG9zZXMgdGhhdCBkbyBub3Qgb3JpZ2luYXRlIGZyb20gZGIuY2xvc2UoKS5cbiAgICAgKiBUaGlzIGNvdWxkIGhhcHBlbiwgZm9yIGV4YW1wbGUsIGlmIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UgaXNcbiAgICAgKiByZW1vdmVkIG9yIGlmIHRoZSB1c2VyIGNsZWFycyB0aGUgZGF0YWJhc2UgaW4gdGhlIGJyb3dzZXInc1xuICAgICAqIGhpc3RvcnkgcHJlZmVyZW5jZXMuXG4gICAgICovXG4gICAgZGIub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0YXRlLmNsb3NlZCA9IHRydWU7XG4gICAgICBpZiAob3B0aW9ucy5pZGIub25jbG9zZSkgb3B0aW9ucy5pZGIub25jbG9zZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBpZiBzZXJ2aWNlLXdvcmtlcnMgYXJlIHVzZWQsXG4gICAgICogd2UgaGF2ZSBubyAnc3RvcmFnZSctZXZlbnQgaWYgdGhleSBwb3N0IGEgbWVzc2FnZSxcbiAgICAgKiB0aGVyZWZvcmUgd2UgYWxzbyBoYXZlIHRvIHNldCBhbiBpbnRlcnZhbFxuICAgICAqL1xuICAgIF9yZWFkTG9vcChzdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIF9yZWFkTG9vcChzdGF0ZSkge1xuICBpZiAoc3RhdGUuY2xvc2VkKSByZXR1cm47XG4gIHJlYWROZXdNZXNzYWdlcyhzdGF0ZSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNsZWVwKHN0YXRlLm9wdGlvbnMuaWRiLmZhbGxiYWNrSW50ZXJ2YWwpO1xuICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3JlYWRMb29wKHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBfZmlsdGVyTWVzc2FnZShtc2dPYmosIHN0YXRlKSB7XG4gIGlmIChtc2dPYmoudXVpZCA9PT0gc3RhdGUudXVpZCkgcmV0dXJuIGZhbHNlOyAvLyBzZW5kIGJ5IG93blxuICBpZiAoc3RhdGUuZU1Jcy5oYXMobXNnT2JqLmlkKSkgcmV0dXJuIGZhbHNlOyAvLyBhbHJlYWR5IGVtaXR0ZWRcbiAgaWYgKG1zZ09iai5kYXRhLnRpbWUgPCBzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSkgcmV0dXJuIGZhbHNlOyAvLyBvbGRlciB0aGVuIG9uTWVzc2FnZUNhbGxiYWNrXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIHJlYWRzIGFsbCBuZXcgbWVzc2FnZXMgZnJvbSB0aGUgZGF0YWJhc2UgYW5kIGVtaXRzIHRoZW1cbiAqL1xuZnVuY3Rpb24gcmVhZE5ld01lc3NhZ2VzKHN0YXRlKSB7XG4gIC8vIGNoYW5uZWwgYWxyZWFkeSBjbG9zZWRcbiAgaWYgKHN0YXRlLmNsb3NlZCkgcmV0dXJuIFBST01JU0VfUkVTT0xWRURfVk9JRDtcblxuICAvLyBpZiBubyBvbmUgaXMgbGlzdGVuaW5nLCB3ZSBkbyBub3QgbmVlZCB0byBzY2FuIGZvciBuZXcgbWVzc2FnZXNcbiAgaWYgKCFzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKSByZXR1cm4gUFJPTUlTRV9SRVNPTFZFRF9WT0lEO1xuICByZXR1cm4gZ2V0TWVzc2FnZXNIaWdoZXJUaGFuKHN0YXRlLmRiLCBzdGF0ZS5sYXN0Q3Vyc29ySWQpLnRoZW4oZnVuY3Rpb24gKG5ld2VyTWVzc2FnZXMpIHtcbiAgICB2YXIgdXNlTWVzc2FnZXMgPSBuZXdlck1lc3NhZ2VzXG4gICAgLyoqXG4gICAgICogdGhlcmUgaXMgYSBidWcgaW4gaU9TIHdoZXJlIHRoZSBtc2dPYmogY2FuIGJlIHVuZGVmaW5lZCBzb21ldGltZXNcbiAgICAgKiBzbyB3ZSBmaWx0ZXIgdGhlbSBvdXRcbiAgICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vcHVia2V5L2Jyb2FkY2FzdC1jaGFubmVsL2lzc3Vlcy8xOVxuICAgICAqLy5maWx0ZXIoZnVuY3Rpb24gKG1zZ09iaikge1xuICAgICAgcmV0dXJuICEhbXNnT2JqO1xuICAgIH0pLm1hcChmdW5jdGlvbiAobXNnT2JqKSB7XG4gICAgICBpZiAobXNnT2JqLmlkID4gc3RhdGUubGFzdEN1cnNvcklkKSB7XG4gICAgICAgIHN0YXRlLmxhc3RDdXJzb3JJZCA9IG1zZ09iai5pZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtc2dPYmo7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChtc2dPYmopIHtcbiAgICAgIHJldHVybiBfZmlsdGVyTWVzc2FnZShtc2dPYmosIHN0YXRlKTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uIChtc2dPYmpBLCBtc2dPYmpCKSB7XG4gICAgICByZXR1cm4gbXNnT2JqQS50aW1lIC0gbXNnT2JqQi50aW1lO1xuICAgIH0pOyAvLyBzb3J0IGJ5IHRpbWVcbiAgICB1c2VNZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2dPYmopIHtcbiAgICAgIGlmIChzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKSB7XG4gICAgICAgIHN0YXRlLmVNSXMuYWRkKG1zZ09iai5pZCk7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sobXNnT2JqLmRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBQUk9NSVNFX1JFU09MVkVEX1ZPSUQ7XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsb3NlKGNoYW5uZWxTdGF0ZSkge1xuICBjaGFubmVsU3RhdGUuY2xvc2VkID0gdHJ1ZTtcbiAgY2hhbm5lbFN0YXRlLmRiLmNsb3NlKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcG9zdE1lc3NhZ2UoY2hhbm5lbFN0YXRlLCBtZXNzYWdlSnNvbikge1xuICBjaGFubmVsU3RhdGUud3JpdGVCbG9ja1Byb21pc2UgPSBjaGFubmVsU3RhdGUud3JpdGVCbG9ja1Byb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdyaXRlTWVzc2FnZShjaGFubmVsU3RhdGUuZGIsIGNoYW5uZWxTdGF0ZS51dWlkLCBtZXNzYWdlSnNvbik7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmIChyYW5kb21JbnQoMCwgMTApID09PSAwKSB7XG4gICAgICAvKiBhd2FpdCAoZG8gbm90IGF3YWl0KSAqL1xuICAgICAgY2xlYW5PbGRNZXNzYWdlcyhjaGFubmVsU3RhdGUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjaGFubmVsU3RhdGUud3JpdGVCbG9ja1Byb21pc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gb25NZXNzYWdlKGNoYW5uZWxTdGF0ZSwgZm4sIHRpbWUpIHtcbiAgY2hhbm5lbFN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2tUaW1lID0gdGltZTtcbiAgY2hhbm5lbFN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sgPSBmbjtcbiAgcmVhZE5ld01lc3NhZ2VzKGNoYW5uZWxTdGF0ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY2FuQmVVc2VkKCkge1xuICByZXR1cm4gISFnZXRJZGIoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhdmVyYWdlUmVzcG9uc2VUaW1lKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuaWRiLmZhbGxiYWNrSW50ZXJ2YWwgKiAyO1xufVxuZXhwb3J0IHZhciBJbmRleGVkREJNZXRob2QgPSB7XG4gIGNyZWF0ZTogY3JlYXRlLFxuICBjbG9zZTogY2xvc2UsXG4gIG9uTWVzc2FnZTogb25NZXNzYWdlLFxuICBwb3N0TWVzc2FnZTogcG9zdE1lc3NhZ2UsXG4gIGNhbkJlVXNlZDogY2FuQmVVc2VkLFxuICB0eXBlOiB0eXBlLFxuICBhdmVyYWdlUmVzcG9uc2VUaW1lOiBhdmVyYWdlUmVzcG9uc2VUaW1lLFxuICBtaWNyb1NlY29uZHM6IG1pY3JvU2Vjb25kc1xufTsiLCIvKipcbiAqIEEgbG9jYWxTdG9yYWdlLW9ubHkgbWV0aG9kIHdoaWNoIHVzZXMgbG9jYWxzdG9yYWdlIGFuZCBpdHMgJ3N0b3JhZ2UnLWV2ZW50XG4gKiBUaGlzIGRvZXMgbm90IHdvcmsgaW5zaWRlIHdlYndvcmtlcnMgYmVjYXVzZSB0aGV5IGhhdmUgbm8gYWNjZXNzIHRvIGxvY2Fsc3RvcmFnZVxuICogVGhpcyBpcyBiYXNpY2FsbHkgaW1wbGVtZW50ZWQgdG8gc3VwcG9ydCBJRTkgb3IgeW91ciBncmFuZG1vdGhlcidzIHRvYXN0ZXIuXG4gKiBAbGluayBodHRwczovL2Nhbml1c2UuY29tLyNmZWF0PW5hbWV2YWx1ZS1zdG9yYWdlXG4gKiBAbGluayBodHRwczovL2Nhbml1c2UuY29tLyNmZWF0PWluZGV4ZWRkYlxuICovXG5cbmltcG9ydCB7IE9ibGl2aW91c1NldCB9IGZyb20gJ29ibGl2aW91cy1zZXQnO1xuaW1wb3J0IHsgZmlsbE9wdGlvbnNXaXRoRGVmYXVsdHMgfSBmcm9tICcuLi9vcHRpb25zLmpzJztcbmltcG9ydCB7IHNsZWVwLCByYW5kb21Ub2tlbiwgbWljcm9TZWNvbmRzIGFzIG1pY3JvIH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5leHBvcnQgdmFyIG1pY3JvU2Vjb25kcyA9IG1pY3JvO1xudmFyIEtFWV9QUkVGSVggPSAncHVia2V5LmJyb2FkY2FzdENoYW5uZWwtJztcbmV4cG9ydCB2YXIgdHlwZSA9ICdsb2NhbHN0b3JhZ2UnO1xuXG4vKipcbiAqIGNvcGllZCBmcm9tIGNyb3NzdGFiXG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vdGVqYWNxdWVzL2Nyb3NzdGFiL2Jsb2IvbWFzdGVyL3NyYy9jcm9zc3RhYi5qcyNMMzJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2FsU3RvcmFnZSgpIHtcbiAgdmFyIGxvY2FsU3RvcmFnZTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbDtcbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgIGxvY2FsU3RvcmFnZSA9IHdpbmRvd1snaWU4LWV2ZW50bGlzdGVuZXIvc3RvcmFnZSddIHx8IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBOZXcgdmVyc2lvbnMgb2YgRmlyZWZveCB0aHJvdyBhIFNlY3VyaXR5IGV4Y2VwdGlvblxuICAgIC8vIGlmIGNvb2tpZXMgYXJlIGRpc2FibGVkLiBTZWVcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDI4MTUzXG4gIH1cbiAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdG9yYWdlS2V5KGNoYW5uZWxOYW1lKSB7XG4gIHJldHVybiBLRVlfUFJFRklYICsgY2hhbm5lbE5hbWU7XG59XG5cbi8qKlxuKiB3cml0ZXMgdGhlIG5ldyBtZXNzYWdlIHRvIHRoZSBzdG9yYWdlXG4qIGFuZCBmaXJlcyB0aGUgc3RvcmFnZS1ldmVudCBzbyBvdGhlciByZWFkZXJzIGNhbiBmaW5kIGl0XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKGNoYW5uZWxTdGF0ZSwgbWVzc2FnZUpzb24pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICBzbGVlcCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGtleSA9IHN0b3JhZ2VLZXkoY2hhbm5lbFN0YXRlLmNoYW5uZWxOYW1lKTtcbiAgICAgIHZhciB3cml0ZU9iaiA9IHtcbiAgICAgICAgdG9rZW46IHJhbmRvbVRva2VuKCksXG4gICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgIGRhdGE6IG1lc3NhZ2VKc29uLFxuICAgICAgICB1dWlkOiBjaGFubmVsU3RhdGUudXVpZFxuICAgICAgfTtcbiAgICAgIHZhciB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHdyaXRlT2JqKTtcbiAgICAgIGdldExvY2FsU3RvcmFnZSgpLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG5cbiAgICAgIC8qKlxuICAgICAgICogU3RvcmFnZUV2ZW50IGRvZXMgbm90IGZpcmUgdGhlICdzdG9yYWdlJyBldmVudFxuICAgICAgICogaW4gdGhlIHdpbmRvdyB0aGF0IGNoYW5nZXMgdGhlIHN0YXRlIG9mIHRoZSBsb2NhbCBzdG9yYWdlLlxuICAgICAgICogU28gd2UgZmlyZSBpdCBtYW51YWxseVxuICAgICAgICovXG4gICAgICB2YXIgZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2LmluaXRFdmVudCgnc3RvcmFnZScsIHRydWUsIHRydWUpO1xuICAgICAgZXYua2V5ID0ga2V5O1xuICAgICAgZXYubmV3VmFsdWUgPSB2YWx1ZTtcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2KTtcbiAgICAgIHJlcygpO1xuICAgIH0pO1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhZGRTdG9yYWdlRXZlbnRMaXN0ZW5lcihjaGFubmVsTmFtZSwgZm4pIHtcbiAgdmFyIGtleSA9IHN0b3JhZ2VLZXkoY2hhbm5lbE5hbWUpO1xuICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcihldikge1xuICAgIGlmIChldi5rZXkgPT09IGtleSkge1xuICAgICAgZm4oSlNPTi5wYXJzZShldi5uZXdWYWx1ZSkpO1xuICAgIH1cbiAgfTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCBsaXN0ZW5lcik7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVTdG9yYWdlRXZlbnRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIGxpc3RlbmVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoY2hhbm5lbE5hbWUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGZpbGxPcHRpb25zV2l0aERlZmF1bHRzKG9wdGlvbnMpO1xuICBpZiAoIWNhbkJlVXNlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCcm9hZGNhc3RDaGFubmVsOiBsb2NhbHN0b3JhZ2UgY2Fubm90IGJlIHVzZWQnKTtcbiAgfVxuICB2YXIgdXVpZCA9IHJhbmRvbVRva2VuKCk7XG5cbiAgLyoqXG4gICAqIGVNSXNcbiAgICogY29udGFpbnMgYWxsIG1lc3NhZ2VzIHRoYXQgaGF2ZSBiZWVuIGVtaXR0ZWQgYmVmb3JlXG4gICAqIEB0eXBlIHtPYmxpdmlvdXNTZXR9XG4gICAqL1xuICB2YXIgZU1JcyA9IG5ldyBPYmxpdmlvdXNTZXQob3B0aW9ucy5sb2NhbHN0b3JhZ2UucmVtb3ZlVGltZW91dCk7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICBjaGFubmVsTmFtZTogY2hhbm5lbE5hbWUsXG4gICAgdXVpZDogdXVpZCxcbiAgICBlTUlzOiBlTUlzIC8vIGVtaXR0ZWRNZXNzYWdlc0lkc1xuICB9O1xuXG4gIHN0YXRlLmxpc3RlbmVyID0gYWRkU3RvcmFnZUV2ZW50TGlzdGVuZXIoY2hhbm5lbE5hbWUsIGZ1bmN0aW9uIChtc2dPYmopIHtcbiAgICBpZiAoIXN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2spIHJldHVybjsgLy8gbm8gbGlzdGVuZXJcbiAgICBpZiAobXNnT2JqLnV1aWQgPT09IHV1aWQpIHJldHVybjsgLy8gb3duIG1lc3NhZ2VcbiAgICBpZiAoIW1zZ09iai50b2tlbiB8fCBlTUlzLmhhcyhtc2dPYmoudG9rZW4pKSByZXR1cm47IC8vIGFscmVhZHkgZW1pdHRlZFxuICAgIGlmIChtc2dPYmouZGF0YS50aW1lICYmIG1zZ09iai5kYXRhLnRpbWUgPCBzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSkgcmV0dXJuOyAvLyB0b28gb2xkXG5cbiAgICBlTUlzLmFkZChtc2dPYmoudG9rZW4pO1xuICAgIHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sobXNnT2JqLmRhdGEpO1xuICB9KTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsb3NlKGNoYW5uZWxTdGF0ZSkge1xuICByZW1vdmVTdG9yYWdlRXZlbnRMaXN0ZW5lcihjaGFubmVsU3RhdGUubGlzdGVuZXIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9uTWVzc2FnZShjaGFubmVsU3RhdGUsIGZuLCB0aW1lKSB7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSA9IHRpbWU7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrID0gZm47XG59XG5leHBvcnQgZnVuY3Rpb24gY2FuQmVVc2VkKCkge1xuICB2YXIgbHMgPSBnZXRMb2NhbFN0b3JhZ2UoKTtcbiAgaWYgKCFscykgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBrZXkgPSAnX19icm9hZGNhc3RjaGFubmVsX2NoZWNrJztcbiAgICBscy5zZXRJdGVtKGtleSwgJ3dvcmtzJyk7XG4gICAgbHMucmVtb3ZlSXRlbShrZXkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gU2FmYXJpIDEwIGluIHByaXZhdGUgbW9kZSB3aWxsIG5vdCBhbGxvdyB3cml0ZSBhY2Nlc3MgdG8gbG9jYWxcbiAgICAvLyBzdG9yYWdlIGFuZCBmYWlsIHdpdGggYSBRdW90YUV4Y2VlZGVkRXJyb3IuIFNlZVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfU3RvcmFnZV9BUEkjUHJpdmF0ZV9Ccm93c2luZ19JbmNvZ25pdG9fbW9kZXNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gYXZlcmFnZVJlc3BvbnNlVGltZSgpIHtcbiAgdmFyIGRlZmF1bHRUaW1lID0gMTIwO1xuICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICBpZiAodXNlckFnZW50LmluY2x1ZGVzKCdzYWZhcmknKSAmJiAhdXNlckFnZW50LmluY2x1ZGVzKCdjaHJvbWUnKSkge1xuICAgIC8vIHNhZmFyaSBpcyBtdWNoIHNsb3dlciBzbyB0aGlzIHRpbWUgaXMgaGlnaGVyXG4gICAgcmV0dXJuIGRlZmF1bHRUaW1lICogMjtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFRpbWU7XG59XG5leHBvcnQgdmFyIExvY2Fsc3RvcmFnZU1ldGhvZCA9IHtcbiAgY3JlYXRlOiBjcmVhdGUsXG4gIGNsb3NlOiBjbG9zZSxcbiAgb25NZXNzYWdlOiBvbk1lc3NhZ2UsXG4gIHBvc3RNZXNzYWdlOiBwb3N0TWVzc2FnZSxcbiAgY2FuQmVVc2VkOiBjYW5CZVVzZWQsXG4gIHR5cGU6IHR5cGUsXG4gIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IGF2ZXJhZ2VSZXNwb25zZVRpbWUsXG4gIG1pY3JvU2Vjb25kczogbWljcm9TZWNvbmRzXG59OyIsImltcG9ydCB7IG1pY3JvU2Vjb25kcyBhcyBtaWNybyB9IGZyb20gJy4uL3V0aWwuanMnO1xuZXhwb3J0IHZhciBtaWNyb1NlY29uZHMgPSBtaWNybztcbmV4cG9ydCB2YXIgdHlwZSA9ICdzaW11bGF0ZSc7XG52YXIgU0lNVUxBVEVfQ0hBTk5FTFMgPSBuZXcgU2V0KCk7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKGNoYW5uZWxOYW1lKSB7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICB0aW1lOiBtaWNyb1NlY29uZHMoKSxcbiAgICBuYW1lOiBjaGFubmVsTmFtZSxcbiAgICBtZXNzYWdlc0NhbGxiYWNrOiBudWxsXG4gIH07XG4gIFNJTVVMQVRFX0NIQU5ORUxTLmFkZChzdGF0ZSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZShjaGFubmVsU3RhdGUpIHtcbiAgU0lNVUxBVEVfQ0hBTk5FTFNbXCJkZWxldGVcIl0oY2hhbm5lbFN0YXRlKTtcbn1cbmV4cG9ydCB2YXIgU0lNVUxBVEVfREVMQVlfVElNRSA9IDU7XG5leHBvcnQgZnVuY3Rpb24gcG9zdE1lc3NhZ2UoY2hhbm5lbFN0YXRlLCBtZXNzYWdlSnNvbikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcykge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjaGFubmVsQXJyYXkgPSBBcnJheS5mcm9tKFNJTVVMQVRFX0NIQU5ORUxTKTtcbiAgICAgIGNoYW5uZWxBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIGlmIChjaGFubmVsLm5hbWUgPT09IGNoYW5uZWxTdGF0ZS5uYW1lICYmXG4gICAgICAgIC8vIGhhcyBzYW1lIG5hbWVcbiAgICAgICAgY2hhbm5lbCAhPT0gY2hhbm5lbFN0YXRlICYmXG4gICAgICAgIC8vIG5vdCBvd24gY2hhbm5lbFxuICAgICAgICAhIWNoYW5uZWwubWVzc2FnZXNDYWxsYmFjayAmJlxuICAgICAgICAvLyBoYXMgc3Vic2NyaWJlcnNcbiAgICAgICAgY2hhbm5lbC50aW1lIDwgbWVzc2FnZUpzb24udGltZSAvLyBjaGFubmVsIG5vdCBjcmVhdGVkIGFmdGVyIHBvc3RNZXNzYWdlKCkgY2FsbFxuICAgICAgICApIHtcbiAgICAgICAgICBjaGFubmVsLm1lc3NhZ2VzQ2FsbGJhY2sobWVzc2FnZUpzb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlcygpO1xuICAgIH0sIFNJTVVMQVRFX0RFTEFZX1RJTUUpO1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvbk1lc3NhZ2UoY2hhbm5lbFN0YXRlLCBmbikge1xuICBjaGFubmVsU3RhdGUubWVzc2FnZXNDYWxsYmFjayA9IGZuO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNhbkJlVXNlZCgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gYXZlcmFnZVJlc3BvbnNlVGltZSgpIHtcbiAgcmV0dXJuIFNJTVVMQVRFX0RFTEFZX1RJTUU7XG59XG5leHBvcnQgdmFyIFNpbXVsYXRlTWV0aG9kID0ge1xuICBjcmVhdGU6IGNyZWF0ZSxcbiAgY2xvc2U6IGNsb3NlLFxuICBvbk1lc3NhZ2U6IG9uTWVzc2FnZSxcbiAgcG9zdE1lc3NhZ2U6IHBvc3RNZXNzYWdlLFxuICBjYW5CZVVzZWQ6IGNhbkJlVXNlZCxcbiAgdHlwZTogdHlwZSxcbiAgYXZlcmFnZVJlc3BvbnNlVGltZTogYXZlcmFnZVJlc3BvbnNlVGltZSxcbiAgbWljcm9TZWNvbmRzOiBtaWNyb1NlY29uZHNcbn07IiwiaW1wb3J0IHsgTmF0aXZlTWV0aG9kIH0gZnJvbSAnLi9tZXRob2RzL25hdGl2ZS5qcyc7XG5pbXBvcnQgeyBJbmRleGVkREJNZXRob2QgfSBmcm9tICcuL21ldGhvZHMvaW5kZXhlZC1kYi5qcyc7XG5pbXBvcnQgeyBMb2NhbHN0b3JhZ2VNZXRob2QgfSBmcm9tICcuL21ldGhvZHMvbG9jYWxzdG9yYWdlLmpzJztcbmltcG9ydCB7IFNpbXVsYXRlTWV0aG9kIH0gZnJvbSAnLi9tZXRob2RzL3NpbXVsYXRlLmpzJztcbi8vIHRoZSBsaW5lIGJlbG93IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIGVzNS9icm93c2VyIGJ1aWxkc1xuXG4vLyBvcmRlciBpcyBpbXBvcnRhbnRcbnZhciBNRVRIT0RTID0gW05hdGl2ZU1ldGhvZCxcbi8vIGZhc3Rlc3RcbkluZGV4ZWREQk1ldGhvZCwgTG9jYWxzdG9yYWdlTWV0aG9kXTtcbmV4cG9ydCBmdW5jdGlvbiBjaG9vc2VNZXRob2Qob3B0aW9ucykge1xuICB2YXIgY2hvb3NlTWV0aG9kcyA9IFtdLmNvbmNhdChvcHRpb25zLm1ldGhvZHMsIE1FVEhPRFMpLmZpbHRlcihCb29sZWFuKTtcblxuICAvLyB0aGUgbGluZSBiZWxvdyB3aWxsIGJlIHJlbW92ZWQgZnJvbSBlczUvYnJvd3NlciBidWlsZHNcblxuICAvLyBkaXJlY3RseSBjaG9zZW5cbiAgaWYgKG9wdGlvbnMudHlwZSkge1xuICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdzaW11bGF0ZScpIHtcbiAgICAgIC8vIG9ubHkgdXNlIHNpbXVsYXRlLW1ldGhvZCBpZiBkaXJlY3RseSBjaG9zZW5cbiAgICAgIHJldHVybiBTaW11bGF0ZU1ldGhvZDtcbiAgICB9XG4gICAgdmFyIHJldCA9IGNob29zZU1ldGhvZHMuZmluZChmdW5jdGlvbiAobSkge1xuICAgICAgcmV0dXJuIG0udHlwZSA9PT0gb3B0aW9ucy50eXBlO1xuICAgIH0pO1xuICAgIGlmICghcmV0KSB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZC10eXBlICcgKyBvcHRpb25zLnR5cGUgKyAnIG5vdCBmb3VuZCcpO2Vsc2UgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBpZiBubyB3ZWJ3b3JrZXIgc3VwcG9ydCBpcyBuZWVkZWQsXG4gICAqIHJlbW92ZSBpZGIgZnJvbSB0aGUgbGlzdCBzbyB0aGF0IGxvY2Fsc3RvcmFnZSB3aWxsIGJlIGNob3NlblxuICAgKi9cbiAgaWYgKCFvcHRpb25zLndlYldvcmtlclN1cHBvcnQpIHtcbiAgICBjaG9vc2VNZXRob2RzID0gY2hvb3NlTWV0aG9kcy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgIHJldHVybiBtLnR5cGUgIT09ICdpZGInO1xuICAgIH0pO1xuICB9XG4gIHZhciB1c2VNZXRob2QgPSBjaG9vc2VNZXRob2RzLmZpbmQoZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIHJldHVybiBtZXRob2QuY2FuQmVVc2VkKCk7XG4gIH0pO1xuICBpZiAoIXVzZU1ldGhvZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHVzYWJsZSBtZXRob2QgZm91bmQgaW4gXCIgKyBKU09OLnN0cmluZ2lmeShNRVRIT0RTLm1hcChmdW5jdGlvbiAobSkge1xuICAgICAgcmV0dXJuIG0udHlwZTtcbiAgICB9KSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1c2VNZXRob2Q7XG4gIH1cbn0iLCJpbXBvcnQgeyBpc1Byb21pc2UsIFBST01JU0VfUkVTT0xWRURfRkFMU0UsIFBST01JU0VfUkVTT0xWRURfVk9JRCB9IGZyb20gJy4vdXRpbC5qcyc7XG5pbXBvcnQgeyBjaG9vc2VNZXRob2QgfSBmcm9tICcuL21ldGhvZC1jaG9vc2VyLmpzJztcbmltcG9ydCB7IGZpbGxPcHRpb25zV2l0aERlZmF1bHRzIH0gZnJvbSAnLi9vcHRpb25zLmpzJztcblxuLyoqXG4gKiBDb250YWlucyBhbGwgb3BlbiBjaGFubmVscyxcbiAqIHVzZWQgaW4gdGVzdHMgdG8gZW5zdXJlIGV2ZXJ5dGhpbmcgaXMgY2xvc2VkLlxuICovXG5leHBvcnQgdmFyIE9QRU5fQlJPQURDQVNUX0NIQU5ORUxTID0gbmV3IFNldCgpO1xudmFyIGxhc3RJZCA9IDA7XG5leHBvcnQgdmFyIEJyb2FkY2FzdENoYW5uZWwgPSBmdW5jdGlvbiBCcm9hZGNhc3RDaGFubmVsKG5hbWUsIG9wdGlvbnMpIHtcbiAgLy8gaWRlbnRpZmllciBvZiB0aGUgY2hhbm5lbCB0byBkZWJ1ZyBzdHVmZlxuICB0aGlzLmlkID0gbGFzdElkKys7XG4gIE9QRU5fQlJPQURDQVNUX0NIQU5ORUxTLmFkZCh0aGlzKTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgaWYgKEVORk9SQ0VEX09QVElPTlMpIHtcbiAgICBvcHRpb25zID0gRU5GT1JDRURfT1BUSU9OUztcbiAgfVxuICB0aGlzLm9wdGlvbnMgPSBmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyhvcHRpb25zKTtcbiAgdGhpcy5tZXRob2QgPSBjaG9vc2VNZXRob2QodGhpcy5vcHRpb25zKTtcblxuICAvLyBpc0xpc3RlbmluZ1xuICB0aGlzLl9pTCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBfb25NZXNzYWdlTGlzdGVuZXJcbiAgICogc2V0dGluZyBvbm1lc3NhZ2UgdHdpY2UsXG4gICAqIHdpbGwgb3ZlcndyaXRlIHRoZSBmaXJzdCBsaXN0ZW5lclxuICAgKi9cbiAgdGhpcy5fb25NTCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIF9hZGRFdmVudExpc3RlbmVyc1xuICAgKi9cbiAgdGhpcy5fYWRkRUwgPSB7XG4gICAgbWVzc2FnZTogW10sXG4gICAgaW50ZXJuYWw6IFtdXG4gIH07XG5cbiAgLyoqXG4gICAqIFVuc2VudCBtZXNzYWdlIHByb21pc2VzXG4gICAqIHdoZXJlIHRoZSBzZW5kaW5nIGlzIHN0aWxsIGluIHByb2dyZXNzXG4gICAqIEB0eXBlIHtTZXQ8UHJvbWlzZT59XG4gICAqL1xuICB0aGlzLl91TVAgPSBuZXcgU2V0KCk7XG5cbiAgLyoqXG4gICAqIF9iZWZvcmVDbG9zZVxuICAgKiBhcnJheSBvZiBwcm9taXNlcyB0aGF0IHdpbGwgYmUgYXdhaXRlZFxuICAgKiBiZWZvcmUgdGhlIGNoYW5uZWwgaXMgY2xvc2VkXG4gICAqL1xuICB0aGlzLl9iZWZDID0gW107XG5cbiAgLyoqXG4gICAqIF9wcmVwYXJlUHJvbWlzZVxuICAgKi9cbiAgdGhpcy5fcHJlcFAgPSBudWxsO1xuICBfcHJlcGFyZUNoYW5uZWwodGhpcyk7XG59O1xuXG4vLyBTVEFUSUNTXG5cbi8qKlxuICogdXNlZCB0byBpZGVudGlmeSBpZiBzb21lb25lIG92ZXJ3cml0ZXNcbiAqIHdpbmRvdy5Ccm9hZGNhc3RDaGFubmVsIHdpdGggdGhpc1xuICogU2VlIG1ldGhvZHMvbmF0aXZlLmpzXG4gKi9cbkJyb2FkY2FzdENoYW5uZWwuX3B1YmtleSA9IHRydWU7XG5cbi8qKlxuICogY2xlYXJzIHRoZSB0bXAtZm9sZGVyIGlmIGlzIG5vZGVcbiAqIEByZXR1cm4ge1Byb21pc2U8Ym9vbGVhbj59IHRydWUgaWYgaGFzIHJ1biwgZmFsc2UgaWYgbm90IG5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyTm9kZUZvbGRlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyhvcHRpb25zKTtcbiAgdmFyIG1ldGhvZCA9IGNob29zZU1ldGhvZChvcHRpb25zKTtcbiAgaWYgKG1ldGhvZC50eXBlID09PSAnbm9kZScpIHtcbiAgICByZXR1cm4gbWV0aG9kLmNsZWFyTm9kZUZvbGRlcigpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFBST01JU0VfUkVTT0xWRURfRkFMU0U7XG4gIH1cbn1cblxuLyoqXG4gKiBpZiBzZXQsIHRoaXMgbWV0aG9kIGlzIGVuZm9yY2VkLFxuICogbm8gbWF0aGVyIHdoYXQgdGhlIG9wdGlvbnMgYXJlXG4gKi9cbnZhciBFTkZPUkNFRF9PUFRJT05TO1xuZXhwb3J0IGZ1bmN0aW9uIGVuZm9yY2VPcHRpb25zKG9wdGlvbnMpIHtcbiAgRU5GT1JDRURfT1BUSU9OUyA9IG9wdGlvbnM7XG59XG5cbi8vIFBST1RPVFlQRVxuQnJvYWRjYXN0Q2hhbm5lbC5wcm90b3R5cGUgPSB7XG4gIHBvc3RNZXNzYWdlOiBmdW5jdGlvbiBwb3N0TWVzc2FnZShtc2cpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSgpOiAnICsgJ0Nhbm5vdCBwb3N0IG1lc3NhZ2UgYWZ0ZXIgY2hhbm5lbCBoYXMgY2xvc2VkICcgK1xuICAgICAgLyoqXG4gICAgICAgKiBJbiB0aGUgcGFzdCB3aGVuIHRoaXMgZXJyb3IgYXBwZWFyZWQsIGl0IHdhcyByZWFsbHkgaGFyZCB0byBkZWJ1Zy5cbiAgICAgICAqIFNvIG5vdyB3ZSBsb2cgdGhlIG1zZyB0b2dldGhlciB3aXRoIHRoZSBlcnJvciBzbyBpdCBhdCBsZWFzdFxuICAgICAgICogZ2l2ZXMgc29tZSBjbHVlIGFib3V0IHdoZXJlIGluIHlvdXIgYXBwbGljYXRpb24gdGhpcyBoYXBwZW5zLlxuICAgICAgICovXG4gICAgICBKU09OLnN0cmluZ2lmeShtc2cpKTtcbiAgICB9XG4gICAgcmV0dXJuIF9wb3N0KHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgfSxcbiAgcG9zdEludGVybmFsOiBmdW5jdGlvbiBwb3N0SW50ZXJuYWwobXNnKSB7XG4gICAgcmV0dXJuIF9wb3N0KHRoaXMsICdpbnRlcm5hbCcsIG1zZyk7XG4gIH0sXG4gIHNldCBvbm1lc3NhZ2UoZm4pIHtcbiAgICB2YXIgdGltZSA9IHRoaXMubWV0aG9kLm1pY3JvU2Vjb25kcygpO1xuICAgIHZhciBsaXN0ZW5PYmogPSB7XG4gICAgICB0aW1lOiB0aW1lLFxuICAgICAgZm46IGZuXG4gICAgfTtcbiAgICBfcmVtb3ZlTGlzdGVuZXJPYmplY3QodGhpcywgJ21lc3NhZ2UnLCB0aGlzLl9vbk1MKTtcbiAgICBpZiAoZm4gJiYgdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9vbk1MID0gbGlzdGVuT2JqO1xuICAgICAgX2FkZExpc3RlbmVyT2JqZWN0KHRoaXMsICdtZXNzYWdlJywgbGlzdGVuT2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb25NTCA9IG51bGw7XG4gICAgfVxuICB9LFxuICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuKSB7XG4gICAgdmFyIHRpbWUgPSB0aGlzLm1ldGhvZC5taWNyb1NlY29uZHMoKTtcbiAgICB2YXIgbGlzdGVuT2JqID0ge1xuICAgICAgdGltZTogdGltZSxcbiAgICAgIGZuOiBmblxuICAgIH07XG4gICAgX2FkZExpc3RlbmVyT2JqZWN0KHRoaXMsIHR5cGUsIGxpc3Rlbk9iaik7XG4gIH0sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4pIHtcbiAgICB2YXIgb2JqID0gdGhpcy5fYWRkRUxbdHlwZV0uZmluZChmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLmZuID09PSBmbjtcbiAgICB9KTtcbiAgICBfcmVtb3ZlTGlzdGVuZXJPYmplY3QodGhpcywgdHlwZSwgb2JqKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9QRU5fQlJPQURDQVNUX0NIQU5ORUxTW1wiZGVsZXRlXCJdKHRoaXMpO1xuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB2YXIgYXdhaXRQcmVwYXJlID0gdGhpcy5fcHJlcFAgPyB0aGlzLl9wcmVwUCA6IFBST01JU0VfUkVTT0xWRURfVk9JRDtcbiAgICB0aGlzLl9vbk1MID0gbnVsbDtcbiAgICB0aGlzLl9hZGRFTC5tZXNzYWdlID0gW107XG4gICAgcmV0dXJuIGF3YWl0UHJlcGFyZVxuICAgIC8vIHdhaXQgdW50aWwgYWxsIGN1cnJlbnQgc2VuZGluZyBhcmUgcHJvY2Vzc2VkXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKEFycmF5LmZyb20oX3RoaXMuX3VNUCkpO1xuICAgIH0pXG4gICAgLy8gcnVuIGJlZm9yZS1jbG9zZSBob29rc1xuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChfdGhpcy5fYmVmQy5tYXAoZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSkpO1xuICAgIH0pXG4gICAgLy8gY2xvc2UgdGhlIGNoYW5uZWxcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMubWV0aG9kLmNsb3NlKF90aGlzLl9zdGF0ZSk7XG4gICAgfSk7XG4gIH0sXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZC50eXBlO1xuICB9LFxuICBnZXQgaXNDbG9zZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VkO1xuICB9XG59O1xuXG4vKipcbiAqIFBvc3QgYSBtZXNzYWdlIG92ZXIgdGhlIGNoYW5uZWxcbiAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGF0IHJlc29sdmVkIHdoZW4gdGhlIG1lc3NhZ2Ugc2VuZGluZyBpcyBkb25lXG4gKi9cbmZ1bmN0aW9uIF9wb3N0KGJyb2FkY2FzdENoYW5uZWwsIHR5cGUsIG1zZykge1xuICB2YXIgdGltZSA9IGJyb2FkY2FzdENoYW5uZWwubWV0aG9kLm1pY3JvU2Vjb25kcygpO1xuICB2YXIgbXNnT2JqID0ge1xuICAgIHRpbWU6IHRpbWUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBkYXRhOiBtc2dcbiAgfTtcbiAgdmFyIGF3YWl0UHJlcGFyZSA9IGJyb2FkY2FzdENoYW5uZWwuX3ByZXBQID8gYnJvYWRjYXN0Q2hhbm5lbC5fcHJlcFAgOiBQUk9NSVNFX1JFU09MVkVEX1ZPSUQ7XG4gIHJldHVybiBhd2FpdFByZXBhcmUudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbmRQcm9taXNlID0gYnJvYWRjYXN0Q2hhbm5lbC5tZXRob2QucG9zdE1lc3NhZ2UoYnJvYWRjYXN0Q2hhbm5lbC5fc3RhdGUsIG1zZ09iaik7XG5cbiAgICAvLyBhZGQvcmVtb3ZlIHRvIHVuc2VudCBtZXNzYWdlcyBsaXN0XG4gICAgYnJvYWRjYXN0Q2hhbm5lbC5fdU1QLmFkZChzZW5kUHJvbWlzZSk7XG4gICAgc2VuZFByb21pc2VbXCJjYXRjaFwiXSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGJyb2FkY2FzdENoYW5uZWwuX3VNUFtcImRlbGV0ZVwiXShzZW5kUHJvbWlzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbmRQcm9taXNlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIF9wcmVwYXJlQ2hhbm5lbChjaGFubmVsKSB7XG4gIHZhciBtYXliZVByb21pc2UgPSBjaGFubmVsLm1ldGhvZC5jcmVhdGUoY2hhbm5lbC5uYW1lLCBjaGFubmVsLm9wdGlvbnMpO1xuICBpZiAoaXNQcm9taXNlKG1heWJlUHJvbWlzZSkpIHtcbiAgICBjaGFubmVsLl9wcmVwUCA9IG1heWJlUHJvbWlzZTtcbiAgICBtYXliZVByb21pc2UudGhlbihmdW5jdGlvbiAocykge1xuICAgICAgLy8gdXNlZCBpbiB0ZXN0cyB0byBzaW11bGF0ZSBzbG93IHJ1bnRpbWVcbiAgICAgIC8qaWYgKGNoYW5uZWwub3B0aW9ucy5wcmVwYXJlRGVsYXkpIHtcbiAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCB0aGlzLm9wdGlvbnMucHJlcGFyZURlbGF5KSk7XG4gICAgICB9Ki9cbiAgICAgIGNoYW5uZWwuX3N0YXRlID0gcztcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFubmVsLl9zdGF0ZSA9IG1heWJlUHJvbWlzZTtcbiAgfVxufVxuZnVuY3Rpb24gX2hhc01lc3NhZ2VMaXN0ZW5lcnMoY2hhbm5lbCkge1xuICBpZiAoY2hhbm5lbC5fYWRkRUwubWVzc2FnZS5sZW5ndGggPiAwKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNoYW5uZWwuX2FkZEVMLmludGVybmFsLmxlbmd0aCA+IDApIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBfYWRkTGlzdGVuZXJPYmplY3QoY2hhbm5lbCwgdHlwZSwgb2JqKSB7XG4gIGNoYW5uZWwuX2FkZEVMW3R5cGVdLnB1c2gob2JqKTtcbiAgX3N0YXJ0TGlzdGVuaW5nKGNoYW5uZWwpO1xufVxuZnVuY3Rpb24gX3JlbW92ZUxpc3RlbmVyT2JqZWN0KGNoYW5uZWwsIHR5cGUsIG9iaikge1xuICBjaGFubmVsLl9hZGRFTFt0eXBlXSA9IGNoYW5uZWwuX2FkZEVMW3R5cGVdLmZpbHRlcihmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICE9PSBvYmo7XG4gIH0pO1xuICBfc3RvcExpc3RlbmluZyhjaGFubmVsKTtcbn1cbmZ1bmN0aW9uIF9zdGFydExpc3RlbmluZyhjaGFubmVsKSB7XG4gIGlmICghY2hhbm5lbC5faUwgJiYgX2hhc01lc3NhZ2VMaXN0ZW5lcnMoY2hhbm5lbCkpIHtcbiAgICAvLyBzb21lb25lIGlzIGxpc3RlbmluZywgc3RhcnQgc3Vic2NyaWJpbmdcblxuICAgIHZhciBsaXN0ZW5lckZuID0gZnVuY3Rpb24gbGlzdGVuZXJGbihtc2dPYmopIHtcbiAgICAgIGNoYW5uZWwuX2FkZEVMW21zZ09iai50eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lck9iamVjdCkge1xuICAgICAgICBpZiAobXNnT2JqLnRpbWUgPj0gbGlzdGVuZXJPYmplY3QudGltZSkge1xuICAgICAgICAgIGxpc3RlbmVyT2JqZWN0LmZuKG1zZ09iai5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgdGltZSA9IGNoYW5uZWwubWV0aG9kLm1pY3JvU2Vjb25kcygpO1xuICAgIGlmIChjaGFubmVsLl9wcmVwUCkge1xuICAgICAgY2hhbm5lbC5fcHJlcFAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoYW5uZWwuX2lMID0gdHJ1ZTtcbiAgICAgICAgY2hhbm5lbC5tZXRob2Qub25NZXNzYWdlKGNoYW5uZWwuX3N0YXRlLCBsaXN0ZW5lckZuLCB0aW1lKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFubmVsLl9pTCA9IHRydWU7XG4gICAgICBjaGFubmVsLm1ldGhvZC5vbk1lc3NhZ2UoY2hhbm5lbC5fc3RhdGUsIGxpc3RlbmVyRm4sIHRpbWUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX3N0b3BMaXN0ZW5pbmcoY2hhbm5lbCkge1xuICBpZiAoY2hhbm5lbC5faUwgJiYgIV9oYXNNZXNzYWdlTGlzdGVuZXJzKGNoYW5uZWwpKSB7XG4gICAgLy8gbm8gb25lIGlzIGxpc3RlbmluZywgc3RvcCBzdWJzY3JpYmluZ1xuICAgIGNoYW5uZWwuX2lMID0gZmFsc2U7XG4gICAgdmFyIHRpbWUgPSBjaGFubmVsLm1ldGhvZC5taWNyb1NlY29uZHMoKTtcbiAgICBjaGFubmVsLm1ldGhvZC5vbk1lc3NhZ2UoY2hhbm5lbC5fc3RhdGUsIG51bGwsIHRpbWUpO1xuICB9XG59IiwiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBCcm9hZGNhc3RDaGFubmVsIGFzIEJyb2FkY2FzdENoYW5uZWxJbXBsMiB9IGZyb20gXCJicm9hZGNhc3QtY2hhbm5lbFwiO1xuXG4vLyBzcmMvdXRpbHMudHNcbmZ1bmN0aW9uIHNlcmlhbGl6ZShvYmosIHNlcmlhbGl6ZXIgPSB7IHNlcmlhbGl6ZTogSlNPTi5zdHJpbmdpZnksIGRlc2VyaWFsaXplOiBKU09OLnBhcnNlIH0pIHtcbiAgcmV0dXJuIHNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoc2VyaWFsaXplci5zZXJpYWxpemUob2JqKSk7XG59XG5cbi8vIHNyYy92YW5pbGxhLnRzXG5pbXBvcnQgeyBCcm9hZGNhc3RDaGFubmVsIGFzIEJyb2FkY2FzdENoYW5uZWxJbXBsIH0gZnJvbSBcImJyb2FkY2FzdC1jaGFubmVsXCI7XG5mdW5jdGlvbiBzaGFyZShrZXksIHN0b3JlLCB7IGluaXRpYWxpemUsIHNlcmlhbGl6ZXIsIHR5cGUgfSkge1xuICBjb25zdCBjaGFubmVsTmFtZSA9IGAke3N0b3JlLiRpZH0tJHtrZXkudG9TdHJpbmcoKX1gO1xuICBjb25zdCBjaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWxJbXBsKGNoYW5uZWxOYW1lLCB7XG4gICAgdHlwZVxuICB9KTtcbiAgbGV0IGV4dGVybmFsVXBkYXRlID0gZmFsc2U7XG4gIGxldCB0aW1lc3RhbXAgPSAwO1xuICBzdG9yZS4kc3Vic2NyaWJlKChfLCBzdGF0ZSkgPT4ge1xuICAgIGlmICghZXh0ZXJuYWxVcGRhdGUpIHtcbiAgICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICBjaGFubmVsLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICBuZXdWYWx1ZTogc2VyaWFsaXplKHN0YXRlLCBzZXJpYWxpemVyKVtrZXldXG4gICAgICB9KTtcbiAgICB9XG4gICAgZXh0ZXJuYWxVcGRhdGUgPSBmYWxzZTtcbiAgfSk7XG4gIGNoYW5uZWwub25tZXNzYWdlID0gKGV2dCkgPT4ge1xuICAgIGlmIChldnQgPT09IHZvaWQgMCkge1xuICAgICAgY2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogVE9ET1xuICAgICAgICBuZXdWYWx1ZTogc2VyaWFsaXplKHN0b3JlLiRzdGF0ZSwgc2VyaWFsaXplcilba2V5XVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldnQudGltZXN0YW1wIDw9IHRpbWVzdGFtcClcbiAgICAgIHJldHVybjtcbiAgICBleHRlcm5hbFVwZGF0ZSA9IHRydWU7XG4gICAgdGltZXN0YW1wID0gZXZ0LnRpbWVzdGFtcDtcbiAgICBzdG9yZVtrZXldID0gZXZ0Lm5ld1ZhbHVlO1xuICB9O1xuICBjb25zdCBzeW5jID0gKCkgPT4gY2hhbm5lbC5wb3N0TWVzc2FnZSh2b2lkIDApO1xuICBjb25zdCB1bnNoYXJlID0gKCkgPT4ge1xuICAgIHJldHVybiBjaGFubmVsLmNsb3NlKCk7XG4gIH07XG4gIGlmIChpbml0aWFsaXplKVxuICAgIHN5bmMoKTtcbiAgcmV0dXJuIHsgc3luYywgdW5zaGFyZSB9O1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIHN0YXRlSGFzS2V5KGtleSwgJHN0YXRlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cygkc3RhdGUpLmluY2x1ZGVzKGtleSk7XG59XG5mdW5jdGlvbiBQaW5pYVNoYXJlZFN0YXRlKHtcbiAgZW5hYmxlID0gdHJ1ZSxcbiAgaW5pdGlhbGl6ZSA9IHRydWUsXG4gIHR5cGUsXG4gIHNlcmlhbGl6ZXJcbn0pIHtcbiAgcmV0dXJuICh7IHN0b3JlLCBvcHRpb25zIH0pID0+IHtcbiAgICBjb25zdCBpc0VuYWJsZWQgPSBvcHRpb25zPy5zaGFyZT8uZW5hYmxlID8/IGVuYWJsZTtcbiAgICBjb25zdCBvbWl0dGVkS2V5cyA9IG9wdGlvbnM/LnNoYXJlPy5vbWl0ID8/IFtdO1xuICAgIGlmICghaXNFbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNoYW5uZWwgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbEltcGwyKHN0b3JlLiRpZCwge1xuICAgICAgdHlwZVxuICAgIH0pO1xuICAgIGxldCB0aW1lc3RhbXAgPSAwO1xuICAgIGxldCBleHRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIGNvbnN0IGtleXNUb1VwZGF0ZSA9IE9iamVjdC5rZXlzKHN0b3JlLiRzdGF0ZSkuZmlsdGVyKChrZXkpID0+ICFvbWl0dGVkS2V5cy5pbmNsdWRlcyhrZXkpICYmIHN0YXRlSGFzS2V5KGtleSwgc3RvcmUuJHN0YXRlKSk7XG4gICAgY2hhbm5lbC5vbm1lc3NhZ2UgPSAobmV3U3RhdGUpID0+IHtcbiAgICAgIGlmIChuZXdTdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNoYW5uZWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICBzdGF0ZTogc2VyaWFsaXplKHN0b3JlLiRzdGF0ZSwgc2VyaWFsaXplcilcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdTdGF0ZS50aW1lc3RhbXAgPD0gdGltZXN0YW1wKVxuICAgICAgICByZXR1cm47XG4gICAgICBleHRlcm5hbFVwZGF0ZSA9IHRydWU7XG4gICAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgc3RvcmUuJHBhdGNoKChzdGF0ZSkgPT4ge1xuICAgICAgICBrZXlzVG9VcGRhdGUuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgc3RhdGVba2V5XSA9IG5ld1N0YXRlLnN0YXRlW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRJbml0aWFsaXplID0gb3B0aW9ucz8uc2hhcmU/LmluaXRpYWxpemUgPz8gaW5pdGlhbGl6ZTtcbiAgICBpZiAoc2hvdWxkSW5pdGlhbGl6ZSlcbiAgICAgIGNoYW5uZWwucG9zdE1lc3NhZ2Uodm9pZCAwKTtcbiAgICBzdG9yZS4kc3Vic2NyaWJlKChfLCBzdGF0ZSkgPT4ge1xuICAgICAgaWYgKCFleHRlcm5hbFVwZGF0ZSkge1xuICAgICAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICBjaGFubmVsLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgc3RhdGU6IHNlcmlhbGl6ZShzdGF0ZSwgc2VyaWFsaXplcilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBleHRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIH0pO1xuICB9O1xufVxuZXhwb3J0IHtcbiAgUGluaWFTaGFyZWRTdGF0ZSxcbiAgc2hhcmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBpbmplY3QsIHR5cGUgQXBwIH0gZnJvbSBcInZ1ZVwiO1xuaW1wb3J0IHsgT3BlbkFJIH0gZnJvbSBcIm9wZW5haVwiO1xuaW1wb3J0IHsgY3JlYXRlUGluaWEgfSBmcm9tIFwicGluaWFcIjtcbmltcG9ydCB7IFBpbmlhU2hhcmVkU3RhdGUgfSBmcm9tIFwicGluaWEtc2hhcmVkLXN0YXRlXCI7XG5cbmNvbnN0IEFJX0NMSUVOVF9QUk9WSURFUiA9IFN5bWJvbChcImNsaWVudFwiKTtcblxudHlwZSBBSUNsaWVudFByb3ZpZGVyID0geyBjbGllbnQ6IE9wZW5BSTsgc3lzdGVtUHJvbXB0OiBzdHJpbmcgfTtcblxuZXhwb3J0IGNvbnN0IGNvbmZpZ3VyZUFwcFdpdGhQcm92aWRlcnMgPVxuICAoeyBjbGllbnQsIHN5c3RlbVByb21wdCB9OiBBSUNsaWVudFByb3ZpZGVyKSA9PlxuICAoYXBwOiBBcHApID0+IHtcbiAgICBjb25zdCBwaW5pYSA9IGNyZWF0ZVBpbmlhKCk7XG4gICAgcGluaWEudXNlKFBpbmlhU2hhcmVkU3RhdGUoeyBlbmFibGU6IHRydWUsIGluaXRpYWxpemU6IGZhbHNlLCB0eXBlOiBcImxvY2Fsc3RvcmFnZVwiIH0pKTtcbiAgICAvLyAudXNlKHBpbmlhUGx1Z2luUGVyc2lzdGVkc3RhdGUpO1xuXG4gICAgYXBwLnVzZShwaW5pYSkucHJvdmlkZShBSV9DTElFTlRfUFJPVklERVIsIHtcbiAgICAgIGNsaWVudCxcbiAgICAgIHN5c3RlbVByb21wdCxcbiAgICB9KTtcbiAgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFJKCkge1xuICByZXR1cm4gaW5qZWN0PEFJQ2xpZW50UHJvdmlkZXI+KEFJX0NMSUVOVF9QUk9WSURFUikhO1xufVxuIiwiaW1wb3J0IHsgZGVmaW5lU3RvcmUgfSBmcm9tIFwicGluaWFcIjtcbmltcG9ydCB0eXBlIHsgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgfSBmcm9tIFwib3BlbmFpL3Jlc291cmNlcy9pbmRleC5tanNcIjtcblxudHlwZSBDaGF0TWVzc2FnZSA9IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nW1wibWVzc2FnZXNcIl1bMF07XG5cbmV4cG9ydCBjb25zdCB1c2VDaGF0Ym94U3RvcmUgPSBkZWZpbmVTdG9yZShcImNoYXRib3hcIiwge1xuICBzdGF0ZTogKCkgPT4gKHtcbiAgICBtb2RlbHM6IFtdIGFzIHN0cmluZ1tdLFxuICAgIHNlbGVjdGVkTW9kZWw6IFwiXCIsXG4gICAgc3lzdGVtUHJvbXB0OiBcIlwiLFxuICAgIHVzZXJNZXNzYWdlczogW10gYXMgQ2hhdE1lc3NhZ2VbXSxcbiAgICBuZXdNZXNzYWdlOiBcIlwiLFxuICAgIG1heFRva2VuczogNTAwMCxcbiAgfSksXG4gIGFjdGlvbnM6IHtcbiAgICBzZXRTeXN0ZW1Qcm9tcHQocHJvbXB0OiBzdHJpbmcpIHtcbiAgICAgIHRoaXMuc3lzdGVtUHJvbXB0ID0gcHJvbXB0O1xuICAgIH0sXG4gICAgc2V0TW9kZWxzKG1vZGVsczogc3RyaW5nW10pIHtcbiAgICAgIHRoaXMubW9kZWxzID0gbW9kZWxzO1xuICAgIH0sXG4gICAgc2V0U2VsZWN0ZWRNb2RlbChtb2RlbDogc3RyaW5nKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkTW9kZWwgPSBtb2RlbDtcbiAgICB9LFxuICAgIGFkZE1lc3NhZ2UobWVzc2FnZTogQ2hhdE1lc3NhZ2UpIHtcbiAgICAgIHRoaXMudXNlck1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgfSxcbiAgICBzZXROZXdNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZykge1xuICAgICAgdGhpcy5uZXdNZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9LFxuICAgIGNsZWFyTmV3TWVzc2FnZSgpIHtcbiAgICAgIHRoaXMubmV3TWVzc2FnZSA9IFwiXCI7XG4gICAgfSxcbiAgICBjbGVhck1lc3NhZ2VzKCkge1xuICAgICAgdGhpcy51c2VyTWVzc2FnZXMgPSBbXTtcbiAgICB9LFxuICB9LFxuICBnZXR0ZXJzOiB7XG4gICAgbWVzc2FnZXM6IChzdGF0ZSkgPT4ge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgeyByb2xlOiBcInN5c3RlbVwiLCBjb250ZW50OiBzdGF0ZS5zeXN0ZW1Qcm9tcHQgfSxcbiAgICAgICAgLi4uc3RhdGUudXNlck1lc3NhZ2VzLFxuICAgICAgXSBzYXRpc2ZpZXMgQ2hhdE1lc3NhZ2VbXTtcbiAgICB9LFxuICB9LFxufSk7XG4iLCIvKipcbiAqIG1hcmtlZCB2MTQuMS4xIC0gYSBtYXJrZG93biBwYXJzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDI0LCBDaHJpc3RvcGhlciBKZWZmcmV5LiAoTUlUIExpY2Vuc2VkKVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZFxuICovXG5cbi8qKlxuICogRE8gTk9UIEVESVQgVEhJUyBGSUxFXG4gKiBUaGUgY29kZSBpbiB0aGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gZmlsZXMgaW4gLi9zcmMvXG4gKi9cblxuLyoqXG4gKiBHZXRzIHRoZSBvcmlnaW5hbCBtYXJrZWQgZGVmYXVsdCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBfZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgICBicmVha3M6IGZhbHNlLFxuICAgICAgICBleHRlbnNpb25zOiBudWxsLFxuICAgICAgICBnZm06IHRydWUsXG4gICAgICAgIGhvb2tzOiBudWxsLFxuICAgICAgICBwZWRhbnRpYzogZmFsc2UsXG4gICAgICAgIHJlbmRlcmVyOiBudWxsLFxuICAgICAgICBzaWxlbnQ6IGZhbHNlLFxuICAgICAgICB0b2tlbml6ZXI6IG51bGwsXG4gICAgICAgIHdhbGtUb2tlbnM6IG51bGwsXG4gICAgfTtcbn1cbmxldCBfZGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHMoKTtcbmZ1bmN0aW9uIGNoYW5nZURlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gICAgX2RlZmF1bHRzID0gbmV3RGVmYXVsdHM7XG59XG5cbi8qKlxuICogSGVscGVyc1xuICovXG5jb25zdCBlc2NhcGVUZXN0ID0gL1smPD5cIiddLztcbmNvbnN0IGVzY2FwZVJlcGxhY2UgPSBuZXcgUmVnRXhwKGVzY2FwZVRlc3Quc291cmNlLCAnZycpO1xuY29uc3QgZXNjYXBlVGVzdE5vRW5jb2RlID0gL1s8PlwiJ118Jig/ISgjXFxkezEsN318I1tYeF1bYS1mQS1GMC05XXsxLDZ9fFxcdyspOykvO1xuY29uc3QgZXNjYXBlUmVwbGFjZU5vRW5jb2RlID0gbmV3IFJlZ0V4cChlc2NhcGVUZXN0Tm9FbmNvZGUuc291cmNlLCAnZycpO1xuY29uc3QgZXNjYXBlUmVwbGFjZW1lbnRzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7Jyxcbn07XG5jb25zdCBnZXRFc2NhcGVSZXBsYWNlbWVudCA9IChjaCkgPT4gZXNjYXBlUmVwbGFjZW1lbnRzW2NoXTtcbmZ1bmN0aW9uIGVzY2FwZSQxKGh0bWwsIGVuY29kZSkge1xuICAgIGlmIChlbmNvZGUpIHtcbiAgICAgICAgaWYgKGVzY2FwZVRlc3QudGVzdChodG1sKSkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShlc2NhcGVSZXBsYWNlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChlc2NhcGVUZXN0Tm9FbmNvZGUudGVzdChodG1sKSkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShlc2NhcGVSZXBsYWNlTm9FbmNvZGUsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbn1cbmNvbnN0IGNhcmV0ID0gLyhefFteXFxbXSlcXF4vZztcbmZ1bmN0aW9uIGVkaXQocmVnZXgsIG9wdCkge1xuICAgIGxldCBzb3VyY2UgPSB0eXBlb2YgcmVnZXggPT09ICdzdHJpbmcnID8gcmVnZXggOiByZWdleC5zb3VyY2U7XG4gICAgb3B0ID0gb3B0IHx8ICcnO1xuICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAgcmVwbGFjZTogKG5hbWUsIHZhbCkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbFNvdXJjZSA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gdmFsIDogdmFsLnNvdXJjZTtcbiAgICAgICAgICAgIHZhbFNvdXJjZSA9IHZhbFNvdXJjZS5yZXBsYWNlKGNhcmV0LCAnJDEnKTtcbiAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKG5hbWUsIHZhbFNvdXJjZSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LFxuICAgICAgICBnZXRSZWdleDogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoc291cmNlLCBvcHQpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIGNsZWFuVXJsKGhyZWYpIHtcbiAgICB0cnkge1xuICAgICAgICBocmVmID0gZW5jb2RlVVJJKGhyZWYpLnJlcGxhY2UoLyUyNS9nLCAnJScpO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaHJlZjtcbn1cbmNvbnN0IG5vb3BUZXN0ID0geyBleGVjOiAoKSA9PiBudWxsIH07XG5mdW5jdGlvbiBzcGxpdENlbGxzKHRhYmxlUm93LCBjb3VudCkge1xuICAgIC8vIGVuc3VyZSB0aGF0IGV2ZXJ5IGNlbGwtZGVsaW1pdGluZyBwaXBlIGhhcyBhIHNwYWNlXG4gICAgLy8gYmVmb3JlIGl0IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb20gYW4gZXNjYXBlZCBwaXBlXG4gICAgY29uc3Qgcm93ID0gdGFibGVSb3cucmVwbGFjZSgvXFx8L2csIChtYXRjaCwgb2Zmc2V0LCBzdHIpID0+IHtcbiAgICAgICAgbGV0IGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGN1cnIgPSBvZmZzZXQ7XG4gICAgICAgIHdoaWxlICgtLWN1cnIgPj0gMCAmJiBzdHJbY3Vycl0gPT09ICdcXFxcJylcbiAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgICAgICAgIC8vIG9kZCBudW1iZXIgb2Ygc2xhc2hlcyBtZWFucyB8IGlzIGVzY2FwZWRcbiAgICAgICAgICAgIC8vIHNvIHdlIGxlYXZlIGl0IGFsb25lXG4gICAgICAgICAgICByZXR1cm4gJ3wnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYWRkIHNwYWNlIGJlZm9yZSB1bmVzY2FwZWQgfFxuICAgICAgICAgICAgcmV0dXJuICcgfCc7XG4gICAgICAgIH1cbiAgICB9KSwgY2VsbHMgPSByb3cuc3BsaXQoLyBcXHwvKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gRmlyc3QvbGFzdCBjZWxsIGluIGEgcm93IGNhbm5vdCBiZSBlbXB0eSBpZiBpdCBoYXMgbm8gbGVhZGluZy90cmFpbGluZyBwaXBlXG4gICAgaWYgKCFjZWxsc1swXS50cmltKCkpIHtcbiAgICAgICAgY2VsbHMuc2hpZnQoKTtcbiAgICB9XG4gICAgaWYgKGNlbGxzLmxlbmd0aCA+IDAgJiYgIWNlbGxzW2NlbGxzLmxlbmd0aCAtIDFdLnRyaW0oKSkge1xuICAgICAgICBjZWxscy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICAgIGlmIChjZWxscy5sZW5ndGggPiBjb3VudCkge1xuICAgICAgICAgICAgY2VsbHMuc3BsaWNlKGNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChjZWxscy5sZW5ndGggPCBjb3VudClcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKCcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZSBpcyBpZ25vcmVkIHBlciB0aGUgZ2ZtIHNwZWNcbiAgICAgICAgY2VsbHNbaV0gPSBjZWxsc1tpXS50cmltKCkucmVwbGFjZSgvXFxcXFxcfC9nLCAnfCcpO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbHM7XG59XG4vKipcbiAqIFJlbW92ZSB0cmFpbGluZyAnYydzLiBFcXVpdmFsZW50IHRvIHN0ci5yZXBsYWNlKC9jKiQvLCAnJykuXG4gKiAvYyokLyBpcyB2dWxuZXJhYmxlIHRvIFJFRE9TLlxuICpcbiAqIEBwYXJhbSBzdHJcbiAqIEBwYXJhbSBjXG4gKiBAcGFyYW0gaW52ZXJ0IFJlbW92ZSBzdWZmaXggb2Ygbm9uLWMgY2hhcnMgaW5zdGVhZC4gRGVmYXVsdCBmYWxzZXkuXG4gKi9cbmZ1bmN0aW9uIHJ0cmltKHN0ciwgYywgaW52ZXJ0KSB7XG4gICAgY29uc3QgbCA9IHN0ci5sZW5ndGg7XG4gICAgaWYgKGwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyBMZW5ndGggb2Ygc3VmZml4IG1hdGNoaW5nIHRoZSBpbnZlcnQgY29uZGl0aW9uLlxuICAgIGxldCBzdWZmTGVuID0gMDtcbiAgICAvLyBTdGVwIGxlZnQgdW50aWwgd2UgZmFpbCB0byBtYXRjaCB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cbiAgICB3aGlsZSAoc3VmZkxlbiA8IGwpIHtcbiAgICAgICAgY29uc3QgY3VyckNoYXIgPSBzdHIuY2hhckF0KGwgLSBzdWZmTGVuIC0gMSk7XG4gICAgICAgIGlmIChjdXJyQ2hhciA9PT0gYyAmJiAhaW52ZXJ0KSB7XG4gICAgICAgICAgICBzdWZmTGVuKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyckNoYXIgIT09IGMgJiYgaW52ZXJ0KSB7XG4gICAgICAgICAgICBzdWZmTGVuKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyLnNsaWNlKDAsIGwgLSBzdWZmTGVuKTtcbn1cbmZ1bmN0aW9uIGZpbmRDbG9zaW5nQnJhY2tldChzdHIsIGIpIHtcbiAgICBpZiAoc3RyLmluZGV4T2YoYlsxXSkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgbGV0IGxldmVsID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3RyW2ldID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHJbaV0gPT09IGJbMF0pIHtcbiAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyW2ldID09PSBiWzFdKSB7XG4gICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAgICAgaWYgKGxldmVsIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gb3V0cHV0TGluayhjYXAsIGxpbmssIHJhdywgbGV4ZXIpIHtcbiAgICBjb25zdCBocmVmID0gbGluay5ocmVmO1xuICAgIGNvbnN0IHRpdGxlID0gbGluay50aXRsZSA/IGVzY2FwZSQxKGxpbmsudGl0bGUpIDogbnVsbDtcbiAgICBjb25zdCB0ZXh0ID0gY2FwWzFdLnJlcGxhY2UoL1xcXFwoW1xcW1xcXV0pL2csICckMScpO1xuICAgIGlmIChjYXBbMF0uY2hhckF0KDApICE9PSAnIScpIHtcbiAgICAgICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgICByYXcsXG4gICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgdG9rZW5zOiBsZXhlci5pbmxpbmVUb2tlbnModGV4dCksXG4gICAgICAgIH07XG4gICAgICAgIGxleGVyLnN0YXRlLmluTGluayA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgIHJhdyxcbiAgICAgICAgaHJlZixcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIHRleHQ6IGVzY2FwZSQxKHRleHQpLFxuICAgIH07XG59XG5mdW5jdGlvbiBpbmRlbnRDb2RlQ29tcGVuc2F0aW9uKHJhdywgdGV4dCkge1xuICAgIGNvbnN0IG1hdGNoSW5kZW50VG9Db2RlID0gcmF3Lm1hdGNoKC9eKFxccyspKD86YGBgKS8pO1xuICAgIGlmIChtYXRjaEluZGVudFRvQ29kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgY29uc3QgaW5kZW50VG9Db2RlID0gbWF0Y2hJbmRlbnRUb0NvZGVbMV07XG4gICAgcmV0dXJuIHRleHRcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAubWFwKG5vZGUgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaEluZGVudEluTm9kZSA9IG5vZGUubWF0Y2goL15cXHMrLyk7XG4gICAgICAgIGlmIChtYXRjaEluZGVudEluTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2luZGVudEluTm9kZV0gPSBtYXRjaEluZGVudEluTm9kZTtcbiAgICAgICAgaWYgKGluZGVudEluTm9kZS5sZW5ndGggPj0gaW5kZW50VG9Db2RlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuc2xpY2UoaW5kZW50VG9Db2RlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xufVxuLyoqXG4gKiBUb2tlbml6ZXJcbiAqL1xuY2xhc3MgX1Rva2VuaXplciB7XG4gICAgb3B0aW9ucztcbiAgICBydWxlczsgLy8gc2V0IGJ5IHRoZSBsZXhlclxuICAgIGxleGVyOyAvLyBzZXQgYnkgdGhlIGxleGVyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IF9kZWZhdWx0cztcbiAgICB9XG4gICAgc3BhY2Uoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2submV3bGluZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXAgJiYgY2FwWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NwYWNlJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29kZShzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5jb2RlLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGNhcFswXS5yZXBsYWNlKC9eKD86IHsxLDR9fCB7MCwzfVxcdCkvZ20sICcnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGNvZGVCbG9ja1N0eWxlOiAnaW5kZW50ZWQnLFxuICAgICAgICAgICAgICAgIHRleHQ6ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICAgICAgICAgICAgPyBydHJpbSh0ZXh0LCAnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgOiB0ZXh0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmZW5jZXMoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZmVuY2VzLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgcmF3ID0gY2FwWzBdO1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCBjYXBbM10gfHwgJycpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgIGxhbmc6IGNhcFsyXSA/IGNhcFsyXS50cmltKCkucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiBjYXBbMl0sXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGVhZGluZyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oZWFkaW5nLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBjYXBbMl0udHJpbSgpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nICNzXG4gICAgICAgICAgICBpZiAoLyMkLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZCA9IHJ0cmltKHRleHQsICcjJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0cmltbWVkIHx8IC8gJC8udGVzdCh0cmltbWVkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21tb25NYXJrIHJlcXVpcmVzIHNwYWNlIGJlZm9yZSB0cmFpbGluZyAjc1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKHRleHQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBocihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oci5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hyJyxcbiAgICAgICAgICAgICAgICByYXc6IHJ0cmltKGNhcFswXSwgJ1xcbicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBibG9ja3F1b3RlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmJsb2NrcXVvdGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBydHJpbShjYXBbMF0sICdcXG4nKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBsZXQgcmF3ID0gJyc7XG4gICAgICAgICAgICBsZXQgdGV4dCA9ICcnO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICAgICAgICB3aGlsZSAobGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBpbkJsb2NrcXVvdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TGluZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGxpbmVzIHVwIHRvIGEgY29udGludWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICgvXiB7MCwzfT4vLnRlc3QobGluZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZXMucHVzaChsaW5lc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkJsb2NrcXVvdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpbkJsb2NrcXVvdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lcy5wdXNoKGxpbmVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmVzID0gbGluZXMuc2xpY2UoaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFJhdyA9IGN1cnJlbnRMaW5lcy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VGV4dCA9IGN1cnJlbnRSYXdcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJlY2VkZSBzZXRleHQgY29udGludWF0aW9uIHdpdGggNCBzcGFjZXMgc28gaXQgaXNuJ3QgYSBzZXRleHRcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcbiB7MCwzfSgoPzo9K3wtKykgKikoPz1cXG58JCkvZywgJ1xcbiAgICAkMScpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eIHswLDN9PlsgXFx0XT8vZ20sICcnKTtcbiAgICAgICAgICAgICAgICByYXcgPSByYXcgPyBgJHtyYXd9XFxuJHtjdXJyZW50UmF3fWAgOiBjdXJyZW50UmF3O1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0ID8gYCR7dGV4dH1cXG4ke2N1cnJlbnRUZXh0fWAgOiBjdXJyZW50VGV4dDtcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSBibG9ja3F1b3RlIGxpbmVzIGFzIHRvcCBsZXZlbCB0b2tlbnNcbiAgICAgICAgICAgICAgICAvLyBtZXJnZSBwYXJhZ3JhcGhzIGlmIHRoaXMgaXMgYSBjb250aW51YXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCB0b3AgPSB0aGlzLmxleGVyLnN0YXRlLnRvcDtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5ibG9ja1Rva2VucyhjdXJyZW50VGV4dCwgdG9rZW5zLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IHRvcDtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBjb250aW51YXRpb24gdGhlbiB3ZSBhcmUgZG9uZVxuICAgICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbj8udHlwZSA9PT0gJ2NvZGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJsb2NrcXVvdGUgY29udGludWF0aW9uIGNhbm5vdCBiZSBwcmVjZWRlZCBieSBhIGNvZGUgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxhc3RUb2tlbj8udHlwZSA9PT0gJ2Jsb2NrcXVvdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluY2x1ZGUgY29udGludWF0aW9uIGluIG5lc3RlZCBibG9ja3F1b3RlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFRva2VuID0gbGFzdFRva2VuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdUZXh0ID0gb2xkVG9rZW4ucmF3ICsgJ1xcbicgKyBsaW5lcy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VG9rZW4gPSB0aGlzLmJsb2NrcXVvdGUobmV3VGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0gPSBuZXdUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgcmF3ID0gcmF3LnN1YnN0cmluZygwLCByYXcubGVuZ3RoIC0gb2xkVG9rZW4ucmF3Lmxlbmd0aCkgKyBuZXdUb2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCB0ZXh0Lmxlbmd0aCAtIG9sZFRva2VuLnRleHQubGVuZ3RoKSArIG5ld1Rva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsYXN0VG9rZW4/LnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmNsdWRlIGNvbnRpbnVhdGlvbiBpbiBuZXN0ZWQgbGlzdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRUb2tlbiA9IGxhc3RUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VGV4dCA9IG9sZFRva2VuLnJhdyArICdcXG4nICsgbGluZXMuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Rva2VuID0gdGhpcy5saXN0KG5ld1RleHQpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdID0gbmV3VG9rZW47XG4gICAgICAgICAgICAgICAgICAgIHJhdyA9IHJhdy5zdWJzdHJpbmcoMCwgcmF3Lmxlbmd0aCAtIGxhc3RUb2tlbi5yYXcubGVuZ3RoKSArIG5ld1Rva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHRleHQubGVuZ3RoIC0gb2xkVG9rZW4ucmF3Lmxlbmd0aCkgKyBuZXdUb2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzID0gbmV3VGV4dC5zdWJzdHJpbmcodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS5yYXcubGVuZ3RoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAgICAgICAgIHJhdyxcbiAgICAgICAgICAgICAgICB0b2tlbnMsXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGlzdChzcmMpIHtcbiAgICAgICAgbGV0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2subGlzdC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCBidWxsID0gY2FwWzFdLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IGlzb3JkZXJlZCA9IGJ1bGwubGVuZ3RoID4gMTtcbiAgICAgICAgICAgIGNvbnN0IGxpc3QgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgICAgICAgICAgIHJhdzogJycsXG4gICAgICAgICAgICAgICAgb3JkZXJlZDogaXNvcmRlcmVkLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBpc29yZGVyZWQgPyArYnVsbC5zbGljZSgwLCAtMSkgOiAnJyxcbiAgICAgICAgICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJ1bGwgPSBpc29yZGVyZWQgPyBgXFxcXGR7MSw5fVxcXFwke2J1bGwuc2xpY2UoLTEpfWAgOiBgXFxcXCR7YnVsbH1gO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICAgIGJ1bGwgPSBpc29yZGVyZWQgPyBidWxsIDogJ1sqKy1dJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCBuZXh0IGxpc3QgaXRlbVxuICAgICAgICAgICAgY29uc3QgaXRlbVJlZ2V4ID0gbmV3IFJlZ0V4cChgXiggezAsM30ke2J1bGx9KSgoPzpbXFx0IF1bXlxcXFxuXSopPyg/OlxcXFxufCQpKWApO1xuICAgICAgICAgICAgbGV0IGVuZHNXaXRoQmxhbmtMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBjdXJyZW50IGJ1bGxldCBwb2ludCBjYW4gc3RhcnQgYSBuZXcgTGlzdCBJdGVtXG4gICAgICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZEVhcmx5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IHJhdyA9ICcnO1xuICAgICAgICAgICAgICAgIGxldCBpdGVtQ29udGVudHMgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoIShjYXAgPSBpdGVtUmVnZXguZXhlYyhzcmMpKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucnVsZXMuYmxvY2suaHIudGVzdChzcmMpKSB7IC8vIEVuZCBsaXN0IGlmIGJ1bGxldCB3YXMgYWN0dWFsbHkgSFIgKHBvc3NpYmx5IG1vdmUgaW50byBpdGVtUmVnZXg/KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmF3ID0gY2FwWzBdO1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSBjYXBbMl0uc3BsaXQoJ1xcbicsIDEpWzBdLnJlcGxhY2UoL15cXHQrLywgKHQpID0+ICcgJy5yZXBlYXQoMyAqIHQubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRMaW5lID0gc3JjLnNwbGl0KCdcXG4nLCAxKVswXTtcbiAgICAgICAgICAgICAgICBsZXQgYmxhbmtMaW5lID0gIWxpbmUudHJpbSgpO1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gbGluZS50cmltU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCA9IGNhcFsxXS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gY2FwWzJdLnNlYXJjaCgvW14gXS8pOyAvLyBGaW5kIGZpcnN0IG5vbi1zcGFjZSBjaGFyXG4gICAgICAgICAgICAgICAgICAgIGluZGVudCA9IGluZGVudCA+IDQgPyAxIDogaW5kZW50OyAvLyBUcmVhdCBpbmRlbnRlZCBjb2RlIGJsb2NrcyAoPiA0IHNwYWNlcykgYXMgaGF2aW5nIG9ubHkgMSBpbmRlbnRcbiAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gbGluZS5zbGljZShpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgKz0gY2FwWzFdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJsYW5rTGluZSAmJiAvXlsgXFx0XSokLy50ZXN0KG5leHRMaW5lKSkgeyAvLyBJdGVtcyBiZWdpbiB3aXRoIGF0IG1vc3Qgb25lIGJsYW5rIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgcmF3ICs9IG5leHRMaW5lICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcobmV4dExpbmUubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGVuZEVhcmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlbmRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0QnVsbGV0UmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSg/OlsqKy1dfFxcXFxkezEsOX1bLildKSgoPzpbIFxcdF1bXlxcXFxuXSopPyg/OlxcXFxufCQpKWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoclJlZ2V4ID0gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0oKD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFxcXCogKil7Myx9KSg/OlxcXFxuK3wkKWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZW5jZXNCZWdpblJlZ2V4ID0gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0oPzpcXGBcXGBcXGB8fn5+KWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkaW5nQmVnaW5SZWdleCA9IG5ldyBSZWdFeHAoYF4gezAsJHtNYXRoLm1pbigzLCBpbmRlbnQgLSAxKX19I2ApO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBmb2xsb3dpbmcgbGluZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIExpc3QgSXRlbVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdMaW5lID0gc3JjLnNwbGl0KCdcXG4nLCAxKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXh0TGluZVdpdGhvdXRUYWJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUgPSByYXdMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmUtYWxpZ24gdG8gZm9sbG93IGNvbW1vbm1hcmsgbmVzdGluZyBydWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRMaW5lID0gbmV4dExpbmUucmVwbGFjZSgvXiB7MSw0fSg/PSggezR9KSpbXiBdKS9nLCAnICAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0TGluZVdpdGhvdXRUYWJzID0gbmV4dExpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0TGluZVdpdGhvdXRUYWJzID0gbmV4dExpbmUucmVwbGFjZSgvXFx0L2csICcgICAgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIGNvZGUgZmVuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVuY2VzQmVnaW5SZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIGxpc3QgaXRlbSBpZiBmb3VuZCBzdGFydCBvZiBuZXcgaGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRpbmdCZWdpblJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIG5ldyBidWxsZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0QnVsbGV0UmVnZXgudGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgcnVsZSBmb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhyUmVnZXgudGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0TGluZVdpdGhvdXRUYWJzLnNlYXJjaCgvW14gXS8pID49IGluZGVudCB8fCAhbmV4dExpbmUudHJpbSgpKSB7IC8vIERlZGVudCBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIG5leHRMaW5lV2l0aG91dFRhYnMuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBlbm91Z2ggaW5kZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJhZ3JhcGggY29udGludWF0aW9uIHVubGVzcyBsYXN0IGxpbmUgd2FzIGEgZGlmZmVyZW50IGJsb2NrIGxldmVsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5yZXBsYWNlKC9cXHQvZywgJyAgICAnKS5zZWFyY2goL1teIF0vKSA+PSA0KSB7IC8vIGluZGVudGVkIGNvZGUgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZW5jZXNCZWdpblJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZWFkaW5nQmVnaW5SZWdleC50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHJSZWdleC50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQ29udGVudHMgKz0gJ1xcbicgKyBuZXh0TGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmxhbmtMaW5lICYmICFuZXh0TGluZS50cmltKCkpIHsgLy8gQ2hlY2sgaWYgY3VycmVudCBsaW5lIGlzIGJsYW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxhbmtMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdyArPSByYXdMaW5lICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHJhd0xpbmUubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gbmV4dExpbmVXaXRob3V0VGFicy5zbGljZShpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbGlzdC5sb29zZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgaXRlbSBlbmRlZCB3aXRoIGEgYmxhbmsgbGluZSwgdGhlIGxpc3QgaXMgbG9vc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHNXaXRoQmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0Lmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXFxuWyBcXHRdKlxcblsgXFx0XSokLy50ZXN0KHJhdykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHNXaXRoQmxhbmtMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaXN0YXNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgaXNjaGVja2VkO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciB0YXNrIGxpc3QgaXRlbXNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgICAgICAgICAgICBpc3Rhc2sgPSAvXlxcW1sgeFhdXFxdIC8uZXhlYyhpdGVtQ29udGVudHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXN0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc2NoZWNrZWQgPSBpc3Rhc2tbMF0gIT09ICdbIF0gJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGl0ZW1Db250ZW50cy5yZXBsYWNlKC9eXFxbWyB4WF1cXF0gKy8sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0Lml0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgICAgICB0YXNrOiAhIWlzdGFzayxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogaXNjaGVja2VkLFxuICAgICAgICAgICAgICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGl0ZW1Db250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiBbXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsaXN0LnJhdyArPSByYXc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEbyBub3QgY29uc3VtZSBuZXdsaW5lcyBhdCBlbmQgb2YgZmluYWwgaXRlbS4gQWx0ZXJuYXRpdmVseSwgbWFrZSBpdGVtUmVnZXggKnN0YXJ0KiB3aXRoIGFueSBuZXdsaW5lcyB0byBzaW1wbGlmeS9zcGVlZCB1cCBlbmRzV2l0aEJsYW5rTGluZSBsb2dpY1xuICAgICAgICAgICAgbGlzdC5pdGVtc1tsaXN0Lml0ZW1zLmxlbmd0aCAtIDFdLnJhdyA9IGxpc3QuaXRlbXNbbGlzdC5pdGVtcy5sZW5ndGggLSAxXS5yYXcudHJpbUVuZCgpO1xuICAgICAgICAgICAgbGlzdC5pdGVtc1tsaXN0Lml0ZW1zLmxlbmd0aCAtIDFdLnRleHQgPSBsaXN0Lml0ZW1zW2xpc3QuaXRlbXMubGVuZ3RoIC0gMV0udGV4dC50cmltRW5kKCk7XG4gICAgICAgICAgICBsaXN0LnJhdyA9IGxpc3QucmF3LnRyaW1FbmQoKTtcbiAgICAgICAgICAgIC8vIEl0ZW0gY2hpbGQgdG9rZW5zIGhhbmRsZWQgaGVyZSBhdCBlbmQgYmVjYXVzZSB3ZSBuZWVkZWQgdG8gaGF2ZSB0aGUgZmluYWwgaXRlbSB0byB0cmltIGl0IGZpcnN0XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxpc3QuaXRlbXNbaV0udG9rZW5zID0gdGhpcy5sZXhlci5ibG9ja1Rva2VucyhsaXN0Lml0ZW1zW2ldLnRleHQsIFtdKTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpc3QubG9vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbGlzdCBzaG91bGQgYmUgbG9vc2VcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BhY2VycyA9IGxpc3QuaXRlbXNbaV0udG9rZW5zLmZpbHRlcih0ID0+IHQudHlwZSA9PT0gJ3NwYWNlJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc011bHRpcGxlTGluZUJyZWFrcyA9IHNwYWNlcnMubGVuZ3RoID4gMCAmJiBzcGFjZXJzLnNvbWUodCA9PiAvXFxuLipcXG4vLnRlc3QodC5yYXcpKTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5sb29zZSA9IGhhc011bHRpcGxlTGluZUJyZWFrcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgYWxsIGl0ZW1zIHRvIGxvb3NlIGlmIGxpc3QgaXMgbG9vc2VcbiAgICAgICAgICAgIGlmIChsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QuaXRlbXNbaV0ubG9vc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGh0bWwoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaHRtbC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgICAgICBibG9jazogdHJ1ZSxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBwcmU6IGNhcFsxXSA9PT0gJ3ByZScgfHwgY2FwWzFdID09PSAnc2NyaXB0JyB8fCBjYXBbMV0gPT09ICdzdHlsZScsXG4gICAgICAgICAgICAgICAgdGV4dDogY2FwWzBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWYoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZGVmLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gY2FwWzFdLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgICAgICAgY29uc3QgaHJlZiA9IGNhcFsyXSA/IGNhcFsyXS5yZXBsYWNlKC9ePCguKik+JC8sICckMScpLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24sICckMScpIDogJyc7XG4gICAgICAgICAgICBjb25zdCB0aXRsZSA9IGNhcFszXSA/IGNhcFszXS5zdWJzdHJpbmcoMSwgY2FwWzNdLmxlbmd0aCAtIDEpLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24sICckMScpIDogY2FwWzNdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGVmJyxcbiAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFibGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGFibGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIWNhcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghL1s6fF0vLnRlc3QoY2FwWzJdKSkge1xuICAgICAgICAgICAgLy8gZGVsaW1pdGVyIHJvdyBtdXN0IGhhdmUgYSBwaXBlICh8KSBvciBjb2xvbiAoOikgb3RoZXJ3aXNlIGl0IGlzIGEgc2V0ZXh0IGhlYWRpbmdcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0gc3BsaXRDZWxscyhjYXBbMV0pO1xuICAgICAgICBjb25zdCBhbGlnbnMgPSBjYXBbMl0ucmVwbGFjZSgvXlxcfHxcXHwgKiQvZywgJycpLnNwbGl0KCd8Jyk7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBjYXBbM10gJiYgY2FwWzNdLnRyaW0oKSA/IGNhcFszXS5yZXBsYWNlKC9cXG5bIFxcdF0qJC8sICcnKS5zcGxpdCgnXFxuJykgOiBbXTtcbiAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgIGhlYWRlcjogW10sXG4gICAgICAgICAgICBhbGlnbjogW10sXG4gICAgICAgICAgICByb3dzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoICE9PSBhbGlnbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBoZWFkZXIgYW5kIGFsaWduIGNvbHVtbnMgbXVzdCBiZSBlcXVhbCwgcm93cyBjYW4gYmUgZGlmZmVyZW50LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgYWxpZ24gb2YgYWxpZ25zKSB7XG4gICAgICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFsaWduLnB1c2goJ3JpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFsaWduLnB1c2goJ2NlbnRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFsaWduLnB1c2goJ2xlZnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ24ucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0uaGVhZGVyLnB1c2goe1xuICAgICAgICAgICAgICAgIHRleHQ6IGhlYWRlcnNbaV0sXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShoZWFkZXJzW2ldKSxcbiAgICAgICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgYWxpZ246IGl0ZW0uYWxpZ25baV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgICBpdGVtLnJvd3MucHVzaChzcGxpdENlbGxzKHJvdywgaXRlbS5oZWFkZXIubGVuZ3RoKS5tYXAoKGNlbGwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjZWxsLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNlbGwpLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbGlnbjogaXRlbS5hbGlnbltpXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICBsaGVhZGluZyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5saGVhZGluZy5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGRlcHRoOiBjYXBbMl0uY2hhckF0KDApID09PSAnPScgPyAxIDogMixcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMV0sXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShjYXBbMV0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJhZ3JhcGgoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sucGFyYWdyYXBoLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGNhcFsxXS5jaGFyQXQoY2FwWzFdLmxlbmd0aCAtIDEpID09PSAnXFxuJ1xuICAgICAgICAgICAgICAgID8gY2FwWzFdLnNsaWNlKDAsIC0xKVxuICAgICAgICAgICAgICAgIDogY2FwWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUodGV4dCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRleHQoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGV4dC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNhcFswXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVzY2FwZShzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuZXNjYXBlLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXNjYXBlJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBlc2NhcGUkMShjYXBbMV0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0YWcoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnRhZy5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgJiYgL148YSAvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluTGluayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxleGVyLnN0YXRlLmluTGluayAmJiAvXjxcXC9hPi9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiAvXjwocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiAvXjxcXC8ocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBpbkxpbms6IHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rLFxuICAgICAgICAgICAgICAgIGluUmF3QmxvY2s6IHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayxcbiAgICAgICAgICAgICAgICBibG9jazogZmFsc2UsXG4gICAgICAgICAgICAgICAgdGV4dDogY2FwWzBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaW5rKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5saW5rLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdHJpbW1lZFVybCA9IGNhcFsyXS50cmltKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5wZWRhbnRpYyAmJiAvXjwvLnRlc3QodHJpbW1lZFVybCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb21tb25tYXJrIHJlcXVpcmVzIG1hdGNoaW5nIGFuZ2xlIGJyYWNrZXRzXG4gICAgICAgICAgICAgICAgaWYgKCEoLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVuZGluZyBhbmdsZSBicmFja2V0IGNhbm5vdCBiZSBlc2NhcGVkXG4gICAgICAgICAgICAgICAgY29uc3QgcnRyaW1TbGFzaCA9IHJ0cmltKHRyaW1tZWRVcmwuc2xpY2UoMCwgLTEpLCAnXFxcXCcpO1xuICAgICAgICAgICAgICAgIGlmICgodHJpbW1lZFVybC5sZW5ndGggLSBydHJpbVNsYXNoLmxlbmd0aCkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGNsb3NpbmcgcGFyZW50aGVzaXNcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UGFyZW5JbmRleCA9IGZpbmRDbG9zaW5nQnJhY2tldChjYXBbMl0sICcoKScpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFyZW5JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gY2FwWzBdLmluZGV4T2YoJyEnKSA9PT0gMCA/IDUgOiA0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rTGVuID0gc3RhcnQgKyBjYXBbMV0ubGVuZ3RoICsgbGFzdFBhcmVuSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNhcFsyXSA9IGNhcFsyXS5zdWJzdHJpbmcoMCwgbGFzdFBhcmVuSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjYXBbMF0gPSBjYXBbMF0uc3Vic3RyaW5nKDAsIGxpbmtMZW4pLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY2FwWzNdID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhyZWYgPSBjYXBbMl07XG4gICAgICAgICAgICBsZXQgdGl0bGUgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCBwZWRhbnRpYyBocmVmIGFuZCB0aXRsZVxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSAvXihbXidcIl0qW15cXHNdKVxccysoWydcIl0pKC4qKVxcMi8uZXhlYyhocmVmKTtcbiAgICAgICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gbGlua1sxXTtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBsaW5rWzNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnNsaWNlKDEsIC0xKSA6ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHJlZiA9IGhyZWYudHJpbSgpO1xuICAgICAgICAgICAgaWYgKC9ePC8udGVzdChocmVmKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgISgvPiQvLnRlc3QodHJpbW1lZFVybCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBlZGFudGljIGFsbG93cyBzdGFydGluZyBhbmdsZSBicmFja2V0IHdpdGhvdXQgZW5kaW5nIGFuZ2xlIGJyYWNrZXRcbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9IGhyZWYuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gaHJlZi5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgICAgICAgICAgaHJlZjogaHJlZiA/IGhyZWYucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiBocmVmLFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSA/IHRpdGxlLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24sICckMScpIDogdGl0bGUsXG4gICAgICAgICAgICB9LCBjYXBbMF0sIHRoaXMubGV4ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZmxpbmsoc3JjLCBsaW5rcykge1xuICAgICAgICBsZXQgY2FwO1xuICAgICAgICBpZiAoKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnJlZmxpbmsuZXhlYyhzcmMpKVxuICAgICAgICAgICAgfHwgKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLm5vbGluay5leGVjKHNyYykpKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rU3RyaW5nID0gKGNhcFsyXSB8fCBjYXBbMV0pLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBsaW5rc1tsaW5rU3RyaW5nLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICByYXc6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRMaW5rKGNhcCwgbGluaywgY2FwWzBdLCB0aGlzLmxleGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIgPSAnJykge1xuICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZ0xEZWxpbS5leGVjKHNyYyk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIF8gY2FuJ3QgYmUgYmV0d2VlbiB0d28gYWxwaGFudW1lcmljcy4gXFxwe0x9XFxwe059IGluY2x1ZGVzIG5vbi1lbmdsaXNoIGFscGhhYmV0L251bWJlcnMgYXMgd2VsbFxuICAgICAgICBpZiAobWF0Y2hbM10gJiYgcHJldkNoYXIubWF0Y2goL1tcXHB7TH1cXHB7Tn1dL3UpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBuZXh0Q2hhciA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdIHx8ICcnO1xuICAgICAgICBpZiAoIW5leHRDaGFyIHx8ICFwcmV2Q2hhciB8fCB0aGlzLnJ1bGVzLmlubGluZS5wdW5jdHVhdGlvbi5leGVjKHByZXZDaGFyKSkge1xuICAgICAgICAgICAgLy8gdW5pY29kZSBSZWdleCBjb3VudHMgZW1vamkgYXMgMSBjaGFyOyBzcHJlYWQgaW50byBhcnJheSBmb3IgcHJvcGVyIGNvdW50ICh1c2VkIG11bHRpcGxlIHRpbWVzIGJlbG93KVxuICAgICAgICAgICAgY29uc3QgbExlbmd0aCA9IFsuLi5tYXRjaFswXV0ubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxldCByRGVsaW0sIHJMZW5ndGgsIGRlbGltVG90YWwgPSBsTGVuZ3RoLCBtaWREZWxpbVRvdGFsID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGVuZFJlZyA9IG1hdGNoWzBdWzBdID09PSAnKicgPyB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZ1JEZWxpbUFzdCA6IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nUkRlbGltVW5kO1xuICAgICAgICAgICAgZW5kUmVnLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAvLyBDbGlwIG1hc2tlZFNyYyB0byBzYW1lIHNlY3Rpb24gb2Ygc3RyaW5nIGFzIHNyYyAobW92ZSB0byBsZXhlcj8pXG4gICAgICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoLTEgKiBzcmMubGVuZ3RoICsgbExlbmd0aCk7XG4gICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gZW5kUmVnLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJEZWxpbSA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdIHx8IG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IG1hdGNoWzZdO1xuICAgICAgICAgICAgICAgIGlmICghckRlbGltKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCBzaW5nbGUgKiBpbiBfX2FiYyphYmNfX1xuICAgICAgICAgICAgICAgIHJMZW5ndGggPSBbLi4uckRlbGltXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoWzNdIHx8IG1hdGNoWzRdKSB7IC8vIGZvdW5kIGFub3RoZXIgTGVmdCBEZWxpbVxuICAgICAgICAgICAgICAgICAgICBkZWxpbVRvdGFsICs9IHJMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaFs1XSB8fCBtYXRjaFs2XSkgeyAvLyBlaXRoZXIgTGVmdCBvciBSaWdodCBEZWxpbVxuICAgICAgICAgICAgICAgICAgICBpZiAobExlbmd0aCAlIDMgJiYgISgobExlbmd0aCArIHJMZW5ndGgpICUgMykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZERlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBDb21tb25NYXJrIEVtcGhhc2lzIFJ1bGVzIDktMTBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxpbVRvdGFsIC09IHJMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGltVG90YWwgPiAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gSGF2ZW4ndCBmb3VuZCBlbm91Z2ggY2xvc2luZyBkZWxpbWl0ZXJzXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGV4dHJhIGNoYXJhY3RlcnMuICphKioqIC0+ICphKlxuICAgICAgICAgICAgICAgIHJMZW5ndGggPSBNYXRoLm1pbihyTGVuZ3RoLCByTGVuZ3RoICsgZGVsaW1Ub3RhbCArIG1pZERlbGltVG90YWwpO1xuICAgICAgICAgICAgICAgIC8vIGNoYXIgbGVuZ3RoIGNhbiBiZSA+MSBmb3IgdW5pY29kZSBjaGFyYWN0ZXJzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RDaGFyTGVuZ3RoID0gWy4uLm1hdGNoWzBdXVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3ID0gc3JjLnNsaWNlKDAsIGxMZW5ndGggKyBtYXRjaC5pbmRleCArIGxhc3RDaGFyTGVuZ3RoICsgckxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGBlbWAgaWYgc21hbGxlc3QgZGVsaW1pdGVyIGhhcyBvZGQgY2hhciBjb3VudC4gKmEqKipcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5taW4obExlbmd0aCwgckxlbmd0aCkgJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSByYXcuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKHRleHQpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgJ3N0cm9uZycgaWYgc21hbGxlc3QgZGVsaW1pdGVyIGhhcyBldmVuIGNoYXIgY291bnQuICoqYSoqKlxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSByYXcuc2xpY2UoMiwgLTIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJvbmcnLFxuICAgICAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb2Rlc3BhbihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuY29kZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gY2FwWzJdLnJlcGxhY2UoL1xcbi9nLCAnICcpO1xuICAgICAgICAgICAgY29uc3QgaGFzTm9uU3BhY2VDaGFycyA9IC9bXiBdLy50ZXN0KHRleHQpO1xuICAgICAgICAgICAgY29uc3QgaGFzU3BhY2VDaGFyc09uQm90aEVuZHMgPSAvXiAvLnRlc3QodGV4dCkgJiYgLyAkLy50ZXN0KHRleHQpO1xuICAgICAgICAgICAgaWYgKGhhc05vblNwYWNlQ2hhcnMgJiYgaGFzU3BhY2VDaGFyc09uQm90aEVuZHMpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgPSBlc2NhcGUkMSh0ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvZGVzcGFuJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBicihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuYnIuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdicicsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuZGVsLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGVsJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMl0sXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZVRva2VucyhjYXBbMl0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdXRvbGluayhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuYXV0b2xpbmsuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBsZXQgdGV4dCwgaHJlZjtcbiAgICAgICAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgIHRleHQgPSBlc2NhcGUkMShjYXBbMV0pO1xuICAgICAgICAgICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZSQxKGNhcFsxXSk7XG4gICAgICAgICAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICAgICAgdG9rZW5zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXJsKHNyYykge1xuICAgICAgICBsZXQgY2FwO1xuICAgICAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudXJsLmV4ZWMoc3JjKSkge1xuICAgICAgICAgICAgbGV0IHRleHQsIGhyZWY7XG4gICAgICAgICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlJDEoY2FwWzBdKTtcbiAgICAgICAgICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRvIGV4dGVuZGVkIGF1dG9saW5rIHBhdGggdmFsaWRhdGlvblxuICAgICAgICAgICAgICAgIGxldCBwcmV2Q2FwWmVybztcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZDYXBaZXJvID0gY2FwWzBdO1xuICAgICAgICAgICAgICAgICAgICBjYXBbMF0gPSB0aGlzLnJ1bGVzLmlubGluZS5fYmFja3BlZGFsLmV4ZWMoY2FwWzBdKT8uWzBdID8/ICcnO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHByZXZDYXBaZXJvICE9PSBjYXBbMF0pO1xuICAgICAgICAgICAgICAgIHRleHQgPSBlc2NhcGUkMShjYXBbMF0pO1xuICAgICAgICAgICAgICAgIGlmIChjYXBbMV0gPT09ICd3d3cuJykge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gJ2h0dHA6Ly8nICsgY2FwWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9IGNhcFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICAgICAgdG9rZW5zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5saW5lVGV4dChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGV4dC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCB0ZXh0O1xuICAgICAgICAgICAgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jaykge1xuICAgICAgICAgICAgICAgIHRleHQgPSBjYXBbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlJDEoY2FwWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAqL1xuY29uc3QgbmV3bGluZSA9IC9eKD86WyBcXHRdKig/OlxcbnwkKSkrLztcbmNvbnN0IGJsb2NrQ29kZSA9IC9eKCg/OiB7NH18IHswLDN9XFx0KVteXFxuXSsoPzpcXG4oPzpbIFxcdF0qKD86XFxufCQpKSopPykrLztcbmNvbnN0IGZlbmNlcyA9IC9eIHswLDN9KGB7Myx9KD89W15gXFxuXSooPzpcXG58JCkpfH57Myx9KShbXlxcbl0qKSg/OlxcbnwkKSg/OnwoW1xcc1xcU10qPykoPzpcXG58JCkpKD86IHswLDN9XFwxW35gXSogKig/PVxcbnwkKXwkKS87XG5jb25zdCBociA9IC9eIHswLDN9KCg/Oi1bXFx0IF0qKXszLH18KD86X1sgXFx0XSopezMsfXwoPzpcXCpbIFxcdF0qKXszLH0pKD86XFxuK3wkKS87XG5jb25zdCBoZWFkaW5nID0gL14gezAsM30oI3sxLDZ9KSg/PVxcc3wkKSguKikoPzpcXG4rfCQpLztcbmNvbnN0IGJ1bGxldCA9IC8oPzpbKistXXxcXGR7MSw5fVsuKV0pLztcbmNvbnN0IGxoZWFkaW5nID0gZWRpdCgvXig/IWJ1bGwgfGJsb2NrQ29kZXxmZW5jZXN8YmxvY2txdW90ZXxoZWFkaW5nfGh0bWwpKCg/Oi58XFxuKD8hXFxzKj9cXG58YnVsbCB8YmxvY2tDb2RlfGZlbmNlc3xibG9ja3F1b3RlfGhlYWRpbmd8aHRtbCkpKz8pXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8pXG4gICAgLnJlcGxhY2UoL2J1bGwvZywgYnVsbGV0KSAvLyBsaXN0cyBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoL2Jsb2NrQ29kZS9nLCAvKD86IHs0fXwgezAsM31cXHQpLykgLy8gaW5kZW50ZWQgY29kZSBibG9ja3MgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKC9mZW5jZXMvZywgLyB7MCwzfSg/OmB7Myx9fH57Myx9KS8pIC8vIGZlbmNlZCBjb2RlIGJsb2NrcyBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoL2Jsb2NrcXVvdGUvZywgLyB7MCwzfT4vKSAvLyBibG9ja3F1b3RlIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgvaGVhZGluZy9nLCAvIHswLDN9I3sxLDZ9LykgLy8gQVRYIGhlYWRpbmcgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKC9odG1sL2csIC8gezAsM308W15cXG4+XSs+XFxuLykgLy8gYmxvY2sgaHRtbCBjYW4gaW50ZXJydXB0XG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBfcGFyYWdyYXBoID0gL14oW15cXG5dKyg/Olxcbig/IWhyfGhlYWRpbmd8bGhlYWRpbmd8YmxvY2txdW90ZXxmZW5jZXN8bGlzdHxodG1sfHRhYmxlfCArXFxuKVteXFxuXSspKikvO1xuY29uc3QgYmxvY2tUZXh0ID0gL15bXlxcbl0rLztcbmNvbnN0IF9ibG9ja0xhYmVsID0gLyg/IVxccypcXF0pKD86XFxcXC58W15cXFtcXF1cXFxcXSkrLztcbmNvbnN0IGRlZiA9IGVkaXQoL14gezAsM31cXFsobGFiZWwpXFxdOiAqKD86XFxuWyBcXHRdKik/KFtePFxcc11bXlxcc10qfDwuKj8+KSg/Oig/OiArKD86XFxuWyBcXHRdKik/fCAqXFxuWyBcXHRdKikodGl0bGUpKT8gKig/Olxcbit8JCkvKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIF9ibG9ja0xhYmVsKVxuICAgIC5yZXBsYWNlKCd0aXRsZScsIC8oPzpcIig/OlxcXFxcIj98W15cIlxcXFxdKSpcInwnW14nXFxuXSooPzpcXG5bXidcXG5dKykqXFxuPyd8XFwoW14oKV0qXFwpKS8pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBsaXN0ID0gZWRpdCgvXiggezAsM31idWxsKShbIFxcdF1bXlxcbl0rPyk/KD86XFxufCQpLylcbiAgICAucmVwbGFjZSgvYnVsbC9nLCBidWxsZXQpXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBfdGFnID0gJ2FkZHJlc3N8YXJ0aWNsZXxhc2lkZXxiYXNlfGJhc2Vmb250fGJsb2NrcXVvdGV8Ym9keXxjYXB0aW9uJ1xuICAgICsgJ3xjZW50ZXJ8Y29sfGNvbGdyb3VwfGRkfGRldGFpbHN8ZGlhbG9nfGRpcnxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbidcbiAgICArICd8ZmlndXJlfGZvb3Rlcnxmb3JtfGZyYW1lfGZyYW1lc2V0fGhbMS02XXxoZWFkfGhlYWRlcnxocnxodG1sfGlmcmFtZSdcbiAgICArICd8bGVnZW5kfGxpfGxpbmt8bWFpbnxtZW51fG1lbnVpdGVtfG1ldGF8bmF2fG5vZnJhbWVzfG9sfG9wdGdyb3VwfG9wdGlvbidcbiAgICArICd8cHxwYXJhbXxzZWFyY2h8c2VjdGlvbnxzdW1tYXJ5fHRhYmxlfHRib2R5fHRkfHRmb290fHRofHRoZWFkfHRpdGxlJ1xuICAgICsgJ3x0cnx0cmFja3x1bCc7XG5jb25zdCBfY29tbWVudCA9IC88IS0tKD86LT8+fFtcXHNcXFNdKj8oPzotLT58JCkpLztcbmNvbnN0IGh0bWwgPSBlZGl0KCdeIHswLDN9KD86JyAvLyBvcHRpb25hbCBpbmRlbnRhdGlvblxuICAgICsgJzwoc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSlbXFxcXHM+XVtcXFxcc1xcXFxTXSo/KD86PC9cXFxcMT5bXlxcXFxuXSpcXFxcbit8JCknIC8vICgxKVxuICAgICsgJ3xjb21tZW50W15cXFxcbl0qKFxcXFxuK3wkKScgLy8gKDIpXG4gICAgKyAnfDxcXFxcP1tcXFxcc1xcXFxTXSo/KD86XFxcXD8+XFxcXG4qfCQpJyAvLyAoMylcbiAgICArICd8PCFbQS1aXVtcXFxcc1xcXFxTXSo/KD86PlxcXFxuKnwkKScgLy8gKDQpXG4gICAgKyAnfDwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj8oPzpcXFxcXVxcXFxdPlxcXFxuKnwkKScgLy8gKDUpXG4gICAgKyAnfDwvPyh0YWcpKD86ICt8XFxcXG58Lz8+KVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG5bIFxcdF0qKStcXFxcbnwkKScgLy8gKDYpXG4gICAgKyAnfDwoPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKShbYS16XVtcXFxcdy1dKikoPzphdHRyaWJ1dGUpKj8gKi8/Pig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG5bIFxcdF0qKStcXFxcbnwkKScgLy8gKDcpIG9wZW4gdGFnXG4gICAgKyAnfDwvKD8hc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSlbYS16XVtcXFxcdy1dKlxcXFxzKj4oPz1bIFxcXFx0XSooPzpcXFxcbnwkKSlbXFxcXHNcXFxcU10qPyg/Oig/OlxcXFxuWyBcXHRdKikrXFxcXG58JCknIC8vICg3KSBjbG9zaW5nIHRhZ1xuICAgICsgJyknLCAnaScpXG4gICAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBfY29tbWVudClcbiAgICAucmVwbGFjZSgndGFnJywgX3RhZylcbiAgICAucmVwbGFjZSgnYXR0cmlidXRlJywgLyArW2EtekEtWjpfXVtcXHcuOi1dKig/OiAqPSAqXCJbXlwiXFxuXSpcInwgKj0gKidbXidcXG5dKid8ICo9ICpbXlxcc1wiJz08PmBdKyk/LylcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IHBhcmFncmFwaCA9IGVkaXQoX3BhcmFncmFwaClcbiAgICAucmVwbGFjZSgnaHInLCBocilcbiAgICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0oPzpcXFxcc3wkKScpXG4gICAgLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleHQgaGVhZGluZ3MgZG9uJ3QgaW50ZXJydXB0IGNvbW1vbm1hcmsgcGFyYWdyYXBoc1xuICAgIC5yZXBsYWNlKCd8dGFibGUnLCAnJylcbiAgICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgICAucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpXG4gICAgLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJylcbiAgICAucmVwbGFjZSgndGFnJywgX3RhZykgLy8gcGFycyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IGJsb2NrcXVvdGUgPSBlZGl0KC9eKCB7MCwzfT4gPyhwYXJhZ3JhcGh8W15cXG5dKikoPzpcXG58JCkpKy8pXG4gICAgLnJlcGxhY2UoJ3BhcmFncmFwaCcsIHBhcmFncmFwaClcbiAgICAuZ2V0UmVnZXgoKTtcbi8qKlxuICogTm9ybWFsIEJsb2NrIEdyYW1tYXJcbiAqL1xuY29uc3QgYmxvY2tOb3JtYWwgPSB7XG4gICAgYmxvY2txdW90ZSxcbiAgICBjb2RlOiBibG9ja0NvZGUsXG4gICAgZGVmLFxuICAgIGZlbmNlcyxcbiAgICBoZWFkaW5nLFxuICAgIGhyLFxuICAgIGh0bWwsXG4gICAgbGhlYWRpbmcsXG4gICAgbGlzdCxcbiAgICBuZXdsaW5lLFxuICAgIHBhcmFncmFwaCxcbiAgICB0YWJsZTogbm9vcFRlc3QsXG4gICAgdGV4dDogYmxvY2tUZXh0LFxufTtcbi8qKlxuICogR0ZNIEJsb2NrIEdyYW1tYXJcbiAqL1xuY29uc3QgZ2ZtVGFibGUgPSBlZGl0KCdeICooW15cXFxcbiBdLiopXFxcXG4nIC8vIEhlYWRlclxuICAgICsgJyB7MCwzfSgoPzpcXFxcfCAqKT86Py0rOj8gKig/OlxcXFx8ICo6Py0rOj8gKikqKD86XFxcXHwgKik/KScgLy8gQWxpZ25cbiAgICArICcoPzpcXFxcbigoPzooPyEgKlxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScpIC8vIENlbGxzXG4gICAgLnJlcGxhY2UoJ2hyJywgaHIpXG4gICAgLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9KD86XFxcXHN8JCknKVxuICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgIC5yZXBsYWNlKCdjb2RlJywgJyg/OiB7NH18IHswLDN9XFx0KVteXFxcXG5dJylcbiAgICAucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpXG4gICAgLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJylcbiAgICAucmVwbGFjZSgndGFnJywgX3RhZykgLy8gdGFibGVzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgYmxvY2tHZm0gPSB7XG4gICAgLi4uYmxvY2tOb3JtYWwsXG4gICAgdGFibGU6IGdmbVRhYmxlLFxuICAgIHBhcmFncmFwaDogZWRpdChfcGFyYWdyYXBoKVxuICAgICAgICAucmVwbGFjZSgnaHInLCBocilcbiAgICAgICAgLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9KD86XFxcXHN8JCknKVxuICAgICAgICAucmVwbGFjZSgnfGxoZWFkaW5nJywgJycpIC8vIHNldGV4dCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gICAgICAgIC5yZXBsYWNlKCd0YWJsZScsIGdmbVRhYmxlKSAvLyBpbnRlcnJ1cHQgcGFyYWdyYXBocyB3aXRoIHRhYmxlXG4gICAgICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgICAgICAucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpXG4gICAgICAgIC5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4gICAgICAgIC5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSknKVxuICAgICAgICAucmVwbGFjZSgndGFnJywgX3RhZykgLy8gcGFycyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgICAgICAgLmdldFJlZ2V4KCksXG59O1xuLyoqXG4gKiBQZWRhbnRpYyBncmFtbWFyIChvcmlnaW5hbCBKb2huIEdydWJlcidzIGxvb3NlIG1hcmtkb3duIHNwZWNpZmljYXRpb24pXG4gKi9cbmNvbnN0IGJsb2NrUGVkYW50aWMgPSB7XG4gICAgLi4uYmxvY2tOb3JtYWwsXG4gICAgaHRtbDogZWRpdCgnXiAqKD86Y29tbWVudCAqKD86XFxcXG58XFxcXHMqJCknXG4gICAgICAgICsgJ3w8KHRhZylbXFxcXHNcXFxcU10rPzwvXFxcXDE+ICooPzpcXFxcbnsyLH18XFxcXHMqJCknIC8vIGNsb3NlZCB0YWdcbiAgICAgICAgKyAnfDx0YWcoPzpcIlteXCJdKlwifFxcJ1teXFwnXSpcXCd8XFxcXHNbXlxcJ1wiLz5cXFxcc10qKSo/Lz8+ICooPzpcXFxcbnsyLH18XFxcXHMqJCkpJylcbiAgICAgICAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBfY29tbWVudClcbiAgICAgICAgLnJlcGxhY2UoL3RhZy9nLCAnKD8hKD86J1xuICAgICAgICArICdhfGVtfHN0cm9uZ3xzbWFsbHxzfGNpdGV8cXxkZm58YWJicnxkYXRhfHRpbWV8Y29kZXx2YXJ8c2FtcHxrYmR8c3ViJ1xuICAgICAgICArICd8c3VwfGl8Ynx1fG1hcmt8cnVieXxydHxycHxiZGl8YmRvfHNwYW58YnJ8d2JyfGluc3xkZWx8aW1nKSdcbiAgICAgICAgKyAnXFxcXGIpXFxcXHcrKD8hOnxbXlxcXFx3XFxcXHNAXSpAKVxcXFxiJylcbiAgICAgICAgLmdldFJlZ2V4KCksXG4gICAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogKyhbXCIoXVteXFxuXStbXCIpXSkpPyAqKD86XFxuK3wkKS8sXG4gICAgaGVhZGluZzogL14oI3sxLDZ9KSguKikoPzpcXG4rfCQpLyxcbiAgICBmZW5jZXM6IG5vb3BUZXN0LCAvLyBmZW5jZXMgbm90IHN1cHBvcnRlZFxuICAgIGxoZWFkaW5nOiAvXiguKz8pXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8sXG4gICAgcGFyYWdyYXBoOiBlZGl0KF9wYXJhZ3JhcGgpXG4gICAgICAgIC5yZXBsYWNlKCdocicsIGhyKVxuICAgICAgICAucmVwbGFjZSgnaGVhZGluZycsICcgKiN7MSw2fSAqW15cXG5dJylcbiAgICAgICAgLnJlcGxhY2UoJ2xoZWFkaW5nJywgbGhlYWRpbmcpXG4gICAgICAgIC5yZXBsYWNlKCd8dGFibGUnLCAnJylcbiAgICAgICAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gICAgICAgIC5yZXBsYWNlKCd8ZmVuY2VzJywgJycpXG4gICAgICAgIC5yZXBsYWNlKCd8bGlzdCcsICcnKVxuICAgICAgICAucmVwbGFjZSgnfGh0bWwnLCAnJylcbiAgICAgICAgLnJlcGxhY2UoJ3x0YWcnLCAnJylcbiAgICAgICAgLmdldFJlZ2V4KCksXG59O1xuLyoqXG4gKiBJbmxpbmUtTGV2ZWwgR3JhbW1hclxuICovXG5jb25zdCBlc2NhcGUgPSAvXlxcXFwoWyFcIiMkJSYnKCkqKyxcXC0uLzo7PD0+P0BcXFtcXF1cXFxcXl9ge3x9fl0pLztcbmNvbnN0IGlubGluZUNvZGUgPSAvXihgKykoW15gXXxbXmBdW1xcc1xcU10qP1teYF0pXFwxKD8hYCkvO1xuY29uc3QgYnIgPSAvXiggezIsfXxcXFxcKVxcbig/IVxccyokKS87XG5jb25zdCBpbmxpbmVUZXh0ID0gL14oYCt8W15gXSkoPzooPz0gezIsfVxcbil8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKl9dfFxcYl98JCl8W14gXSg/PSB7Mix9XFxuKSkpLztcbi8vIGxpc3Qgb2YgdW5pY29kZSBwdW5jdHVhdGlvbiBtYXJrcywgcGx1cyBhbnkgbWlzc2luZyBjaGFyYWN0ZXJzIGZyb20gQ29tbW9uTWFyayBzcGVjXG5jb25zdCBfcHVuY3R1YXRpb24gPSAnXFxcXHB7UH1cXFxccHtTfSc7XG5jb25zdCBwdW5jdHVhdGlvbiA9IGVkaXQoL14oKD8hWypfXSlbXFxzcHVuY3R1YXRpb25dKS8sICd1JylcbiAgICAucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpO1xuLy8gc2VxdWVuY2VzIGVtIHNob3VsZCBza2lwIG92ZXIgW3RpdGxlXShsaW5rKSwgYGNvZGVgLCA8aHRtbD5cbmNvbnN0IGJsb2NrU2tpcCA9IC9cXFtbXltcXF1dKj9cXF1cXChbXlxcKFxcKV0qP1xcKXxgW15gXSo/YHw8W148Pl0qPz4vZztcbmNvbnN0IGVtU3Ryb25nTERlbGltID0gZWRpdCgvXig/OlxcKisoPzooKD8hXFwqKVtwdW5jdF0pfFteXFxzKl0pKXxeXysoPzooKD8hXylbcHVuY3RdKXwoW15cXHNfXSkpLywgJ3UnKVxuICAgIC5yZXBsYWNlKC9wdW5jdC9nLCBfcHVuY3R1YXRpb24pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBlbVN0cm9uZ1JEZWxpbUFzdCA9IGVkaXQoJ15bXl8qXSo/X19bXl8qXSo/XFxcXCpbXl8qXSo/KD89X18pJyAvLyBTa2lwIG9ycGhhbiBpbnNpZGUgc3Ryb25nXG4gICAgKyAnfFteKl0rKD89W14qXSknIC8vIENvbnN1bWUgdG8gZGVsaW1cbiAgICArICd8KD8hXFxcXCopW3B1bmN0XShcXFxcKispKD89W1xcXFxzXXwkKScgLy8gKDEpICMqKiogY2FuIG9ubHkgYmUgYSBSaWdodCBEZWxpbWl0ZXJcbiAgICArICd8W15wdW5jdFxcXFxzXShcXFxcKispKD8hXFxcXCopKD89W3B1bmN0XFxcXHNdfCQpJyAvLyAoMikgYSoqKiMsIGEqKiogY2FuIG9ubHkgYmUgYSBSaWdodCBEZWxpbWl0ZXJcbiAgICArICd8KD8hXFxcXCopW3B1bmN0XFxcXHNdKFxcXFwqKykoPz1bXnB1bmN0XFxcXHNdKScgLy8gKDMpICMqKiphLCAqKiphIGNhbiBvbmx5IGJlIExlZnQgRGVsaW1pdGVyXG4gICAgKyAnfFtcXFxcc10oXFxcXCorKSg/IVxcXFwqKSg/PVtwdW5jdF0pJyAvLyAoNCkgKioqIyBjYW4gb25seSBiZSBMZWZ0IERlbGltaXRlclxuICAgICsgJ3woPyFcXFxcKilbcHVuY3RdKFxcXFwqKykoPyFcXFxcKikoPz1bcHVuY3RdKScgLy8gKDUpICMqKiojIGNhbiBiZSBlaXRoZXIgTGVmdCBvciBSaWdodCBEZWxpbWl0ZXJcbiAgICArICd8W15wdW5jdFxcXFxzXShcXFxcKispKD89W15wdW5jdFxcXFxzXSknLCAnZ3UnKSAvLyAoNikgYSoqKmEgY2FuIGJlIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltaXRlclxuICAgIC5yZXBsYWNlKC9wdW5jdC9nLCBfcHVuY3R1YXRpb24pXG4gICAgLmdldFJlZ2V4KCk7XG4vLyAoNikgTm90IGFsbG93ZWQgZm9yIF9cbmNvbnN0IGVtU3Ryb25nUkRlbGltVW5kID0gZWRpdCgnXlteXypdKj9cXFxcKlxcXFwqW15fKl0qP19bXl8qXSo/KD89XFxcXCpcXFxcKiknIC8vIFNraXAgb3JwaGFuIGluc2lkZSBzdHJvbmdcbiAgICArICd8W15fXSsoPz1bXl9dKScgLy8gQ29uc3VtZSB0byBkZWxpbVxuICAgICsgJ3woPyFfKVtwdW5jdF0oXyspKD89W1xcXFxzXXwkKScgLy8gKDEpICNfX18gY2FuIG9ubHkgYmUgYSBSaWdodCBEZWxpbWl0ZXJcbiAgICArICd8W15wdW5jdFxcXFxzXShfKykoPyFfKSg/PVtwdW5jdFxcXFxzXXwkKScgLy8gKDIpIGFfX18jLCBhX19fIGNhbiBvbmx5IGJlIGEgUmlnaHQgRGVsaW1pdGVyXG4gICAgKyAnfCg/IV8pW3B1bmN0XFxcXHNdKF8rKSg/PVtecHVuY3RcXFxcc10pJyAvLyAoMykgI19fX2EsIF9fX2EgY2FuIG9ubHkgYmUgTGVmdCBEZWxpbWl0ZXJcbiAgICArICd8W1xcXFxzXShfKykoPyFfKSg/PVtwdW5jdF0pJyAvLyAoNCkgX19fIyBjYW4gb25seSBiZSBMZWZ0IERlbGltaXRlclxuICAgICsgJ3woPyFfKVtwdW5jdF0oXyspKD8hXykoPz1bcHVuY3RdKScsICdndScpIC8vICg1KSAjX19fIyBjYW4gYmUgZWl0aGVyIExlZnQgb3IgUmlnaHQgRGVsaW1pdGVyXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIF9wdW5jdHVhdGlvbilcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IGFueVB1bmN0dWF0aW9uID0gZWRpdCgvXFxcXChbcHVuY3RdKS8sICdndScpXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIF9wdW5jdHVhdGlvbilcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IGF1dG9saW5rID0gZWRpdCgvXjwoc2NoZW1lOlteXFxzXFx4MDAtXFx4MWY8Pl0qfGVtYWlsKT4vKVxuICAgIC5yZXBsYWNlKCdzY2hlbWUnLCAvW2EtekEtWl1bYS16QS1aMC05Ky4tXXsxLDMxfS8pXG4gICAgLnJlcGxhY2UoJ2VtYWlsJywgL1thLXpBLVowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rKEApW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSsoPyFbLV9dKS8pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBfaW5saW5lQ29tbWVudCA9IGVkaXQoX2NvbW1lbnQpLnJlcGxhY2UoJyg/Oi0tPnwkKScsICctLT4nKS5nZXRSZWdleCgpO1xuY29uc3QgdGFnID0gZWRpdCgnXmNvbW1lbnQnXG4gICAgKyAnfF48L1thLXpBLVpdW1xcXFx3Oi1dKlxcXFxzKj4nIC8vIHNlbGYtY2xvc2luZyB0YWdcbiAgICArICd8XjxbYS16QS1aXVtcXFxcdy1dKig/OmF0dHJpYnV0ZSkqP1xcXFxzKi8/PicgLy8gb3BlbiB0YWdcbiAgICArICd8XjxcXFxcP1tcXFxcc1xcXFxTXSo/XFxcXD8+JyAvLyBwcm9jZXNzaW5nIGluc3RydWN0aW9uLCBlLmcuIDw/cGhwID8+XG4gICAgKyAnfF48IVthLXpBLVpdK1xcXFxzW1xcXFxzXFxcXFNdKj8+JyAvLyBkZWNsYXJhdGlvbiwgZS5nLiA8IURPQ1RZUEUgaHRtbD5cbiAgICArICd8XjwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj9cXFxcXVxcXFxdPicpIC8vIENEQVRBIHNlY3Rpb25cbiAgICAucmVwbGFjZSgnY29tbWVudCcsIF9pbmxpbmVDb21tZW50KVxuICAgIC5yZXBsYWNlKCdhdHRyaWJ1dGUnLCAvXFxzK1thLXpBLVo6X11bXFx3LjotXSooPzpcXHMqPVxccypcIlteXCJdKlwifFxccyo9XFxzKidbXiddKid8XFxzKj1cXHMqW15cXHNcIic9PD5gXSspPy8pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBfaW5saW5lTGFiZWwgPSAvKD86XFxbKD86XFxcXC58W15cXFtcXF1cXFxcXSkqXFxdfFxcXFwufGBbXmBdKmB8W15cXFtcXF1cXFxcYF0pKj8vO1xuY29uc3QgbGluayA9IGVkaXQoL14hP1xcWyhsYWJlbClcXF1cXChcXHMqKGhyZWYpKD86XFxzKyh0aXRsZSkpP1xccypcXCkvKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIF9pbmxpbmVMYWJlbClcbiAgICAucmVwbGFjZSgnaHJlZicsIC88KD86XFxcXC58W15cXG48PlxcXFxdKSs+fFteXFxzXFx4MDAtXFx4MWZdKi8pXG4gICAgLnJlcGxhY2UoJ3RpdGxlJywgL1wiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCcoPzpcXFxcJz98W14nXFxcXF0pKid8XFwoKD86XFxcXFxcKT98W14pXFxcXF0pKlxcKS8pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCByZWZsaW5rID0gZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcWyhyZWYpXFxdLylcbiAgICAucmVwbGFjZSgnbGFiZWwnLCBfaW5saW5lTGFiZWwpXG4gICAgLnJlcGxhY2UoJ3JlZicsIF9ibG9ja0xhYmVsKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3Qgbm9saW5rID0gZWRpdCgvXiE/XFxbKHJlZilcXF0oPzpcXFtcXF0pPy8pXG4gICAgLnJlcGxhY2UoJ3JlZicsIF9ibG9ja0xhYmVsKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgcmVmbGlua1NlYXJjaCA9IGVkaXQoJ3JlZmxpbmt8bm9saW5rKD8hXFxcXCgpJywgJ2cnKVxuICAgIC5yZXBsYWNlKCdyZWZsaW5rJywgcmVmbGluaylcbiAgICAucmVwbGFjZSgnbm9saW5rJywgbm9saW5rKVxuICAgIC5nZXRSZWdleCgpO1xuLyoqXG4gKiBOb3JtYWwgSW5saW5lIEdyYW1tYXJcbiAqL1xuY29uc3QgaW5saW5lTm9ybWFsID0ge1xuICAgIF9iYWNrcGVkYWw6IG5vb3BUZXN0LCAvLyBvbmx5IHVzZWQgZm9yIEdGTSB1cmxcbiAgICBhbnlQdW5jdHVhdGlvbixcbiAgICBhdXRvbGluayxcbiAgICBibG9ja1NraXAsXG4gICAgYnIsXG4gICAgY29kZTogaW5saW5lQ29kZSxcbiAgICBkZWw6IG5vb3BUZXN0LFxuICAgIGVtU3Ryb25nTERlbGltLFxuICAgIGVtU3Ryb25nUkRlbGltQXN0LFxuICAgIGVtU3Ryb25nUkRlbGltVW5kLFxuICAgIGVzY2FwZSxcbiAgICBsaW5rLFxuICAgIG5vbGluayxcbiAgICBwdW5jdHVhdGlvbixcbiAgICByZWZsaW5rLFxuICAgIHJlZmxpbmtTZWFyY2gsXG4gICAgdGFnLFxuICAgIHRleHQ6IGlubGluZVRleHQsXG4gICAgdXJsOiBub29wVGVzdCxcbn07XG4vKipcbiAqIFBlZGFudGljIElubGluZSBHcmFtbWFyXG4gKi9cbmNvbnN0IGlubGluZVBlZGFudGljID0ge1xuICAgIC4uLmlubGluZU5vcm1hbCxcbiAgICBsaW5rOiBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFwoKC4qPylcXCkvKVxuICAgICAgICAucmVwbGFjZSgnbGFiZWwnLCBfaW5saW5lTGFiZWwpXG4gICAgICAgIC5nZXRSZWdleCgpLFxuICAgIHJlZmxpbms6IGVkaXQoL14hP1xcWyhsYWJlbClcXF1cXHMqXFxbKFteXFxdXSopXFxdLylcbiAgICAgICAgLnJlcGxhY2UoJ2xhYmVsJywgX2lubGluZUxhYmVsKVxuICAgICAgICAuZ2V0UmVnZXgoKSxcbn07XG4vKipcbiAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICovXG5jb25zdCBpbmxpbmVHZm0gPSB7XG4gICAgLi4uaW5saW5lTm9ybWFsLFxuICAgIGVzY2FwZTogZWRpdChlc2NhcGUpLnJlcGxhY2UoJ10pJywgJ358XSknKS5nZXRSZWdleCgpLFxuICAgIHVybDogZWRpdCgvXigoPzpmdHB8aHR0cHM/KTpcXC9cXC98d3d3XFwuKSg/OlthLXpBLVowLTlcXC1dK1xcLj8pK1teXFxzPF0qfF5lbWFpbC8sICdpJylcbiAgICAgICAgLnJlcGxhY2UoJ2VtYWlsJywgL1tBLVphLXowLTkuXystXSsoQClbYS16QS1aMC05LV9dKyg/OlxcLlthLXpBLVowLTktX10qW2EtekEtWjAtOV0pKyg/IVstX10pLylcbiAgICAgICAgLmdldFJlZ2V4KCksXG4gICAgX2JhY2twZWRhbDogLyg/OltePyEuLDo7Kl8nXCJ+KCkmXSt8XFwoW14pXSpcXCl8Jig/IVthLXpBLVowLTldKzskKXxbPyEuLDo7Kl8nXCJ+KV0rKD8hJCkpKy8sXG4gICAgZGVsOiAvXih+fj8pKD89W15cXHN+XSkoW1xcc1xcU10qP1teXFxzfl0pXFwxKD89W15+XXwkKS8sXG4gICAgdGV4dDogL14oW2B+XSt8W15gfl0pKD86KD89IHsyLH1cXG4pfCg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCl8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKn5fXXxcXGJffGh0dHBzPzpcXC9cXC98ZnRwOlxcL1xcL3x3d3dcXC58JCl8W14gXSg/PSB7Mix9XFxuKXxbXmEtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXSg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCkpKS8sXG59O1xuLyoqXG4gKiBHRk0gKyBMaW5lIEJyZWFrcyBJbmxpbmUgR3JhbW1hclxuICovXG5jb25zdCBpbmxpbmVCcmVha3MgPSB7XG4gICAgLi4uaW5saW5lR2ZtLFxuICAgIGJyOiBlZGl0KGJyKS5yZXBsYWNlKCd7Mix9JywgJyonKS5nZXRSZWdleCgpLFxuICAgIHRleHQ6IGVkaXQoaW5saW5lR2ZtLnRleHQpXG4gICAgICAgIC5yZXBsYWNlKCdcXFxcYl8nLCAnXFxcXGJffCB7Mix9XFxcXG4nKVxuICAgICAgICAucmVwbGFjZSgvXFx7MixcXH0vZywgJyonKVxuICAgICAgICAuZ2V0UmVnZXgoKSxcbn07XG4vKipcbiAqIGV4cG9ydHNcbiAqL1xuY29uc3QgYmxvY2sgPSB7XG4gICAgbm9ybWFsOiBibG9ja05vcm1hbCxcbiAgICBnZm06IGJsb2NrR2ZtLFxuICAgIHBlZGFudGljOiBibG9ja1BlZGFudGljLFxufTtcbmNvbnN0IGlubGluZSA9IHtcbiAgICBub3JtYWw6IGlubGluZU5vcm1hbCxcbiAgICBnZm06IGlubGluZUdmbSxcbiAgICBicmVha3M6IGlubGluZUJyZWFrcyxcbiAgICBwZWRhbnRpYzogaW5saW5lUGVkYW50aWMsXG59O1xuXG4vKipcbiAqIEJsb2NrIExleGVyXG4gKi9cbmNsYXNzIF9MZXhlciB7XG4gICAgdG9rZW5zO1xuICAgIG9wdGlvbnM7XG4gICAgc3RhdGU7XG4gICAgdG9rZW5pemVyO1xuICAgIGlubGluZVF1ZXVlO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVG9rZW5MaXN0IGNhbm5vdCBiZSBjcmVhdGVkIGluIG9uZSBnb1xuICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLnRva2Vucy5saW5rcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgICAgICB0aGlzLm9wdGlvbnMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplciB8fCBuZXcgX1Rva2VuaXplcigpO1xuICAgICAgICB0aGlzLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXI7XG4gICAgICAgIHRoaXMudG9rZW5pemVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHRoaXMudG9rZW5pemVyLmxleGVyID0gdGhpcztcbiAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaW5MaW5rOiBmYWxzZSxcbiAgICAgICAgICAgIGluUmF3QmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgdG9wOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBydWxlcyA9IHtcbiAgICAgICAgICAgIGJsb2NrOiBibG9jay5ub3JtYWwsXG4gICAgICAgICAgICBpbmxpbmU6IGlubGluZS5ub3JtYWwsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2sucGVkYW50aWM7XG4gICAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUucGVkYW50aWM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgICAgcnVsZXMuYmxvY2sgPSBibG9jay5nZm07XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5icmVha3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUuZ2ZtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9rZW5pemVyLnJ1bGVzID0gcnVsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9zZSBSdWxlc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgcnVsZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBibG9jayxcbiAgICAgICAgICAgIGlubGluZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIExleCBNZXRob2RcbiAgICAgKi9cbiAgICBzdGF0aWMgbGV4KHNyYywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBsZXhlciA9IG5ldyBfTGV4ZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBsZXhlci5sZXgoc3JjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIExleCBJbmxpbmUgTWV0aG9kXG4gICAgICovXG4gICAgc3RhdGljIGxleElubGluZShzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbGV4ZXIgPSBuZXcgX0xleGVyKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbGV4ZXIuaW5saW5lVG9rZW5zKHNyYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXByb2Nlc3NpbmdcbiAgICAgKi9cbiAgICBsZXgoc3JjKSB7XG4gICAgICAgIHNyYyA9IHNyY1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpO1xuICAgICAgICB0aGlzLmJsb2NrVG9rZW5zKHNyYywgdGhpcy50b2tlbnMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5saW5lUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmlubGluZVF1ZXVlW2ldO1xuICAgICAgICAgICAgdGhpcy5pbmxpbmVUb2tlbnMobmV4dC5zcmMsIG5leHQudG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlubGluZVF1ZXVlID0gW107XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VucztcbiAgICB9XG4gICAgYmxvY2tUb2tlbnMoc3JjLCB0b2tlbnMgPSBbXSwgbGFzdFBhcmFncmFwaENsaXBwZWQgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXFx0L2csICcgICAgJykucmVwbGFjZSgvXiArJC9nbSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgbGV0IGxhc3RUb2tlbjtcbiAgICAgICAgbGV0IGN1dFNyYztcbiAgICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuYmxvY2tcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5ibG9jay5zb21lKChleHRUb2tlbml6ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID0gZXh0VG9rZW5pemVyLmNhbGwoeyBsZXhlcjogdGhpcyB9LCBzcmMsIHRva2VucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5ld2xpbmVcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnNwYWNlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5yYXcubGVuZ3RoID09PSAxICYmIHRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYSBzaW5nbGUgXFxuIGFzIGEgc3BhY2VyLCBpdCdzIHRlcm1pbmF0aW5nIHRoZSBsYXN0IGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIG1vdmUgaXQgdGhlcmUgc28gdGhhdCB3ZSBkb24ndCBnZXQgdW5uZWNlc3NhcnkgcGFyYWdyYXBoIHRhZ3NcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS5yYXcgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29kZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIC8vIEFuIGluZGVudGVkIGNvZGUgYmxvY2sgY2Fubm90IGludGVycnVwdCBhIHBhcmFncmFwaC5cbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuICYmIChsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcgfHwgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmVuY2VzXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5mZW5jZXMoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGVhZGluZ1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaGVhZGluZyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoclxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaHIoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYmxvY2txdW90ZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYmxvY2txdW90ZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsaXN0XG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saXN0KHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGh0bWxcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmh0bWwoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVmXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5kZWYoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuICYmIChsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcgfHwgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMudG9rZW5zLmxpbmtzW3Rva2VuLnRhZ10pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IHRva2VuLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdG9rZW4udGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGFibGUgKGdmbSlcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhYmxlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxoZWFkaW5nXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saGVhZGluZyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0b3AtbGV2ZWwgcGFyYWdyYXBoXG4gICAgICAgICAgICAvLyBwcmV2ZW50IHBhcmFncmFwaCBjb25zdW1pbmcgZXh0ZW5zaW9ucyBieSBjbGlwcGluZyAnc3JjJyB0byBleHRlbnNpb24gc3RhcnRcbiAgICAgICAgICAgIGN1dFNyYyA9IHNyYztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wU3JjID0gc3JjLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wU3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRCbG9jay5mb3JFYWNoKChnZXRTdGFydEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdGFydCA9IGdldFN0YXJ0SW5kZXguY2FsbCh7IGxleGVyOiB0aGlzIH0sIHRlbXBTcmMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1pbihzdGFydEluZGV4LCB0ZW1wU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCBJbmZpbml0eSAmJiBzdGFydEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3V0U3JjID0gc3JjLnN1YnN0cmluZygwLCBzdGFydEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUudG9wICYmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnBhcmFncmFwaChjdXRTcmMpKSkge1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQYXJhZ3JhcGhDbGlwcGVkICYmIGxhc3RUb2tlbj8udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RQYXJhZ3JhcGhDbGlwcGVkID0gKGN1dFNyYy5sZW5ndGggIT09IHNyYy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXh0XG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50ZXh0KHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLnRvcCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIGlubGluZShzcmMsIHRva2VucyA9IFtdKSB7XG4gICAgICAgIHRoaXMuaW5saW5lUXVldWUucHVzaCh7IHNyYywgdG9rZW5zIH0pO1xuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXhpbmcvQ29tcGlsaW5nXG4gICAgICovXG4gICAgaW5saW5lVG9rZW5zKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICAgICAgbGV0IHRva2VuLCBsYXN0VG9rZW4sIGN1dFNyYztcbiAgICAgICAgLy8gU3RyaW5nIHdpdGggbGlua3MgbWFza2VkIHRvIGF2b2lkIGludGVyZmVyZW5jZSB3aXRoIGVtIGFuZCBzdHJvbmdcbiAgICAgICAgbGV0IG1hc2tlZFNyYyA9IHNyYztcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICBsZXQga2VlcFByZXZDaGFyLCBwcmV2Q2hhcjtcbiAgICAgICAgLy8gTWFzayBvdXQgcmVmbGlua3NcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zLmxpbmtzKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IE9iamVjdC5rZXlzKHRoaXMudG9rZW5zLmxpbmtzKTtcbiAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlua3MuaW5jbHVkZXMobWF0Y2hbMF0uc2xpY2UobWF0Y2hbMF0ubGFzdEluZGV4T2YoJ1snKSArIDEsIC0xKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyAnYScucmVwZWF0KG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmxhc3RJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFzayBvdXQgb3RoZXIgYmxvY2tzXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdbJyArICdhJy5yZXBlYXQobWF0Y2hbMF0ubGVuZ3RoIC0gMikgKyAnXScgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmJsb2NrU2tpcC5sYXN0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hc2sgb3V0IGVzY2FwZWQgY2hhcmFjdGVyc1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmFueVB1bmN0dWF0aW9uLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICcrKycgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmFueVB1bmN0dWF0aW9uLmxhc3RJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICAgICAgaWYgKCFrZWVwUHJldkNoYXIpIHtcbiAgICAgICAgICAgICAgICBwcmV2Q2hhciA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2VlcFByZXZDaGFyID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBleHRlbnNpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5pbmxpbmVcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5pbmxpbmUuc29tZSgoZXh0VG9rZW5pemVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9IGV4dFRva2VuaXplci5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2NhcGVcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmVzY2FwZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0YWdcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhZyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGlua1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGluayhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWZsaW5rLCBub2xpbmtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnJlZmxpbmsoc3JjLCB0aGlzLnRva2Vucy5saW5rcykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbSAmIHN0cm9uZ1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29kZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZXNwYW4oc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYnJcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJyKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlbCAoZ2ZtKVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVsKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGF1dG9saW5rXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5hdXRvbGluayhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1cmwgKGdmbSlcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5pbkxpbmsgJiYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudXJsKHNyYykpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXh0XG4gICAgICAgICAgICAvLyBwcmV2ZW50IGlubGluZVRleHQgY29uc3VtaW5nIGV4dGVuc2lvbnMgYnkgY2xpcHBpbmcgJ3NyYycgdG8gZXh0ZW5zaW9uIHN0YXJ0XG4gICAgICAgICAgICBjdXRTcmMgPSBzcmM7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRJbmxpbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBTcmMgPSBzcmMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXBTdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydElubGluZS5mb3JFYWNoKChnZXRTdGFydEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdGFydCA9IGdldFN0YXJ0SW5kZXguY2FsbCh7IGxleGVyOiB0aGlzIH0sIHRlbXBTcmMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1pbihzdGFydEluZGV4LCB0ZW1wU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCBJbmZpbml0eSAmJiBzdGFydEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3V0U3JjID0gc3JjLnN1YnN0cmluZygwLCBzdGFydEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaW5saW5lVGV4dChjdXRTcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4ucmF3LnNsaWNlKC0xKSAhPT0gJ18nKSB7IC8vIFRyYWNrIHByZXZDaGFyIGJlZm9yZSBzdHJpbmcgb2YgX19fXyBzdGFydGVkXG4gICAgICAgICAgICAgICAgICAgIHByZXZDaGFyID0gdG9rZW4ucmF3LnNsaWNlKC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2VlcFByZXZDaGFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG59XG5cbi8qKlxuICogUmVuZGVyZXJcbiAqL1xuY2xhc3MgX1JlbmRlcmVyIHtcbiAgICBvcHRpb25zO1xuICAgIHBhcnNlcjsgLy8gc2V0IGJ5IHRoZSBwYXJzZXJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgIH1cbiAgICBzcGFjZSh0b2tlbikge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNvZGUoeyB0ZXh0LCBsYW5nLCBlc2NhcGVkIH0pIHtcbiAgICAgICAgY29uc3QgbGFuZ1N0cmluZyA9IChsYW5nIHx8ICcnKS5tYXRjaCgvXlxcUyovKT8uWzBdO1xuICAgICAgICBjb25zdCBjb2RlID0gdGV4dC5yZXBsYWNlKC9cXG4kLywgJycpICsgJ1xcbic7XG4gICAgICAgIGlmICghbGFuZ1N0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuICc8cHJlPjxjb2RlPidcbiAgICAgICAgICAgICAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZSQxKGNvZGUsIHRydWUpKVxuICAgICAgICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLSdcbiAgICAgICAgICAgICsgZXNjYXBlJDEobGFuZ1N0cmluZylcbiAgICAgICAgICAgICsgJ1wiPidcbiAgICAgICAgICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlJDEoY29kZSwgdHJ1ZSkpXG4gICAgICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgICB9XG4gICAgYmxvY2txdW90ZSh7IHRva2VucyB9KSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLnBhcnNlci5wYXJzZSh0b2tlbnMpO1xuICAgICAgICByZXR1cm4gYDxibG9ja3F1b3RlPlxcbiR7Ym9keX08L2Jsb2NrcXVvdGU+XFxuYDtcbiAgICB9XG4gICAgaHRtbCh7IHRleHQgfSkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgaGVhZGluZyh7IHRva2VucywgZGVwdGggfSkge1xuICAgICAgICByZXR1cm4gYDxoJHtkZXB0aH0+JHt0aGlzLnBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMpfTwvaCR7ZGVwdGh9PlxcbmA7XG4gICAgfVxuICAgIGhyKHRva2VuKSB7XG4gICAgICAgIHJldHVybiAnPGhyPlxcbic7XG4gICAgfVxuICAgIGxpc3QodG9rZW4pIHtcbiAgICAgICAgY29uc3Qgb3JkZXJlZCA9IHRva2VuLm9yZGVyZWQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdG9rZW4uc3RhcnQ7XG4gICAgICAgIGxldCBib2R5ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdG9rZW4uaXRlbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0b2tlbi5pdGVtc1tqXTtcbiAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5saXN0aXRlbShpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnO1xuICAgICAgICBjb25zdCBzdGFydEF0dHIgPSAob3JkZXJlZCAmJiBzdGFydCAhPT0gMSkgPyAoJyBzdGFydD1cIicgKyBzdGFydCArICdcIicpIDogJyc7XG4gICAgICAgIHJldHVybiAnPCcgKyB0eXBlICsgc3RhcnRBdHRyICsgJz5cXG4nICsgYm9keSArICc8LycgKyB0eXBlICsgJz5cXG4nO1xuICAgIH1cbiAgICBsaXN0aXRlbShpdGVtKSB7XG4gICAgICAgIGxldCBpdGVtQm9keSA9ICcnO1xuICAgICAgICBpZiAoaXRlbS50YXNrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGVja2JveCA9IHRoaXMuY2hlY2tib3goeyBjaGVja2VkOiAhIWl0ZW0uY2hlY2tlZCB9KTtcbiAgICAgICAgICAgIGlmIChpdGVtLmxvb3NlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udGV4dCA9IGNoZWNrYm94ICsgJyAnICsgaXRlbS50b2tlbnNbMF0udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zWzBdLnRva2VucyAmJiBpdGVtLnRva2Vuc1swXS50b2tlbnMubGVuZ3RoID4gMCAmJiBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udGV4dCA9IGNoZWNrYm94ICsgJyAnICsgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiBjaGVja2JveCArICcgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNoZWNrYm94ICsgJyAnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtQm9keSArPSBjaGVja2JveCArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpdGVtQm9keSArPSB0aGlzLnBhcnNlci5wYXJzZShpdGVtLnRva2VucywgISFpdGVtLmxvb3NlKTtcbiAgICAgICAgcmV0dXJuIGA8bGk+JHtpdGVtQm9keX08L2xpPlxcbmA7XG4gICAgfVxuICAgIGNoZWNrYm94KHsgY2hlY2tlZCB9KSB7XG4gICAgICAgIHJldHVybiAnPGlucHV0ICdcbiAgICAgICAgICAgICsgKGNoZWNrZWQgPyAnY2hlY2tlZD1cIlwiICcgOiAnJylcbiAgICAgICAgICAgICsgJ2Rpc2FibGVkPVwiXCIgdHlwZT1cImNoZWNrYm94XCI+JztcbiAgICB9XG4gICAgcGFyYWdyYXBoKHsgdG9rZW5zIH0pIHtcbiAgICAgICAgcmV0dXJuIGA8cD4ke3RoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyl9PC9wPlxcbmA7XG4gICAgfVxuICAgIHRhYmxlKHRva2VuKSB7XG4gICAgICAgIGxldCBoZWFkZXIgPSAnJztcbiAgICAgICAgLy8gaGVhZGVyXG4gICAgICAgIGxldCBjZWxsID0gJyc7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdG9rZW4uaGVhZGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjZWxsICs9IHRoaXMudGFibGVjZWxsKHRva2VuLmhlYWRlcltqXSk7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVyICs9IHRoaXMudGFibGVyb3coeyB0ZXh0OiBjZWxsIH0pO1xuICAgICAgICBsZXQgYm9keSA9ICcnO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRva2VuLnJvd3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IHRva2VuLnJvd3Nbal07XG4gICAgICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJvdy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGNlbGwgKz0gdGhpcy50YWJsZWNlbGwocm93W2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHkgKz0gdGhpcy50YWJsZXJvdyh7IHRleHQ6IGNlbGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHkpXG4gICAgICAgICAgICBib2R5ID0gYDx0Ym9keT4ke2JvZHl9PC90Ym9keT5gO1xuICAgICAgICByZXR1cm4gJzx0YWJsZT5cXG4nXG4gICAgICAgICAgICArICc8dGhlYWQ+XFxuJ1xuICAgICAgICAgICAgKyBoZWFkZXJcbiAgICAgICAgICAgICsgJzwvdGhlYWQ+XFxuJ1xuICAgICAgICAgICAgKyBib2R5XG4gICAgICAgICAgICArICc8L3RhYmxlPlxcbic7XG4gICAgfVxuICAgIHRhYmxlcm93KHsgdGV4dCB9KSB7XG4gICAgICAgIHJldHVybiBgPHRyPlxcbiR7dGV4dH08L3RyPlxcbmA7XG4gICAgfVxuICAgIHRhYmxlY2VsbCh0b2tlbikge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5wYXJzZXIucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKTtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRva2VuLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICAgICAgICBjb25zdCB0YWcgPSB0b2tlbi5hbGlnblxuICAgICAgICAgICAgPyBgPCR7dHlwZX0gYWxpZ249XCIke3Rva2VuLmFsaWdufVwiPmBcbiAgICAgICAgICAgIDogYDwke3R5cGV9PmA7XG4gICAgICAgIHJldHVybiB0YWcgKyBjb250ZW50ICsgYDwvJHt0eXBlfT5cXG5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzcGFuIGxldmVsIHJlbmRlcmVyXG4gICAgICovXG4gICAgc3Ryb25nKHsgdG9rZW5zIH0pIHtcbiAgICAgICAgcmV0dXJuIGA8c3Ryb25nPiR7dGhpcy5wYXJzZXIucGFyc2VJbmxpbmUodG9rZW5zKX08L3N0cm9uZz5gO1xuICAgIH1cbiAgICBlbSh7IHRva2VucyB9KSB7XG4gICAgICAgIHJldHVybiBgPGVtPiR7dGhpcy5wYXJzZXIucGFyc2VJbmxpbmUodG9rZW5zKX08L2VtPmA7XG4gICAgfVxuICAgIGNvZGVzcGFuKHsgdGV4dCB9KSB7XG4gICAgICAgIHJldHVybiBgPGNvZGU+JHt0ZXh0fTwvY29kZT5gO1xuICAgIH1cbiAgICBicih0b2tlbikge1xuICAgICAgICByZXR1cm4gJzxicj4nO1xuICAgIH1cbiAgICBkZWwoeyB0b2tlbnMgfSkge1xuICAgICAgICByZXR1cm4gYDxkZWw+JHt0aGlzLnBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMpfTwvZGVsPmA7XG4gICAgfVxuICAgIGxpbmsoeyBocmVmLCB0aXRsZSwgdG9rZW5zIH0pIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyk7XG4gICAgICAgIGNvbnN0IGNsZWFuSHJlZiA9IGNsZWFuVXJsKGhyZWYpO1xuICAgICAgICBpZiAoY2xlYW5IcmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICBocmVmID0gY2xlYW5IcmVmO1xuICAgICAgICBsZXQgb3V0ID0gJzxhIGhyZWY9XCInICsgaHJlZiArICdcIic7XG4gICAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnPicgKyB0ZXh0ICsgJzwvYT4nO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBpbWFnZSh7IGhyZWYsIHRpdGxlLCB0ZXh0IH0pIHtcbiAgICAgICAgY29uc3QgY2xlYW5IcmVmID0gY2xlYW5VcmwoaHJlZik7XG4gICAgICAgIGlmIChjbGVhbkhyZWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGhyZWYgPSBjbGVhbkhyZWY7XG4gICAgICAgIGxldCBvdXQgPSBgPGltZyBzcmM9XCIke2hyZWZ9XCIgYWx0PVwiJHt0ZXh0fVwiYDtcbiAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICBvdXQgKz0gYCB0aXRsZT1cIiR7dGl0bGV9XCJgO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnPic7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHRleHQodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuICd0b2tlbnMnIGluIHRva2VuICYmIHRva2VuLnRva2VucyA/IHRoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykgOiB0b2tlbi50ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBUZXh0UmVuZGVyZXJcbiAqIHJldHVybnMgb25seSB0aGUgdGV4dHVhbCBwYXJ0IG9mIHRoZSB0b2tlblxuICovXG5jbGFzcyBfVGV4dFJlbmRlcmVyIHtcbiAgICAvLyBubyBuZWVkIGZvciBibG9jayBsZXZlbCByZW5kZXJlcnNcbiAgICBzdHJvbmcoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGVtKHsgdGV4dCB9KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBjb2Rlc3Bhbih7IHRleHQgfSkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgZGVsKHsgdGV4dCB9KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBodG1sKHsgdGV4dCB9KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICB0ZXh0KHsgdGV4dCB9KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBsaW5rKHsgdGV4dCB9KSB7XG4gICAgICAgIHJldHVybiAnJyArIHRleHQ7XG4gICAgfVxuICAgIGltYWdlKHsgdGV4dCB9KSB7XG4gICAgICAgIHJldHVybiAnJyArIHRleHQ7XG4gICAgfVxuICAgIGJyKCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuXG4vKipcbiAqIFBhcnNpbmcgJiBDb21waWxpbmdcbiAqL1xuY2xhc3MgX1BhcnNlciB7XG4gICAgb3B0aW9ucztcbiAgICByZW5kZXJlcjtcbiAgICB0ZXh0UmVuZGVyZXI7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IF9kZWZhdWx0cztcbiAgICAgICAgdGhpcy5vcHRpb25zLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBfUmVuZGVyZXIoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnBhcnNlciA9IHRoaXM7XG4gICAgICAgIHRoaXMudGV4dFJlbmRlcmVyID0gbmV3IF9UZXh0UmVuZGVyZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IF9QYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2UodG9rZW5zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIElubGluZSBNZXRob2RcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VJbmxpbmUodG9rZW5zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBfUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIExvb3BcbiAgICAgKi9cbiAgICBwYXJzZSh0b2tlbnMsIHRvcCA9IHRydWUpIHtcbiAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYW55VG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICAvLyBSdW4gYW55IHJlbmRlcmVyIGV4dGVuc2lvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW2FueVRva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJpY1Rva2VuID0gYW55VG9rZW47XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW2dlbmVyaWNUb2tlbi50eXBlXS5jYWxsKHsgcGFyc2VyOiB0aGlzIH0sIGdlbmVyaWNUb2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHJldCAhPT0gZmFsc2UgfHwgIVsnc3BhY2UnLCAnaHInLCAnaGVhZGluZycsICdjb2RlJywgJ3RhYmxlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcsICdodG1sJywgJ3BhcmFncmFwaCcsICd0ZXh0J10uaW5jbHVkZXMoZ2VuZXJpY1Rva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gYW55VG9rZW47XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuc3BhY2UodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaHInOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmhyKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2hlYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmhlYWRpbmcodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnY29kZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuY29kZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIudGFibGUodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxvY2txdW90ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuYmxvY2txdW90ZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdsaXN0Jzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saXN0KHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2h0bWwnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmh0bWwodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAncGFyYWdyYXBoJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRleHRUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYm9keSA9IHRoaXMucmVuZGVyZXIudGV4dCh0ZXh0VG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSArIDEgPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0VG9rZW4gPSB0b2tlbnNbKytpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgKz0gJ1xcbicgKyB0aGlzLnJlbmRlcmVyLnRleHQodGV4dFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhdzogYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuczogW3sgdHlwZTogJ3RleHQnLCByYXc6IGJvZHksIHRleHQ6IGJvZHkgfV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBib2R5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9ICdUb2tlbiB3aXRoIFwiJyArIHRva2VuLnR5cGUgKyAnXCIgdHlwZSB3YXMgbm90IGZvdW5kLic7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBJbmxpbmUgVG9rZW5zXG4gICAgICovXG4gICAgcGFyc2VJbmxpbmUodG9rZW5zLCByZW5kZXJlcikge1xuICAgICAgICByZW5kZXJlciA9IHJlbmRlcmVyIHx8IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIGxldCBvdXQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFueVRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgLy8gUnVuIGFueSByZW5kZXJlciBleHRlbnNpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1thbnlUb2tlbi50eXBlXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1thbnlUb2tlbi50eXBlXS5jYWxsKHsgcGFyc2VyOiB0aGlzIH0sIGFueVRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSBmYWxzZSB8fCAhWydlc2NhcGUnLCAnaHRtbCcsICdsaW5rJywgJ2ltYWdlJywgJ3N0cm9uZycsICdlbScsICdjb2Rlc3BhbicsICdicicsICdkZWwnLCAndGV4dCddLmluY2x1ZGVzKGFueVRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gYW55VG9rZW47XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdlc2NhcGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci50ZXh0KHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2h0bWwnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5odG1sKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2xpbmsnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5saW5rKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2ltYWdlJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaW1hZ2UodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnc3Ryb25nJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuc3Ryb25nKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2VtJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuZW0odG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnY29kZXNwYW4nOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5jb2Rlc3Bhbih0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdicic6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmJyKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2RlbCc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmRlbCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9ICdUb2tlbiB3aXRoIFwiJyArIHRva2VuLnR5cGUgKyAnXCIgdHlwZSB3YXMgbm90IGZvdW5kLic7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbn1cblxuY2xhc3MgX0hvb2tzIHtcbiAgICBvcHRpb25zO1xuICAgIGJsb2NrO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBfZGVmYXVsdHM7XG4gICAgfVxuICAgIHN0YXRpYyBwYXNzVGhyb3VnaEhvb2tzID0gbmV3IFNldChbXG4gICAgICAgICdwcmVwcm9jZXNzJyxcbiAgICAgICAgJ3Bvc3Rwcm9jZXNzJyxcbiAgICAgICAgJ3Byb2Nlc3NBbGxUb2tlbnMnLFxuICAgIF0pO1xuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgbWFya2Rvd24gYmVmb3JlIG1hcmtlZFxuICAgICAqL1xuICAgIHByZXByb2Nlc3MobWFya2Rvd24pIHtcbiAgICAgICAgcmV0dXJuIG1hcmtkb3duO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIEhUTUwgYWZ0ZXIgbWFya2VkIGlzIGZpbmlzaGVkXG4gICAgICovXG4gICAgcG9zdHByb2Nlc3MoaHRtbCkge1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhbGwgdG9rZW5zIGJlZm9yZSB3YWxrIHRva2Vuc1xuICAgICAqL1xuICAgIHByb2Nlc3NBbGxUb2tlbnModG9rZW5zKSB7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgZnVuY3Rpb24gdG8gdG9rZW5pemUgbWFya2Rvd25cbiAgICAgKi9cbiAgICBwcm92aWRlTGV4ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NrID8gX0xleGVyLmxleCA6IF9MZXhlci5sZXhJbmxpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgZnVuY3Rpb24gdG8gcGFyc2UgdG9rZW5zXG4gICAgICovXG4gICAgcHJvdmlkZVBhcnNlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2sgPyBfUGFyc2VyLnBhcnNlIDogX1BhcnNlci5wYXJzZUlubGluZTtcbiAgICB9XG59XG5cbmNsYXNzIE1hcmtlZCB7XG4gICAgZGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHMoKTtcbiAgICBvcHRpb25zID0gdGhpcy5zZXRPcHRpb25zO1xuICAgIHBhcnNlID0gdGhpcy5wYXJzZU1hcmtkb3duKHRydWUpO1xuICAgIHBhcnNlSW5saW5lID0gdGhpcy5wYXJzZU1hcmtkb3duKGZhbHNlKTtcbiAgICBQYXJzZXIgPSBfUGFyc2VyO1xuICAgIFJlbmRlcmVyID0gX1JlbmRlcmVyO1xuICAgIFRleHRSZW5kZXJlciA9IF9UZXh0UmVuZGVyZXI7XG4gICAgTGV4ZXIgPSBfTGV4ZXI7XG4gICAgVG9rZW5pemVyID0gX1Rva2VuaXplcjtcbiAgICBIb29rcyA9IF9Ib29rcztcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMudXNlKC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IHRva2VuXG4gICAgICovXG4gICAgd2Fsa1Rva2Vucyh0b2tlbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoY2FsbGJhY2suY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndGFibGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHRhYmxlVG9rZW4uaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2VucyhjZWxsLnRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZVRva2VuLnJvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiByb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2VucyhjZWxsLnRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbGlzdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlzdFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGxpc3RUb2tlbi5pdGVtcywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJpY1Rva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRzLmV4dGVuc2lvbnM/LmNoaWxkVG9rZW5zPy5bZ2VuZXJpY1Rva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRzLmV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbZ2VuZXJpY1Rva2VuLnR5cGVdLmZvckVhY2goKGNoaWxkVG9rZW5zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gZ2VuZXJpY1Rva2VuW2NoaWxkVG9rZW5zXS5mbGF0KEluZmluaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2Vucyh0b2tlbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChnZW5lcmljVG9rZW4udG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2VucyhnZW5lcmljVG9rZW4udG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIHVzZSguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmRlZmF1bHRzLmV4dGVuc2lvbnMgfHwgeyByZW5kZXJlcnM6IHt9LCBjaGlsZFRva2Vuczoge30gfTtcbiAgICAgICAgYXJncy5mb3JFYWNoKChwYWNrKSA9PiB7XG4gICAgICAgICAgICAvLyBjb3B5IG9wdGlvbnMgdG8gbmV3IG9iamVjdFxuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IHsgLi4ucGFjayB9O1xuICAgICAgICAgICAgLy8gc2V0IGFzeW5jIHRvIHRydWUgaWYgaXQgd2FzIHNldCB0byB0cnVlIGJlZm9yZVxuICAgICAgICAgICAgb3B0cy5hc3luYyA9IHRoaXMuZGVmYXVsdHMuYXN5bmMgfHwgb3B0cy5hc3luYyB8fCBmYWxzZTtcbiAgICAgICAgICAgIC8vID09LS0gUGFyc2UgXCJhZGRvblwiIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgICAgICAgICAgaWYgKHBhY2suZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgIHBhY2suZXh0ZW5zaW9ucy5mb3JFYWNoKChleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleHQubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHRlbnNpb24gbmFtZSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgncmVuZGVyZXInIGluIGV4dCkgeyAvLyBSZW5kZXJlciBleHRlbnNpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2UmVuZGVyZXIgPSBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldlJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBleHRlbnNpb24gd2l0aCBmdW5jIHRvIHJ1biBuZXcgZXh0ZW5zaW9uIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV0ID0gZXh0LnJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHJldlJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXSA9IGV4dC5yZW5kZXJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ3Rva2VuaXplcicgaW4gZXh0KSB7IC8vIFRva2VuaXplciBFeHRlbnNpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4dC5sZXZlbCB8fCAoZXh0LmxldmVsICE9PSAnYmxvY2snICYmIGV4dC5sZXZlbCAhPT0gJ2lubGluZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXh0ZW5zaW9uIGxldmVsIG11c3QgYmUgJ2Jsb2NrJyBvciAnaW5saW5lJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dExldmVsID0gZXh0ZW5zaW9uc1tleHQubGV2ZWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dExldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0TGV2ZWwudW5zaGlmdChleHQudG9rZW5pemVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0LmxldmVsXSA9IFtleHQudG9rZW5pemVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHQuc3RhcnQpIHsgLy8gRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHN0YXJ0IG9mIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dC5sZXZlbCA9PT0gJ2Jsb2NrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sucHVzaChleHQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydEJsb2NrID0gW2V4dC5zdGFydF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXh0LmxldmVsID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5zdGFydElubGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydElubGluZS5wdXNoKGV4dC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0SW5saW5lID0gW2V4dC5zdGFydF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCdjaGlsZFRva2VucycgaW4gZXh0ICYmIGV4dC5jaGlsZFRva2VucykgeyAvLyBDaGlsZCB0b2tlbnMgdG8gYmUgdmlzaXRlZCBieSB3YWxrVG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLmNoaWxkVG9rZW5zW2V4dC5uYW1lXSA9IGV4dC5jaGlsZFRva2VucztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9wdHMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA9PS0tIFBhcnNlIFwib3ZlcndyaXRlXCIgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICAgICAgICBpZiAocGFjay5yZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5kZWZhdWx0cy5yZW5kZXJlciB8fCBuZXcgX1JlbmRlcmVyKHRoaXMuZGVmYXVsdHMpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYWNrLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHByb3AgaW4gcmVuZGVyZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlbmRlcmVyICcke3Byb3B9JyBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChbJ29wdGlvbnMnLCAncGFyc2VyJ10uaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBvcHRpb25zIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlclByb3AgPSBwcm9wO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlckZ1bmMgPSBwYWNrLnJlbmRlcmVyW3JlbmRlcmVyUHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZSZW5kZXJlciA9IHJlbmRlcmVyW3JlbmRlcmVyUHJvcF07XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgcmVuZGVyZXIgd2l0aCBmdW5jIHRvIHJ1biBleHRlbnNpb24sIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJbcmVuZGVyZXJQcm9wXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV0ID0gcmVuZGVyZXJGdW5jLmFwcGx5KHJlbmRlcmVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHJldlJlbmRlcmVyLmFwcGx5KHJlbmRlcmVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdHMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWNrLnRva2VuaXplcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuaXplciA9IHRoaXMuZGVmYXVsdHMudG9rZW5pemVyIHx8IG5ldyBfVG9rZW5pemVyKHRoaXMuZGVmYXVsdHMpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYWNrLnRva2VuaXplcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShwcm9wIGluIHRva2VuaXplcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdG9rZW5pemVyICcke3Byb3B9JyBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChbJ29wdGlvbnMnLCAncnVsZXMnLCAnbGV4ZXInXS5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG9wdGlvbnMsIHJ1bGVzLCBhbmQgbGV4ZXIgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5pemVyUHJvcCA9IHByb3A7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuaXplckZ1bmMgPSBwYWNrLnRva2VuaXplclt0b2tlbml6ZXJQcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldlRva2VuaXplciA9IHRva2VuaXplclt0b2tlbml6ZXJQcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0b2tlbml6ZXIgd2l0aCBmdW5jIHRvIHJ1biBleHRlbnNpb24sIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBjYW5ub3QgdHlwZSB0b2tlbml6ZXIgZnVuY3Rpb24gZHluYW1pY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5pemVyW3Rva2VuaXplclByb3BdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSB0b2tlbml6ZXJGdW5jLmFwcGx5KHRva2VuaXplciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHByZXZUb2tlbml6ZXIuYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gPT0tLSBQYXJzZSBIb29rcyBleHRlbnNpb25zIC0tPT0gLy9cbiAgICAgICAgICAgIGlmIChwYWNrLmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaG9va3MgPSB0aGlzLmRlZmF1bHRzLmhvb2tzIHx8IG5ldyBfSG9va3MoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFjay5ob29rcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShwcm9wIGluIGhvb2tzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBob29rICcke3Byb3B9JyBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChbJ29wdGlvbnMnLCAnYmxvY2snXS5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG9wdGlvbnMgYW5kIGJsb2NrIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvb2tzUHJvcCA9IHByb3A7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvb2tzRnVuYyA9IHBhY2suaG9va3NbaG9va3NQcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldkhvb2sgPSBob29rc1tob29rc1Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX0hvb2tzLnBhc3NUaHJvdWdoSG9va3MuaGFzKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNhbm5vdCB0eXBlIGhvb2sgZnVuY3Rpb24gZHluYW1pY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzW2hvb2tzUHJvcF0gPSAoYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdHMuYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShob29rc0Z1bmMuY2FsbChob29rcywgYXJnKSkudGhlbihyZXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZIb29rLmNhbGwoaG9va3MsIHJldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXQgPSBob29rc0Z1bmMuY2FsbChob29rcywgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldkhvb2suY2FsbChob29rcywgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNhbm5vdCB0eXBlIGhvb2sgZnVuY3Rpb24gZHluYW1pY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzW2hvb2tzUHJvcF0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSBob29rc0Z1bmMuYXBwbHkoaG9va3MsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHByZXZIb29rLmFwcGx5KGhvb2tzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0cy5ob29rcyA9IGhvb2tzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gPT0tLSBQYXJzZSBXYWxrVG9rZW5zIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgICAgICAgICAgaWYgKHBhY2sud2Fsa1Rva2Vucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhbGtUb2tlbnMgPSB0aGlzLmRlZmF1bHRzLndhbGtUb2tlbnM7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFja1dhbGt0b2tlbnMgPSBwYWNrLndhbGtUb2tlbnM7XG4gICAgICAgICAgICAgICAgb3B0cy53YWxrVG9rZW5zID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFja1dhbGt0b2tlbnMuY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2Fsa1Rva2Vucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh3YWxrVG9rZW5zLmNhbGwodGhpcywgdG9rZW4pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRzID0geyAuLi50aGlzLmRlZmF1bHRzLCAuLi5vcHRzIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhvcHQpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0cyA9IHsgLi4udGhpcy5kZWZhdWx0cywgLi4ub3B0IH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsZXhlcihzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9MZXhlci5sZXgoc3JjLCBvcHRpb25zID8/IHRoaXMuZGVmYXVsdHMpO1xuICAgIH1cbiAgICBwYXJzZXIodG9rZW5zLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfUGFyc2VyLnBhcnNlKHRva2Vucywgb3B0aW9ucyA/PyB0aGlzLmRlZmF1bHRzKTtcbiAgICB9XG4gICAgcGFyc2VNYXJrZG93bihibG9ja1R5cGUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgcGFyc2UgPSAoc3JjLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcmlnT3B0ID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBvcHQgPSB7IC4uLnRoaXMuZGVmYXVsdHMsIC4uLm9yaWdPcHQgfTtcbiAgICAgICAgICAgIGNvbnN0IHRocm93RXJyb3IgPSB0aGlzLm9uRXJyb3IoISFvcHQuc2lsZW50LCAhIW9wdC5hc3luYyk7XG4gICAgICAgICAgICAvLyB0aHJvdyBlcnJvciBpZiBhbiBleHRlbnNpb24gc2V0IGFzeW5jIHRvIHRydWUgYnV0IHBhcnNlIHdhcyBjYWxsZWQgd2l0aCBhc3luYzogZmFsc2VcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRzLmFzeW5jID09PSB0cnVlICYmIG9yaWdPcHQuYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IobmV3IEVycm9yKCdtYXJrZWQoKTogVGhlIGFzeW5jIG9wdGlvbiB3YXMgc2V0IHRvIHRydWUgYnkgYW4gZXh0ZW5zaW9uLiBSZW1vdmUgYXN5bmM6IGZhbHNlIGZyb20gdGhlIHBhcnNlIG9wdGlvbnMgb2JqZWN0IHRvIHJldHVybiBhIFByb21pc2UuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhyb3cgZXJyb3IgaW4gY2FzZSBvZiBub24gc3RyaW5nIGlucHV0XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IobmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCBvciBudWxsJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IobmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJ1xuICAgICAgICAgICAgICAgICAgICArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzcmMpICsgJywgc3RyaW5nIGV4cGVjdGVkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgICAgICAgIG9wdC5ob29rcy5vcHRpb25zID0gb3B0O1xuICAgICAgICAgICAgICAgIG9wdC5ob29rcy5ibG9jayA9IGJsb2NrVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxleGVyID0gb3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnByb3ZpZGVMZXhlcigpIDogKGJsb2NrVHlwZSA/IF9MZXhlci5sZXggOiBfTGV4ZXIubGV4SW5saW5lKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9IG9wdC5ob29rcyA/IG9wdC5ob29rcy5wcm92aWRlUGFyc2VyKCkgOiAoYmxvY2tUeXBlID8gX1BhcnNlci5wYXJzZSA6IF9QYXJzZXIucGFyc2VJbmxpbmUpO1xuICAgICAgICAgICAgaWYgKG9wdC5hc3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnByZXByb2Nlc3Moc3JjKSA6IHNyYylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oc3JjID0+IGxleGVyKHNyYywgb3B0KSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odG9rZW5zID0+IG9wdC5ob29rcyA/IG9wdC5ob29rcy5wcm9jZXNzQWxsVG9rZW5zKHRva2VucykgOiB0b2tlbnMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHRva2VucyA9PiBvcHQud2Fsa1Rva2VucyA/IFByb21pc2UuYWxsKHRoaXMud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKSkudGhlbigoKSA9PiB0b2tlbnMpIDogdG9rZW5zKVxuICAgICAgICAgICAgICAgICAgICAudGhlbih0b2tlbnMgPT4gcGFyc2VyKHRva2Vucywgb3B0KSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oaHRtbCA9PiBvcHQuaG9va3MgPyBvcHQuaG9va3MucG9zdHByb2Nlc3MoaHRtbCkgOiBodG1sKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2godGhyb3dFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gb3B0Lmhvb2tzLnByZXByb2Nlc3Moc3JjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHRva2VucyA9IGxleGVyKHNyYywgb3B0KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VucyA9IG9wdC5ob29rcy5wcm9jZXNzQWxsVG9rZW5zKHRva2Vucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHQud2Fsa1Rva2Vucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndhbGtUb2tlbnModG9rZW5zLCBvcHQud2Fsa1Rva2Vucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBodG1sID0gcGFyc2VyKHRva2Vucywgb3B0KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgPSBvcHQuaG9va3MucG9zdHByb2Nlc3MoaHRtbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhcnNlO1xuICAgIH1cbiAgICBvbkVycm9yKHNpbGVudCwgYXN5bmMpIHtcbiAgICAgICAgcmV0dXJuIChlKSA9PiB7XG4gICAgICAgICAgICBlLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkLic7XG4gICAgICAgICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gJzxwPkFuIGVycm9yIG9jY3VycmVkOjwvcD48cHJlPidcbiAgICAgICAgICAgICAgICAgICAgKyBlc2NhcGUkMShlLm1lc3NhZ2UgKyAnJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgKyAnPC9wcmU+JztcbiAgICAgICAgICAgICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmNvbnN0IG1hcmtlZEluc3RhbmNlID0gbmV3IE1hcmtlZCgpO1xuZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0KSB7XG4gICAgcmV0dXJuIG1hcmtlZEluc3RhbmNlLnBhcnNlKHNyYywgb3B0KTtcbn1cbi8qKlxuICogU2V0cyB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIEhhc2ggb2Ygb3B0aW9uc1xuICovXG5tYXJrZWQub3B0aW9ucyA9XG4gICAgbWFya2VkLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBtYXJrZWRJbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBtYXJrZWQuZGVmYXVsdHMgPSBtYXJrZWRJbnN0YW5jZS5kZWZhdWx0cztcbiAgICAgICAgY2hhbmdlRGVmYXVsdHMobWFya2VkLmRlZmF1bHRzKTtcbiAgICAgICAgcmV0dXJuIG1hcmtlZDtcbiAgICB9O1xuLyoqXG4gKiBHZXRzIHRoZSBvcmlnaW5hbCBtYXJrZWQgZGVmYXVsdCBvcHRpb25zLlxuICovXG5tYXJrZWQuZ2V0RGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHM7XG5tYXJrZWQuZGVmYXVsdHMgPSBfZGVmYXVsdHM7XG4vKipcbiAqIFVzZSBFeHRlbnNpb25cbiAqL1xubWFya2VkLnVzZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgbWFya2VkSW5zdGFuY2UudXNlKC4uLmFyZ3MpO1xuICAgIG1hcmtlZC5kZWZhdWx0cyA9IG1hcmtlZEluc3RhbmNlLmRlZmF1bHRzO1xuICAgIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gICAgcmV0dXJuIG1hcmtlZDtcbn07XG4vKipcbiAqIFJ1biBjYWxsYmFjayBmb3IgZXZlcnkgdG9rZW5cbiAqL1xubWFya2VkLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW5zLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBtYXJrZWRJbnN0YW5jZS53YWxrVG9rZW5zKHRva2VucywgY2FsbGJhY2spO1xufTtcbi8qKlxuICogQ29tcGlsZXMgbWFya2Rvd24gdG8gSFRNTCB3aXRob3V0IGVuY2xvc2luZyBgcGAgdGFnLlxuICpcbiAqIEBwYXJhbSBzcmMgU3RyaW5nIG9mIG1hcmtkb3duIHNvdXJjZSB0byBiZSBjb21waWxlZFxuICogQHBhcmFtIG9wdGlvbnMgSGFzaCBvZiBvcHRpb25zXG4gKiBAcmV0dXJuIFN0cmluZyBvZiBjb21waWxlZCBIVE1MXG4gKi9cbm1hcmtlZC5wYXJzZUlubGluZSA9IG1hcmtlZEluc3RhbmNlLnBhcnNlSW5saW5lO1xuLyoqXG4gKiBFeHBvc2VcbiAqL1xubWFya2VkLlBhcnNlciA9IF9QYXJzZXI7XG5tYXJrZWQucGFyc2VyID0gX1BhcnNlci5wYXJzZTtcbm1hcmtlZC5SZW5kZXJlciA9IF9SZW5kZXJlcjtcbm1hcmtlZC5UZXh0UmVuZGVyZXIgPSBfVGV4dFJlbmRlcmVyO1xubWFya2VkLkxleGVyID0gX0xleGVyO1xubWFya2VkLmxleGVyID0gX0xleGVyLmxleDtcbm1hcmtlZC5Ub2tlbml6ZXIgPSBfVG9rZW5pemVyO1xubWFya2VkLkhvb2tzID0gX0hvb2tzO1xubWFya2VkLnBhcnNlID0gbWFya2VkO1xuY29uc3Qgb3B0aW9ucyA9IG1hcmtlZC5vcHRpb25zO1xuY29uc3Qgc2V0T3B0aW9ucyA9IG1hcmtlZC5zZXRPcHRpb25zO1xuY29uc3QgdXNlID0gbWFya2VkLnVzZTtcbmNvbnN0IHdhbGtUb2tlbnMgPSBtYXJrZWQud2Fsa1Rva2VucztcbmNvbnN0IHBhcnNlSW5saW5lID0gbWFya2VkLnBhcnNlSW5saW5lO1xuY29uc3QgcGFyc2UgPSBtYXJrZWQ7XG5jb25zdCBwYXJzZXIgPSBfUGFyc2VyLnBhcnNlO1xuY29uc3QgbGV4ZXIgPSBfTGV4ZXIubGV4O1xuXG5leHBvcnQgeyBfSG9va3MgYXMgSG9va3MsIF9MZXhlciBhcyBMZXhlciwgTWFya2VkLCBfUGFyc2VyIGFzIFBhcnNlciwgX1JlbmRlcmVyIGFzIFJlbmRlcmVyLCBfVGV4dFJlbmRlcmVyIGFzIFRleHRSZW5kZXJlciwgX1Rva2VuaXplciBhcyBUb2tlbml6ZXIsIF9kZWZhdWx0cyBhcyBkZWZhdWx0cywgX2dldERlZmF1bHRzIGFzIGdldERlZmF1bHRzLCBsZXhlciwgbWFya2VkLCBvcHRpb25zLCBwYXJzZSwgcGFyc2VJbmxpbmUsIHBhcnNlciwgc2V0T3B0aW9ucywgdXNlLCB3YWxrVG9rZW5zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXJrZWQuZXNtLmpzLm1hcFxuIiwiPHNjcmlwdCBzZXR1cCBsYW5nPVwidHNcIj5cbmltcG9ydCB7IHVzZUFJIH0gZnJvbSBcIkAvcHJvdmlkZXJcIjtcbmltcG9ydCB7IG9uTW91bnRlZCB9IGZyb20gXCJ2dWVcIjtcbmltcG9ydCB7IHVzZUNoYXRib3hTdG9yZSB9IGZyb20gXCJAL3N0b3JlL2NoYXRib3hcIjtcbmltcG9ydCB7IG1hcmtlZCB9IGZyb20gXCJtYXJrZWRcIjtcbmltcG9ydCB0eXBlIHsgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcgfSBmcm9tIFwib3BlbmFpL3Jlc291cmNlcy9pbmRleC5tanNcIjtcbmNvbnN0IGNoYXRib3ggPSB1c2VDaGF0Ym94U3RvcmUoKTtcbmNvbnN0IHsgY2xpZW50LCBzeXN0ZW1Qcm9tcHQgfSA9IHVzZUFJKCk7XG5cbmNvbnN0IGZldGNoTW9kZWxzID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50Lm1vZGVscy5saXN0KCk7XG4gICAgY2hhdGJveC5zZXRNb2RlbHMocmVzcG9uc2UuZGF0YS5tYXAoKG1vZGVsKSA9PiBtb2RlbC5pZCkpO1xuICAgIGNoYXRib3guc2V0U2VsZWN0ZWRNb2RlbChjaGF0Ym94Lm1vZGVsc1swXSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBtb2RlbHM6XCIsIGVycm9yKTtcbiAgICAvLyBIYW5kbGUgdGhlIGVycm9yLCBtYXliZSBub3RpZnkgdGhlIHVzZXJcbiAgfVxufTtcblxuY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblxuY29uc3Qgc2VuZE1lc3NhZ2UgPSBhc3luYyAoKSA9PiB7XG4gIGlmICghY2hhdGJveC5uZXdNZXNzYWdlKSByZXR1cm47XG5cbiAgY2hhdGJveC5hZGRNZXNzYWdlKHtcbiAgICBjb250ZW50OiBjaGF0Ym94Lm5ld01lc3NhZ2UsXG4gICAgcm9sZTogXCJ1c2VyXCIsXG4gIH0pO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoXG4gICAgICB7XG4gICAgICAgIG1vZGVsOiBjaGF0Ym94LnNlbGVjdGVkTW9kZWwsXG4gICAgICAgIG1lc3NhZ2VzOiBjaGF0Ym94Lm1lc3NhZ2VzLFxuICAgICAgICBtYXhfdG9rZW5zOiBjaGF0Ym94Lm1heFRva2VucyxcbiAgICAgIH0sXG4gICAgICB7IHNpZ25hbDogY29udHJvbGxlci5zaWduYWwgfSxcbiAgICApO1xuXG4gICAgY2hhdGJveC5hZGRNZXNzYWdlKHtcbiAgICAgIGNvbnRlbnQ6IHJlc3BvbnNlLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50LFxuICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNlbmQgbWVzc2FnZTpcIiwgZXJyb3IpO1xuICAgIC8vIEhhbmRsZSB0aGUgZXJyb3IsIG1heWJlIG5vdGlmeSB0aGUgdXNlclxuICB9IGZpbmFsbHkge1xuICAgIGNoYXRib3guY2xlYXJOZXdNZXNzYWdlKCk7XG4gIH1cbn07XG5cbmNvbnN0IGNsZWFyTWVzc2FnZXMgPSAoKSA9PiB7XG4gIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgY2hhdGJveC5jbGVhck1lc3NhZ2VzKCk7XG59O1xuXG4vLyBQcm9wcyBhcmUgdXNlZCB0byBwYXNzIHRoZSB0ZXh0IGZyb20gdGhlIHBhcmVudCBjb21wb25lbnRcbiAgY29uc3QgcHJvcHMgPSBkZWZpbmVQcm9wczx7IHRleHQ6IHN0cmluZyB9PigpO1xuICBcbiAgLy8gRnVuY3Rpb24gdG8gY29weSB0aGUgcHJvdmlkZWQgdGV4dCB0byB0aGUgY2xpcGJvYXJkXG4gIGNvbnN0IGNvcHlUZXh0ID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgdXNlck1lc3NhZ2VzICR7dHlwZW9mIGNoYXRib3gudXNlck1lc3NhZ2VzfWApO1xuICAgICAgY29uc29sZS5sb2coY2hhdGJveC51c2VyTWVzc2FnZXMubGVuZ3RoKTtcbiAgICAgIGNvbnNvbGUubG9nKGNoYXRib3gudXNlck1lc3NhZ2VzKTtcbiAgICAgIGlmKGNoYXRib3gudXNlck1lc3NhZ2VzLmxlbmd0aD4wKXtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhjaGF0Ym94LnVzZXJNZXNzYWdlc1swXSk7XG4gICAgICB9XG4gICAgICAvL2F3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHByb3BzLnRleHQpO1xuICAgICAgLy9hbGVydChcIkhlbGxvXCIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjb3B5OlwiLCBlcnIpO1xuICAgIH1cbiAgfTtcblxuXG5vbk1vdW50ZWQoYXN5bmMgKCkgPT4ge1xuICBhd2FpdCBmZXRjaE1vZGVscygpO1xuICBjaGF0Ym94LnNldFN5c3RlbVByb21wdChzeXN0ZW1Qcm9tcHQpO1xufSk7XG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8ZGl2IGRhdGEtdGhlbWU9XCJsaWdodFwiIGNsYXNzPVwibWF4LXctbGcgbXgtYXV0byBwLTQgYm9yZGVyIGJvcmRlci1ncmF5LTMwMCByb3VuZGVkLWxnIHNoYWRvdy1tZFwiPlxuICAgIDxkaXYgY2xhc3M9XCJtYi00XCI+XG4gICAgICA8YnV0dG9uIEBjbGljaz1cImNsZWFyTWVzc2FnZXNcIiBjbGFzcz1cImJ0biBidG4tZXJyb3IgYnRuLXNtIGZsb2F0LXJpZ2h0XCI+XG4gICAgICAgIENsZWFyIE1lc3NhZ2VzXG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxidXR0b25cbiAgICAgICAgQGNsaWNrPVwiY29weVRleHRcIlxuICAgICAgICBjbGFzcz1cInB4LTQgcHktMiBiZy1ncmVlbi01MDAgdGV4dC13aGl0ZSByb3VuZGVkLWxnIGhvdmVyOmJnLWdyZWVuLTYwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctZ3JlZW4tNTAwXCJcbiAgICAgID5cbiAgICAgICAgQ29weSBMYXN0IFJlc3BvbnNlXG4gICAgICA8L2J1dHRvbj5cbiAgICAgIFxuICAgICAgPGgyIGNsYXNzPVwidGV4dC14bCBmb250LXNlbWlib2xkXCI+Q2hhdDwvaDI+XG4gICAgICA8ZGl2IGNsYXNzPVwibWItMlwiPlxuICAgICAgICA8bGFiZWwgZm9yPVwibW9kZWwtc2VsZWN0XCIgY2xhc3M9XCJibG9jayB0ZXh0LWdyYXktNzAwXCI+U2VsZWN0IE1vZGVsOjwvbGFiZWw+XG4gICAgICAgIDxzZWxlY3RcbiAgICAgICAgICBpZD1cIm1vZGVsLXNlbGVjdFwiXG4gICAgICAgICAgdi1tb2RlbD1cImNoYXRib3guc2VsZWN0ZWRNb2RlbFwiXG4gICAgICAgICAgY2xhc3M9XCJzZWxlY3Qgc2VsZWN0LWJvcmRlcmVkIHNlbGVjdC1zbSB3LWZ1bGwgbWF4LXcteHNcIlxuICAgICAgICA+XG4gICAgICAgICAgPG9wdGlvbiB2LWZvcj1cIm1vZGVsIGluIGNoYXRib3gubW9kZWxzXCIgOmtleT1cIm1vZGVsXCIgOnZhbHVlPVwibW9kZWxcIj57eyBtb2RlbCB9fTwvb3B0aW9uPlxuICAgICAgICA8L3NlbGVjdD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtYi00XCI+XG4gICAgICA8ZGl2IHYtZm9yPVwiKG1lc3NhZ2UsIGluZGV4KSBpbiBjaGF0Ym94Lm1lc3NhZ2VzXCIgOmtleT1cImluZGV4XCIgY2xhc3M9XCJtYi0yXCI+XG4gICAgICAgIDxkaXYgdi1pZj1cIm1lc3NhZ2Uucm9sZSA9PT0gJ3N5c3RlbSdcIiBjbGFzcz1cInRleHQtY2VudGVyXCI+XG4gICAgICAgICAgPHAgY2xhc3M9XCJ0ZXh0LWdyYXktNTAwXCI+e3sgbWVzc2FnZS5jb250ZW50IH19PC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiB2LWlmPVwibWVzc2FnZS5yb2xlICE9PSAnc3lzdGVtJ1wiIDpjbGFzcz1cInsgJ3RleHQtcmlnaHQnOiBtZXNzYWdlLnJvbGUgPT09ICd1c2VyJyB9XCI+XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3M9XCJpbmxpbmUtYmxvY2sgcC0yIHJvdW5kZWQtbGdcIlxuICAgICAgICAgICAgOmNsYXNzPVwibWVzc2FnZS5yb2xlID09PSAndXNlcicgPyAnYmctYmx1ZS01MDAgdGV4dC13aGl0ZScgOiAnYmctZ3JheS0zMDAgdGV4dC1ibGFjaydcIlxuICAgICAgICAgICAgdi1odG1sPVwibWFya2VkLnBhcnNlKG1lc3NhZ2UuY29udGVudCBhcyBzdHJpbmcpXCJcbiAgICAgICAgICA+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImZsZXhcIj5cbiAgICAgIDxpbnB1dFxuICAgICAgICB2LW1vZGVsPVwiY2hhdGJveC5uZXdNZXNzYWdlXCJcbiAgICAgICAgQGtleXVwLmVudGVyPVwic2VuZE1lc3NhZ2VcIlxuICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgIHBsYWNlaG9sZGVyPVwiVHlwZSBhIG1lc3NhZ2UuLi5cIlxuICAgICAgICBjbGFzcz1cInctZnVsbCBwLTIgYm9yZGVyIGJvcmRlci1ncmF5LTMwMCByb3VuZGVkLWxnIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ibHVlLTUwMFwiXG4gICAgICAvPlxuICAgICAgPGJ1dHRvblxuICAgICAgICBAY2xpY2s9XCJzZW5kTWVzc2FnZVwiXG4gICAgICAgIGNsYXNzPVwibWwtMiBweC00IHB5LTIgYmctYmx1ZS01MDAgdGV4dC13aGl0ZSByb3VuZGVkLWxnIGhvdmVyOmJnLWJsdWUtNjAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ibHVlLTUwMFwiXG4gICAgICA+XG4gICAgICAgIFNlbmRcbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzdHlsZSBzY29wZWQ+XG5AaW1wb3J0IFwiLi4vYXNzZXRzL21haW4uY3NzXCI7XG48L3N0eWxlPlxuIiwiaW1wb3J0IHsgY2FsbCBhcyBmZXRjaE1hbnkgfSBmcm9tIFwiY29yZS9hamF4XCI7XG5cbmludGVyZmFjZSBSZXF1ZXN0SW5pdCB7XG4gIGVuZHBvaW50OiBzdHJpbmc7XG4gIG1ldGhvZDogc3RyaW5nO1xuICBwYXJhbXM6IHN0cmluZztcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hUaHJvdWdobG9jYWxUZWFjaGVyYWlkZU9wZW5BSUdhdGV3YXkoe1xuICBlbmRwb2ludCxcbiAgbWV0aG9kLFxuICBwYXJhbXMsXG59OiBSZXF1ZXN0SW5pdCkge1xuICByZXR1cm4gZmV0Y2hNYW55KFtcbiAgICB7XG4gICAgICBtZXRob2RuYW1lOiBcImxvY2FsX3RlYWNoZXJhaWRlX29wZW5haV9nYXRld2F5XCIsXG4gICAgICBhcmdzOiB7XG4gICAgICAgIGVuZHBvaW50LFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgIH0sXG4gICAgfSxcbiAgXSlbMF07XG59XG5cbmNvbnN0IHd3d3Jvb3QgPSBNLmNmZy53d3dyb290O1xuXG5leHBvcnQgY29uc3Qgd2Vic2VydmljZUJhc2VVcmwgPSBgJHt3d3dyb290fS93ZWJzZXJ2aWNlL3Jlc3RmdWwvc2VydmVyLnBocC9sb2NhbF90ZWFjaGVyYWlkZV9vcGVuYWlfZ2F0ZXdheWA7XG5cbmV4cG9ydCBjb25zdCB3ZWJzZXJ2aWNlRmV0Y2g6IHR5cGVvZiBmZXRjaCA9IGFzeW5jICh1cmwsIGluaXQpID0+IHtcbiAgY29uc3QgZW5kcG9pbnQgPSBgJHt1cmx9YC5yZXBsYWNlKHdlYnNlcnZpY2VCYXNlVXJsLCBcIlwiKTtcbiAgY29uc3QgbWV0aG9kID0gaW5pdD8ubWV0aG9kIGFzIHN0cmluZztcbiAgY29uc3QgYm9keSA9IGluaXQ/LmJvZHkgYXMgc3RyaW5nO1xuXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoVGhyb3VnaGxvY2FsVGVhY2hlcmFpZGVPcGVuQUlHYXRld2F5KHtcbiAgICBlbmRwb2ludCxcbiAgICBtZXRob2QsXG4gICAgcGFyYW1zOiBib2R5LFxuICB9KTtcblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKHJlcy5kYXRhLCB7XG4gICAgLy8gY3JlYXRlIHN0YW5kYXJkIFJlc3BvbnNlIG9iamVjdFxuICAgIHN0YXR1czogMjAwLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIH0sXG4gIH0pO1xufTtcbiIsImltcG9ydCBTaW1wbGVDaGF0IGZyb20gXCIuL2NvbXBvbmVudHMvU2ltcGxlQ2hhdC52dWVcIjtcbmltcG9ydCB7IGNvbmZpZ3VyZUFwcFdpdGhQcm92aWRlcnMgfSBmcm9tIFwiLi9wcm92aWRlclwiO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCB9IGZyb20gXCJ2dWVcIjtcbmltcG9ydCB7IE9wZW5BSSB9IGZyb20gXCJvcGVuYWlcIjtcbmltcG9ydCB7IHdlYnNlcnZpY2VCYXNlVXJsLCB3ZWJzZXJ2aWNlRmV0Y2ggfSBmcm9tIFwiLi93ZWJzZXJ2aWNlXCI7XG5cbmludGVyZmFjZSBJbml0T3B0aW9ucyB7XG4gIHN5c3RlbVByb21wdDogc3RyaW5nO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpbml0KHsgc3lzdGVtUHJvbXB0IH06IEluaXRPcHRpb25zKSB7XG4gIC8vIENyZWF0ZSBPcGVuQUkgY2xpZW50XG4gIGNvbnN0IGNsaWVudCA9IG5ldyBPcGVuQUkoe1xuICAgIGJhc2VVUkw6IHdlYnNlcnZpY2VCYXNlVXJsLFxuICAgIGFwaUtleTogXCJkdW1teVwiLCAvLyBUaGlzIGlzIGEgZHVtbXkgQVBJIGtleSwgYXMgdGhlIEFQSSBrZXkgaXMgbm90IG5lZWRlZCBmb3IgdXNpbmcgdGhlIHdlYnNlcnZpY2VcbiAgICBkYW5nZXJvdXNseUFsbG93QnJvd3NlcjogdHJ1ZSxcbiAgICBmZXRjaDogd2Vic2VydmljZUZldGNoLFxuICB9KTtcblxuICAvLyBDb25maWd1cmUgdGhlIGFwcCB3aXRoIHByb3ZpZGVyc1xuICBjb25zdCBjb25maWd1cmVBcHAgPSBjb25maWd1cmVBcHBXaXRoUHJvdmlkZXJzKHsgY2xpZW50LCBzeXN0ZW1Qcm9tcHQgfSk7XG5cbiAgLy8gUmVnaXN0ZXIgdGhlIGN1c3RvbSBlbGVtZW50XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShcbiAgICBcInRlYWNoZXJhaWRlLXNpbXBsZS1jaGF0XCIsXG4gICAgZGVmaW5lQ3VzdG9tRWxlbWVudChTaW1wbGVDaGF0LCB7IGNvbmZpZ3VyZUFwcCB9KSxcbiAgKTtcbn1cblxuZXhwb3J0IHsgaW5pdCB9O1xuIl0sIm5hbWVzIjpbIm1ha2VNYXAiLCJzdHIiLCJzZXQiLCJFTVBUWV9PQkoiLCJOT09QIiwiZXh0ZW5kIiwicmVtb3ZlIiwiaGFzT3duUHJvcGVydHkiLCJoYXNPd24iLCJpc0FycmF5IiwiaXNNYXAiLCJ0b1R5cGVTdHJpbmciLCJpc1NldCIsImlzRnVuY3Rpb24iLCJpc1N0cmluZyIsImlzU3ltYm9sIiwiaXNPYmplY3QiLCJvYmplY3RUb1N0cmluZyIsImlzUGxhaW5PYmplY3QiLCJkZWYiLCJsaW5rIiwiY29tcHV0ZWQiLCJ0eXBlIiwiX2EiLCJzZWxmIiwiaXNSZWYiLCJ3YXRjaCIsImVmZmVjdCIsImlzT24iLCJpc01vZGVsTGlzdGVuZXIiLCJpc1Byb21pc2UiLCJjYWNoZVN0cmluZ0Z1bmN0aW9uIiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwiaHlwaGVuYXRlUkUiLCJoeXBoZW5hdGUiLCJjYXBpdGFsaXplIiwiaW52b2tlQXJyYXlGbnMiLCJsb29zZVRvTnVtYmVyIiwiY2xvc2UiLCJwIiwicmVmIiwicmVuZGVyIiwiZ2V0IiwiaCIsImNyZWF0ZUFwcCIsInJlbW92ZTIiLCJpc0ZsdXNoaW5nIiwiZW1pdCIsInJlbmRlcjIiLCJ0YWciLCJjYW1lbGl6ZSQxIiwiaGFzIiwiZmV0Y2giLCJGb3JtRGF0YSIsIkZpbGUiLCJSZWFkYWJsZVN0cmVhbSIsInNoaW1zLmtpbmQiLCJzaGltcy5zZXRTaGltcyIsImF1dG8uZ2V0UnVudGltZSIsIml0ZXJhdG9yIiwicXVldWUiLCJuZXdsaW5lIiwiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsImtpbmQiLCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0Iiwib3B0cyIsIlBhZ2UiLCJzaGltc0tpbmQiLCJyZXRyeU1lc3NhZ2UiLCJpbml0Iiwic2xlZXAiLCJDb21wbGV0aW9ucyIsIkNvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25zIiwiQ2hhdCIsIlNwZWVjaCIsIkNvcmUubXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zIiwiVHJhbnNjcmlwdGlvbnMiLCJUcmFuc2xhdGlvbnMiLCJUcmFuc2NyaXB0aW9uc0FQSS5UcmFuc2NyaXB0aW9ucyIsIlRyYW5zbGF0aW9uc0FQSS5UcmFuc2xhdGlvbnMiLCJTcGVlY2hBUEkuU3BlZWNoIiwiQXVkaW8iLCJCYXRjaGVzIiwiQmF0Y2hlc0FQSS5CYXRjaGVzUGFnZSIsIkFzc2lzdGFudHMiLCJBc3Npc3RhbnRzQVBJLkFzc2lzdGFudHNQYWdlIiwiX0V2ZW50U3RyZWFtX2hhbmRsZUVycm9yIiwiaW5wdXRUb29sIiwiY29udGVudCIsIm5hbWUiLCJfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbENvbnRlbnQiLCJfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbE1lc3NhZ2UiLCJfQWJzdHJhY3RDaGF0Q29tcGxldGlvblJ1bm5lcl9nZXRGaW5hbEZ1bmN0aW9uQ2FsbCIsIl9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX2dldEZpbmFsRnVuY3Rpb25DYWxsUmVzdWx0IiwiX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfY2FsY3VsYXRlVG90YWxVc2FnZSIsIl9BYnN0cmFjdENoYXRDb21wbGV0aW9uUnVubmVyX3ZhbGlkYXRlUGFyYW1zIiwiX0Fic3RyYWN0Q2hhdENvbXBsZXRpb25SdW5uZXJfc3RyaW5naWZ5RnVuY3Rpb25DYWxsUmVzdWx0IiwiX0NoYXRDb21wbGV0aW9uU3RyZWFtX2JlZ2luUmVxdWVzdCIsIl9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRDaG9pY2VFdmVudFN0YXRlIiwiX0NoYXRDb21wbGV0aW9uU3RyZWFtX2FkZENodW5rIiwiX0NoYXRDb21wbGV0aW9uU3RyZWFtX2VtaXRUb29sQ2FsbERvbmVFdmVudCIsIl9DaGF0Q29tcGxldGlvblN0cmVhbV9lbWl0Q29udGVudERvbmVFdmVudHMiLCJfQ2hhdENvbXBsZXRpb25TdHJlYW1fZW5kUmVxdWVzdCIsIl9DaGF0Q29tcGxldGlvblN0cmVhbV9nZXRBdXRvUGFyc2VhYmxlUmVzcG9uc2VGb3JtYXQiLCJfQ2hhdENvbXBsZXRpb25TdHJlYW1fYWNjdW11bGF0ZUNoYXRDb21wbGV0aW9uIiwicmVmdXNhbCIsInJlc3QiLCJpbmRleCIsImNodW5rIiwiaWQiLCJDb3JlLmlzT2JqIiwiX0Fzc2lzdGFudFN0cmVhbV9hZGRFdmVudCIsIl9Bc3Npc3RhbnRTdHJlYW1fZW5kUmVxdWVzdCIsIl9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlTWVzc2FnZSIsIl9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlUnVuU3RlcCIsIl9Bc3Npc3RhbnRTdHJlYW1faGFuZGxlRXZlbnQiLCJfQXNzaXN0YW50U3RyZWFtX2FjY3VtdWxhdGVSdW5TdGVwIiwiX0Fzc2lzdGFudFN0cmVhbV9hY2N1bXVsYXRlTWVzc2FnZSIsIl9Bc3Npc3RhbnRTdHJlYW1fYWNjdW11bGF0ZUNvbnRlbnQiLCJfQXNzaXN0YW50U3RyZWFtX2hhbmRsZVJ1biIsIk1lc3NhZ2VzIiwiTWVzc2FnZXNBUEkuTWVzc2FnZXNQYWdlIiwiU3RlcHMiLCJTdGVwc0FQSS5SdW5TdGVwc1BhZ2UiLCJTdGVwc0FQSS5TdGVwcyIsIlJ1bnMiLCJSdW5zQVBJLlJ1bnNQYWdlIiwiUnVuc0FQSS5SdW5zIiwiTWVzc2FnZXNBUEkuTWVzc2FnZXMiLCJUaHJlYWRzIiwiRmlsZXMiLCJGaWxlc0FQSS5WZWN0b3JTdG9yZUZpbGVzUGFnZSIsIkZpbGVCYXRjaGVzIiwiRmlsZXNBUEkuRmlsZXMiLCJGaWxlQmF0Y2hlc0FQSS5GaWxlQmF0Y2hlcyIsIlZlY3RvclN0b3JlcyIsIlZlY3RvclN0b3Jlc0FQSS5WZWN0b3JTdG9yZXNQYWdlIiwiVmVjdG9yU3RvcmVzQVBJLlZlY3RvclN0b3JlcyIsIkNoYXRBUEkuQ2hhdCIsIkFzc2lzdGFudHNBUEkuQXNzaXN0YW50cyIsIlRocmVhZHNBUEkuVGhyZWFkcyIsIkJldGEiLCJFbWJlZGRpbmdzIiwiRmlsZXNBUEkuRmlsZU9iamVjdHNQYWdlIiwiQ2hlY2twb2ludHMiLCJDaGVja3BvaW50c0FQSS5GaW5lVHVuaW5nSm9iQ2hlY2twb2ludHNQYWdlIiwiQ2hlY2twb2ludHNBUEkuQ2hlY2twb2ludHMiLCJKb2JzIiwiSm9ic0FQSS5GaW5lVHVuaW5nSm9ic1BhZ2UiLCJKb2JzQVBJLkZpbmVUdW5pbmdKb2JFdmVudHNQYWdlIiwiSm9ic0FQSS5Kb2JzIiwiRmluZVR1bmluZyIsIkltYWdlcyIsIk1vZGVscyIsIk1vZGVsc0FQSS5Nb2RlbHNQYWdlIiwiTW9kZXJhdGlvbnMiLCJQYXJ0cyIsIlBhcnRzQVBJLlBhcnRzIiwiVXBsb2FkcyIsIkNvcmUuQVBJQ2xpZW50IiwiQ29yZS5yZWFkRW52IiwiRXJyb3JzLk9wZW5BSUVycm9yIiwiQ29yZS5pc1J1bm5pbmdJbkJyb3dzZXIiLCJBUEkuQ29tcGxldGlvbnMiLCJBUEkuQ2hhdCIsIkFQSS5FbWJlZGRpbmdzIiwiQVBJLkZpbGVzIiwiQVBJLkltYWdlcyIsIkFQSS5BdWRpbyIsIkFQSS5Nb2RlcmF0aW9ucyIsIkFQSS5Nb2RlbHMiLCJBUEkuRmluZVR1bmluZyIsIkFQSS5CZXRhIiwiQVBJLkJhdGNoZXMiLCJBUEkuVXBsb2FkcyIsIkVycm9ycy5BUElFcnJvciIsIkVycm9ycy5BUElDb25uZWN0aW9uRXJyb3IiLCJFcnJvcnMuQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvciIsIkVycm9ycy5BUElVc2VyQWJvcnRFcnJvciIsIkVycm9ycy5Ob3RGb3VuZEVycm9yIiwiRXJyb3JzLkNvbmZsaWN0RXJyb3IiLCJFcnJvcnMuUmF0ZUxpbWl0RXJyb3IiLCJFcnJvcnMuQmFkUmVxdWVzdEVycm9yIiwiRXJyb3JzLkF1dGhlbnRpY2F0aW9uRXJyb3IiLCJFcnJvcnMuSW50ZXJuYWxTZXJ2ZXJFcnJvciIsIkVycm9ycy5QZXJtaXNzaW9uRGVuaWVkRXJyb3IiLCJFcnJvcnMuVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yIiwiVXBsb2Fkcy50b0ZpbGUiLCJVcGxvYWRzLmZpbGVGcm9tUGF0aCIsIk9wZW5BSSIsIlBhZ2luYXRpb24uUGFnZSIsIlBhZ2luYXRpb24uQ3Vyc29yUGFnZSIsIkFQSS5GaWxlT2JqZWN0c1BhZ2UiLCJBUEkuTW9kZWxzUGFnZSIsIkFQSS5CYXRjaGVzUGFnZSIsIk11dGF0aW9uVHlwZSIsInN0b3JlIiwiJHJlc2V0Iiwib3B0aW9ucyIsIm1pY3JvU2Vjb25kcyIsIm1pY3JvIiwiY3JlYXRlIiwicG9zdE1lc3NhZ2UiLCJvbk1lc3NhZ2UiLCJjYW5CZVVzZWQiLCJhdmVyYWdlUmVzcG9uc2VUaW1lIiwibGlzdGVuZXIiLCJCcm9hZGNhc3RDaGFubmVsIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvYmoiLCJsaXN0ZW5lckZuIiwiQnJvYWRjYXN0Q2hhbm5lbEltcGwyIiwiaHRtbCIsImxpc3QiLCJ0ZXh0IiwicmVuZGVyZXIiLCJ0b2tlbnMiLCJhcmdzIiwicmV0Iiwic3JjIiwiZmV0Y2hNYW55Il0sIm1hcHBpbmdzIjoiOzs7OztFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBO0FBQUE7QUFFQSxXQUFTQSxVQUFRQyxNQUFLLGtCQUFrQjtBQUN0QyxVQUFNQyxPQUFNLElBQUksSUFBSUQsS0FBSSxNQUFNLEdBQUcsQ0FBQztBQUNsQyxXQUFnRSxDQUFDLFFBQVFDLEtBQUksSUFBSSxHQUFHO0FBQUEsRUFDdEY7QUFFQSxRQUFNQyxjQUE0RSxDQUFBO0FBRWxGLFFBQU1DLFNBQU8sTUFBTTtBQUFBLEVBQ25CO0FBS0EsUUFBTUMsV0FBUyxPQUFPO0FBQ3RCLFFBQU1DLFdBQVMsQ0FBQyxLQUFLLE9BQU87QUFDcEIsVUFBQSxJQUFJLElBQUksUUFBUSxFQUFFO0FBQ3hCLFFBQUksSUFBSSxJQUFJO0FBQ04sVUFBQSxPQUFPLEdBQUcsQ0FBQztBQUFBLElBQ2pCO0FBQUEsRUFDRjtBQUNBLFFBQU1DLG1CQUFpQixPQUFPLFVBQVU7QUFDeEMsUUFBTUMsV0FBUyxDQUFDLEtBQUssUUFBUUQsaUJBQWUsS0FBSyxLQUFLLEdBQUc7QUFDekQsUUFB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VUFBVSxFQUFFLElBQUk7QUFFVCxRQUFBLG9CQUFvQixHQUFHLE9BQU87QUFFOUIsUUFBQSxrQkFBZ0MsT0FBTyxLQUFLeEosVUFBUztBQUNoRSxVQUFNLFdBQVcsR0FBRyxHQUFHLEdBQUcsUUFBUSxtQkFBbUIsRUFBRTtBQUN2RCxVQUFNLFNBQVNBLFNBQUEsZ0JBQUFBLE1BQU07QUFDckIsVUFBTSxPQUFPQSxTQUFBLGdCQUFBQSxNQUFNO0FBRWIsVUFBQSxNQUFNLE1BQU0sMENBQTBDO0FBQUEsTUFDMUQ7QUFBQSxNQUNBO0FBQUEsTUFDQSxRQUFRO0FBQUEsSUFBQSxDQUNUO0FBRU0sV0FBQSxJQUFJLFNBQVMsSUFBSSxNQUFNO0FBQUE7QUFBQSxNQUU1QixRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsUUFDUCxnQkFBZ0I7QUFBQSxNQUNsQjtBQUFBLElBQUEsQ0FDRDtBQUFBLEVBQ0g7QUNyQ0EsaUJBQWUsS0FBSyxFQUFFLGdCQUE2QjtBQUUzQyxVQUFBLFNBQVMsSUFBSSxPQUFPO0FBQUEsTUFDeEIsU0FBUztBQUFBLE1BQ1QsUUFBUTtBQUFBO0FBQUEsTUFDUix5QkFBeUI7QUFBQSxNQUN6QixPQUFPO0FBQUEsSUFBQSxDQUNSO0FBR0QsVUFBTSxlQUFlLDBCQUEwQixFQUFFLFFBQVEsYUFBYyxDQUFBO0FBR3hELG1CQUFBO0FBQUEsTUFDYjtBQUFBLE1BQ0Esb0NBQW9CLFlBQVksRUFBRSxjQUFjO0FBQUEsSUFBQTtBQUFBLEVBRXBEOzs7OyIsInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5LDcyXX0=
